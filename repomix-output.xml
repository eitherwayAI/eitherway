This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
configs/
  agent.json
  anthropic.example.json
packages/
  database/
    src/
      migrations/
        001_initial_schema.sql
        002_phase2_schema.sql
        003_phase3_performance.sql
        004_vfs_optimizations.sql
        005_fix_index_size.sql
        006_rate_limiting.sql
        007_plan_execution.sql
        008_brand_kits.sql
        009_security_audit.sql
        010_preview_system.sql
        011_deployment_export.sql
        012_telemetry_observability.sql
        013_netlify_integration.sql
        create.ts
        runner.ts
      repositories/
        apps.ts
        brand-kits.ts
        deployments.ts
        embeddings.ts
        events.ts
        files.ts
        images.ts
        index.ts
        messages.ts
        netlify.ts
        session-memory.ts
        sessions.ts
        users.ts
      services/
        atomic-file-writer.ts
        deployment-service.ts
        diff-builder.ts
        export-service.ts
        file-store.ts
        image-generator.ts
        impacted-analyzer.ts
        integrity-checker.ts
        memory-prelude.ts
        netlify-service.ts
        palette-extractor.ts
        prepared-queries.ts
        rate-limiter.ts
      tests/
        fixtures.ts
        golden.test.ts
        image-generation.test.ts
        smoke.test.ts
      client.ts
      index.ts
      types.ts
    package.json
    tsconfig.json
    vitest.config.ts
  evaluations/
    src/
      calculator-eval.ts
      run-evals.ts
    package.json
    tsconfig.json
  logger/
    src/
      index.ts
    package.json
    tsconfig.json
  runtime/
    src/
      types/
        tool-result.ts
      agent.ts
      cli.ts
      config.ts
      constants.ts
      database-agent.ts
      index.ts
      metrics.ts
      model-client.ts
      rate-limiter.ts
      tool-runner.ts
      transcript.ts
      verifier.ts
    package.json
    tsconfig.json
  tools-core/
    src/
      index.ts
      schemas.ts
      types.ts
      validator.ts
    package.json
    tsconfig.json
  tools-impl/
    src/
      either-line-replace.ts
      either-search-files.ts
      either-view.ts
      either-write.ts
      imagegen.ts
      index.ts
      security.ts
    package.json
    tsconfig.json
  ui/
    package.json
    tsconfig.json
  ui-frontend/
    .husky/
      commit-msg
    app/
      components/
        auth/
          AuthDialog.module.scss
          AuthDialog.tsx
          GoogleAuthButton.tsx
        brand-kit/
          BrandKitPanel.tsx
        chat/
          Artifact.tsx
          AssistantMessage.tsx
          BaseChat.module.scss
          BaseChat.tsx
          BaseChatFallback.tsx
          Chat.client.tsx
          CodeBlock.module.scss
          CodeBlock.tsx
          FileOperationProgress.tsx
          Markdown.module.scss
          Markdown.tsx
          Messages.client.tsx
          PhaseIndicator.tsx
          ReasoningPanel.tsx
          SendButton.client.tsx
          StreamingIndicators.tsx
          TokenUsage.tsx
          UserMessage.tsx
        deployment/
          DeploymentPanel.tsx
        editor/
          codemirror/
            BinaryContent.tsx
            cm-theme.ts
            CodeMirrorEditor.tsx
            indent.ts
            languages.ts
        header/
          Header.tsx
          HeaderActionButtons.client.tsx
        landing/
          ContentBlock1.tsx
          CornerDecorations.tsx
          FaqBlockBlue.tsx
          Footer.tsx
          Header.tsx
          Landing.module.scss
          Landing.tsx
          LastBlock.module.scss
          LastBlock.tsx
          LastWorksCard.tsx
          LeftSidebar.tsx
          PhoneSlider.tsx
          PricingBlock.tsx
          RightSidebar.tsx
          useSlider.ts
        plan/
          PlanProgress.tsx
        preview/
          MobilePreview.tsx
        sidebar/
          date-binning.ts
          HistoryItem.tsx
          Menu.client.tsx
        ui/
          Dialog.tsx
          IconButton.tsx
          Loader.tsx
          LoadingDots.tsx
          PanelHeader.tsx
          PanelHeaderButton.tsx
          Slider.tsx
          ThemeSwitch.tsx
        workbench/
          terminal/
            Terminal.tsx
            theme.ts
          EditorPanel.tsx
          FileBreadcrumb.tsx
          FileTree.tsx
          PortDropdown.tsx
          Preview.tsx
          Workbench.client.tsx
        GooglePlayMock.tsx
        HeaderWithGlow.tsx
      config/
        api.ts
      lib/
        client/
          preview-helpers.client.ts
        hooks/
          index.ts
          useShortcuts.ts
          useSnapScroll.ts
        persistence/
          ChatDescription.client.tsx
          db.ts
          index.ts
          useBackendHistory.ts
          useChatHistory.ts
        runtime/
          action-runner.ts
          message-parser.ts
          style-preserver.ts
          theme-lock.ts
        services/
          portfolio-pipeline.ts
          price-pipeline.ts
        stores/
          artifact-validator.ts
          auth.ts
          brandKit.ts
          chat.ts
          deployStore.ts
          editor.ts
          files.ts
          preview-mode.ts
          previews.ts
          settings.ts
          sidebar.ts
          terminal.ts
          theme.ts
          workbench.ts
        templates/
          button-utilities-enhanced.js
          button-utilities.js
          dark-mode-fix.js
          env-template.js
          portfolio-service.js
          price-service.js
          testing-templates.js
          wallet-connection-fix.js
          web3-react.tsx
          web3-vanilla.js
        web3/
          config.ts
          hooks.ts
          index.ts
          Web3Provider.tsx
        webcontainer/
          auth.client.ts
          debug.ts
          ensure-dev-headers.ts
          index.ts
          url-helper.ts
        crypto.ts
        fetch.ts
      routes/
        _index.tsx
        chat._index.tsx
        chat.$id.tsx
        playmarket.tsx
      styles/
        components/
          code.scss
          editor.scss
          resize-handle.scss
          terminal.scss
          toast.scss
        animations.scss
        index.scss
        variables.scss
        z-index.scss
      templates/
        webcontainer-server.template.js
      types/
        actions.ts
        artifact.ts
        terminal.ts
        theme.ts
        webcontainer.ts
      utils/
        brandAssetSync.ts
        buffer.ts
        classNames.ts
        constants.ts
        debounce.ts
        diff.ts
        easings.ts
        fileSync.ts
        logger.ts
        markdown.ts
        mobile.ts
        promises.ts
        react.ts
        sessionManager.ts
        shell.ts
        streamClient.ts
        stripIndent.ts
        terminal.ts
        unreachable.ts
        webcontainerRunner.ts
        websocketClient.ts
      entry.client.tsx
      entry.server.tsx
      root.tsx
    backend/
      app.ts
      server.ts
      streaming.ts
    cloudflare/
      src/
        worker.ts
      wrangler.toml
    public/
      icons/
        block1/
          bgauth.svg
          builtForWeb3&Beyond.svg
          noCodeJustAi.svg
          readyInMinutes.svg
          visibility.svg
        chat/
          brackets.svg
          deploy.svg
          download.svg
          eye.svg
          loader.svg
          sendMessage.svg
          sidebar.svg
          stopStreaming.svg
        deploy/
          addImage.svg
          apple.svg
          chrome.svg
          google.svg
          mozilla.svg
          netlify.svg
        links/
          discord.svg
          tg.svg
          x.svg
        android.svg
        buyArrow.svg
        chat-black.svg
        chat.svg
        dots.svg
        LaunchDapp.svg
        logo.svg
        rainbowCircle.svg
        stars.svg
        whitepaper.svg
      base.css
      favicon.svg
      logo.svg
      styles.css
      test-streaming.html
    types/
      istextorbinary.d.ts
    .editorconfig
    .gitignore
    .prettierignore
    .prettierrc
    .tool-versions
    eslint.config.mjs
    LICENSE
    package.json
    patterns.json
    server.js
    tsconfig.json
    uno.config.ts
    vercel.json
    vite.config.ts
  ui-server/
    src/
      events/
        index.ts
        logger.ts
        send.ts
        types.ts
      routes/
        apps.ts
        brand-kits.ts
        deployments.ts
        images.ts
        netlify.ts
        session-files.ts
        sessions.ts
      security/
        ssrf-guard.ts
      cdn-rewriter.ts
      constants.ts
      server-enhanced.ts
      server.ts
    workspace/
      src/
        App.jsx
        index.css
        main.jsx
      index.html
      package.json
      postcss.config.js
      tailwind.config.js
      vite.config.js
    package.json
    tsconfig.json
scripts/
  setup-https.sh
.env.example
.eslintrc.json
.gitignore
.prettierignore
.prettierrc
docker-compose.yml
package.json
pnpm-workspace.yaml
tsconfig.base.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="configs/anthropic.example.json">
{
  "apiKey": "sk-ant-...",
  "model": "claude-sonnet-4-5-20250929",
  "maxTokens": 8192,
  "temperature": 0.2,
  "topP": 0.9,
  "streaming": true,
  "provider": "anthropic",
  "providerConfig": {
    "anthropic": {
      "baseURL": "https://api.anthropic.com"
    },
    "vertex": {
      "projectId": "your-project-id",
      "location": "us-central1",
      "model": "claude-sonnet-4-5@20250929"
    },
    "bedrock": {
      "region": "us-east-1",
      "modelId": "anthropic.claude-sonnet-4-5-v2:0"
    }
  },
  "thinking": {
    "enabled": false,
    "budget": "medium"
  },
  "promptCaching": {
    "enabled": false
  }
}
</file>

<file path="packages/database/src/migrations/001_initial_schema.sql">
-- Migration 001: Initial Schema
-- Phase 1 - Database foundation

-- ============================================================================
-- EXTENSIONS
-- ============================================================================

CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE EXTENSION IF NOT EXISTS citext;
CREATE EXTENSION IF NOT EXISTS vector;

-- ============================================================================
-- SCHEMA
-- ============================================================================

CREATE SCHEMA IF NOT EXISTS core;

-- ============================================================================
-- USERS
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.users (
  id           UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email        CITEXT UNIQUE NOT NULL,
  display_name TEXT,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS users_email_idx ON core.users(email);

-- ============================================================================
-- SESSIONS
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.sessions (
  id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id          UUID NOT NULL REFERENCES core.users(id) ON DELETE CASCADE,
  title            TEXT NOT NULL,
  app_id           UUID,
  status           TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active','archived')),
  last_message_at  TIMESTAMPTZ,
  created_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at       TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS sessions_by_user ON core.sessions(user_id, updated_at DESC);
CREATE INDEX IF NOT EXISTS sessions_by_app ON core.sessions(app_id) WHERE app_id IS NOT NULL;

-- ============================================================================
-- MESSAGES
-- ============================================================================

DO $$ BEGIN
  CREATE TYPE core.message_role AS ENUM ('user','assistant','system','tool');
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

CREATE TABLE IF NOT EXISTS core.messages (
  id           BIGSERIAL PRIMARY KEY,
  session_id   UUID NOT NULL REFERENCES core.sessions(id) ON DELETE CASCADE,
  role         core.message_role NOT NULL,
  content      JSONB NOT NULL,
  model        TEXT,
  token_count  INT,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS messages_by_session ON core.messages(session_id, id);
CREATE INDEX IF NOT EXISTS messages_content_gin ON core.messages USING GIN (content jsonb_path_ops);

-- ============================================================================
-- APPS
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.apps (
  id                 UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id           UUID NOT NULL REFERENCES core.users(id) ON DELETE CASCADE,
  name               TEXT NOT NULL,
  visibility         TEXT NOT NULL DEFAULT 'private' CHECK (visibility IN ('private','team','public')),
  default_session_id UUID,
  created_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at         TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS apps_by_owner ON core.apps(owner_id, created_at DESC);

-- Add foreign key constraint for sessions.app_id
ALTER TABLE core.sessions
  ADD CONSTRAINT sessions_app_id_fkey
  FOREIGN KEY (app_id) REFERENCES core.apps(id) ON DELETE SET NULL;

-- ============================================================================
-- FILES
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.files (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  app_id          UUID NOT NULL REFERENCES core.apps(id) ON DELETE CASCADE,
  path            TEXT NOT NULL,
  is_binary       BOOLEAN NOT NULL DEFAULT FALSE,
  mime_type       TEXT,
  size_bytes      INT,
  sha256          BYTEA,
  head_version_id UUID,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (app_id, path)
);

CREATE INDEX IF NOT EXISTS files_by_app_path ON core.files(app_id, path);
CREATE INDEX IF NOT EXISTS files_path_trgm ON core.files USING GIN (path gin_trgm_ops);

-- ============================================================================
-- FILE VERSIONS
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.file_versions (
  id                 UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  file_id            UUID NOT NULL REFERENCES core.files(id) ON DELETE CASCADE,
  version            INT  NOT NULL,
  parent_version_id  UUID REFERENCES core.file_versions(id),
  content_text       TEXT,
  content_bytes      BYTEA,
  diff_from_parent   JSONB,
  created_by         UUID REFERENCES core.users(id),
  created_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (file_id, version)
);

CREATE INDEX IF NOT EXISTS file_versions_by_file ON core.file_versions(file_id, version DESC);

-- Add foreign key for files.head_version_id
ALTER TABLE core.files
  ADD CONSTRAINT files_head_version_id_fkey
  FOREIGN KEY (head_version_id) REFERENCES core.file_versions(id) ON DELETE SET NULL;

-- ============================================================================
-- FILE REFERENCES
-- ============================================================================

DO $$ BEGIN
  CREATE TYPE core.reference_type AS ENUM ('import','style','asset','link','test','build','env','other');
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

CREATE TABLE IF NOT EXISTS core.file_references (
  id           BIGSERIAL PRIMARY KEY,
  app_id       UUID NOT NULL REFERENCES core.apps(id) ON DELETE CASCADE,
  src_file_id  UUID NOT NULL REFERENCES core.files(id) ON DELETE CASCADE,
  dest_file_id UUID     REFERENCES core.files(id) ON DELETE CASCADE,
  raw_target   TEXT,
  symbol       TEXT,
  ref_type     core.reference_type NOT NULL,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS file_refs_src ON core.file_references(app_id, src_file_id);
CREATE INDEX IF NOT EXISTS file_refs_dest ON core.file_references(app_id, dest_file_id);
CREATE INDEX IF NOT EXISTS file_refs_target_trgm ON core.file_references USING GIN (raw_target gin_trgm_ops);

-- ============================================================================
-- SESSION MEMORY
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.session_memory (
  session_id                 UUID PRIMARY KEY REFERENCES core.sessions(id) ON DELETE CASCADE,
  rolling_summary            TEXT,
  facts                      JSONB,
  last_compacted_message_id  BIGINT,
  updated_at                 TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ============================================================================
-- WORKING SET
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.working_set (
  session_id  UUID NOT NULL REFERENCES core.sessions(id) ON DELETE CASCADE,
  app_id      UUID NOT NULL REFERENCES core.apps(id) ON DELETE CASCADE,
  file_id     UUID NOT NULL REFERENCES core.files(id) ON DELETE CASCADE,
  reason      TEXT,
  pinned_by   TEXT,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (session_id, file_id)
);

CREATE INDEX IF NOT EXISTS working_set_by_session ON core.working_set(session_id);

-- ============================================================================
-- IMAGE GENERATION JOBS
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.image_jobs (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id    UUID REFERENCES core.sessions(id) ON DELETE CASCADE,
  app_id        UUID REFERENCES core.apps(id) ON DELETE SET NULL,
  prompt        TEXT NOT NULL,
  model         TEXT NOT NULL,
  size          TEXT,
  n             INT NOT NULL DEFAULT 1,
  state         TEXT NOT NULL DEFAULT 'queued' CHECK (state IN ('queued','generating','succeeded','failed','canceled')),
  requested_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  started_at    TIMESTAMPTZ,
  finished_at   TIMESTAMPTZ,
  error         JSONB
);

CREATE INDEX IF NOT EXISTS image_jobs_by_session ON core.image_jobs(session_id, requested_at DESC);
CREATE INDEX IF NOT EXISTS image_jobs_by_state ON core.image_jobs(state, requested_at);

-- ============================================================================
-- IMAGE ASSETS
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.image_assets (
  id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id     UUID NOT NULL REFERENCES core.image_jobs(id) ON DELETE CASCADE,
  position   INT  NOT NULL,
  mime_type  TEXT NOT NULL,
  bytes      BYTEA,
  storage_url TEXT,
  checksum   BYTEA,
  width      INT,
  height     INT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (job_id, position)
);

CREATE INDEX IF NOT EXISTS image_assets_by_job ON core.image_assets(job_id, position);

-- ============================================================================
-- EVENT LOG
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.events (
  id         BIGSERIAL PRIMARY KEY,
  session_id UUID,
  app_id     UUID,
  actor      TEXT,
  kind       TEXT,
  payload    JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS events_by_session ON core.events(session_id, id);
CREATE INDEX IF NOT EXISTS events_by_app ON core.events(app_id, id);
CREATE INDEX IF NOT EXISTS events_by_kind ON core.events(kind, created_at DESC);

-- ============================================================================
-- ROW LEVEL SECURITY (Optional - Disabled by default)
-- ============================================================================

-- Uncomment to enable RLS on sessions
-- ALTER TABLE core.sessions ENABLE ROW LEVEL SECURITY;
-- CREATE POLICY session_owner_all ON core.sessions
--   USING (user_id = current_setting('app.user_id', true)::uuid);

-- ============================================================================
-- HELPER FUNCTIONS
-- ============================================================================

CREATE OR REPLACE FUNCTION core.update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER sessions_updated_at
  BEFORE UPDATE ON core.sessions
  FOR EACH ROW
  EXECUTE FUNCTION core.update_updated_at();

CREATE TRIGGER apps_updated_at
  BEFORE UPDATE ON core.apps
  FOR EACH ROW
  EXECUTE FUNCTION core.update_updated_at();

CREATE TRIGGER files_updated_at
  BEFORE UPDATE ON core.files
  FOR EACH ROW
  EXECUTE FUNCTION core.update_updated_at();
</file>

<file path="packages/database/src/migrations/002_phase2_schema.sql">
-- Migration 002: Phase 2 Schema - Embeddings, Symbol Index, Enhanced Features

-- ============================================================================
-- DOC EMBEDDINGS (Semantic Search)
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.doc_embeddings (
  id         BIGSERIAL PRIMARY KEY,
  app_id     UUID NOT NULL REFERENCES core.apps(id) ON DELETE CASCADE,
  scope      TEXT NOT NULL CHECK (scope IN ('file', 'symbol', 'session', 'chunk')),
  ref_id     UUID,
  chunk_idx  INT,
  vector     VECTOR(1536),
  content_preview TEXT,
  metadata   JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS doc_embeddings_app_scope ON core.doc_embeddings(app_id, scope);
CREATE INDEX IF NOT EXISTS doc_embeddings_ref ON core.doc_embeddings(ref_id) WHERE ref_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS doc_embeddings_vector_idx
  ON core.doc_embeddings
  USING ivfflat (vector vector_cosine_ops)
  WITH (lists = 100);

-- ============================================================================
-- SYMBOL INDEX (Code Navigation)
-- ============================================================================

DO $$ BEGIN
  CREATE TYPE core.symbol_kind AS ENUM (
    'function', 'class', 'interface', 'type', 'const', 'variable',
    'component', 'hook', 'endpoint', 'model', 'other'
  );
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

CREATE TABLE IF NOT EXISTS core.symbol_index (
  id            BIGSERIAL PRIMARY KEY,
  app_id        UUID NOT NULL REFERENCES core.apps(id) ON DELETE CASCADE,
  file_id       UUID NOT NULL REFERENCES core.files(id) ON DELETE CASCADE,
  symbol_name   TEXT NOT NULL,
  symbol_kind   core.symbol_kind NOT NULL,
  is_exported   BOOLEAN NOT NULL DEFAULT FALSE,
  line_start    INT,
  line_end      INT,
  signature     TEXT,
  doc_comment   TEXT,
  metadata      JSONB,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS symbol_index_app_file ON core.symbol_index(app_id, file_id);
CREATE INDEX IF NOT EXISTS symbol_index_name_trgm ON core.symbol_index USING GIN (symbol_name gin_trgm_ops);
CREATE INDEX IF NOT EXISTS symbol_index_exported ON core.symbol_index(app_id, is_exported) WHERE is_exported = TRUE;

-- ============================================================================
-- SYMBOL USAGES (Cross-references)
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.symbol_usages (
  id                BIGSERIAL PRIMARY KEY,
  app_id            UUID NOT NULL REFERENCES core.apps(id) ON DELETE CASCADE,
  symbol_id         BIGINT NOT NULL REFERENCES core.symbol_index(id) ON DELETE CASCADE,
  usage_file_id     UUID NOT NULL REFERENCES core.files(id) ON DELETE CASCADE,
  usage_line        INT,
  usage_kind        TEXT CHECK (usage_kind IN ('import', 'call', 'reference', 'extend', 'implement')),
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS symbol_usages_symbol ON core.symbol_usages(symbol_id);
CREATE INDEX IF NOT EXISTS symbol_usages_file ON core.symbol_usages(usage_file_id);

-- ============================================================================
-- ENHANCED IMAGE JOBS (Idempotency)
-- ============================================================================

ALTER TABLE core.image_jobs
  ADD COLUMN IF NOT EXISTS idempotency_key TEXT,
  ADD COLUMN IF NOT EXISTS revised_prompt TEXT,
  ADD COLUMN IF NOT EXISTS generation_params JSONB;

CREATE UNIQUE INDEX IF NOT EXISTS image_jobs_idempotency
  ON core.image_jobs(idempotency_key)
  WHERE idempotency_key IS NOT NULL;

-- ============================================================================
-- PROJECT METADATA (Global Context)
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.project_metadata (
  app_id          UUID PRIMARY KEY REFERENCES core.apps(id) ON DELETE CASCADE,
  framework       TEXT,
  language        TEXT,
  package_manager TEXT,
  entry_points    JSONB,
  routes_map      JSONB,
  dependencies    JSONB,
  dev_dependencies JSONB,
  scripts         JSONB,
  readme_summary  TEXT,
  last_analyzed   TIMESTAMPTZ,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ============================================================================
-- CONTEXT BUILD CACHE (Performance)
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.context_cache (
  id              BIGSERIAL PRIMARY KEY,
  session_id      UUID NOT NULL REFERENCES core.sessions(id) ON DELETE CASCADE,
  app_id          UUID REFERENCES core.apps(id) ON DELETE CASCADE,
  cache_key       TEXT NOT NULL,
  context_data    JSONB NOT NULL,
  token_count     INT,
  expires_at      TIMESTAMPTZ NOT NULL,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (session_id, cache_key)
);

CREATE INDEX IF NOT EXISTS context_cache_expires ON core.context_cache(expires_at);

-- ============================================================================
-- BACKGROUND JOBS (Compaction, Indexing)
-- ============================================================================

DO $$ BEGIN
  CREATE TYPE core.job_status AS ENUM ('pending', 'running', 'completed', 'failed', 'canceled');
EXCEPTION WHEN duplicate_object THEN NULL; END $$;

CREATE TABLE IF NOT EXISTS core.background_jobs (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  job_type      TEXT NOT NULL,
  target_id     UUID,
  payload       JSONB,
  status        core.job_status NOT NULL DEFAULT 'pending',
  scheduled_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  started_at    TIMESTAMPTZ,
  completed_at  TIMESTAMPTZ,
  error         JSONB,
  retries       INT NOT NULL DEFAULT 0,
  max_retries   INT NOT NULL DEFAULT 3,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS background_jobs_status ON core.background_jobs(status, scheduled_at);
CREATE INDEX IF NOT EXISTS background_jobs_type ON core.background_jobs(job_type, status);

-- ============================================================================
-- TRIGGERS
-- ============================================================================

CREATE TRIGGER doc_embeddings_updated_at
  BEFORE UPDATE ON core.doc_embeddings
  FOR EACH ROW
  EXECUTE FUNCTION core.update_updated_at();

CREATE TRIGGER symbol_index_updated_at
  BEFORE UPDATE ON core.symbol_index
  FOR EACH ROW
  EXECUTE FUNCTION core.update_updated_at();

CREATE TRIGGER project_metadata_updated_at
  BEFORE UPDATE ON core.project_metadata
  FOR EACH ROW
  EXECUTE FUNCTION core.update_updated_at();
</file>

<file path="packages/database/src/migrations/003_phase3_performance.sql">
-- Migration 003: Phase 3 Performance Optimizations

-- ============================================================================
-- COVERING INDEXES (Hot Queries)
-- ============================================================================

CREATE INDEX IF NOT EXISTS messages_session_created_covering
  ON core.messages(session_id, created_at DESC)
  INCLUDE (role, content, model, token_count);

CREATE INDEX IF NOT EXISTS files_app_updated_covering
  ON core.files(app_id, updated_at DESC)
  INCLUDE (path, head_version_id, is_binary, mime_type, size_bytes);

CREATE INDEX IF NOT EXISTS file_versions_file_version_covering
  ON core.file_versions(file_id, version DESC)
  INCLUDE (content_text, content_bytes, created_by, created_at);

CREATE INDEX IF NOT EXISTS working_set_session_covering
  ON core.working_set(session_id)
  INCLUDE (app_id, file_id, reason, pinned_by, created_at);

CREATE INDEX IF NOT EXISTS file_refs_src_covering
  ON core.file_references(src_file_id)
  INCLUDE (dest_file_id, raw_target, symbol, ref_type);

-- ============================================================================
-- OPTIMIZED QUERIES FOR N+1 ELIMINATION
-- ============================================================================

CREATE INDEX IF NOT EXISTS files_app_paths ON core.files(app_id, path);

CREATE INDEX IF NOT EXISTS messages_session_id_range
  ON core.messages(session_id, id)
  WHERE id > 0;

-- ============================================================================
-- STATISTICS UPDATES
-- ============================================================================

ALTER TABLE core.messages ALTER COLUMN session_id SET STATISTICS 1000;
ALTER TABLE core.files ALTER COLUMN app_id SET STATISTICS 1000;
ALTER TABLE core.file_references ALTER COLUMN src_file_id SET STATISTICS 1000;

-- ============================================================================
-- MATERIALIZED VIEW FOR WORKING SET WITH FILE INFO
-- ============================================================================

CREATE MATERIALIZED VIEW IF NOT EXISTS core.working_set_enriched AS
SELECT
  ws.session_id,
  ws.app_id,
  ws.file_id,
  ws.reason,
  ws.pinned_by,
  ws.created_at,
  f.path as file_path,
  f.is_binary,
  f.mime_type,
  f.size_bytes,
  f.updated_at as file_updated_at
FROM core.working_set ws
JOIN core.files f ON ws.file_id = f.id;

CREATE UNIQUE INDEX IF NOT EXISTS working_set_enriched_pk
  ON core.working_set_enriched(session_id, file_id);

CREATE INDEX IF NOT EXISTS working_set_enriched_session
  ON core.working_set_enriched(session_id);

-- Refresh function
CREATE OR REPLACE FUNCTION core.refresh_working_set_enriched()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY core.working_set_enriched;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- ROW LEVEL SECURITY SETUP (Disabled by default, enable as needed)
-- ============================================================================

ALTER TABLE core.sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE core.apps ENABLE ROW LEVEL SECURITY;
ALTER TABLE core.files ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS sessions_owner_policy ON core.sessions;
CREATE POLICY sessions_owner_policy ON core.sessions
  FOR ALL
  USING (user_id = current_setting('app.current_user_id', true)::uuid)
  WITH CHECK (user_id = current_setting('app.current_user_id', true)::uuid);

DROP POLICY IF EXISTS apps_owner_policy ON core.apps;
CREATE POLICY apps_owner_policy ON core.apps
  FOR ALL
  USING (owner_id = current_setting('app.current_user_id', true)::uuid)
  WITH CHECK (owner_id = current_setting('app.current_user_id', true)::uuid);

DROP POLICY IF EXISTS files_app_owner_policy ON core.files;
CREATE POLICY files_app_owner_policy ON core.files
  FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM core.apps
      WHERE apps.id = files.app_id
        AND apps.owner_id = current_setting('app.current_user_id', true)::uuid
    )
  );

-- ============================================================================
-- PARTITION STRATEGY PREPARATION (For future growth)
-- ============================================================================

-- Events table partitioning by month (example, not auto-created)
-- CREATE TABLE core.events_2025_01 PARTITION OF core.events
--   FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- Add partition key helper
CREATE OR REPLACE FUNCTION core.get_partition_name(table_name text, date timestamptz)
RETURNS text AS $$
BEGIN
  RETURN table_name || '_' || to_char(date, 'YYYY_MM');
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ============================================================================
-- INTEGRITY CHECK HELPERS
-- ============================================================================

CREATE OR REPLACE FUNCTION core.verify_file_checksums(p_app_id uuid DEFAULT NULL)
RETURNS TABLE(
  file_id uuid,
  path text,
  stored_checksum bytea,
  computed_checksum bytea,
  matches boolean
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    f.id,
    f.path,
    f.sha256,
    digest(
      COALESCE(fv.content_text::bytea, fv.content_bytes),
      'sha256'
    ) as computed,
    f.sha256 = digest(
      COALESCE(fv.content_text::bytea, fv.content_bytes),
      'sha256'
    ) as matches
  FROM core.files f
  JOIN core.file_versions fv ON f.head_version_id = fv.id
  WHERE (p_app_id IS NULL OR f.app_id = p_app_id);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION core.verify_image_integrity(p_job_id uuid DEFAULT NULL)
RETURNS TABLE(
  asset_id uuid,
  job_id uuid,
  mime_type text,
  has_valid_magic_bytes boolean,
  has_valid_eof boolean,
  checksum_valid boolean
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    ia.id,
    ia.job_id,
    ia.mime_type,
    CASE
      WHEN ia.mime_type = 'image/png' THEN
        get_byte(ia.bytes, 0) = 137 AND
        get_byte(ia.bytes, 1) = 80 AND
        get_byte(ia.bytes, 2) = 78 AND
        get_byte(ia.bytes, 3) = 71
      WHEN ia.mime_type = 'image/jpeg' THEN
        get_byte(ia.bytes, 0) = 255 AND
        get_byte(ia.bytes, 1) = 216
      ELSE false
    END as has_valid_magic,
    CASE
      WHEN ia.mime_type = 'image/jpeg' THEN
        get_byte(ia.bytes, length(ia.bytes) - 2) = 255 AND
        get_byte(ia.bytes, length(ia.bytes) - 1) = 217
      WHEN ia.mime_type = 'image/png' THEN
        position(E'IEND'::bytea in ia.bytes) > 0
      ELSE false
    END as has_valid_eof,
    ia.checksum = digest(ia.bytes, 'sha256') as checksum_valid
  FROM core.image_assets ia
  WHERE (p_job_id IS NULL OR ia.job_id = p_job_id);
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- QUERY PLAN HELPERS
-- ============================================================================

CREATE OR REPLACE FUNCTION core.analyze_query_performance()
RETURNS void AS $$
BEGIN
  ANALYZE core.messages;
  ANALYZE core.files;
  ANALYZE core.file_versions;
  ANALYZE core.file_references;
  ANALYZE core.working_set;
  ANALYZE core.sessions;
  ANALYZE core.apps;
END;
$$ LANGUAGE plpgsql;

-- Initial analysis
SELECT core.analyze_query_performance();
</file>

<file path="packages/database/src/migrations/004_vfs_optimizations.sql">
-- Migration 004: VFS Optimizations
-- Optimizations for DB-backed Virtual File System

-- ============================================================================
-- SESSION FILES VIEW
-- ============================================================================

CREATE OR REPLACE VIEW core.session_files AS
SELECT
  s.id AS session_id,
  s.user_id,
  s.title AS session_title,
  f.id,
  f.app_id,
  f.path,
  f.is_binary,
  f.mime_type,
  f.size_bytes,
  f.sha256,
  f.head_version_id,
  f.created_at,
  f.updated_at
FROM core.sessions s
JOIN core.files f ON f.app_id = s.app_id
WHERE s.app_id IS NOT NULL;

COMMENT ON VIEW core.session_files IS 'Session-centric view of files for easier querying';

-- ============================================================================
-- ADDITIONAL INDEXES FOR VFS PERFORMANCE
-- ============================================================================

CREATE INDEX IF NOT EXISTS files_app_id_idx ON core.files(app_id) WHERE app_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS file_versions_file_id_idx ON core.file_versions(file_id);

CREATE INDEX IF NOT EXISTS sessions_app_id_idx ON core.sessions(app_id) WHERE app_id IS NOT NULL;

-- ============================================================================
-- FUNCTIONS FOR VFS OPERATIONS
-- ============================================================================

CREATE OR REPLACE FUNCTION core.get_file_content(p_session_id UUID, p_path TEXT)
RETURNS TABLE (
  content_text TEXT,
  content_bytes BYTEA,
  mime_type TEXT,
  version INT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    fv.content_text,
    fv.content_bytes,
    f.mime_type,
    fv.version
  FROM core.sessions s
  JOIN core.files f ON f.app_id = s.app_id
  JOIN core.file_versions fv ON fv.id = f.head_version_id
  WHERE s.id = p_session_id AND f.path = p_path;
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION core.get_file_content IS 'Efficiently retrieve file content by session and path';

-- ============================================================================
-- STATISTICS
-- ============================================================================

ANALYZE core.files;
ANALYZE core.file_versions;
ANALYZE core.sessions;
</file>

<file path="packages/database/src/migrations/005_fix_index_size.sql">
-- Migration 005: Fix Index Size Limit Error
-- Drop problematic covering index that includes large content columns

-- ============================================================================
-- PROBLEM
-- ============================================================================
-- The file_versions_file_version_covering index includes content_text and
-- content_bytes in the INCLUDE clause, which can exceed PostgreSQL's btree
-- index size limit (2704 bytes for version 4) when files are larger than ~2KB.
--
-- Error: "index row size 3800 exceeds btree version 4 maximum 2704"

-- ============================================================================
-- SOLUTION
-- ============================================================================
-- Drop the covering index since we already have file_versions_by_file which
-- provides the same indexed columns (file_id, version DESC) without the
-- problematic INCLUDE clause.

DROP INDEX IF EXISTS core.file_versions_file_version_covering;

-- The existing file_versions_by_file index provides the same functionality:
-- CREATE INDEX file_versions_by_file ON core.file_versions(file_id, version DESC)
--
-- This index is sufficient for queries that need to find versions by file_id,
-- and PostgreSQL will do a regular table lookup for the content columns which
-- is acceptable since content retrieval is typically infrequent compared to
-- metadata queries.

-- Also drop messages covering index that includes content to prevent same issue
DROP INDEX IF EXISTS core.messages_session_created_covering;

-- Recreate without content column to avoid size limit issues with large messages
CREATE INDEX IF NOT EXISTS messages_session_created_idx
  ON core.messages(session_id, created_at DESC)
  INCLUDE (role, model, token_count);

-- ============================================================================
-- VERIFICATION
-- ============================================================================

ANALYZE core.file_versions;
ANALYZE core.messages;

COMMENT ON INDEX core.file_versions_by_file IS
  'Index for file version queries. Content columns are fetched via table lookup to avoid btree size limits.';

COMMENT ON INDEX core.messages_session_created_idx IS
  'Index for message queries without content column to avoid btree size limits with large messages.';
</file>

<file path="packages/database/src/migrations/006_rate_limiting.sql">
-- Migration 006: Rate Limiting
-- Add tables to track daily rate limits per user and per session

-- ============================================================================
-- USER DAILY LIMITS
-- Tracks the number of sessions created by each user per UTC day
-- Limit: 5 sessions per day
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.user_daily_limits (
  user_id         UUID NOT NULL REFERENCES core.users(id) ON DELETE CASCADE,
  limit_date      DATE NOT NULL,
  sessions_created INT NOT NULL DEFAULT 0,
  PRIMARY KEY (user_id, limit_date)
);

CREATE INDEX IF NOT EXISTS user_daily_limits_date_idx ON core.user_daily_limits(limit_date);

-- ============================================================================
-- SESSION DAILY LIMITS
-- Tracks the number of messages sent per session per UTC day
-- Limit: 5 messages per session per day
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.session_daily_limits (
  session_id    UUID NOT NULL REFERENCES core.sessions(id) ON DELETE CASCADE,
  limit_date    DATE NOT NULL,
  messages_sent INT NOT NULL DEFAULT 0,
  PRIMARY KEY (session_id, limit_date)
);

CREATE INDEX IF NOT EXISTS session_daily_limits_date_idx ON core.session_daily_limits(limit_date);

-- ============================================================================
-- CLEANUP FUNCTION
-- Optional: Function to clean up old limit records (older than 7 days)
-- Can be called periodically to prevent table growth
-- ============================================================================

CREATE OR REPLACE FUNCTION core.cleanup_old_rate_limits()
RETURNS void AS $$
BEGIN
  DELETE FROM core.user_daily_limits WHERE limit_date < CURRENT_DATE - INTERVAL '7 days';
  DELETE FROM core.session_daily_limits WHERE limit_date < CURRENT_DATE - INTERVAL '7 days';
END;
$$ LANGUAGE plpgsql;
</file>

<file path="packages/database/src/repositories/index.ts">
export { UsersRepository } from './users.js';
export { SessionsRepository } from './sessions.js';
export { MessagesRepository } from './messages.js';
export { AppsRepository } from './apps.js';
export { FilesRepository, FileReferencesRepository } from './files.js';
export { SessionMemoryRepository, WorkingSetRepository } from './session-memory.js';
export { ImageJobsRepository, ImageAssetsRepository } from './images.js';
export { EventsRepository } from './events.js';
export { EmbeddingsRepository } from './embeddings.js';
</file>

<file path="packages/database/src/client.ts">
import pg from 'pg';

const { Pool } = pg;

export interface DatabaseConfig {
  host: string;
  port: number;
  database: string;
  user: string;
  password: string;
  max?: number;
  idleTimeoutMillis?: number;
  connectionTimeoutMillis?: number;
}

export class DatabaseClient {
  private pool: pg.Pool;
  private static instance: DatabaseClient;

  private constructor(config: DatabaseConfig) {
    this.pool = new Pool({
      host: config.host,
      port: config.port,
      database: config.database,
      user: config.user,
      password: config.password,
      max: config.max ?? 20,
      idleTimeoutMillis: config.idleTimeoutMillis ?? 30000,
      connectionTimeoutMillis: config.connectionTimeoutMillis ?? 2000,
    });

    this.pool.on('error', (err) => {
      console.error('Unexpected database pool error:', err);
    });
  }

  static initialize(config: DatabaseConfig): DatabaseClient {
    if (!DatabaseClient.instance) {
      DatabaseClient.instance = new DatabaseClient(config);
    }
    return DatabaseClient.instance;
  }

  static getInstance(): DatabaseClient {
    if (!DatabaseClient.instance) {
      throw new Error('DatabaseClient not initialized. Call initialize() first.');
    }
    return DatabaseClient.instance;
  }

  async query<T extends pg.QueryResultRow = any>(text: string, params?: any[]): Promise<pg.QueryResult<T>> {
    return this.pool.query<T>(text, params);
  }

  async getClient(): Promise<pg.PoolClient> {
    return this.pool.connect();
  }

  async transaction<T>(callback: (client: pg.PoolClient) => Promise<T>): Promise<T> {
    const client = await this.getClient();
    try {
      await client.query('BEGIN');
      const result = await callback(client);
      await client.query('COMMIT');
      return result;
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async healthCheck(): Promise<boolean> {
    try {
      const result = await this.query('SELECT 1 as health');
      return result.rows[0]?.health === 1;
    } catch (error) {
      console.error('Database health check failed:', error);
      return false;
    }
  }

  async close(): Promise<void> {
    await this.pool.end();
  }
}

export function createDatabaseClient(config?: Partial<DatabaseConfig>): DatabaseClient {
  const defaultConfig: DatabaseConfig = {
    host: process.env.POSTGRES_HOST || 'localhost',
    port: parseInt(process.env.POSTGRES_PORT || '5432', 10),
    database: process.env.POSTGRES_DB || 'eitherway',
    user: process.env.POSTGRES_USER || 'postgres',
    password: process.env.POSTGRES_PASSWORD || 'postgres',
    max: parseInt(process.env.POSTGRES_MAX_CONNECTIONS || '20', 10),
  };

  return DatabaseClient.initialize({ ...defaultConfig, ...config });
}
</file>

<file path="packages/logger/src/index.ts">
/**
 * Structured Logging Package
 * Provides JSON/pretty logging with correlation IDs and context
 */

export type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error';

export interface LogContext {
  correlationId?: string;
  scope?: string;
  [key: string]: unknown;
}

export interface StructuredLogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  context?: LogContext;
  error?: {
    name: string;
    message: string;
    stack?: string;
  };
}

export interface LoggerOptions {
  format?: 'json' | 'pretty';
  minLevel?: LogLevel;
  context?: LogContext;
}

export interface Logger {
  trace: (message: string, context?: LogContext) => void;
  debug: (message: string, context?: LogContext) => void;
  info: (message: string, context?: LogContext) => void;
  warn: (message: string, context?: LogContext) => void;
  error: (message: string, error?: Error, context?: LogContext) => void;
  child: (childContext: LogContext) => Logger;
}

const LOG_LEVEL_PRIORITY: Record<LogLevel, number> = {
  trace: 0,
  debug: 1,
  info: 2,
  warn: 3,
  error: 4,
};

const LOG_LEVEL_COLORS: Record<LogLevel, string> = {
  trace: '\x1b[90m', // Gray
  debug: '\x1b[36m', // Cyan
  info: '\x1b[34m', // Blue
  warn: '\x1b[33m', // Yellow
  error: '\x1b[31m', // Red
};

const RESET_COLOR = '\x1b[0m';

/**
 * Create a structured logger
 */
export function createLogger(options: LoggerOptions = {}): Logger {
  const format = options.format || (process.env.LOG_FORMAT as 'json' | 'pretty') || 'pretty';
  const minLevel = options.minLevel || (process.env.LOG_LEVEL as LogLevel) || 'info';
  const baseContext = options.context || {};

  const log = (level: LogLevel, message: string, error?: Error, context?: LogContext) => {
    if (LOG_LEVEL_PRIORITY[level] < LOG_LEVEL_PRIORITY[minLevel]) {
      return;
    }

    const entry: StructuredLogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context: { ...baseContext, ...context },
    };

    if (error) {
      entry.error = {
        name: error.name,
        message: error.message,
        stack: error.stack,
      };
    }

    if (format === 'json') {
      console.log(JSON.stringify(entry));
    } else {
      const color = LOG_LEVEL_COLORS[level];
      const levelStr = `[${level.toUpperCase()}]`.padEnd(7);
      const scopeStr = entry.context?.scope ? `[${entry.context.scope}]` : '';
      const corrIdStr = entry.context?.correlationId ? `[${entry.context.correlationId}]` : '';

      let output = `${color}${levelStr}${RESET_COLOR} ${scopeStr}${corrIdStr} ${message}`;

      // Include additional context keys (excluding scope and correlationId)
      const contextKeys = Object.keys(entry.context || {}).filter((k) => k !== 'scope' && k !== 'correlationId');
      if (contextKeys.length > 0) {
        const contextStr = contextKeys.map((k) => `${k}=${entry.context?.[k]}`).join(' ');
        output += ` ${contextStr}`;
      }

      if (error) {
        output += `\n  Error: ${error.message}`;
        if (error.stack) {
          output += `\n${error.stack.split('\n').slice(1).join('\n')}`;
        }
      }

      console.log(output);
    }
  };

  const logger: Logger = {
    trace: (message, context) => log('trace', message, undefined, context),
    debug: (message, context) => log('debug', message, undefined, context),
    info: (message, context) => log('info', message, undefined, context),
    warn: (message, context) => log('warn', message, undefined, context),
    error: (message, error, context) => log('error', message, error, context),
    child: (childContext) =>
      createLogger({
        ...options,
        context: { ...baseContext, ...childContext },
      }),
  };

  return logger;
}

/**
 * Create a scoped logger (convenience function)
 */
export function createScopedLogger(scope: string, options: Omit<LoggerOptions, 'context'> = {}): Logger {
  return createLogger({
    ...options,
    context: { scope },
  });
}

/**
 * Generate a correlation ID for request tracing
 */
export function generateCorrelationId(): string {
  return `${Date.now()}-${Math.random().toString(36).slice(2, 11)}`;
}
</file>

<file path="packages/logger/package.json">
{
  "name": "@eitherway/logger",
  "version": "0.1.0",
  "description": "Structured logging for EitherWay",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  },
  "scripts": {
    "build": "tsc",
    "watch": "tsc --watch"
  },
  "dependencies": {},
  "devDependencies": {
    "typescript": "^5.3.3"
  }
}
</file>

<file path="packages/logger/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "composite": true,
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"]
}
</file>

<file path="packages/runtime/src/types/tool-result.ts">
/**
 * Type definitions for tool execution results
 */

/**
 * Metadata attached to tool results by tool executors
 */
export interface ToolResultMetadata {
  /** File path for file operation tools */
  path?: string;
  /** Operation type */
  operation?: 'create' | 'edit' | 'read';
  /** SHA-256 hash of file content (for verification) */
  sha256?: string;
  /** Number of lines in the file */
  lineCount?: number;
  /** Additional context */
  [key: string]: unknown;
}
</file>

<file path="packages/runtime/src/constants.ts">
/**
 * Agent Runtime Configuration Constants
 */

/**
 * Maximum number of agent turns before forcing termination
 * Prevents infinite loops in agent execution
 */
export const MAX_AGENT_TURNS = 20;

/**
 * Number of reasoning tokens to buffer before streaming to client
 * Smaller chunks = more frequent updates, larger chunks = less network overhead
 */
export const REASONING_STREAM_CHUNK_SIZE = 2;

/**
 * Delay between reasoning stream chunks (milliseconds)
 * ~16ms achieves approximately 60fps for smooth streaming experience
 */
export const REASONING_STREAM_DELAY_MS = 16;
</file>

<file path="packages/tools-core/src/index.ts">
/**
 * @eitherway/tools-core - Tool type definitions, JSON schemas, and validation
 */

export * from './types.js';
export * from './schemas.js';
export * from './validator.js';
</file>

<file path="packages/tools-core/package.json">
{
  "name": "@eitherway/tools-core",
  "version": "0.1.0",
  "description": "Tool type definitions, JSON schemas, and validation",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "test": "vitest run"
  },
  "dependencies": {
    "ajv": "^8.12.0",
    "ajv-formats": "^2.1.1"
  },
  "devDependencies": {
    "typescript": "^5.3.3"
  }
}
</file>

<file path="packages/ui-frontend/.husky/commit-msg">
#!/usr/bin/env sh

. "$(dirname "$0")/_/husky.sh"

npx commitlint --edit $1

exit 0
</file>

<file path="packages/ui-frontend/app/components/auth/AuthDialog.module.scss">
.connect-wallet-button {
  &:hover {
    .button-overlay {
      left: calc(100% + 20px);
      transition: left 0.4s ease;
    }
  }
}

.enter-button {
  &:hover:not(:disabled) {
    .button-overlay {
      left: calc(100% + 20px);
      transition: left 0.4s ease;
    }
  }
}

.button-overlay {
  position: absolute;
  width: 40px;
  height: 100%;
  left: -60px;
  top: 0px;
  background: #ffffff40;
  transform: skewX(-20deg);
  z-index: 1;
  transition: left 0.4s ease;
}
</file>

<file path="packages/ui-frontend/app/components/auth/AuthDialog.tsx">
import React, { useState } from 'react';
import { Dialog, DialogRoot } from '~/components/ui/Dialog';
import { useWalletConnection } from '~/lib/web3/hooks';
import styles from './AuthDialog.module.scss';

interface AuthDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onAuthenticated: (message?: string) => void;
  pendingMessage?: string | null;
}

export const AuthDialog: React.FC<AuthDialogProps> = ({ isOpen, onClose, onAuthenticated, pendingMessage }) => {
  const { isConnected, connectWallet } = useWalletConnection();
  const [password, setPassword] = useState('');
  const [passwordError, setPasswordError] = useState('');
  const [isCheckingPassword, setIsCheckingPassword] = useState(false);
  const [isInitializing, setIsInitializing] = useState(true);
  const [showPassword, setShowPassword] = useState(false);

  React.useEffect(() => {
    if (isOpen) {
      const timer = setTimeout(() => {
        setIsInitializing(false);
      }, 1000);
      return () => clearTimeout(timer);
    }

    return undefined;
  }, [isOpen]);

  const handlePasswordSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsCheckingPassword(true);
    setPasswordError('');

    const today = new Date();
    const todayPassword =
      today.getDate().toString().padStart(2, '0') +
      (today.getMonth() + 1).toString().padStart(2, '0') +
      today.getFullYear().toString();

    if (password === todayPassword) {
      const passwordData = {
        password: todayPassword,
        timestamp: new Date().getTime(),
      };

      localStorage.setItem('daily_password_verified', JSON.stringify(passwordData));
      onAuthenticated(pendingMessage || undefined);
      onClose();
    } else {
      setPasswordError('Invalid code, try again.');
    }

    setIsCheckingPassword(false);
  };

  const handleConnectWallet = async () => {
    onClose(); // close dialog so wallet popup can appear
    await connectWallet();
  };

  const renderContent = () => {
    if (isInitializing) {
      return (
        <div className="p-8 text-center">
          <div className="text-6xl mb-6"></div>
          <h2 className="text-2xl font-bold mb-4 text-white font-syne">Initializing...</h2>
          <p className="text-gray-400 font-montserrat">Please wait while we connect to your wallet.</p>
        </div>
      );
    }

    if (!isConnected) {
      return (
        <div className="flex h-fit">
          {/* Left column - Welcome text and form */}
          <div className="w-1/2 p-8 flex flex-col justify-center">
            <div className="mb-8">
              <h1 className="text-6xl font-medium leading-[130%] tracking-[-0.05em] text-white mb-4 font-syne">
                Welcome
                <br />
                to Eitherway!
              </h1>
              <p className="text-white font-montserrat mb-4">
                Eitherway is currently in <span className="font-bold text-white italic">closed beta</span>.
              </p>
              <p className="text-gray-400 font-montserrat text-sm">
                First, connect your Web3 wallet, then enter your access code.
              </p>
            </div>

            <button
              onClick={handleConnectWallet}
              className={`w-fit bg-[#0D00FF] text-white font-bold py-3 px-12 transition-colors italic rounded-full font-montserrat text-[15px] relative overflow-hidden ${styles['connect-wallet-button']}`}
            >
              <span className="relative z-10">CONNECT WALLET</span>
              <div className={styles['button-overlay']}></div>
            </button>
          </div>

          {/* Right column - Illustration */}
          <div className="w-1/2 p-8 px-13 flex flex-col justify-center items-center rounded-r-lg h-[600px]">
            <img src="/icons/block1/bgauth.svg" />
          </div>
        </div>
      );
    }

    return (
      <div className="flex h-fit">
        {/* Left column - Welcome text and form */}
        <div className="w-1/2 p-8 flex flex-col justify-center">
          <div className="mb-8">
            <h1 className="text-6xl font-medium leading-[130%] tracking-[-0.05em] text-white mb-4 font-syne">
              Welcome
              <br />
              to Eitherway!
            </h1>
            <p className="text-white font-montserrat mb-4">
              Eitherway is currently in <span className="font-bold text-white italic">closed beta</span>.
            </p>
            <p className="text-gray-400 font-montserrat text-sm">
              Wallet connected! Now enter your access code to continue.
            </p>
          </div>
          <div className="mb-6">
            <div className="relative">
              <input
                type={showPassword ? 'text' : 'password'}
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="Enter access code"
                className={`w-full px-4 py-3 bg-transparent border rounded-lg text-white placeholder-gray-500 focus:outline-none ${
                  passwordError ? 'border-red-500 focus:border-red-500' : 'border-gray-600 focus:border-blue-500'
                }`}
                disabled={isCheckingPassword}
              />
              <button
                type="button"
                onClick={() => setShowPassword(!showPassword)}
                className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-500 bg-transparent hover:text-gray-300 transition-colors"
              >
                <img src="/icons/block1/visibility.svg" alt="Toggle password visibility" />
              </button>
            </div>
            {passwordError && <p className="text-red-500 text-xs font-montserrat mt-2">{passwordError}</p>}
          </div>
          <button
            onClick={handlePasswordSubmit}
            disabled={!password || isCheckingPassword}
            className={`w-fit bg-blue-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white text-[16px] font-bold py-3 px-16 italic bg-gray-900 rounded-full font-montserrat relative overflow-hidden ${styles['enter-button']}`}
          >
            <span className="relative z-10">{isCheckingPassword ? 'CHECKING...' : 'ENTER'}</span>
            <div className={styles['button-overlay']}></div>
          </button>
        </div>

        {/* Right column - Illustration */}
        <div className="w-1/2 p-5 px-12 flex flex-col justify-center items-center rounded-r-lg h-[600px]">
          <img src="/icons/block1/bgauth.svg" />
        </div>
      </div>
    );
  };

  return (
    <DialogRoot open={isOpen} onOpenChange={(open) => !open && onClose()}>
      <Dialog className="max-w-4xl w-[90vw] bg-black border border-gray-800" noBorder={true} onClose={onClose}>
        {renderContent()}
      </Dialog>
    </DialogRoot>
  );
};
</file>

<file path="packages/ui-frontend/app/components/auth/GoogleAuthButton.tsx">
import { useState, useEffect } from 'react';
import type { GoogleUser } from '~/lib/auth/google';

interface GoogleAuthButtonProps {
  onSuccess: (user: GoogleUser) => void;
  onError: () => void;
  className?: string;
}

export function GoogleAuthButton({ onSuccess, onError, className }: GoogleAuthButtonProps) {
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    console.log(' GoogleAuthButton mounted, onSuccess:', onSuccess, 'onError:', onError);
  }, [onSuccess, onError]);

  const handleGoogleLogin = () => {
    console.log(' Google login button clicked!');
    setIsLoading(true);

    const clientId = '631136632309-58183vsuk8cit3qrsfie88as8lsric21.apps.googleusercontent.com';
    const redirectUri = encodeURIComponent(window.location.origin + '/auth/google/callback');
    const scope = encodeURIComponent('openid email profile');
    const responseType = 'code';

    const googleAuthUrl = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${clientId}&redirect_uri=${redirectUri}&scope=${scope}&response_type=${responseType}&access_type=offline&prompt=consent`;

    console.log(' Opening popup with URL:', googleAuthUrl);

    const popup = window.open(googleAuthUrl, 'googleAuth', 'width=500,height=600,scrollbars=yes,resizable=yes');

    if (popup) {
      const checkClosed = setInterval(() => {
        if (popup.closed) {
          clearInterval(checkClosed);
          setIsLoading(false);
        }
      }, 1000);

      window.addEventListener('message', (event) => {
        if (event.origin !== window.location.origin) {
          return;
        }

        if (event.data && typeof event.data === 'object' && event.data.type) {
          console.log(' Received Google OAuth message:', event.data);

          if (event.data.type === 'GOOGLE_AUTH_SUCCESS') {
            console.log(' Google auth success, user:', event.data.user);
            console.log(' Calling onSuccess with user data');
            popup.close();
            onSuccess(event.data.user);
            setIsLoading(false);
          } else if (event.data.type === 'GOOGLE_AUTH_ERROR') {
            console.log(' Google auth error:', event.data.error);
            popup.close();
            onError();
            setIsLoading(false);
          }
        }
      });
    } else {
      setIsLoading(false);
      onError();
    }
  };

  useEffect(() => {
    console.log(' GoogleAuthButton mounted, onSuccess:', onSuccess, 'onError:', onError);
  }, [onSuccess, onError]);

  return (
    <div className={className}>
      <button
        onClick={handleGoogleLogin}
        disabled={isLoading}
        className="google-signin-button"
        style={{
          display: 'flex',
          flexDirection: 'row',
          justifyContent: 'center',
          alignItems: 'center',
          padding: '8px',
          gap: '8px',
          width: '100%',
          height: '40px',
          backgroundColor: '#5184EC',
          border: 'none',
          borderRadius: '48px',
          cursor: isLoading ? 'not-allowed' : 'pointer',
          transition: 'all 0.2s',
          opacity: isLoading ? 0.7 : 1,
        }}
        onMouseEnter={(e) => {
          if (!isLoading) {
            e.currentTarget.style.backgroundColor = '#3367d6';
            e.currentTarget.style.boxShadow = '0 4px 8px rgba(66, 133, 244, 0.4)';
          }
        }}
        onMouseLeave={(e) => {
          if (!isLoading) {
            e.currentTarget.style.backgroundColor = '#4285f4';
            e.currentTarget.style.boxShadow = '0 2px 4px rgba(66, 133, 244, 0.3)';
          }
        }}
      >
        {isLoading ? (
          <>
            <div
              className="spin"
              style={{
                width: '16px',
                height: '16px',
                border: '2px solid #f3f3f3',
                borderTop: '2px solid #4285f4',
                borderRadius: '50%',
              }}
            />
            <span>Loading Google Sign-In...</span>
          </>
        ) : (
          <>
            <div
              style={{
                display: 'flex',
                flexDirection: 'row',
                justifyContent: 'center',
                alignItems: 'center',
                padding: '8px',
                gap: '8px',
                width: '24px',
                height: '24px',
                background: '#FFFFFF',
                borderRadius: '64px',
                flex: 'none',
                order: 0,
                flexGrow: 0,
              }}
            >
              <img
                src="/icons/deploy/google.svg"
                alt="Google"
                style={{
                  width: '16px',
                  height: '16px',
                  flex: 'none',
                  order: 0,
                  flexGrow: 0,
                }}
              />
            </div>
            <span
              style={{
                width: '149px',
                height: '14px',
                fontFamily: 'Azeret Mono',
                fontStyle: 'normal',
                fontWeight: '400',
                fontSize: '12px',
                lineHeight: '14px',
                textAlign: 'center',
                color: '#FFFFFF',
                flex: 'none',
                order: 1,
                flexGrow: 0,
              }}
            >
              Sign In with Google
            </span>
          </>
        )}
      </button>
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/chat/AssistantMessage.tsx">
import { memo } from 'react';
import { Markdown } from './Markdown';
import { StreamingIndicators } from './StreamingIndicators';

interface AssistantMessageProps {
  content: string;
  isStreaming?: boolean;
  phase?: 'pending' | 'thinking' | 'reasoning' | 'code-writing' | 'building' | 'completed' | null;
  reasoningText?: string;
  thinkingDuration?: number | null;
  fileOperations?: Array<{ operation: string; filePath: string }>;
  tokenUsage?: { inputTokens: number; outputTokens: number } | null;
}

export const AssistantMessage = memo(
  ({
    content,
    isStreaming = false,
    phase = null,
    reasoningText = '',
    thinkingDuration = null,
    fileOperations = [],
    tokenUsage = null,
  }: AssistantMessageProps) => {
    return (
      <div className="overflow-hidden w-full">
        {/* Streaming indicators - phase, reasoning, file operations, token usage */}
        <StreamingIndicators
          phase={phase}
          reasoningText={reasoningText}
          thinkingDuration={thinkingDuration}
          fileOperations={fileOperations}
          tokenUsage={tokenUsage}
          isStreaming={isStreaming}
        />

        {/* Main message content */}
        <Markdown html>{content}</Markdown>

        {/* Streaming progress bar */}
        {isStreaming && (
          <div className="absolute bottom-0 left-0 right-0 h-2 overflow-hidden rounded-b-lg">
            <div
              className="w-[200%] h-full animate-barbershop"
              style={{
                background:
                  'linear-gradient(45deg, #0D00FF -15%, #FFFFFF 0%, #429BFF 15%, #0D00FF 30%, #FFFFFF 50%, #87CEEB 70%, #0D00FF 85%, #FFFFFF 100%, #429BFF 115%)',
              }}
            />
          </div>
        )}
      </div>
    );
  },
);
</file>

<file path="packages/ui-frontend/app/components/chat/BaseChat.module.scss">
.BaseChat {
  &[data-chat-visible='false'] {
    --workbench-inner-width: 100%;
    --workbench-left: 0;

    .Chat {
      --at-apply: eitherway-ease-cubic-bezier;
      transition-property: transform, opacity;
      transition-duration: 0.3s;
      will-change: transform, opacity;
      transform: translateX(-50%);
      opacity: 0;
    }
  }
}

.Chat {
  opacity: 1;
}

.chatScroll {
  scrollbar-width: thin;
  scrollbar-color: rgba(255, 255, 255, 0.2) transparent;

  &::-webkit-scrollbar {
    width: 8px;
  }

  &::-webkit-scrollbar-track {
    background: transparent;
  }

  &::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 4px;

    &:hover {
      background: rgba(255, 255, 255, 0.3);
    }
  }
}
</file>

<file path="packages/ui-frontend/app/components/chat/BaseChatFallback.tsx">
import React from 'react';
import { Loader } from '~/components/ui/Loader';

export function BaseChatFallback() {
  return <Loader />;
}
</file>

<file path="packages/ui-frontend/app/components/chat/CodeBlock.module.scss">
.CopyButtonContainer {
  button:before {
    content: 'Copied';
    font-size: 12px;
    position: absolute;
    left: -53px;
    padding: 2px 6px;
    height: 30px;
  }
}
</file>

<file path="packages/ui-frontend/app/components/chat/CodeBlock.tsx">
import { memo, useEffect, useState } from 'react';
import { bundledLanguages, codeToHtml, isSpecialLang, type BundledLanguage, type SpecialLanguage } from 'shiki';
import { classNames } from '~/utils/classNames';
import { createScopedLogger } from '~/utils/logger';

import styles from './CodeBlock.module.scss';

const logger = createScopedLogger('CodeBlock');

interface CodeBlockProps {
  className?: string;
  code: string;
  language?: BundledLanguage | SpecialLanguage;
  theme?: 'light-plus' | 'dark-plus';
  disableCopy?: boolean;
}

export const CodeBlock = memo(
  ({ className, code, language = 'plaintext', theme = 'dark-plus', disableCopy = false }: CodeBlockProps) => {
    const [html, setHTML] = useState<string | undefined>(undefined);
    const [copied, setCopied] = useState(false);

    const copyToClipboard = () => {
      if (copied) {
        return;
      }

      navigator.clipboard.writeText(code);

      setCopied(true);

      setTimeout(() => {
        setCopied(false);
      }, 2000);
    };

    useEffect(() => {
      if (language && !isSpecialLang(language) && !(language in bundledLanguages)) {
        logger.warn(`Unsupported language '${language}'`);
      }

      logger.trace(`Language = ${language}`);

      const processCode = async () => {
        setHTML(await codeToHtml(code, { lang: language, theme }));
      };

      processCode();
    }, [code]);

    return (
      <div className={classNames('relative group text-left', className)}>
        <div
          className={classNames(
            styles.CopyButtonContainer,
            'bg-white absolute top-[10px] right-[10px] rounded-md z-10 text-lg flex items-center justify-center opacity-0 group-hover:opacity-100',
            {
              'rounded-l-0 opacity-100': copied,
            },
          )}
        >
          {!disableCopy && (
            <button
              className={classNames(
                'flex items-center bg-transparent p-[6px] justify-center before:bg-white before:rounded-l-md before:text-gray-500 before:border-r before:border-gray-300',
                {
                  'before:opacity-0': !copied,
                  'before:opacity-100': copied,
                },
              )}
              title="Copy Code"
              onClick={() => copyToClipboard()}
            >
              <div className="i-ph:clipboard-text-duotone"></div>
            </button>
          )}
        </div>
        <div dangerouslySetInnerHTML={{ __html: html ?? '' }}></div>
      </div>
    );
  },
);
</file>

<file path="packages/ui-frontend/app/components/chat/Markdown.module.scss">
$font-mono: var(--font-mono);
$code-font-size: 13px;

@mixin not-inside-actions {
  &:not(:has(:global(.actions)), :global(.actions *)) {
    @content;
  }
}

.MarkdownContent {
  line-height: 1.6;
  color: var(--eitherway-elements-textPrimary);

  > *:not(:last-child) {
    margin-block-end: 16px;
  }

  :global(.artifact) {
    margin: 1.5em 0;
  }

  :is(h1, h2, h3, h4, h5, h6) {
    @include not-inside-actions {
      margin-block-start: 24px;
      margin-block-end: 16px;
      font-weight: 600;
      line-height: 1.25;
      color: var(--eitherway-elements-textPrimary);
    }
  }

  h1 {
    font-size: 2em;
    border-bottom: 1px solid var(--eitherway-elements-borderColor);
    padding-bottom: 0.3em;
  }

  h2 {
    font-size: 1.5em;
    border-bottom: 1px solid var(--eitherway-elements-borderColor);
    padding-bottom: 0.3em;
  }

  h3 {
    font-size: 1.25em;
  }

  h4 {
    font-size: 1em;
  }

  h5 {
    font-size: 0.875em;
  }

  h6 {
    font-size: 0.85em;
    color: var(--eitherway-elements-textSecondary);
  }

  p {
    white-space: pre-wrap;

    &:not(:last-of-type) {
      margin-block-start: 0;
      margin-block-end: 16px;
    }
  }

  a {
    color: var(--eitherway-elements-messages-linkColor);
    text-decoration: none;
    cursor: pointer;

    &:hover {
      text-decoration: underline;
    }
  }

  :not(pre) > code {
    font-family: $font-mono;
    font-size: $code-font-size;

    @include not-inside-actions {
      border-radius: 6px;
      padding: 0.2em 0.4em;
      background-color: var(--eitherway-elements-messages-inlineCode-background);
      color: var(--eitherway-elements-messages-inlineCode-text);
    }
  }

  pre {
    padding: 20px 16px;
    border-radius: 6px;
  }

  pre:has(> code) {
    font-family: $font-mono;
    font-size: $code-font-size;
    background: transparent;
    overflow-x: auto;
    min-width: 0;
  }

  blockquote {
    margin: 0;
    padding: 0 1em;
    color: var(--eitherway-elements-textTertiary);
    border-left: 0.25em solid var(--eitherway-elements-borderColor);
  }

  :is(ul, ol) {
    @include not-inside-actions {
      padding-left: 2em;
      margin-block-start: 0;
      margin-block-end: 16px;
    }
  }

  ul {
    @include not-inside-actions {
      list-style-type: disc;
    }
  }

  ol {
    @include not-inside-actions {
      list-style-type: decimal;
    }
  }

  li {
    @include not-inside-actions {
      & + li {
        margin-block-start: 8px;
      }

      > *:not(:last-child) {
        margin-block-end: 16px;
      }
    }
  }

  img {
    max-width: 100%;
    box-sizing: border-box;
  }

  hr {
    height: 0.25em;
    padding: 0;
    margin: 24px 0;
    background-color: var(--eitherway-elements-borderColor);
    border: 0;
  }

  table {
    border-collapse: collapse;
    width: 100%;
    margin-block-end: 16px;

    :is(th, td) {
      padding: 6px 13px;
      border: 1px solid var(--eitherway-elements-borderColor);
    }

    tr:nth-child(2n) {
      background-color: var(--eitherway-elements-bg-depth-3);
    }
  }
}
</file>

<file path="packages/ui-frontend/app/components/chat/Markdown.tsx">
import { memo, useMemo } from 'react';
import ReactMarkdown, { type Components } from 'react-markdown';
import type { BundledLanguage } from 'shiki';
import { createScopedLogger } from '~/utils/logger';
import { rehypePlugins, remarkPlugins, allowedHTMLElements } from '~/utils/markdown';
import { Artifact } from './Artifact';
import { CodeBlock } from './CodeBlock';

import styles from './Markdown.module.scss';

const logger = createScopedLogger('MarkdownComponent');

interface MarkdownProps {
  children: string;
  html?: boolean;
  limitedMarkdown?: boolean;
}

export const Markdown = memo(({ children, html = false, limitedMarkdown = false }: MarkdownProps) => {
  logger.trace('Render');

  const components = useMemo(() => {
    return {
      div: ({ className, children, node, ...props }) => {
        if (className?.includes('__eitherwayArtifact__')) {
          // const messageId = node?.properties.dataMessageId as string;
          const artifactId = node?.properties.dataArtifactId as string;

          if (!artifactId) {
            logger.error(`Invalid artifact id ${artifactId}`);
          }

          // messageId is still present if needed for debugging, but artifactId is authoritative
          return <Artifact artifactId={artifactId} />;
        }

        return (
          <div className={className} {...props}>
            {children}
          </div>
        );
      },
      pre: (props) => {
        const { children, node, ...rest } = props;

        const [firstChild] = node?.children ?? [];

        if (
          firstChild &&
          firstChild.type === 'element' &&
          firstChild.tagName === 'code' &&
          firstChild.children[0].type === 'text'
        ) {
          const { className, ...rest } = firstChild.properties;
          const [, language = 'plaintext'] = /language-(\w+)/.exec(String(className) || '') ?? [];

          return <CodeBlock code={firstChild.children[0].value} language={language as BundledLanguage} {...rest} />;
        }

        return <pre {...rest}>{children}</pre>;
      },
    } satisfies Components;
  }, []);

  return (
    <ReactMarkdown
      allowedElements={allowedHTMLElements}
      className={styles.MarkdownContent}
      components={components}
      remarkPlugins={remarkPlugins(limitedMarkdown)}
      rehypePlugins={rehypePlugins(html)}
    >
      {children}
    </ReactMarkdown>
  );
});
</file>

<file path="packages/ui-frontend/app/components/chat/SendButton.client.tsx">
import { AnimatePresence, cubicBezier, motion } from 'framer-motion';

interface SendButtonProps {
  show: boolean;
  isStreaming?: boolean;
  onClick?: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;
}

const customEasingFn = cubicBezier(0.4, 0, 0.2, 1);

export function SendButton({ show, isStreaming, onClick }: SendButtonProps) {
  return (
    <AnimatePresence>
      {show ? (
        <motion.button
          className="absolute flex justify-center  items-center top-[18px] right-[22px] p-1 hover:brightness-94 color-white bg-black rounded-md w-[34px] h-[34px] transition-theme"
          transition={{ ease: customEasingFn, duration: 0.17 }}
          initial={{ opacity: 0, x: 10 }}
          animate={{ opacity: 1, x: 0 }}
          exit={{ opacity: 0, x: 10 }}
          onClick={(event) => {
            event.preventDefault();
            onClick?.(event);
          }}
        >
          <div className="text-lg">
            {!isStreaming ? (
              <img
                width={40}
                height={40}
                className="min-w-[40px] min-h-[40px] rotate-90"
                src="/icons/chat/sendMessage.svg"
                alt="Send message"
              />
            ) : (
              <img
                width={40}
                height={40}
                className="min-w-[40px] min-h-[40px] "
                src="/icons/chat/stopStreaming.svg"
                alt="Stop streaming"
              />
            )}
          </div>
        </motion.button>
      ) : null}
    </AnimatePresence>
  );
}
</file>

<file path="packages/ui-frontend/app/components/chat/StreamingIndicators.tsx">
import { memo } from 'react';
import { PhaseIndicator } from './PhaseIndicator';
import { FileOperationProgress } from './FileOperationProgress';
import { ReasoningPanel } from './ReasoningPanel';
import { TokenUsage } from './TokenUsage';

interface StreamingIndicatorsProps {
  phase: 'pending' | 'thinking' | 'reasoning' | 'code-writing' | 'building' | 'completed' | null;
  reasoningText: string;
  thinkingDuration: number | null;
  fileOperations: Array<{ operation: string; filePath: string }>;
  tokenUsage: { inputTokens: number; outputTokens: number } | null;
  isStreaming: boolean;
}

export const StreamingIndicators = memo(
  ({ phase, reasoningText, thinkingDuration, fileOperations, tokenUsage, isStreaming }: StreamingIndicatorsProps) => {
    // Don't show anything if not streaming and no completed state
    if (!isStreaming && !tokenUsage) return null;

    return (
      <div className="flex flex-col gap-2 mb-3">
        {/* Phase indicator - always show when streaming or phase exists */}
        {phase && <PhaseIndicator phase={phase} thinkingDuration={thinkingDuration} />}

        {/* Reasoning panel - show during reasoning phase or if there's reasoning text */}
        {reasoningText && <ReasoningPanel text={reasoningText} isActive={phase === 'reasoning'} />}

        {/* File operations - show when there are operations */}
        {fileOperations.length > 0 && <FileOperationProgress operations={fileOperations} />}

        {/* Token usage - show after streaming completes */}
        {tokenUsage && <TokenUsage inputTokens={tokenUsage.inputTokens} outputTokens={tokenUsage.outputTokens} />}
      </div>
    );
  },
);
</file>

<file path="packages/ui-frontend/app/components/chat/TokenUsage.tsx">
import { memo } from 'react';

interface TokenUsageProps {
  inputTokens: number;
  outputTokens: number;
}

export const TokenUsage = memo(({ inputTokens, outputTokens }: TokenUsageProps) => {
  const totalTokens = inputTokens + outputTokens;

  return (
    <div className="flex items-center gap-3 px-3 py-2 bg-black/30 border border-white/10 rounded-lg text-xs">
      <div className="flex items-center gap-1.5">
        <div className="i-ph:arrow-down text-blue-400" />
        <span className="text-white/60">Input:</span>
        <span className="text-white/90 font-medium">{inputTokens.toLocaleString()}</span>
      </div>
      <div className="h-3 w-px bg-white/20" />
      <div className="flex items-center gap-1.5">
        <div className="i-ph:arrow-up text-green-400" />
        <span className="text-white/60">Output:</span>
        <span className="text-white/90 font-medium">{outputTokens.toLocaleString()}</span>
      </div>
      <div className="h-3 w-px bg-white/20" />
      <div className="flex items-center gap-1.5">
        <div className="i-ph:sigma text-purple-400" />
        <span className="text-white/60">Total:</span>
        <span className="text-white/90 font-medium">{totalTokens.toLocaleString()}</span>
      </div>
    </div>
  );
});
</file>

<file path="packages/ui-frontend/app/components/chat/UserMessage.tsx">
import { modificationsRegex } from '~/utils/diff';
import { Markdown } from './Markdown';

interface UserMessageProps {
  content: string;
}

export function UserMessage({ content }: UserMessageProps) {
  return (
    <div className="overflow-hidden">
      <Markdown limitedMarkdown>{sanitizeUserMessage(content)}</Markdown>
    </div>
  );
}

function sanitizeUserMessage(content: string) {
  return content.replace(modificationsRegex, '').trim();
}
</file>

<file path="packages/ui-frontend/app/components/editor/codemirror/BinaryContent.tsx">
export function BinaryContent() {
  return (
    <div className="flex items-center justify-center absolute inset-0 z-10 text-sm bg-tk-elements-app-backgroundColor text-tk-elements-app-textColor">
      File format cannot be displayed.
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/editor/codemirror/cm-theme.ts">
import { Compartment, type Extension } from '@codemirror/state';
import { EditorView } from '@codemirror/view';
import { vscodeDark, vscodeLight } from '@uiw/codemirror-theme-vscode';
import type { Theme } from '~/types/theme.js';
import type { EditorSettings } from './CodeMirrorEditor.js';

export const darkTheme = EditorView.theme({}, { dark: true });
export const themeSelection = new Compartment();

export function getTheme(theme: Theme, settings: EditorSettings = {}): Extension {
  return [
    getEditorTheme(settings),
    theme === 'dark' ? themeSelection.of([getDarkTheme()]) : themeSelection.of([getLightTheme()]),
  ];
}

export function reconfigureTheme(theme: Theme) {
  return themeSelection.reconfigure(theme === 'dark' ? getDarkTheme() : getLightTheme());
}

function getEditorTheme(settings: EditorSettings) {
  return EditorView.theme({
    '&': {
      fontSize: settings.fontSize ?? '12px',
    },
    '&.cm-editor': {
      height: '100%',
      background: 'var(--cm-backgroundColor)',
      color: 'var(--cm-textColor)',
    },
    '.cm-cursor': {
      borderLeft: 'var(--cm-cursor-width) solid var(--cm-cursor-backgroundColor)',
    },
    '.cm-scroller': {
      lineHeight: '1.5',
      '&:focus-visible': {
        outline: 'none',
      },
    },
    '.cm-line': {
      padding: '0 0 0 4px',
    },
    '&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground': {
      backgroundColor: 'var(--cm-selection-backgroundColorFocused) !important',
      opacity: 'var(--cm-selection-backgroundOpacityFocused, 0.3)',
    },
    '&:not(.cm-focused) > .cm-scroller > .cm-selectionLayer .cm-selectionBackground': {
      backgroundColor: 'var(--cm-selection-backgroundColorBlured)',
      opacity: 'var(--cm-selection-backgroundOpacityBlured, 0.3)',
    },
    '&.cm-focused > .cm-scroller .cm-matchingBracket': {
      backgroundColor: 'var(--cm-matching-bracket)',
    },
    '.cm-activeLine': {
      background: 'var(--cm-activeLineBackgroundColor)',
    },
    '.cm-gutters': {
      background: 'var(--cm-gutter-backgroundColor)',
      borderRight: 0,
      color: 'var(--cm-gutter-textColor)',
    },
    '.cm-gutter': {
      '&.cm-lineNumbers': {
        fontFamily: 'Roboto Mono, monospace',
        fontSize: settings.gutterFontSize ?? settings.fontSize ?? '12px',
        minWidth: '40px',
      },
      '& .cm-activeLineGutter': {
        background: 'transparent',
        color: 'var(--cm-gutter-activeLineTextColor)',
      },
      '&.cm-foldGutter .cm-gutterElement > .fold-icon': {
        cursor: 'pointer',
        color: 'var(--cm-foldGutter-textColor)',
        transform: 'translateY(2px)',
        '&:hover': {
          color: 'var(--cm-foldGutter-textColorHover)',
        },
      },
    },
    '.cm-foldGutter .cm-gutterElement': {
      padding: '0 4px',
    },
    '.cm-tooltip-autocomplete > ul > li': {
      minHeight: '18px',
    },
    '.cm-panel.cm-search label': {
      marginLeft: '2px',
      fontSize: '12px',
    },
    '.cm-panel.cm-search .cm-button': {
      fontSize: '12px',
    },
    '.cm-panel.cm-search .cm-textfield': {
      fontSize: '12px',
    },
    '.cm-panel.cm-search input[type=checkbox]': {
      position: 'relative',
      transform: 'translateY(2px)',
      marginRight: '4px',
    },
    '.cm-panels': {
      borderColor: 'var(--cm-panels-borderColor)',
    },
    '.cm-panels-bottom': {
      borderTop: '1px solid var(--cm-panels-borderColor)',
      backgroundColor: 'transparent',
    },
    '.cm-panel.cm-search': {
      background: 'var(--cm-search-backgroundColor)',
      color: 'var(--cm-search-textColor)',
      padding: '8px',
    },
    '.cm-search .cm-button': {
      background: 'var(--cm-search-button-backgroundColor)',
      borderColor: 'var(--cm-search-button-borderColor)',
      color: 'var(--cm-search-button-textColor)',
      borderRadius: '4px',
      '&:hover': {
        color: 'var(--cm-search-button-textColorHover)',
      },
      '&:focus-visible': {
        outline: 'none',
        borderColor: 'var(--cm-search-button-borderColorFocused)',
      },
      '&:hover:not(:focus-visible)': {
        background: 'var(--cm-search-button-backgroundColorHover)',
        borderColor: 'var(--cm-search-button-borderColorHover)',
      },
      '&:hover:focus-visible': {
        background: 'var(--cm-search-button-backgroundColorHover)',
        borderColor: 'var(--cm-search-button-borderColorFocused)',
      },
    },
    '.cm-panel.cm-search [name=close]': {
      top: '6px',
      right: '6px',
      padding: '0 6px',
      fontSize: '1rem',
      backgroundColor: 'var(--cm-search-closeButton-backgroundColor)',
      color: 'var(--cm-search-closeButton-textColor)',
      '&:hover': {
        'border-radius': '6px',
        color: 'var(--cm-search-closeButton-textColorHover)',
        backgroundColor: 'var(--cm-search-closeButton-backgroundColorHover)',
      },
    },
    '.cm-search input': {
      background: 'var(--cm-search-input-backgroundColor)',
      borderColor: 'var(--cm-search-input-borderColor)',
      color: 'var(--cm-search-input-textColor)',
      outline: 'none',
      borderRadius: '4px',
      '&:focus-visible': {
        borderColor: 'var(--cm-search-input-borderColorFocused)',
      },
    },
    '.cm-tooltip': {
      background: 'var(--cm-tooltip-backgroundColor)',
      border: '1px solid transparent',
      borderColor: 'var(--cm-tooltip-borderColor)',
      color: 'var(--cm-tooltip-textColor)',
    },
    '.cm-tooltip.cm-tooltip-autocomplete ul li[aria-selected]': {
      background: 'var(--cm-tooltip-backgroundColorSelected)',
      color: 'var(--cm-tooltip-textColorSelected)',
    },
    '.cm-searchMatch': {
      backgroundColor: 'var(--cm-searchMatch-backgroundColor)',
    },
    '.cm-tooltip.cm-readonly-tooltip': {
      padding: '4px',
      whiteSpace: 'nowrap',
      backgroundColor: 'var(--eitherway-elements-bg-depth-2)',
      borderColor: 'var(--eitherway-elements-borderColorActive)',
      '& .cm-tooltip-arrow:before': {
        borderTopColor: 'var(--eitherway-elements-borderColorActive)',
      },
      '& .cm-tooltip-arrow:after': {
        borderTopColor: 'transparent',
      },
    },
  });
}

function getLightTheme() {
  return vscodeLight;
}

function getDarkTheme() {
  return vscodeDark;
}
</file>

<file path="packages/ui-frontend/app/components/editor/codemirror/languages.ts">
import { LanguageDescription } from '@codemirror/language';

export const supportedLanguages = [
  LanguageDescription.of({
    name: 'TS',
    extensions: ['ts'],
    async load() {
      return import('@codemirror/lang-javascript').then((module) => module.javascript({ typescript: true }));
    },
  }),
  LanguageDescription.of({
    name: 'JS',
    extensions: ['js', 'mjs', 'cjs'],
    async load() {
      return import('@codemirror/lang-javascript').then((module) => module.javascript());
    },
  }),
  LanguageDescription.of({
    name: 'TSX',
    extensions: ['tsx'],
    async load() {
      return import('@codemirror/lang-javascript').then((module) => module.javascript({ jsx: true, typescript: true }));
    },
  }),
  LanguageDescription.of({
    name: 'JSX',
    extensions: ['jsx'],
    async load() {
      return import('@codemirror/lang-javascript').then((module) => module.javascript({ jsx: true }));
    },
  }),
  LanguageDescription.of({
    name: 'HTML',
    extensions: ['html'],
    async load() {
      return import('@codemirror/lang-html').then((module) => module.html());
    },
  }),
  LanguageDescription.of({
    name: 'CSS',
    extensions: ['css'],
    async load() {
      return import('@codemirror/lang-css').then((module) => module.css());
    },
  }),
  LanguageDescription.of({
    name: 'SASS',
    extensions: ['sass'],
    async load() {
      return import('@codemirror/lang-sass').then((module) => module.sass({ indented: true }));
    },
  }),
  LanguageDescription.of({
    name: 'SCSS',
    extensions: ['scss'],
    async load() {
      return import('@codemirror/lang-sass').then((module) => module.sass({ indented: false }));
    },
  }),
  LanguageDescription.of({
    name: 'JSON',
    extensions: ['json'],
    async load() {
      return import('@codemirror/lang-json').then((module) => module.json());
    },
  }),
  LanguageDescription.of({
    name: 'Markdown',
    extensions: ['md'],
    async load() {
      return import('@codemirror/lang-markdown').then((module) => module.markdown());
    },
  }),
  LanguageDescription.of({
    name: 'Wasm',
    extensions: ['wat'],
    async load() {
      return import('@codemirror/lang-wast').then((module) => module.wast());
    },
  }),
  LanguageDescription.of({
    name: 'Python',
    extensions: ['py'],
    async load() {
      return import('@codemirror/lang-python').then((module) => module.python());
    },
  }),
  LanguageDescription.of({
    name: 'C++',
    extensions: ['cpp'],
    async load() {
      return import('@codemirror/lang-cpp').then((module) => module.cpp());
    },
  }),
];

export async function getLanguage(fileName: string) {
  const languageDescription = LanguageDescription.matchFilename(supportedLanguages, fileName);

  if (languageDescription) {
    return await languageDescription.load();
  }

  return undefined;
}
</file>

<file path="packages/ui-frontend/app/components/landing/CornerDecorations.tsx">
import styles from './Landing.module.scss';

export function CornerDecorations() {
  return (
    <div className={styles['card-corners']}>
      <svg className={`${styles.corner} ${styles['corner-tl']}`} width="17" height="17" viewBox="0 0 17 17" fill="none">
        <path d="M1 17V9C1 4.58172 4.58172 1 9 1H17" stroke="black" strokeOpacity="0.3" strokeWidth="2" />
      </svg>
      <svg className={`${styles.corner} ${styles['corner-tr']}`} width="17" height="17" viewBox="0 0 17 17" fill="none">
        <path d="M16 17V9C16 4.58172 12.4183 1 8 1H0" stroke="black" strokeOpacity="0.3" strokeWidth="2" />
      </svg>
      <svg className={`${styles.corner} ${styles['corner-bl']}`} width="17" height="17" viewBox="0 0 17 17" fill="none">
        <path d="M1 0V8C1 12.4183 4.58172 16 9 16H17" stroke="black" strokeOpacity="0.3" strokeWidth="2" />
      </svg>
      <svg className={`${styles.corner} ${styles['corner-br']}`} width="17" height="17" viewBox="0 0 17 17" fill="none">
        <path d="M16 0V8C16 12.4183 12.4183 16 8 16H0" stroke="black" strokeOpacity="0.3" strokeWidth="2" />
      </svg>
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/landing/FaqBlockBlue.tsx">
import React, { useState } from 'react';

export function FaqBlock() {
  const [openIndex, setOpenIndex] = useState<number | null>(null);

  const faqs = [
    {
      question: 'What is Eitherway?',
      answer:
        'Eitherway is an AI-native development platform that turns plain ideas into fully working apps. From mobile and web to browser extensions and Web3 dApps, apps are created and deployed in minutes with a single prompt.',
    },
    {
      question: 'Do I need to know how to code?',
      answer:
        'No. Non-technical users can ship production-ready applications with just prompts. Developers can dive into the code at any time for full customization.',
    },
    {
      question: 'Where can I deploy my apps?',
      answer:
        'Apps built with Eitherway can be published to the App Store, Google Play, Chrome/Firefox extension stores, or deployed as web apps. Web3 apps can be deployed directly to Ethereum or other EVM-compatible networks.',
    },
    {
      question: 'How does Eitherway differ from no-code tools?',
      answer:
        'Traditional no-code platforms limit flexibility and lock you into proprietary builders. Eitherway operates in a real full-stack environment where AI installs packages, manages environments, and executes builds. You always own your code.',
    },
    {
      question: 'What about Web3 support?',
      answer:
        'Eitherway can generate smart contracts, integrate wallets, and deploy dApps with IPFS hosting. Its designed to handle both Web2 and Web3 outputs in one workflow.',
    },
    {
      question: 'Is Eitherway secure?',
      answer:
        'Yes. Apps are built inside isolated WebContainers that sandbox execution. Dependencies are scanned for vulnerabilities, and store compliance checks are automated before publishing.',
    },
    {
      question: 'How does pricing work?',
      answer:
        'Eitherway will launch with a freemium model: free tier for basic builds, Pro subscriptions for unlimited builds and multi-platform deployments, and Enterprise plans with dedicated AI instances and on-premise options.',
    },
    {
      question: 'Will there be a marketplace?',
      answer:
        'Yes. Eitherway will feature a marketplace for templates, plugins, and UI kits. Developers, designers, and AI specialists can earn revenue by publishing their work, with transactions handled in EITHER tokens or credits.',
    },
    {
      question: 'What is the $EITHER token used for?',
      answer:
        'EITHER is the backbone of the ecosystem. It powers subscriptions, deployment credits, marketplace transactions, governance, and incentives for creators and stakers.',
    },
  ];

  const toggleFAQ = (index: number) => {
    setOpenIndex(openIndex === index ? null : index);
  };

  return (
    <div className="w-full bg-black py-32 max-w-[1280px] mx-auto">
      <div className="max-w-6xl mx-auto px-6 bg-black">
        <h2 className="text-[56px] font-syne font-medium leading-[67px] tracking-[-0.05em] text-white mb-16 bg-black">
          FAQ
        </h2>

        <div className="bg-black">
          {faqs.map((faq, index) => (
            <div key={index} className="border-b border-white last:border-b-0 bg-black">
              <button
                onClick={() => toggleFAQ(index)}
                className="w-full flex items-start justify-between py-12 gap-12  transition-all duration-200 group bg-black"
              >
                <div className="flex-1 text-left bg-black">
                  <h3 className="text-[32px] max-[768px]:text-[24px] font-syne font-medium leading-[38px] max-[768px]:leading-[28px] tracking-[-0.05em] text-white group-hover:text-white transition-colors duration-200 bg-black">
                    {faq.question}
                  </h3>

                  {openIndex === index && (
                    <div className="bg-black mt-6">
                      <p className="text-[16px] max-[768px]:text-[14px] font-montserrat font-medium leading-[150%] text-white/90 pb-4 bg-black">
                        {faq.answer}
                      </p>
                    </div>
                  )}
                </div>

                <div className="flex-shrink-0 w-8 h-8 flex items-center justify-center bg-black">
                  <div className="w-8 h-8 rounded-full  flex items-center justify-center  transition-all duration-200">
                    <svg
                      className={`w-32 h-32 text-white transition-transform duration-300 ease-out ${
                        openIndex === index ? 'rotate-180' : 'rotate-0'
                      }`}
                      fill="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
                    </svg>
                  </div>
                </div>
              </button>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/landing/Footer.tsx">
import React from 'react';

export function Footer() {
  return (
    <div className="w-full bg-black py-8">
      <div className="max-w-6xl mx-auto px-6 flex justify-between items-center">
        <div className="text-white text-sm font-montserrat">Copyright  2025 Eitherway. All rights reserved.</div>

        <div className="flex items-center gap-4">
          <a href="http://t.me/eitherway_ai" className="p-0">
            <img src="/icons/links/tg.svg" alt="Telegram" className="w-7" />
          </a>
          <a href="http://x.com/eitherwayai" target="_blank" rel="noopener noreferrer">
            <svg className="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 24 24">
              <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
            </svg>
          </a>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/landing/Header.tsx">
import { useWalletConnection } from '~/lib/web3/hooks';
import { useState, useEffect } from 'react';
import { Menu } from '~/components/sidebar/Menu.client';
import { ClientOnly } from 'remix-utils/client-only';
import { useStore } from '@nanostores/react';
import { chatStore } from '~/lib/stores/chat';
import styles from './Landing.module.scss';

function HeaderContent() {
  const { connectWallet } = useWalletConnection();
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  const chatState = useStore(chatStore);
  const chatStarted = chatState?.started || false;

  const toggleMobileMenu = () => {
    setIsMobileMenuOpen(!isMobileMenuOpen);
  };

  useEffect(() => {
    const handleResize = () => {
      if (window.innerWidth > 1024 && isMobileMenuOpen) {
        setIsMobileMenuOpen(false);
      }
    };

    window.addEventListener('resize', handleResize);

    return () => window.removeEventListener('resize', handleResize);
  }, [isMobileMenuOpen]);

  return (
    <div className={`${styles['landing-header']} ${chatStarted ? styles['chat-mode'] : ''}`}>
      <div className={styles['header-container']}>
        <div className={styles.navbar}>
          {!chatStarted && (
            <div className={styles['right-side']}>
              <nav className={styles['navbar-links']}>
                <a href="#pricing" className={styles['navbar-link']}>
                  Pricing
                </a>
                <a
                  href="http://docs.eitherway.ai"
                  target="_blank"
                  rel="noopener noreferrer"
                  className={styles['navbar-link']}
                >
                  Documentation
                </a>
              </nav>

              <button className={styles['primary-button']} onClick={connectWallet}>
                <span className={styles['button-text']}>BUY $EITHER</span>
                <div className={styles['button-overlay']}></div>
              </button>
            </div>
          )}

          <button className={styles['burger-menu']} onClick={toggleMobileMenu}>
            <div className={styles['burger-line']}></div>
            <div className={styles['burger-line']}></div>
            <div className={styles['burger-line']}></div>
          </button>
        </div>
      </div>

      {isMobileMenuOpen && (
        <div className={styles['mobile-menu']}>
          <nav className={styles['mobile-nav']}>
            <a href="#pricing" className={styles['mobile-nav-item']}>
              Pricing
            </a>
            <a
              href="http://docs.eitherway.ai"
              target="_blank"
              rel="noopener noreferrer"
              className={styles['mobile-nav-item']}
            >
              Documentation
            </a>
          </nav>
          <div className={styles['mobile-wallet-section']}>
            <button className={styles['mobile-wallet-button']} onClick={connectWallet}>
              Connect Wallet
              <div className={styles['button-overlay']}></div>
            </button>
            <button className={styles['mobile-buy-button']} onClick={connectWallet}>
              BUY $EITHER
              <div className={styles['button-overlay']}></div>
            </button>
          </div>
        </div>
      )}

      <ClientOnly>{() => <Menu />}</ClientOnly>
    </div>
  );
}

function StaticHeader() {
  return (
    <div className={styles['landing-header']}>
      <div className={styles['header-container']}>
        <div className={styles.navbar}>
          <div className={styles['right-side']}>
            <nav className={styles['navbar-links']}>
              <a href="#pricing" className={styles['navbar-link']}>
                Pricing
              </a>
              <a
                href="http://docs.eitherway.ai"
                target="_blank"
                rel="noopener noreferrer"
                className={styles['navbar-link']}
              >
                Documentation
              </a>
            </nav>

            <button className={styles['primary-button']}>
              <span className={styles['button-text']}>BUY $EITHER</span>
              <div className={styles['button-overlay']}></div>
            </button>
          </div>

          <button className={styles['burger-menu']}>
            <div className={styles['burger-line']}></div>
            <div className={styles['burger-line']}></div>
            <div className={styles['burger-line']}></div>
          </button>
        </div>
      </div>
    </div>
  );
}

export function Header() {
  useEffect(() => {
    const staticHeader = document.querySelector('.static-header') as HTMLElement;
    const interactiveHeader = document.querySelector('.interactive-header') as HTMLElement;

    if (staticHeader && interactiveHeader) {
      setTimeout(() => {
        staticHeader.style.display = 'none';
        interactiveHeader.style.display = 'block';
      }, 100);
    }
  }, []);

  return (
    <>
      <div className="static-header">
        <StaticHeader />
      </div>
      <div className="interactive-header" style={{ display: 'none' }}>
        <ClientOnly>{() => <HeaderContent />}</ClientOnly>
      </div>
    </>
  );
}
</file>

<file path="packages/ui-frontend/app/components/landing/Landing.module.scss">
.landing {
  position: relative;
  width: 100%;
  min-height: 100vh;
  margin: 0;
  background: #000000;
  font-family: 'Inter', sans-serif;
  overflow-x: hidden;
  display: flex;
  flex-direction: column;
  padding: 0;
}

.landing-header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 20;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  padding: 24px 0 24px;
  width: 100vw;

  &.chat-mode {
    justify-content: flex-start;
    left: 0;
    right: auto;
    width: auto;
    padding-left: 24px;
  }
}

.header-container {
  position: relative;
  width: 100%;

  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0 24px 0 12px;

  .chat-mode & {
    margin-left: 0;
    margin-right: 0;
    max-width: none;
    width: auto;
    justify-content: flex-start;
  }
}

.sidebar-button {
  display: flex !important;
  align-items: center;
  justify-content: center;
  width: 48px;
  height: 48px;
  background: transparent;
  border: none;
  cursor: pointer;
  position: fixed;
  left: 0;
  top: 40px;
  transform: translateY(0);
  z-index: 998;
  padding: 0;

  .sidebar-icon {
    width: 24px;
    height: 24px;
    filter: brightness(0) invert(1);
  }

  @media (max-width: 1024px) {
    left: 0;
    top: 40px;
    transform: translateY(0);
    z-index: 998;
  }
}

.navbar {
  box-sizing: border-box;
  position: relative;
  max-width: 100%;
  width: 100%;
  height: 80px;
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border-radius: 512px;
  display: flex;
  align-items: center;
  justify-content: flex-end;
  padding: 0 12px 0 48px;

  .logo-container {
    position: relative;
    width: 202px;
    height: 32px;
    display: flex;
    align-items: center;
    z-index: 1000;

    .logo-icon {
      height: 32px;
      width: auto;
      object-fit: contain;
    }
  }

  .right-side {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 24px;
    height: 56px;

    .navbar-links {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 0;
      height: 56px;

      .navbar-link {
        display: flex;
        flex-direction: row;
        justify-content: center;
        align-items: center;
        padding: 8px 24px;
        gap: 8px;
        height: 56px;
        text-decoration: none;
        transition: all 0.2s ease;

        &:hover {
          background: rgba(255, 255, 255, 0.05);
          border-radius: 64px;
        }

        &:first-child {
          width: 106px;
        }

        &:nth-child(2) {
          width: 177px;
        }

        &:last-child {
          width: 154px;
        }

        font-family: 'Montserrat', sans-serif;
        font-style: normal;
        font-weight: 500;
        font-size: 16px;
        line-height: 150%;
        text-align: center;
        color: #ffffff;
      }
    }

    .primary-button {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      padding: 16px 48px;
      gap: 8px;
      isolation: isolate;
      width: 209px;
      height: 56px;
      background: var(--eitherway-primary);
      border-radius: 512px;
      border: none;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      transition: all 0.2s ease;

      &:hover {
        .button-overlay {
          left: calc(100% + 20px);
          transition: left 0.4s ease;
        }
      }

      .button-text {
        width: 113px;
        height: 24px;
        font-family: 'Montserrat', sans-serif;
        font-style: italic;
        font-weight: 800;
        font-size: 16px;
        line-height: 150%;
        text-align: center;
        color: #ffffff;
        z-index: 2;
        position: relative;
      }

      .button-overlay {
        position: absolute;
        width: 40px;
        height: 100%;
        left: -60px;
        top: 0px;
        background: #ffffff40;
        transform: skewX(-20deg);
        z-index: 1;
        transition: left 0.4s ease;
      }
    }
  }

  .burger-menu {
    display: none;
    flex-direction: column;
    gap: 4px;
    background: transparent;
    border: none;
    cursor: pointer;
    padding: 8px;

    @media (max-width: 1024px) {
      display: flex;
    }

    @media (min-width: 1025px) {
      display: none !important;
    }

    .burger-line {
      width: 24px;
      height: 3px;
      background: #ffffff;
      border-radius: 2px;
      transition: all 0.3s ease;
    }
  }

  @media (max-width: 1024px) {
    width: 100%;
    max-width: none;
    padding: 0 24px;
    // margin-left: 48px;

    .right-side {
      display: none;
    }
  }
}

.mobile-menu {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(16px);
  border-radius: 16px;
  margin: 16px 24px;
  padding: 32px;
  display: block;
  z-index: 100;

  @media (min-width: 1025px) {
    display: none !important;
  }

  .mobile-nav {
    display: flex;
    flex-direction: column;
    gap: 24px;
    margin-bottom: 32px;

    .mobile-nav-item {
      font-family: 'Montserrat', sans-serif;
      font-weight: 500;
      font-size: 16px;
      color: #ffffff;
      text-decoration: none;
      padding: 12px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.15);

      &:last-child {
        border-bottom: none;
      }

      &:hover {
        color: #cccccc;
      }
    }
  }

  .mobile-wallet-section {
    border-top: 1px solid rgba(255, 255, 255, 0.15);
    padding-top: 24px;
    display: flex;
    flex-direction: column;
    gap: 16px;

    .mobile-wallet-button {
      width: 100%;
      padding: 16px 48px;
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 512px;
      font-family: 'Montserrat', sans-serif;
      font-weight: 500;
      font-size: 16px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;

      &:hover {
        .button-overlay {
          left: calc(100% + 20px);
          transition: left 0.4s ease;
        }
      }

      .button-overlay {
        position: absolute;
        width: 40px;
        height: 100%;
        left: -60px;
        top: 0px;
        background: linear-gradient(45deg, transparent 0%, rgba(255, 255, 255, 0.3) 50%, transparent 100%);
        transform: skewX(-20deg);
        z-index: 1;
        transition: left 0.4s ease;
      }
    }

    .mobile-buy-button {
      width: 100%;
      padding: 16px 48px;
      background: #0d00ff;
      border: none;
      border-radius: 512px;
      font-family: 'Montserrat', sans-serif;
      font-style: italic;
      font-weight: 800;
      font-size: 16px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;

      &:hover {
        .button-overlay {
          left: calc(100% + 20px);
          transition: left 0.4s ease;
        }
      }

      .button-overlay {
        position: absolute;
        width: 40px;
        height: 100%;
        left: -60px;
        top: 0px;
        background: #ffffff40;
        transform: skewX(-20deg);
        z-index: 1;
        transition: left 0.4s ease;
      }
    }
  }
}
</file>

<file path="packages/ui-frontend/app/components/landing/Landing.tsx">
import styles from './Landing.module.scss';
import { Header } from './Header';
import { ClientOnly } from 'remix-utils/client-only';

export function Landing() {
  return (
    <div className={styles.landing}>
      <ClientOnly>{() => <Header />}</ClientOnly>
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/landing/LastBlock.module.scss">
.start-building-button {
  &:hover {
    .button-overlay {
      left: calc(100% + 20px);
      transition: left 0.4s ease;
    }
  }

  .button-overlay {
    position: absolute;
    width: 40px;
    height: 100%;
    left: -60px;
    top: 0px;
    background: #ffffff40;
    transform: skewX(-20deg);
    z-index: 1;
    transition: left 0.4s ease;
  }
}
</file>

<file path="packages/ui-frontend/app/components/landing/LastBlock.tsx">
import React from 'react';
import styles from './LastBlock.module.scss';

export function LastBlock() {
  const scrollToTop = () => {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };

  return (
    <div className="w-full bg-black py-80">
      <div className="max-w-4xl mx-auto px-6 text-center">
        <h2 className="text-[64px] font-syne font-medium leading-[77px] tracking-[-0.05em] text-white mb-6">
          Build today. Launch tomorrow.
        </h2>

        <p className="text-[16px] font-montserrat font-medium leading-[150%] text-white mb-12">
          Your ideas deserve to live in the world. With Eitherway, they can  instantly.
        </p>

        <div className="relative inline-block">
          <div className="absolute -left-9 top-0 w-9 h-14"></div>
          <button
            onClick={scrollToTop}
            className={`relative bg-[#0D00FF] text-white px-12 py-4 rounded-full font-montserrat italic font-extrabold text-[16px] leading-[150%] uppercase transition-colors duration-200 cursor-pointer overflow-hidden ${styles['start-building-button']}`}
          >
            <span className="relative z-10">START BUILDING</span>
            <div className={styles['button-overlay']}></div>
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/landing/LastWorksCard.tsx">
import styles from './Landing.module.scss';
import { PhoneSlider } from './PhoneSlider';

interface LastWorksCardProps {
  activeSlide: number;
  isTransitioning: boolean;
  onMouseEnter: () => void;
  onMouseLeave: () => void;
  onDotClick: (slideIndex: number) => void;
}

export function LastWorksCard({
  activeSlide,
  isTransitioning,
  onMouseEnter,
  onMouseLeave,
  onDotClick,
}: LastWorksCardProps) {
  return (
    <div className={styles['last-works-card']} onMouseEnter={onMouseEnter} onMouseLeave={onMouseLeave}>
      <h3>LATEST APP IDEAS</h3>
      <div className={styles['text-slider']}>
        <p
          className={`${styles['app-name']} ${activeSlide === 0 ? styles.active : ''} ${isTransitioning ? styles.transitioning : ''}`}
        >
          Fitness app
        </p>
        <p
          className={`${styles['app-name']} ${activeSlide === 1 ? styles.active : ''} ${isTransitioning ? styles.transitioning : ''}`}
        >
          Wallet app
        </p>
        <p
          className={`${styles['app-name']} ${activeSlide === 2 ? styles.active : ''} ${isTransitioning ? styles.transitioning : ''}`}
        >
          Chat app
        </p>
      </div>
      <div className={styles['dots-indicator']}>
        <button
          className={`${styles.dot} ${activeSlide === 0 ? styles.active : ''}`}
          onClick={() => onDotClick(0)}
        ></button>
        <button
          className={`${styles.dot} ${activeSlide === 1 ? styles.active : ''}`}
          onClick={() => onDotClick(1)}
        ></button>
        <button
          className={`${styles.dot} ${activeSlide === 2 ? styles.active : ''}`}
          onClick={() => onDotClick(2)}
        ></button>
      </div>
      <PhoneSlider activeSlide={activeSlide} isTransitioning={isTransitioning} />
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/landing/LeftSidebar.tsx">
import styles from './Landing.module.scss';
import { CornerDecorations } from './CornerDecorations';
import { LastWorksCard } from './LastWorksCard';
import { useSlider } from './useSlider';

export function LeftSidebar() {
  const { activeSlide, isTransitioning, handleDotClick, handleMouseEnter, handleMouseLeave } = useSlider();

  return (
    <div className={styles['left-sidebar']}>
      <a href="/" rel="noopener noreferrer" className={styles['whitepaper-card']}>
        <CornerDecorations />
        <div className={styles['card-content']}>
          <img src="/icons/whitepaper.svg" alt="Whitepaper" />
          <span>DOCS</span>
        </div>
      </a>
      <LastWorksCard
        activeSlide={activeSlide}
        isTransitioning={isTransitioning}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        onDotClick={handleDotClick}
      />
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/landing/PhoneSlider.tsx">
import styles from './Landing.module.scss';

interface PhoneSliderProps {
  activeSlide: number;
  isTransitioning: boolean;
}

export function PhoneSlider({ activeSlide, isTransitioning }: PhoneSliderProps) {
  return (
    <div className={styles['phone-slider']}>
      <div className={styles['phone-track']}>
        <div
          className={`${styles['phone-slide']} ${activeSlide === 0 ? styles.active : ''} ${isTransitioning ? styles.transitioning : ''}`}
        >
          <img src="/icons/phones/phone-01.png" alt="Phone 1" />
        </div>
        <div
          className={`${styles['phone-slide']} ${activeSlide === 1 ? styles.active : ''} ${isTransitioning ? styles.transitioning : ''}`}
        >
          <img src="/icons/phones/phone-02.png" alt="Phone 2" />
        </div>
        <div
          className={`${styles['phone-slide']} ${activeSlide === 2 ? styles.active : ''} ${isTransitioning ? styles.transitioning : ''}`}
        >
          <img src="/icons/phones/phone-03.png" alt="Phone 3" />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/landing/PricingBlock.tsx">
import React, { useState } from 'react';

export function PricingBlock() {
  const [copied, setCopied] = useState(false);

  const handleCopyEmail = async () => {
    try {
      await navigator.clipboard.writeText('inquiries@eitherway.ai');
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error('Failed to copy email:', err);
    }
  };

  return (
    <div id="pricing" className="w-full h-[512px] bg-[#0D00FF] flex items-center justify-center scroll-mt-32">
      <div className="text-center text-white max-w-[592px] mx-auto px-6">
        <h2 className="min-[600px]:text-[56px] text-[40px] font-bold mb-8 font-syne">Pricing plans</h2>

        <div className="space-y-4 mb-12">
          <p className="text-lg font-montserrat">This section is coming soon.</p>
          <p className="text-lg font-montserrat">
            Eitherway is currently in <span className="font-bold italic">closed beta</span>. For more information,
            please contact us.
          </p>
        </div>

        <div className="flex flex-col items-center gap-4">
          <div
            onClick={handleCopyEmail}
            className="flex cursor-pointer w-[360px]  items-center gap-2 opacity-75 hover:opacity-100 px-12 py-4 border-2 border-dashed border-white rounded-2xl bg-transparent"
          >
            <button
              onClick={handleCopyEmail}
              className="flex items-center group justify-center bg-transparent rounded transition-colors"
            >
              {copied ? (
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  height="24px"
                  viewBox="0 -960 960 960"
                  width="24px"
                  fill="#e3e3e3"
                >
                  <path d="M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z" />
                </svg>
              ) : (
                <svg width="24" height="22" viewBox="0 0 24 25" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <g clipPath="url(#clip0_257_9)">
                    <path d="M16 1.5H2V17.5H4V3.5H16V1.5ZM21 5.5H6V23.5H21V5.5ZM19 21.5H8V7.5H19V21.5Z" fill="white" />
                  </g>
                  <defs>
                    <clipPath id="clip0_257_9">
                      <rect width="24" height="24" fill="white" transform="translate(0 0.5)" />
                    </clipPath>
                  </defs>
                </svg>
              )}
            </button>
            {copied ? (
              <span className="font-syne text-center w-full text-2xl tracking-tighter leading-none font-medium hover:underline cursor-pointer">
                Copied!
              </span>
            ) : (
              <a
                href="mailto:inquiries@eitherway.ai"
                className="font-syne text-2xl tracking-tighter leading-none font-medium hover:underline cursor-pointer"
              >
                inquiries@eitherway.ai
              </a>
            )}
          </div>
          <span className="font-montserrat text-white w-full text-center">click to copy</span>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/landing/RightSidebar.tsx">
import styles from './Landing.module.scss';
import { CornerDecorations } from './CornerDecorations';

export function RightSidebar() {
  return (
    <div className={styles['right-sidebar']}>
      <div className={styles['buy-token-card']}>
        <div className={styles['rainbow-circle']}>
          <img src="/icons/rainbowCircle.svg" alt="Rainbow Circle" />
        </div>
        <div className={styles['text-content']}>
          <h3>BUY TOKEN</h3>
          <p className={styles['network-text']}>Ethereum Mainnet</p>
          <span className={styles['price-badge']}>+19.51%</span>
        </div>
        <button className={styles['buy-button']}>
          <img src="/icons/buyArrow.svg" alt="Buy Arrow" />
        </button>
      </div>
      <a href="/chat" className={styles['launch-dapp-card']}>
        <CornerDecorations />
        <div className={styles['card-content']}>
          <img src="/icons/LaunchDapp.svg" alt="Launch dApp" />
          <span>LAUNCH APP</span>
        </div>
      </a>
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/landing/useSlider.ts">
import { useEffect, useState } from 'react';

export function useSlider() {
  const [activeSlide, setActiveSlide] = useState(0);
  const [isTransitioning, setIsTransitioning] = useState(false);
  const [isHovered, setIsHovered] = useState(false);
  const [userInteracted, setUserInteracted] = useState(false);
  const [isPageVisible, setIsPageVisible] = useState(true);

  useEffect(() => {
    if (isHovered || userInteracted || !isPageVisible) {
      return;
    }

    const interval = setInterval(() => {
      void setIsTransitioning(true);
      setTimeout(() => {
        void setActiveSlide((prev) => (prev + 1) % 3);
        setTimeout(() => {
          void setIsTransitioning(false);
        }, 300);
      }, 300);
    }, 4000);

    // eslint-disable-next-line
    return () => clearInterval(interval);
  }, [isHovered, userInteracted, isPageVisible]);

  useEffect(() => {
    const handleVisibilityChange = () => {
      const isVisible = !document.hidden;
      void setIsPageVisible(isVisible);

      if (!isVisible) {
        void setIsTransitioning(false);
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, []);

  const handleDotClick = (slideIndex: number) => {
    void setUserInteracted(true);
    void setActiveSlide(slideIndex);
  };

  const handleMouseEnter = () => {
    void setIsHovered(true);
  };

  const handleMouseLeave = () => {
    void setIsHovered(false);
    void setUserInteracted(false);
  };

  return {
    activeSlide,
    isTransitioning,
    isHovered,
    handleDotClick,
    handleMouseEnter,
    handleMouseLeave,
  };
}
</file>

<file path="packages/ui-frontend/app/components/sidebar/date-binning.ts">
import { format, isAfter, isThisWeek, isThisYear, isToday, isYesterday, subDays } from 'date-fns';
import type { ChatHistoryItem } from '~/lib/persistence';

type Bin = { category: string; items: ChatHistoryItem[] };

export function binDates(_list: ChatHistoryItem[]) {
  const list = _list.toSorted((a, b) => Date.parse(b.timestamp) - Date.parse(a.timestamp));

  const binLookup: Record<string, Bin> = {};
  const bins: Array<Bin> = [];

  list.forEach((item) => {
    const category = dateCategory(new Date(item.timestamp));

    if (!(category in binLookup)) {
      const bin = {
        category,
        items: [item],
      };

      binLookup[category] = bin;

      bins.push(bin);
    } else {
      binLookup[category].items.push(item);
    }
  });

  return bins;
}

function dateCategory(date: Date) {
  if (isToday(date)) {
    return 'Today';
  }

  if (isYesterday(date)) {
    return 'Yesterday';
  }

  if (isThisWeek(date)) {
    // e.g., "Monday"
    return format(date, 'eeee');
  }

  const thirtyDaysAgo = subDays(new Date(), 30);

  if (isAfter(date, thirtyDaysAgo)) {
    return 'Last 30 Days';
  }

  if (isThisYear(date)) {
    // e.g., "July"
    return format(date, 'MMMM');
  }

  // e.g., "July 2023"
  return format(date, 'MMMM yyyy');
}
</file>

<file path="packages/ui-frontend/app/components/sidebar/HistoryItem.tsx">
import * as Dialog from '@radix-ui/react-dialog';
import { useEffect, useRef, useState } from 'react';
import { type ChatHistoryItem } from '~/lib/persistence';

interface HistoryItemProps {
  item: ChatHistoryItem;
  onDelete?: (event: React.UIEvent) => void;
}

export function HistoryItem({ item, onDelete }: HistoryItemProps) {
  const [hovering, setHovering] = useState(false);
  const hoverRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    let timeout: NodeJS.Timeout | undefined;

    function mouseEnter() {
      setHovering(true);

      if (timeout) {
        clearTimeout(timeout);
      }
    }

    function mouseLeave() {
      setHovering(false);
    }

    hoverRef.current?.addEventListener('mouseenter', mouseEnter);
    hoverRef.current?.addEventListener('mouseleave', mouseLeave);

    return () => {
      hoverRef.current?.removeEventListener('mouseenter', mouseEnter);
      hoverRef.current?.removeEventListener('mouseleave', mouseLeave);
    };
  }, []);

  return (
    <div
      ref={hoverRef}
      className="group rounded-md hover:bg-white/10 text-eitherway-elements-textSecondary hover:text-eitherway-elements-textPrimary hover:bg-eitherway-elements-background-depth-3 overflow-hidden flex justify-between items-center px-2 py-1"
    >
      <a href={`/chat/${item.urlId}`} className="flex w-full relative truncate  block">
        {item.description}
        <div className="absolute right-0 z-1 top-0 bottom-0 bg-gradient-to-l  w-10 flex justify-end group-hover:w-15 group-hover:from-45%">
          {hovering && (
            <div className="flex items-center p-1 text-eitherway-elements-textSecondary hover:text-eitherway-elements-item-contentDanger">
              <Dialog.Trigger asChild>
                <button
                  className="i-ph:trash scale-110"
                  onClick={(event) => {
                    // we prevent the default so we don't trigger the anchor above
                    event.preventDefault();
                    onDelete?.(event);
                  }}
                />
              </Dialog.Trigger>
            </div>
          )}
        </div>
      </a>
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/ui/Dialog.tsx">
import * as RadixDialog from '@radix-ui/react-dialog';
import { motion, type Variants } from 'framer-motion';
import React, { memo, type ReactNode } from 'react';
import { classNames } from '~/utils/classNames';
import { cubicEasingFn } from '~/utils/easings';

export { Close as DialogClose, Root as DialogRoot } from '@radix-ui/react-dialog';

const transition = {
  duration: 0.15,
  ease: cubicEasingFn,
};

export const dialogBackdropVariants = {
  closed: {
    opacity: 0,
    transition,
  },
  open: {
    opacity: 1,
    transition,
  },
} satisfies Variants;

export const dialogVariants = {
  closed: {
    x: '-50%',
    y: '-40%',
    scale: 0.96,
    opacity: 0,
    transition,
  },
  open: {
    x: '-50%',
    y: '-50%',
    scale: 1,
    opacity: 1,
    transition,
  },
} satisfies Variants;

interface DialogButtonProps {
  type: 'primary' | 'secondary' | 'danger';
  children: ReactNode;
  onClick?: (event: React.UIEvent) => void;
}

export const DialogButton = memo(({ type, children, onClick }: DialogButtonProps) => {
  return (
    <button
      className={classNames(
        'inline-flex h-[35px] items-center justify-center rounded-lg px-4 text-sm leading-none focus:outline-none',
        {
          'bg-eitherway-elements-button-primary-background text-eitherway-elements-button-primary-text hover:bg-eitherway-elements-button-primary-backgroundHover':
            type === 'primary',
          'bg-eitherway-elements-button-secondary-background text-eitherway-elements-button-secondary-text hover:bg-eitherway-elements-button-secondary-backgroundHover':
            type === 'secondary',
          'bg-eitherway-elements-button-danger-background text-eitherway-elements-button-danger-text hover:bg-eitherway-elements-button-danger-backgroundHover':
            type === 'danger',
        },
      )}
      onClick={onClick}
    >
      {children}
    </button>
  );
});

export const DialogTitle = memo(({ className, children, ...props }: RadixDialog.DialogTitleProps) => {
  return (
    <RadixDialog.Title
      className={classNames(
        'px-5 py-4 flex items-center justify-between border-b border-eitherway-elements-borderColor text-lg font-semibold leading-6 text-eitherway-elements-textPrimary',
        className,
      )}
      {...props}
    >
      {children}
    </RadixDialog.Title>
  );
});

export const DialogDescription = memo(({ className, children, ...props }: RadixDialog.DialogDescriptionProps) => {
  return (
    <RadixDialog.Description
      className={classNames('px-5 py-4 text-eitherway-elements-textPrimary text-md', className)}
      {...props}
    >
      {children}
    </RadixDialog.Description>
  );
});

interface DialogProps {
  children: ReactNode | ReactNode[];
  className?: string;
  onBackdrop?: (event: React.UIEvent) => void;
  onClose?: (event: React.UIEvent) => void;
  noBorder?: boolean;
}

export const Dialog = memo(({ className, children, onBackdrop, onClose, noBorder = false }: DialogProps) => {
  return (
    <RadixDialog.Portal>
      <RadixDialog.Overlay onClick={onBackdrop} asChild>
        <motion.div
          className="bg-black/50 fixed inset-0 z-max"
          initial="closed"
          animate="open"
          exit="closed"
          variants={dialogBackdropVariants}
        />
      </RadixDialog.Overlay>
      <RadixDialog.Content asChild>
        <motion.div
          className={classNames(
            'fixed top-[50%] left-[50%] z-max max-h-[85vh] w-[90vw] max-w-[450px] translate-x-[-50%] translate-y-[-50%] rounded-lg bg-eitherway-elements-background-depth-2 shadow-lg focus:outline-none overflow-hidden',
            !noBorder ? 'border border-eitherway-elements-borderColor' : '',
            className,
          )}
          initial="closed"
          animate="open"
          exit="closed"
          variants={dialogVariants}
        >
          {children}
          <RadixDialog.Close asChild onClick={onClose}>
            <button className="absolute top-[10px] bg-black right-[10px] w-8 h-8 flex items-center justify-center text-gray-500 hover:text-gray-700 rounded-full transition-colors">
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </RadixDialog.Close>
        </motion.div>
      </RadixDialog.Content>
    </RadixDialog.Portal>
  );
});
</file>

<file path="packages/ui-frontend/app/components/ui/IconButton.tsx">
import { memo } from 'react';
import { classNames } from '~/utils/classNames';

type IconSize = 'sm' | 'md' | 'lg' | 'xl' | 'xxl';

interface BaseIconButtonProps {
  size?: IconSize;
  className?: string;
  iconClassName?: string;
  disabledClassName?: string;
  title?: string;
  disabled?: boolean;
  onClick?: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;
}

type IconButtonWithoutChildrenProps = {
  icon: string;
  children?: undefined;
} & BaseIconButtonProps;

type IconButtonWithChildrenProps = {
  icon?: undefined;
  children: string | JSX.Element | JSX.Element[];
} & BaseIconButtonProps;

type IconButtonProps = IconButtonWithoutChildrenProps | IconButtonWithChildrenProps;

export const IconButton = memo(
  ({
    icon,
    size = 'xl',
    className,
    iconClassName,
    disabledClassName,
    disabled = false,
    title,
    onClick,
    children,
  }: IconButtonProps) => {
    return (
      <button
        className={classNames(
          'flex items-center text-eitherway-elements-item-contentDefault bg-transparent enabled:hover:text-eitherway-elements-item-contentActive rounded-md p-1 enabled:hover:bg-eitherway-elements-item-backgroundActive disabled:cursor-not-allowed',
          {
            [classNames('opacity-30', disabledClassName)]: disabled,
          },
          className,
        )}
        title={title}
        disabled={disabled}
        onClick={(event) => {
          if (disabled) {
            return;
          }

          onClick?.(event);
        }}
      >
        {children ? children : <div className={classNames(icon, getIconSize(size), iconClassName)}></div>}
      </button>
    );
  },
);

function getIconSize(size: IconSize) {
  if (size === 'sm') {
    return 'text-sm';
  } else if (size === 'md') {
    return 'text-md';
  } else if (size === 'lg') {
    return 'text-lg';
  } else if (size === 'xl') {
    return 'text-xl';
  } else {
    return 'text-2xl';
  }
}
</file>

<file path="packages/ui-frontend/app/components/ui/Loader.tsx">
import React from 'react';

export function Loader() {
  return (
    <div className="fixed inset-0 bg-black flex items-center justify-center z-[9999]">
      <div className="text-center">
        <div className="w-16 h-16 border-4 border-white/20 border-t-white rounded-full animate-spin mx-auto mb-4"></div>
        <p className="text-white text-lg">Loading Eitherway...</p>
      </div>
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/ui/LoadingDots.tsx">
import { memo, useEffect, useState } from 'react';

interface LoadingDotsProps {
  text: string;
}

export const LoadingDots = memo(({ text }: LoadingDotsProps) => {
  const [dotCount, setDotCount] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setDotCount((prevDotCount) => (prevDotCount + 1) % 4);
    }, 500);

    return () => clearInterval(interval);
  }, []);

  return (
    <div className="flex justify-center items-center h-full">
      <div className="relative">
        <span>{text}</span>
        <span className="absolute left-[calc(100%-12px)]">{'.'.repeat(dotCount)}</span>
        <span className="invisible">...</span>
      </div>
    </div>
  );
});
</file>

<file path="packages/ui-frontend/app/components/ui/PanelHeader.tsx">
import { memo } from 'react';
import { classNames } from '~/utils/classNames';

interface PanelHeaderProps {
  className?: string;
  children: React.ReactNode;
}

export const PanelHeader = memo(({ className, children }: PanelHeaderProps) => {
  return (
    <div
      className={classNames(
        'flex items-center gap-2 bg-eitherway-elements-background-depth-2 text-eitherway-elements-textSecondary border-b border-eitherway-elements-borderColor px-4 py-1 min-h-[34px] text-sm',
        className,
      )}
    >
      {children}
    </div>
  );
});
</file>

<file path="packages/ui-frontend/app/components/ui/PanelHeaderButton.tsx">
import { memo } from 'react';
import { classNames } from '~/utils/classNames';

interface PanelHeaderButtonProps {
  className?: string;
  disabledClassName?: string;
  disabled?: boolean;
  children: string | JSX.Element | Array<JSX.Element | string>;
  onClick?: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;
}

export const PanelHeaderButton = memo(
  ({ className, disabledClassName, disabled = false, children, onClick }: PanelHeaderButtonProps) => {
    return (
      <button
        className={classNames(
          'flex items-center shrink-0 gap-1.5 px-1.5 rounded-md py-0.5 text-eitherway-elements-item-contentDefault bg-transparent enabled:hover:text-eitherway-elements-item-contentActive enabled:hover:bg-eitherway-elements-item-backgroundActive disabled:cursor-not-allowed',
          {
            [classNames('opacity-30', disabledClassName)]: disabled,
          },
          className,
        )}
        disabled={disabled}
        onClick={(event) => {
          if (disabled) {
            return;
          }

          onClick?.(event);
        }}
      >
        {children}
      </button>
    );
  },
);
</file>

<file path="packages/ui-frontend/app/components/ui/Slider.tsx">
import { memo } from 'react';
import { classNames } from '~/utils/classNames';
import { genericMemo } from '~/utils/react';

interface SliderOption<T> {
  value: T;
  text: string;
}

export interface SliderOptions<T> {
  left: SliderOption<T>;
  right: SliderOption<T>;
}

interface SliderProps<T> {
  selected: T;
  options: SliderOptions<T>;
  setSelected?: (selected: T) => void;
}

export const Slider = genericMemo(<T,>({ selected, options, setSelected }: SliderProps<T>) => {
  const isLeftSelected = selected === options.left.value;

  return (
    <div className="flex items-center flex-wrap border border-eitherway-elements-borderColor shrink-0 gap-1 overflow-hidden rounded-full p-1">
      <SliderButton selected={isLeftSelected} setSelected={() => setSelected?.(options.left.value)}>
        <img src="/icons/chat/brackets.svg" alt="Brackets" />
      </SliderButton>
      <SliderButton selected={!isLeftSelected} setSelected={() => setSelected?.(options.right.value)}>
        <img src="/icons/chat/eye.svg" alt="Eye" />
      </SliderButton>
    </div>
  );
});

interface SliderButtonProps {
  selected: boolean;
  children: string | JSX.Element | Array<JSX.Element | string>;
  setSelected: () => void;
}

const SliderButton = memo(({ selected, children, setSelected }: SliderButtonProps) => {
  return (
    <button
      onClick={setSelected}
      className={classNames(
        'text-sm px-2.5 py-1 rounded-full bg-black relative',
        selected ? 'opacity-100' : 'opacity-50 hover:opacity-100',
      )}
    >
      <span className="relative z-10">{children}</span>
    </button>
  );
});
</file>

<file path="packages/ui-frontend/app/components/workbench/terminal/Terminal.tsx">
import { FitAddon } from '@xterm/addon-fit';
import { WebLinksAddon } from '@xterm/addon-web-links';
import { Terminal as XTerm } from '@xterm/xterm';
import { forwardRef, memo, useEffect, useImperativeHandle, useRef } from 'react';
import type { Theme } from '~/lib/stores/theme';
import { createScopedLogger } from '~/utils/logger';
import { getTerminalTheme } from './theme';

const logger = createScopedLogger('Terminal');

export interface TerminalRef {
  reloadStyles: () => void;
}

export interface TerminalProps {
  className?: string;
  theme: Theme;
  readonly?: boolean;
  onTerminalReady?: (terminal: XTerm) => void;
  onTerminalResize?: (cols: number, rows: number) => void;
}

export const Terminal = memo(
  forwardRef<TerminalRef, TerminalProps>(({ className, theme, readonly, onTerminalReady, onTerminalResize }, ref) => {
    const terminalElementRef = useRef<HTMLDivElement>(null);
    const terminalRef = useRef<XTerm>();

    useEffect(() => {
      const element = terminalElementRef.current!;

      const fitAddon = new FitAddon();
      const webLinksAddon = new WebLinksAddon();

      const terminal = new XTerm({
        cursorBlink: true,
        convertEol: true,
        disableStdin: readonly,
        theme: getTerminalTheme(readonly ? { cursor: '#00000000' } : {}),
        fontSize: 12,
        fontFamily: 'Menlo, courier-new, courier, monospace',
      });

      terminalRef.current = terminal;

      terminal.loadAddon(fitAddon);
      terminal.loadAddon(webLinksAddon);
      terminal.open(element);

      const resizeObserver = new ResizeObserver(() => {
        fitAddon.fit();
        onTerminalResize?.(terminal.cols, terminal.rows);
      });

      resizeObserver.observe(element);

      logger.info('Attach terminal');

      onTerminalReady?.(terminal);

      return () => {
        resizeObserver.disconnect();
        terminal.dispose();
      };
    }, []);

    useEffect(() => {
      const terminal = terminalRef.current!;

      // we render a transparent cursor in case the terminal is readonly
      terminal.options.theme = getTerminalTheme(readonly ? { cursor: '#00000000' } : {});

      terminal.options.disableStdin = readonly;
    }, [theme, readonly]);

    useImperativeHandle(ref, () => {
      return {
        reloadStyles: () => {
          const terminal = terminalRef.current!;
          terminal.options.theme = getTerminalTheme(readonly ? { cursor: '#00000000' } : {});
        },
      };
    }, []);

    return <div className={className} ref={terminalElementRef} />;
  }),
);
</file>

<file path="packages/ui-frontend/app/components/workbench/terminal/theme.ts">
import type { ITheme } from '@xterm/xterm';

const style = getComputedStyle(document.documentElement);
const cssVar = (token: string) => style.getPropertyValue(token) || undefined;

export function getTerminalTheme(overrides?: ITheme): ITheme {
  return {
    cursor: cssVar('--eitherway-elements-terminal-cursorColor'),
    cursorAccent: cssVar('--eitherway-elements-terminal-cursorColorAccent'),
    foreground: cssVar('--eitherway-elements-terminal-textColor'),
    background: cssVar('--eitherway-elements-terminal-backgroundColor'),
    selectionBackground: cssVar('--eitherway-elements-terminal-selection-backgroundColor'),
    selectionForeground: cssVar('--eitherway-elements-terminal-selection-textColor'),
    selectionInactiveBackground: cssVar('--eitherway-elements-terminal-selection-backgroundColorInactive'),

    // ansi escape code colors
    black: cssVar('--eitherway-elements-terminal-color-black'),
    red: cssVar('--eitherway-elements-terminal-color-red'),
    green: cssVar('--eitherway-elements-terminal-color-green'),
    yellow: cssVar('--eitherway-elements-terminal-color-yellow'),
    blue: cssVar('--eitherway-elements-terminal-color-blue'),
    magenta: cssVar('--eitherway-elements-terminal-color-magenta'),
    cyan: cssVar('--eitherway-elements-terminal-color-cyan'),
    white: cssVar('--eitherway-elements-terminal-color-white'),
    brightBlack: cssVar('--eitherway-elements-terminal-color-brightBlack'),
    brightRed: cssVar('--eitherway-elements-terminal-color-brightRed'),
    brightGreen: cssVar('--eitherway-elements-terminal-color-brightGreen'),
    brightYellow: cssVar('--eitherway-elements-terminal-color-brightYellow'),
    brightBlue: cssVar('--eitherway-elements-terminal-color-brightBlue'),
    brightMagenta: cssVar('--eitherway-elements-terminal-color-brightMagenta'),
    brightCyan: cssVar('--eitherway-elements-terminal-color-brightCyan'),
    brightWhite: cssVar('--eitherway-elements-terminal-color-brightWhite'),

    ...overrides,
  };
}
</file>

<file path="packages/ui-frontend/app/components/workbench/PortDropdown.tsx">
import { memo, useEffect, useRef } from 'react';
import { IconButton } from '~/components/ui/IconButton';
import type { PreviewInfo } from '~/lib/stores/previews';

interface PortDropdownProps {
  activePreviewIndex: number;
  setActivePreviewIndex: (index: number) => void;
  isDropdownOpen: boolean;
  setIsDropdownOpen: (value: boolean) => void;
  setHasSelectedPreview: (value: boolean) => void;
  previews: PreviewInfo[];
}

export const PortDropdown = memo(
  ({
    activePreviewIndex,
    setActivePreviewIndex,
    isDropdownOpen,
    setIsDropdownOpen,
    setHasSelectedPreview,
    previews,
  }: PortDropdownProps) => {
    const dropdownRef = useRef<HTMLDivElement>(null);

    // sort previews, preserving original index
    const sortedPreviews = previews
      .map((previewInfo, index) => ({ ...previewInfo, index }))
      .sort((a, b) => a.port - b.port);

    // close dropdown if user clicks outside
    useEffect(() => {
      const handleClickOutside = (event: MouseEvent) => {
        if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
          setIsDropdownOpen(false);
        }
      };

      if (isDropdownOpen) {
        window.addEventListener('mousedown', handleClickOutside);
      } else {
        window.removeEventListener('mousedown', handleClickOutside);
      }

      return () => {
        window.removeEventListener('mousedown', handleClickOutside);
      };
    }, [isDropdownOpen]);

    return (
      <div className="relative z-port-dropdown" ref={dropdownRef}>
        <IconButton icon="i-ph:plug" onClick={() => setIsDropdownOpen(!isDropdownOpen)} />
        {isDropdownOpen && (
          <div className="absolute right-0 mt-2 bg-eitherway-elements-background-depth-2 border border-eitherway-elements-borderColor rounded shadow-sm min-w-[140px] dropdown-animation">
            <div className="px-4 py-2 border-b border-eitherway-elements-borderColor text-sm font-semibold text-eitherway-elements-textPrimary">
              Ports
            </div>
            {sortedPreviews.map((preview) => (
              <div
                key={preview.port}
                className="flex items-center px-4 py-2 cursor-pointer hover:bg-eitherway-elements-item-backgroundActive"
                onClick={() => {
                  setActivePreviewIndex(preview.index);
                  setIsDropdownOpen(false);
                  setHasSelectedPreview(true);
                }}
              >
                <span
                  className={
                    activePreviewIndex === preview.index
                      ? 'text-eitherway-elements-item-contentAccent'
                      : 'text-eitherway-elements-item-contentDefault group-hover:text-eitherway-elements-item-contentActive'
                  }
                >
                  {preview.port}
                </span>
              </div>
            ))}
          </div>
        )}
      </div>
    );
  },
);
</file>

<file path="packages/ui-frontend/app/components/GooglePlayMock.tsx">
import React, { useEffect } from 'react';
import { useStore } from '@nanostores/react';
import { deployStore, loadDeployDataFromStorage } from '~/lib/stores/deployStore';
import { authStore } from '~/lib/stores/auth';

export const GooglePlayMock = () => {
  const appData = useStore(deployStore);
  const user = useStore(authStore.user);

  useEffect(() => {
    loadDeployDataFromStorage();
  }, []);

  console.log(' GooglePlayMock - user data:', appData);
  console.log(' GooglePlayMock - user.picture:', user?.picture);

  return (
    <div className="min-h-screen bg-white">
      {/* Top Navigation Bar */}
      <div className="bg-white px-8 py-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-8">
            <div className="flex items-center space-x-3">
              <svg className="w-10 h-10" aria-hidden="true" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
                <path fill="none" d="M0,0h40v40H0V0z"></path>
                <g>
                  <path
                    d="M19.7,19.2L4.3,35.3c0,0,0,0,0,0c0.5,1.7,2.1,3,4,3c0.8,0,1.5-0.2,2.1-0.6l0,0l17.4-9.9L19.7,19.2z"
                    fill="#EA4335"
                  ></path>
                  <path
                    d="M35.3,16.4L35.3,16.4l-7.5-4.3l-8.4,7.4l8.5,8.3l7.5-4.2c1.3-0.7,2.2-2.1,2.2-3.6C37.5,18.5,36.6,17.1,35.3,16.4z"
                    fill="#FBBC04"
                  ></path>
                  <path
                    d="M4.3,4.7C4.2,5,4.2,5.4,4.2,5.8v28.5c0,0.4,0,0.7,0.1,1.1l16-15.7L4.3,4.7z"
                    fill="#4285F4"
                  ></path>
                  <path
                    d="M19.8,20l8-7.9L10.5,2.3C9.9,1.9,9.1,1.7,8.3,1.7c-1.9,0-3.6,1.3-4,3c0,0,0,0,0,0L19.8,20z"
                    fill="#34A853"
                  ></path>
                </g>
              </svg>
              <span className="font-medium text-xl" style={{ color: '#676a6f' }}>
                Google Play
              </span>
            </div>
            <div className="flex space-x-6 items-center">
              <span
                className={`text-sm relative cursor-pointer ${appData.name?.toLowerCase().includes('game') ? 'text-[#01875f]' : 'text-gray-600'}`}
              >
                Games
                {appData.name?.toLowerCase().includes('game') && (
                  <div className="absolute -bottom-3 left-0 w-full h-0.5" style={{ backgroundColor: '#01875f' }}></div>
                )}
              </span>
              <span
                className={`text-sm relative cursor-pointer ${!appData.name?.toLowerCase().includes('game') ? 'text-[#01875f]' : 'text-gray-600'}`}
              >
                Apps
                {!appData.name?.toLowerCase().includes('game') && (
                  <div className="absolute -bottom-3 left-0 w-full h-0.5" style={{ backgroundColor: '#01875f' }}></div>
                )}
              </span>
              <span className="text-sm text-gray-600 cursor-pointer">Books</span>
              <span className="text-sm text-gray-600 cursor-pointer">Kids</span>
            </div>
          </div>
          <div className="flex items-center space-x-4">
            <svg className="w-6 h-6 text-gray-600 cursor-pointer" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
              />
            </svg>
            <svg className="w-6 h-6 text-gray-600 cursor-pointer" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
              />
            </svg>
            {user?.picture ? (
              <img
                src={user.picture}
                alt={user.name}
                onError={(e) => (e.currentTarget.src = '/icons/appstoreapps/avatar.jpg')}
                className="w-8 h-8 rounded-full"
              />
            ) : (
              <img src="/icons/appstoreapps/avatar.jpg" alt={'avatar'} className="w-8 h-8 rounded-full" />
            )}
          </div>
        </div>
      </div>

      <div className="max-w-7xl mx-auto px-8 py-8">
        {/* Main App Info - Full Width */}
        <div className="mb-8">
          <div className="flex space-x-6">
            <div className="flex-1">
              <h1 className="text-6xl font-bold text-black mb-8">{appData.name.toUpperCase() || 'App Name'}</h1>
              <p className="font-medium" style={{ color: '#01875f' }}>
                {user?.name || 'Developer'}
              </p>
              <p className="mb-8 text-sm" style={{ color: '#676a6f' }}>
                {appData.hasAds ? 'Contains ads' : 'No ads'}
              </p>

              <div className="flex items-center divide-x divide-gray-300 mb-8">
                <div className="flex flex-col items-center justify-center px-4">
                  <div className="flex items-center w-full justify-center">
                    <span className=" text-lg font-semibold">5.0</span>
                    <span className="text-xl"></span>
                  </div>
                  <span className="text-sm" style={{ color: '#676a6f' }}>
                    Reviews: 0
                  </span>
                </div>
                <div className="flex flex-col items-center px-4">
                  <span className="text-lg font-semibold">0</span>
                  <span className="text-sm" style={{ color: '#676a6f' }}>
                    Downloads
                  </span>
                </div>
                <div className="flex flex-col items-center px-4">
                  <span className="border border-gray-300 px-2 py-1 text-sm font-medium">3+</span>
                  <span className="text-sm" style={{ color: '#676a6f' }}>
                    Age rating
                  </span>
                </div>
              </div>

              <div className="flex gap-8 items-center">
                <button
                  className="text-white px-8 py-3 rounded-lg text-lg font-medium mb-4"
                  style={{ backgroundColor: '#01875f' }}
                >
                  Install
                </button>

                <div className="flex space-x-6 text-sm mb-4">
                  <div className="flex items-center cursor-pointer">
                    <svg
                      className="w-5 h-5 mr-2"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                      style={{ color: '#01875f' }}
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.367 2.684 3 3 0 00-5.367-2.684z"
                      />
                    </svg>
                    <span style={{ color: '#01875f' }}>Share</span>
                  </div>
                  <div className="flex items-center cursor-pointer">
                    <svg
                      className="w-5 h-5 mr-2"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                      style={{ color: '#01875f' }}
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M12 6v6m0 0v6m0-6h6m-6 0H6"
                      />
                    </svg>
                    <span style={{ color: '#01875f' }}>Add to wishlist</span>
                  </div>
                </div>
              </div>

              <div className="flex items-center text-sm gap-2" style={{ color: '#676a6f' }}>
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  height="24px"
                  viewBox="0 -960 960 960"
                  width="24px"
                  fill="#676a6f"
                >
                  <path d="M480-540ZM80-160v-80h400v80H80Zm120-120q-33 0-56.5-23.5T120-360v-360q0-33 23.5-56.5T200-800h560q33 0 56.5 23.5T840-720H200v360h280v80H200Zm600 40v-320H640v320h160Zm-180 80q-25 0-42.5-17.5T560-220v-360q0-25 17.5-42.5T620-640h200q25 0 42.5 17.5T880-580v360q0 25-17.5 42.5T820-160H620Zm100-300q13 0 21.5-9t8.5-21q0-13-8.5-21.5T720-520q-12 0-21 8.5t-9 21.5q0 12 9 21t21 9Zm0 60Z" />
                </svg>
                This app is available for your device
              </div>
            </div>

            {/* App Icon - 240x240 */}
            <div className="w-60 h-60 flex-shrink-0">
              {appData.icon ? (
                <img src={appData.icon} alt="App Icon" className="w-60 h-60 rounded-2xl object-cover" />
              ) : (
                <div className="w-60 h-60 bg-gray-300 rounded-2xl flex items-center justify-center">
                  <span className="text-gray-500 text-4xl"></span>
                </div>
              )}
            </div>
          </div>
        </div>

        <div className="flex space-x-8">
          {/* Main Content */}
          <div className="flex-1 max-w-4xl">
            {/* About This App */}
            <div className="mb-8 mt-8">
              <div className="flex items-center justify-between mb-4">
                <div className="flex gap-2 items-center">
                  <h2 className="text-xl font-semibold text-black">About this app</h2>
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    height="24px"
                    viewBox="0 -960 960 960"
                    width="24px"
                    fill="#000000"
                  >
                    <path d="M647-440H160v-80h487L423-744l57-56 320 320-320 320-57-56 224-224Z" />
                  </svg>
                </div>
              </div>
              <p className="mb-4" style={{ color: '#676a6f' }}>
                {appData.fullDescription || 'No description available'}
              </p>
              <ul className="list-disc list-inside space-y-2 mb-4" style={{ color: '#676a6f' }}>
                <li>{appData.shortDescription || 'Create and edit forms on the go'}</li>
                <li>{appData.category ? `Category: ${appData.category}` : 'Create forms easily using templates'}</li>
                <li>
                  {appData.contentRating
                    ? `Content Rating: ${appData.contentRating}`
                    : 'Job application form, feedback form'}
                </li>
              </ul>
              <div className="flex items-center justify-between text-sm">
                <span style={{ color: '#676a6f' }}>Updated {new Date().toLocaleDateString('en-US')}</span>
                <span className="bg-gray-200 px-3 py-1 rounded-full" style={{ color: '#676a6f' }}>
                  {appData.category || 'Category'}
                </span>
              </div>
            </div>

            {/* Data Safety */}
            <div className="mb-8">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-xl font-semibold text-black">Data safety</h2>
              </div>
              <p className="mb-6" style={{ color: '#676a6f' }}>
                Safety is determined by how the app collects and to whom it transfers your data. Methods of ensuring
                confidentiality and data protection may vary depending on the use of the app, region, and user's age.
                The developer who provides this information may update it.
              </p>

              <div className="bg-white border border-gray-200 rounded-lg p-6 mb-6">
                <div className="space-y-6">
                  <div className="flex items-start space-x-4">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      height="24px"
                      viewBox="0 -960 960 960"
                      width="24px"
                      fill="#676a6f"
                    >
                      <path d="M680-80q-50 0-85-35t-35-85q0-6 3-28L282-392q-16 15-37 23.5t-45 8.5q-50 0-85-35t-35-85q0-50 35-85t85-35q24 0 45 8.5t37 23.5l281-164q-2-7-2.5-13.5T560-760q0-50 35-85t85-35q50 0 85 35t35 85q0 50-35 85t-85 35q-24 0-45-8.5T598-672L317-508q2 7 2.5 13.5t.5 14.5q0 8-.5 14.5T317-452l281 164q16-15 37-23.5t45-8.5q50 0 85 35t35 85q0 50-35 85t-85 35Zm0-80q17 0 28.5-11.5T720-200q0-17-11.5-28.5T680-240q-17 0-28.5 11.5T640-200q0 17 11.5 28.5T680-160ZM200-440q17 0 28.5-11.5T240-480q0-17-11.5-28.5T200-520q-17 0-28.5 11.5T160-480q0 17 11.5 28.5T200-440Zm480-280q17 0 28.5-11.5T720-760q0-17-11.5-28.5T680-800q-17 0-28.5 11.5T640-760q0 17 11.5 28.5T680-720Zm0 520ZM200-480Zm480-280Z" />
                    </svg>
                    <div className="flex-1">
                      <h3 className="font-medium text-black mb-2">Data sharing</h3>
                      <p className="text-sm mb-2" style={{ color: '#676a6f' }}>
                        Data is not transferred to third parties
                      </p>
                      <a href="#" className="text-sm cursor-pointer" style={{ color: '#01875f' }}>
                        More details on how developers declare data transfer
                      </a>
                    </div>
                  </div>

                  <div className="flex items-start space-x-4">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      height="24px"
                      viewBox="0 -960 960 960"
                      width="24px"
                      fill="#676a6f"
                    >
                      <path d="M260-160q-91 0-155.5-63T40-377q0-78 47-139t123-78q25-92 100-149t170-57q117 0 198.5 81.5T760-520q69 8 114.5 59.5T920-340q0 75-52.5 127.5T740-160H520q-33 0-56.5-23.5T440-240v-206l-64 62-56-56 160-160 160 160-56 56-64-62v206h220q42 0 71-29t29-71q0-42-29-71t-71-29h-60v-80q0-83-58.5-141.5T480-720q-83 0-141.5 58.5T280-520h-20q-58 0-99 41t-41 99q0 58 41 99t99 41h100v80H260Zm220-280Z" />
                    </svg>
                    <div className="flex-1">
                      <h3 className="font-medium text-black mb-2">Data collection</h3>
                      <p className="text-sm mb-2" style={{ color: '#676a6f' }}>
                        This app may collect the following types of data
                      </p>
                      <a href="#" className="text-sm cursor-pointer" style={{ color: '#01875f' }}>
                        Personal information, Photos & videos and 2 more
                      </a>
                    </div>
                  </div>

                  <div className="flex items-start space-x-4">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      height="24px"
                      viewBox="0 -960 960 960"
                      width="24px"
                      fill="#676a6f"
                    >
                      <path d="M280-440h400v-80H280v80ZM480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z" />
                    </svg>
                    <div className="flex-1">
                      <h3 className="font-medium text-black mb-2">Data encryption</h3>
                      <p className="text-sm" style={{ color: '#676a6f' }}>
                        Data is not encrypted
                      </p>
                    </div>
                  </div>

                  <div className="flex items-start space-x-4">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      height="24px"
                      viewBox="0 -960 960 960"
                      width="24px"
                      fill="#676a6f"
                    >
                      <path d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm400-600H280v520h400v-520ZM360-280h80v-360h-80v360Zm160 0h80v-360h-80v360ZM280-720v520-520Z" />
                    </svg>
                    <div className="flex-1">
                      <h3 className="font-medium text-black mb-2">Data deletion</h3>
                      <p className="text-sm" style={{ color: '#676a6f' }}>
                        You can send a request to delete this data
                      </p>
                    </div>
                  </div>
                </div>
              </div>

              <a href="#" className="text-sm font-medium cursor-pointer" style={{ color: '#01875f' }}>
                More details
              </a>
            </div>

            {/* App Permissions */}
            <div className="mb-8">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-xl font-semibold text-black">App permissions</h2>
              </div>
              <p className="mb-4" style={{ color: '#676a6f' }}>
                This app requires the following permissions to function properly. You can manage these permissions in
                your device settings.
              </p>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="flex items-center space-x-3 p-3 bg-gray-50 rounded-lg">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    height="24px"
                    viewBox="0 -960 960 960"
                    width="24px"
                    fill="#000000"
                  >
                    <path d="M480-260q75 0 127.5-52.5T660-440q0-75-52.5-127.5T480-620q-75 0-127.5 52.5T300-440q0 75 52.5 127.5T480-260Zm0-80q-42 0-71-29t-29-71q0-42 29-71t71-29q42 0 71 29t29 71q0 42-29 71t-71 29ZM160-120q-33 0-56.5-23.5T80-200v-480q0-33 23.5-56.5T160-760h126l74-80h240l74 80h126q33 0 56.5 23.5T880-680v480q0 33-23.5 56.5T800-120H160Zm0-80h640v-480H638l-73-80H395l-73 80H160v480Zm320-240Z" />
                  </svg>
                  <span className="text-sm font-medium">Camera</span>
                </div>
                <div className="flex items-center space-x-3 p-3 bg-gray-50 rounded-lg">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    height="24px"
                    viewBox="0 -960 960 960"
                    width="24px"
                    fill="#000000"
                  >
                    <path d="M120-160v-160h720v160H120Zm80-40h80v-80h-80v80Zm-80-440v-160h720v160H120Zm80-40h80v-80h-80v80Zm-80 280v-160h720v160H120Zm80-40h80v-80h-80v80Z" />
                  </svg>
                  <span className="text-sm font-medium">Storage</span>
                </div>
                <div className="flex items-center space-x-3 p-3 bg-gray-50 rounded-lg">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    height="24px"
                    viewBox="0 -960 960 960"
                    width="24px"
                    fill="#000000"
                  >
                    <path d="M480-480q33 0 56.5-23.5T560-560q0-33-23.5-56.5T480-640q-33 0-56.5 23.5T400-560q0 33 23.5 56.5T480-480Zm0 294q122-112 181-203.5T720-552q0-109-69.5-178.5T480-800q-101 0-170.5 69.5T240-552q0 71 59 162.5T480-186Zm0 106Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Zm0-480Z" />
                  </svg>
                  <span className="text-sm font-medium">Location</span>
                </div>
                <div className="flex items-center space-x-3 p-3 bg-gray-50 rounded-lg">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    height="24px"
                    viewBox="0 -960 960 960"
                    width="24px"
                    fill="#000000"
                  >
                    <path d="M480-400q-50 0-85-35t-35-85v-240q0-50 35-85t85-35q50 0 85 35t35 85v240q0 50-35 85t-85 35Zm0-240Zm-40 520v-123q-104-14-172-93t-68-184h80q0 83 58.5 141.5T480-320q83 0 141.5-58.5T680-520h80q0 105-68 184t-172 93v123h-80Zm40-360q17 0 28.5-11.5T520-520v-240q0-17-11.5-28.5T480-800q-17 0-28.5 11.5T440-760v240q0 17 11.5 28.5T480-480Z" />
                  </svg>
                  <span className="text-sm font-medium">Microphone</span>
                </div>
              </div>
            </div>
          </div>

          {/* Right Sidebar */}
          <div className="w-72 flex-shrink-0 pl-8 mt-8">
            <div className="mb-8">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-semibold text-black">Similar apps</h3>
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  height="24px"
                  viewBox="0 -960 960 960"
                  width="24px"
                  fill="#000000"
                >
                  <path d="M647-440H160v-80h487L423-744l57-56 320 320-320 320-57-56 224-224Z" />
                </svg>
              </div>
              <div className="space-y-4">
                {[
                  {
                    name: 'OKX Web3 Wallet',
                    dev: 'OKX Labs',
                    icon: '/icons/appstoreapps/1.png',
                    rating: '4.7',
                  },
                  {
                    name: 'Xverse Bitcoin & Stacks Wallet',
                    dev: 'Secret Key Labs',
                    icon: '/icons/appstoreapps/2.png',
                    rating: '4.8',
                  },
                  {
                    name: 'MetaMask - Blockchain Wallet',
                    dev: 'ConsenSys Software Inc.',
                    icon: '/icons/appstoreapps/3.png',
                    rating: '4.6',
                  },
                  { name: 'Kwork', dev: 'RemoteFirst', icon: '/icons/appstoreapps/4.webp', rating: '4.2' },
                  { name: 'Livestock Manager', dev: 'Livestock Farm Co.', icon: '/icons/appstoreapps/5.webp' },
                  {
                    name: 'SurveyHeart: Form, Poll & Quiz',
                    dev: 'SurveyHeart LLP',
                    icon: '/icons/appstoreapps/6.webp',
                    rating: '4.0',
                  },
                ].map((app, i) => (
                  <div key={i} className="flex items-center space-x-3 cursor-pointer">
                    <img src={app.icon} alt={app.name} className="w-16 h-16 rounded-lg object-cover" />
                    <div className="flex-1">
                      <p className="font-medium text-sm text-black mb-1">{app.name}</p>
                      <p className="text-xs" style={{ color: '#676a6f' }}>
                        {app.dev}
                      </p>
                      {app.rating && (
                        <p className="text-sm mb-1 gap-2 flex items-center" style={{ color: '#676a6f' }}>
                          <span className="text-xl"></span> {app.rating}
                        </p>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="packages/ui-frontend/app/components/HeaderWithGlow.tsx">
import { useState, useEffect, useRef } from 'react';
import { chatStore } from '~/lib/stores/chat';
import { Header as LandingHeader } from '~/components/landing/Header';
import { Header as ChatHeader } from '~/components/header/Header';
import { Loader } from '~/components/ui/Loader';
import { createPortal } from 'react-dom';
import { toggleSidebar } from '~/lib/stores/sidebar';
import styles from '~/components/landing/Landing.module.scss';

interface HeaderWithGlowProps {
  children: React.ReactNode;
}

//        Portal
function HeaderLogoAndSidebar() {
  if (typeof window === 'undefined') {
    return null;
  }

  return createPortal(
    <div className="fixed top-13 min-[450px]:top-12 left-7 z-max flex items-center gap-8">
      <img src="/icons/chat/sidebar.svg" alt="Sidebar" className="w-6 h-6 cursor-pointer" onClick={toggleSidebar} />
      <a href="/chat" className="flex items-center">
        <img src="/icons/logo.svg" alt="Eitherway Logo" className="h-8 w-auto max-[450px]:h-6" />
      </a>
    </div>,
    document.body,
  );
}

export function HeaderWithGlow({ children }: HeaderWithGlowProps) {
  const [chatStarted, setChatStarted] = useState(false);
  const [glowPosition, setGlowPosition] = useState('200vh');
  const [isGlowVisible, setIsGlowVisible] = useState(false);
  const [isGlowAnimatingOut, setIsGlowAnimatingOut] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const glowRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const unsubscribe = chatStore.subscribe((value) => {
      console.log('HeaderWithGlow - chatStore changed:', value);
      setChatStarted(value.started);

      if (value.started && isGlowVisible) {
        console.log('Starting glow animation out...');
        setIsGlowAnimatingOut(true);
        setTimeout(() => {
          console.log('Glow animation completed, hiding element');
          setIsGlowVisible(false);
          setIsGlowAnimatingOut(false);
        }, 2000);
      }
    });

    //    1 
    const timer = setTimeout(() => {
      setIsLoading(false);
    }, 1000);

    return () => {
      unsubscribe();
      clearTimeout(timer);
    };
  }, [isGlowVisible]);

  useEffect(() => {
    let timeoutId: NodeJS.Timeout;

    const updateGlowPosition = () => {
      if (chatStarted) {
        return;
      }

      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        const authContainer = document.querySelector('#auth-chat');

        if (authContainer && glowRef.current) {
          const authRect = authContainer.getBoundingClientRect();

          if (authRect.width > 0 && authRect.height > 0) {
            const authTop = (authContainer as HTMLElement).offsetTop;
            const glowTop = authTop + 48;
            console.log('authTop', authTop, 'glowTop', glowTop);

            setGlowPosition(`${glowTop}px`);

            if (!isGlowVisible) {
              setTimeout(() => {
                setIsGlowVisible(true);
              }, 50);
            }
          }
        }
      }, 100);
    };

    updateGlowPosition();

    window.addEventListener('resize', updateGlowPosition);
    window.addEventListener('scroll', updateGlowPosition);

    const observer = new MutationObserver((mutations) => {
      const hasRelevantChanges = mutations.some((mutation) => {
        if (mutation.type === 'childList') {
          const addedNodes = Array.from(mutation.addedNodes);
          const removedNodes = Array.from(mutation.removedNodes);

          return [...addedNodes, ...removedNodes].some(
            (node) =>
              node.nodeType === Node.ELEMENT_NODE &&
              ((node as Element).id === 'auth-chat' || (node as Element).querySelector?.('#auth-chat')),
          );
        }

        return false;
      });

      if (hasRelevantChanges) {
        updateGlowPosition();
      }
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: false,
      characterData: false,
    });

    return () => {
      clearTimeout(timeoutId);
      window.removeEventListener('resize', updateGlowPosition);
      window.removeEventListener('scroll', updateGlowPosition);
      observer.disconnect();
    };
  }, [chatStarted, isGlowVisible]);

  if (isLoading) {
    return <Loader />;
  }

  return (
    <div className={styles.landing}>
      <HeaderLogoAndSidebar />

      {/* Landing Header */}
      <div
        className={`fixed top-0 left-0 w-full z-[5] transition-opacity duration-500 ease-in-out ${
          chatStarted ? 'opacity-0 pointer-events-none' : 'opacity-100 pointer-events-auto'
        }`}
      >
        <LandingHeader />
      </div>

      {/* Chat Header */}
      <div
        className={`fixed top-0 left-0 w-full z-[5] transition-all duration-500 ease-in-out ${
          chatStarted
            ? 'opacity-100 translate-y-0 pointer-events-auto'
            : 'opacity-0 translate-y-full pointer-events-none'
        }`}
      >
        <ChatHeader />
      </div>

      <div className={`flex-1 flex flex-col relative ${chatStarted ? 'mt-[128px]' : 'mt-[128px]'}`}>
        <div
          className={`absolute top-0 left-0 w-screen h-[calc(100vh-128px)] overflow-hidden z-1 pointer-events-none transition-all duration-[2s] ease-in-out ${
            isGlowAnimatingOut ? 'opacity-0 scale-105' : isGlowVisible ? 'opacity-100 scale-100' : 'opacity-0 scale-100'
          }`}
          style={{
            background:
              'radial-gradient(200% 70% at center 70%, rgb(13, 0, 255) 0%, rgba(13, 0, 255, 0.8) 10%, rgba(13, 0, 255, 0.6) 20%, rgba(13, 0, 255, 0.4) 35%, rgba(13, 0, 255, 0.2) 50%, transparent 70%)',
          }}
        >
          <div
            ref={glowRef}
            className={`absolute left-1/2 -translate-x-1/2 w-[200%] h-[200%] border-[16px] border-white rounded-[50%] bg-black z-[10] pointer-events-none max-[1023px]:w-[500%] max-[1023px]:h-[250%] transition-all duration-[2s] ease-in-out ${
              isGlowAnimatingOut
                ? 'translate-y-[-120vh] scale-80 opacity-0'
                : isGlowVisible
                  ? 'translate-y-0 scale-100 opacity-100'
                  : 'translate-y-full scale-100 opacity-0'
            }`}
            style={{ top: glowPosition }}
          ></div>
        </div>
        {children}
      </div>
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/lib/hooks/index.ts">
export * from './useShortcuts';
export * from './useSnapScroll';
</file>

<file path="packages/ui-frontend/app/lib/hooks/useShortcuts.ts">
import { useStore } from '@nanostores/react';
import { useEffect } from 'react';
import { shortcutsStore, type Shortcuts } from '~/lib/stores/settings';

class ShortcutEventEmitter {
  #emitter = new EventTarget();

  dispatch(type: keyof Shortcuts) {
    this.#emitter.dispatchEvent(new Event(type));
  }

  on(type: keyof Shortcuts, cb: VoidFunction) {
    this.#emitter.addEventListener(type, cb);

    return () => {
      this.#emitter.removeEventListener(type, cb);
    };
  }
}

export const shortcutEventEmitter = new ShortcutEventEmitter();

export function useShortcuts(): void {
  const shortcuts = useStore(shortcutsStore);

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent): void => {
      const { key, ctrlKey, shiftKey, altKey, metaKey } = event;

      for (const name in shortcuts) {
        const shortcut = shortcuts[name as keyof Shortcuts];

        if (
          shortcut.key.toLowerCase() === key.toLowerCase() &&
          (shortcut.ctrlOrMetaKey
            ? ctrlKey || metaKey
            : (shortcut.ctrlKey === undefined || shortcut.ctrlKey === ctrlKey) &&
              (shortcut.metaKey === undefined || shortcut.metaKey === metaKey)) &&
          (shortcut.shiftKey === undefined || shortcut.shiftKey === shiftKey) &&
          (shortcut.altKey === undefined || shortcut.altKey === altKey)
        ) {
          shortcutEventEmitter.dispatch(name as keyof Shortcuts);
          event.preventDefault();
          event.stopPropagation();

          shortcut.action();

          break;
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [shortcuts]);
}
</file>

<file path="packages/ui-frontend/app/lib/hooks/useSnapScroll.ts">
import { useRef, useCallback } from 'react';

export function useSnapScroll() {
  const autoScrollRef = useRef(true);
  const scrollNodeRef = useRef<HTMLDivElement>();
  const onScrollRef = useRef<() => void>();
  const observerRef = useRef<ResizeObserver>();

  const messageRef = useCallback((node: HTMLDivElement | null) => {
    if (node) {
      const observer = new ResizeObserver(() => {
        if (autoScrollRef.current && scrollNodeRef.current) {
          const { scrollHeight, clientHeight } = scrollNodeRef.current;
          const scrollTarget = scrollHeight - clientHeight;

          scrollNodeRef.current.scrollTo({
            top: scrollTarget,
          });
        }
      });

      observer.observe(node);
    } else {
      observerRef.current?.disconnect();
      observerRef.current = undefined;
    }
  }, []);

  const scrollRef = useCallback((node: HTMLDivElement | null) => {
    if (node) {
      onScrollRef.current = () => {
        const { scrollTop, scrollHeight, clientHeight } = node;
        const scrollTarget = scrollHeight - clientHeight;

        autoScrollRef.current = Math.abs(scrollTop - scrollTarget) <= 10;
      };

      node.addEventListener('scroll', onScrollRef.current);

      scrollNodeRef.current = node;
    } else {
      if (onScrollRef.current) {
        scrollNodeRef.current?.removeEventListener('scroll', onScrollRef.current);
      }

      scrollNodeRef.current = undefined;
      onScrollRef.current = undefined;
    }
  }, []);

  return [messageRef, scrollRef];
}
</file>

<file path="packages/ui-frontend/app/lib/persistence/ChatDescription.client.tsx">
import { useStore } from '@nanostores/react';
import { description } from './useChatHistory';

export function ChatDescription() {
  return useStore(description);
}
</file>

<file path="packages/ui-frontend/app/lib/persistence/index.ts">
export * from './db';
export * from './useChatHistory';
</file>

<file path="packages/ui-frontend/app/lib/runtime/theme-lock.ts">
export interface ThemeLock {
  colors: Record<string, string>;
  updatedAt: number;
}

const LOCK_PATH = '/.eitherway/theme-lock.json';

export async function loadThemeLock(fs: any): Promise<ThemeLock> {
  try {
    const raw = await fs.readFile(LOCK_PATH, 'utf8');
    return JSON.parse(raw);
  } catch {
    return { colors: {}, updatedAt: 0 };
  }
}

export async function saveThemeLock(fs: any, lock: ThemeLock): Promise<void> {
  try {
    await fs.mkdir('/.eitherway', { recursive: true });
  } catch {}
  await fs.writeFile(LOCK_PATH, JSON.stringify(lock), 'utf8');
}
</file>

<file path="packages/ui-frontend/app/lib/stores/auth.ts">
import { atom, type WritableAtom } from 'nanostores';
import type { GoogleUser } from '~/lib/auth/google';

export interface AuthState {
  isAuthenticated: boolean;
  user: GoogleUser | null;
  platform: string | null;
}

export class AuthStore {
  isAuthenticated: WritableAtom<boolean> = import.meta.hot?.data.isAuthenticated ?? atom(false);
  user: WritableAtom<GoogleUser | null> = import.meta.hot?.data.user ?? atom(null);
  platform: WritableAtom<string | null> = import.meta.hot?.data.platform ?? atom(null);

  constructor() {
    if (import.meta.hot) {
      import.meta.hot.data.isAuthenticated = this.isAuthenticated;
      import.meta.hot.data.user = this.user;
      import.meta.hot.data.platform = this.platform;
    }
  }

  login(user: GoogleUser, platform: string) {
    console.log(' AuthStore.login called with:', { user, platform });
    this.user.set(user);
    this.platform.set(platform);
    this.isAuthenticated.set(true);
    console.log(' AuthStore.login completed, new state:', this.authState);
  }

  logout() {
    this.user.set(null);
    this.platform.set(null);
    this.isAuthenticated.set(false);
  }

  get authState(): AuthState {
    return {
      isAuthenticated: this.isAuthenticated.get(),
      user: this.user.get(),
      platform: this.platform.get(),
    };
  }
}

export const authStore = new AuthStore();
</file>

<file path="packages/ui-frontend/app/lib/stores/deployStore.ts">
import { atom } from 'nanostores';

export interface AppData {
  name: string;
  shortDescription: string;
  fullDescription: string;
  icon: string | null;
  screenshots: string[];
  promoVideo: string;
  category: string;
  contactEmail: string;
  website: string;
  privacyPolicy: string;
  contentRating: string;
  googlePlayCompliance: boolean;
  hasAds: boolean;
  targetAudience: 'children' | 'general' | 'adults';
  isPaid: boolean;
  distributionCountries: string[];
  minAndroidVersion: string;
  permissions: string[];
  deviceSupport: string;
  versionCode: string;
  versionName: string;
  releaseName: string;
  releaseNotes: string;
}

export const deployStore = atom<AppData>({
  name: '',
  shortDescription: '',
  fullDescription: '',
  icon: null,
  screenshots: [],
  promoVideo: '',
  category: '',
  contactEmail: '',
  website: '',
  privacyPolicy: '',
  contentRating: '',
  googlePlayCompliance: false,
  hasAds: false,
  targetAudience: 'general',
  isPaid: false,
  distributionCountries: [],
  minAndroidVersion: '',
  permissions: [],
  deviceSupport: '',
  versionCode: '',
  versionName: '',
  releaseName: '',
  releaseNotes: '',
});

export const updateDeployData = (data: Partial<AppData>) => {
  deployStore.set({ ...deployStore.get(), ...data });
};

export const clearDeployData = () => {
  deployStore.set({
    name: '',
    shortDescription: '',
    fullDescription: '',
    icon: null,
    screenshots: [],
    promoVideo: '',
    category: '',
    contactEmail: '',
    website: '',
    privacyPolicy: '',
    contentRating: '',
    googlePlayCompliance: false,
    hasAds: false,
    targetAudience: 'general',
    isPaid: false,
    distributionCountries: [],
    minAndroidVersion: '',
    permissions: [],
    deviceSupport: '',
    versionCode: '',
    versionName: '',
    releaseName: '',
    releaseNotes: '',
  });
};

export const loadDeployDataFromStorage = () => {
  if (typeof window !== 'undefined') {
    const savedData = localStorage.getItem('deployment_data');

    if (savedData) {
      try {
        const parsedData = JSON.parse(savedData);

        if (parsedData.appData) {
          deployStore.set(parsedData.appData);
          return true;
        }
      } catch (error) {
        console.error('Error loading deployment data from localStorage:', error);
      }
    }
  }

  return false;
};

if (typeof window !== 'undefined') {
  loadDeployDataFromStorage();
}
</file>

<file path="packages/ui-frontend/app/lib/stores/editor.ts">
import { atom, computed, map, type MapStore, type WritableAtom } from 'nanostores';
import type { EditorDocument, ScrollPosition } from '~/components/editor/codemirror/CodeMirrorEditor';
import type { FileMap, FilesStore } from './files';

export type EditorDocuments = Record<string, EditorDocument>;

type SelectedFile = WritableAtom<string | undefined>;

export class EditorStore {
  #filesStore: FilesStore;

  selectedFile: SelectedFile = import.meta.hot?.data.selectedFile ?? atom<string | undefined>();
  documents: MapStore<EditorDocuments> = import.meta.hot?.data.documents ?? map({});

  currentDocument = computed([this.documents, this.selectedFile], (documents, selectedFile) => {
    if (!selectedFile) {
      return undefined;
    }

    return documents[selectedFile];
  });

  constructor(filesStore: FilesStore) {
    this.#filesStore = filesStore;

    if (import.meta.hot) {
      import.meta.hot.data.documents = this.documents;
      import.meta.hot.data.selectedFile = this.selectedFile;
    }
  }

  setDocuments(files: FileMap) {
    const previousDocuments = this.documents.value;

    this.documents.set(
      Object.fromEntries<EditorDocument>(
        Object.entries(files)
          .map(([filePath, dirent]) => {
            if (dirent === undefined || dirent.type === 'folder') {
              return undefined;
            }

            const previousDocument = previousDocuments?.[filePath];

            return [
              filePath,
              {
                value: dirent.content,
                filePath,
                scroll: previousDocument?.scroll,
              },
            ] as [string, EditorDocument];
          })
          .filter(Boolean) as Array<[string, EditorDocument]>,
      ),
    );
  }

  setSelectedFile(filePath: string | undefined) {
    this.selectedFile.set(filePath);
  }

  updateScrollPosition(filePath: string, position: ScrollPosition) {
    const documents = this.documents.get();
    const documentState = documents[filePath];

    if (!documentState) {
      return;
    }

    this.documents.setKey(filePath, {
      ...documentState,
      scroll: position,
    });
  }

  updateFile(filePath: string, newContent: string) {
    const documents = this.documents.get();
    const documentState = documents[filePath];

    if (!documentState) {
      return;
    }

    const currentContent = documentState.value;
    const contentChanged = currentContent !== newContent;

    if (contentChanged) {
      this.documents.setKey(filePath, {
        ...documentState,
        value: newContent,
      });
    }
  }
}
</file>

<file path="packages/ui-frontend/app/lib/stores/preview-mode.ts">
import { atom } from 'nanostores';

export type PreviewMode = 'desktop' | 'mobile';

export const previewModeStore = atom<PreviewMode>('desktop');
</file>

<file path="packages/ui-frontend/app/lib/stores/settings.ts">
import { map } from 'nanostores';
import { workbenchStore } from './workbench';

export interface Shortcut {
  key: string;
  ctrlKey?: boolean;
  shiftKey?: boolean;
  altKey?: boolean;
  metaKey?: boolean;
  ctrlOrMetaKey?: boolean;
  action: () => void;
}

export interface Shortcuts {
  toggleTerminal: Shortcut;
}

export interface Settings {
  shortcuts: Shortcuts;
}

export const shortcutsStore = map<Shortcuts>({
  toggleTerminal: {
    key: 'j',
    ctrlOrMetaKey: true,
    action: () => workbenchStore.toggleTerminal(),
  },
});

export const settingsStore = map<Settings>({
  shortcuts: shortcutsStore.get(),
});

shortcutsStore.subscribe((shortcuts) => {
  settingsStore.set({
    ...settingsStore.get(),
    shortcuts,
  });
});
</file>

<file path="packages/ui-frontend/app/lib/stores/sidebar.ts">
import { atom } from 'nanostores';

export const sidebarStore = atom({
  isOpen: false,
});

export const toggleSidebar = () => {
  const current = sidebarStore.get();
  sidebarStore.set({ ...current, isOpen: !current.isOpen });
};

export const openSidebar = () => {
  sidebarStore.set({ isOpen: true });
};

export const closeSidebar = () => {
  sidebarStore.set({ isOpen: false });
};
</file>

<file path="packages/ui-frontend/app/lib/stores/terminal.ts">
import type { WebContainer, WebContainerProcess } from '@webcontainer/api';
import { atom, type WritableAtom } from 'nanostores';
import type { ITerminal } from '~/types/terminal';
import { newShellProcess } from '~/utils/shell';
import { coloredText } from '~/utils/terminal';

export class TerminalStore {
  #webcontainer: Promise<WebContainer>;
  #terminals: Array<{ terminal: ITerminal; process: WebContainerProcess }> = [];

  showTerminal: WritableAtom<boolean> = import.meta.hot?.data.showTerminal ?? atom(false);

  constructor(webcontainerPromise: Promise<WebContainer>) {
    this.#webcontainer = webcontainerPromise;

    if (import.meta.hot) {
      import.meta.hot.data.showTerminal = this.showTerminal;
    }
  }

  toggleTerminal(value?: boolean) {
    this.showTerminal.set(value !== undefined ? value : !this.showTerminal.get());
  }

  async attachTerminal(terminal: ITerminal) {
    try {
      const shellProcess = await newShellProcess(await this.#webcontainer, terminal);
      this.#terminals.push({ terminal, process: shellProcess });
    } catch (error: any) {
      terminal.write(coloredText.red('Failed to spawn shell\n\n') + error.message);
      return;
    }
  }

  onTerminalResize(cols: number, rows: number) {
    for (const { process } of this.#terminals) {
      process.resize({ cols, rows });
    }
  }
}
</file>

<file path="packages/ui-frontend/app/lib/stores/theme.ts">
import { atom } from 'nanostores';

export type Theme = 'dark' | 'light';

export const kTheme = 'eitherway_theme';

export function themeIsDark() {
  return themeStore.get() === 'dark';
}

export const DEFAULT_THEME = 'light';

export const themeStore = atom<Theme>(initStore());

function initStore() {
  if (!import.meta.env.SSR) {
    const persistedTheme = localStorage.getItem(kTheme) as Theme | undefined;
    const themeAttribute = document.querySelector('html')?.getAttribute('data-theme');

    return persistedTheme ?? (themeAttribute as Theme) ?? DEFAULT_THEME;
  }

  return 'light';
}

export function toggleTheme() {
  const currentTheme = themeStore.get();
  const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

  themeStore.set(newTheme);

  localStorage.setItem(kTheme, newTheme);

  document.querySelector('html')?.setAttribute('data-theme', newTheme);
}
</file>

<file path="packages/ui-frontend/app/lib/templates/env-template.js">
// Environment Configuration Template
// Provides .env.example and README for Web3 applications

export const envExampleTemplate = `
# Web3 Application Environment Configuration
# Copy this file to .env.local and fill in your values

# REQUIRED: WalletConnect Project ID
# Get yours at: https://cloud.walletconnect.com/
WALLETCONNECT_PROJECT_ID=your-project-id-here

# RPC Endpoints (at least one recommended)
# Option 1: Alchemy - https://www.alchemy.com/
RPC_URL_MAINNET=https://eth-mainnet.g.alchemy.com/v2/YOUR_KEY
RPC_URL_POLYGON=https://polygon-mainnet.g.alchemy.com/v2/YOUR_KEY
RPC_URL_ARBITRUM=https://arb-mainnet.g.alchemy.com/v2/YOUR_KEY
RPC_URL_BASE=https://base-mainnet.g.alchemy.com/v2/YOUR_KEY
ALCHEMY_API_KEY=your-alchemy-api-key

# Option 2: QuickNode - https://www.quicknode.com/
QUICKNODE_ENDPOINT=https://your-endpoint.quiknode.pro/YOUR_KEY/

# Option 3: Infura - https://infura.io/
RPC_URL_MAINNET=https://mainnet.infura.io/v3/YOUR_KEY
RPC_URL_POLYGON=https://polygon-mainnet.infura.io/v3/YOUR_KEY

# Option 4: Public RPCs (less reliable, no key needed)
# RPC_URL_MAINNET=https://eth.llamarpc.com
# RPC_URL_POLYGON=https://polygon-rpc.com

# Portfolio & Balance Indexers (choose one)
# Covalent - https://www.covalenthq.com/
COVALENT_API_KEY=your-covalent-key

# Moralis - https://moralis.io/
MORALIS_API_KEY=your-moralis-key

# Bitquery - https://bitquery.io/
BITQUERY_API_KEY=your-bitquery-key

# Price Data Providers (optional, enhances price accuracy)
# CoinGecko Pro - https://www.coingecko.com/api/pricing
COINGECKO_API_KEY=your-coingecko-key

# CryptoCompare - https://min-api.cryptocompare.com/
CRYPTOCOMPARE_API_KEY=your-cryptocompare-key

# CoinMarketCap - https://coinmarketcap.com/api/
COINMARKETCAP_API_KEY=your-coinmarketcap-key

# Messari - https://messari.io/api
MESSARI_API_KEY=your-messari-key

# Optional: Analytics
ANALYTICS_ID=your-analytics-id

# Demo Mode Settings
# When true, shows demo data even with API keys configured
FORCE_DEMO_MODE=false
`;

export const readmeTemplate = `
# Web3 Application Setup

## Quick Start

1. **Clone and Install**
   \`\`\`bash
   npm install
   # or
   yarn install
   \`\`\`

2. **Configure Environment**
   - Copy \`.env.example\` to \`.env.local\`
   - Fill in your API keys (see below for obtaining keys)

3. **Run Development Server**
   \`\`\`bash
   npm run dev
   # or
   yarn dev
   \`\`\`

## Getting API Keys

### Required: WalletConnect Project ID
1. Go to [WalletConnect Cloud](https://cloud.walletconnect.com/)
2. Sign up or log in
3. Create a new project
4. Copy your Project ID

### Recommended: RPC Provider (choose one)

#### Alchemy (Recommended)
1. Visit [Alchemy](https://www.alchemy.com/)
2. Create free account
3. Create an app for each network you need
4. Copy the API keys

#### QuickNode
1. Visit [QuickNode](https://www.quicknode.com/)
2. Create free account
3. Create an endpoint
4. Copy the HTTP provider URL

#### Infura
1. Visit [Infura](https://infura.io/)
2. Create free account
3. Create a project
4. Copy the project ID

### Optional: Portfolio Indexers

#### Covalent
- Free tier: 100,000 credits/month
- Sign up at [Covalent](https://www.covalenthq.com/)
- Good for multi-chain portfolio data

#### Moralis
- Free tier: 3,000 requests/day
- Sign up at [Moralis](https://moralis.io/)
- Fast Web3 data API

### Optional: Price Data

#### CoinGecko
- Free tier: 10,000 calls/month
- Pro features at [CoinGecko](https://www.coingecko.com/api/pricing)
- Most comprehensive crypto data

## Features

### When Configured (Production Mode)
-  Real wallet connections (MetaMask, WalletConnect, etc.)
-  Live blockchain data from your RPC provider
-  Real-time portfolio balances
-  Live price feeds
-  Transaction signing and sending
-  Multi-chain support

### Demo Mode (No Configuration)
-  UI fully functional
-  Wallet connection UI works (but doesn't connect)
-  Shows sample data instead of real data
-  Transactions disabled
-  Banner shows "Demo Mode"

## Architecture

### Tech Stack
- Frontend: [Vanilla JS / React]
- Web3: Reown AppKit / wagmi + viem
- Styling: CSS Variables with Pattern System
- State: LocalStorage / React Context

### Services
- **Web3 Service**: Handles wallet connections and blockchain interactions
- **Portfolio Service**: Fetches and caches token balances
- **Price Service**: Real-time price updates with caching
- **Navigation**: Multi-page (MPA) or Single-page (SPA) routing

### Caching Strategy
- Portfolio data: 60 second cache
- Price data: 30 second cache
- LocalStorage for persistence
- Automatic retry on API failure

## Deployment

### Vercel
\`\`\`bash
vercel --prod
\`\`\`

### Netlify
\`\`\`bash
netlify deploy --prod
\`\`\`

### Railway
\`\`\`bash
railway up
\`\`\`

## Security Notes

 **Never commit .env.local or expose API keys**
- Add \`.env.local\` to \`.gitignore\`
- Use environment variables in production
- Rotate keys regularly
- Use read-only RPC endpoints
- Implement rate limiting for production

## Troubleshooting

### Wallet Won't Connect
- Check WalletConnect Project ID is valid
- Ensure you're on HTTPS (or localhost)
- Try different wallet (MetaMask vs WalletConnect)

### No Balance Data
- Verify indexer API key is correct
- Check rate limits haven't been exceeded
- Try different indexer service

### Prices Not Updating
- Price provider API might be down
- Check browser console for errors
- Falls back to demo prices automatically

## Support

- Documentation: [Link to docs]
- Issues: [GitHub Issues]
- Discord: [Community Discord]

## License

MIT
`;

export const envLoaderTemplate = `
// Environment Variable Loader
// /scripts/env-loader.js

(function loadEnvironment() {
  // In production, these would be injected by your build process
  // For development, load from .env.local / Vite env

  window.ENV = {
    WALLETCONNECT_PROJECT_ID: process.env.WALLETCONNECT_PROJECT_ID || import.meta.env.VITE_WALLETCONNECT_PROJECT_ID || '',
    RPC_URL_MAINNET: process.env.RPC_URL_MAINNET || import.meta.env.VITE_RPC_URL_MAINNET || '',
    RPC_URL_POLYGON: process.env.RPC_URL_POLYGON || import.meta.env.VITE_RPC_URL_POLYGON || '',
    RPC_URL_ARBITRUM: process.env.RPC_URL_ARBITRUM || import.meta.env.VITE_RPC_URL_ARBITRUM || '',
    RPC_URL_BASE: process.env.RPC_URL_BASE || import.meta.env.VITE_RPC_URL_BASE || '',
    ALCHEMY_API_KEY: process.env.ALCHEMY_API_KEY || import.meta.env.VITE_ALCHEMY_API_KEY || '',
    COVALENT_API_KEY: process.env.COVALENT_API_KEY || import.meta.env.VITE_COVALENT_API_KEY || '',
    MORALIS_API_KEY: process.env.MORALIS_API_KEY || import.meta.env.VITE_MORALIS_API_KEY || '',
    QUICKNODE_ENDPOINT: process.env.QUICKNODE_ENDPOINT || import.meta.env.VITE_QUICKNODE_ENDPOINT || '',
    BITQUERY_API_KEY: process.env.BITQUERY_API_KEY || import.meta.env.VITE_BITQUERY_API_KEY || '',
    COINGECKO_API_KEY: process.env.COINGECKO_API_KEY || import.meta.env.VITE_COINGECKO_API_KEY || '',
    FORCE_DEMO_MODE: process.env.FORCE_DEMO_MODE === 'true' || import.meta.env.VITE_FORCE_DEMO_MODE === 'true'
  };

  const hasWalletConnect = !!(window.ENV.WALLETCONNECT_PROJECT_ID && window.ENV.WALLETCONNECT_PROJECT_ID !== 'your-project-id-here');

  const hasIndexerOrRpc = !!(
    window.ENV.COVALENT_API_KEY ||
    window.ENV.MORALIS_API_KEY ||
    window.ENV.ALCHEMY_API_KEY ||
    window.ENV.BITQUERY_API_KEY ||
    window.ENV.QUICKNODE_ENDPOINT ||
    window.ENV.RPC_URL_MAINNET ||
    window.ENV.RPC_URL_POLYGON ||
    window.ENV.RPC_URL_ARBITRUM ||
    window.ENV.RPC_URL_BASE
  );

  // Portfolio can be "limited live" with RPC (native balance only) without an indexer
  window.IS_PORTFOLIO_LIVE = hasIndexerOrRpc;
  window.IS_DEMO_MODE = !(hasWalletConnect && hasIndexerOrRpc) || window.ENV.FORCE_DEMO_MODE;

  if (window.IS_DEMO_MODE) {
    console.log('%c Running in Demo Mode ', 'background: #f59e0b; color: white; padding: 4px 8px; border-radius: 4px;');
    console.log('Configure .env.local with your API keys for production features');
  } else {
    console.log('%c Running in Production Mode ', 'background: #10b981; color: white; padding: 4px 8px; border-radius: 4px;');
  }
})();
`;
</file>

<file path="packages/ui-frontend/app/lib/templates/portfolio-service.js">
// Portfolio Service Template
// Provides live portfolio data with fallback to demo mode

export const portfolioServiceTemplate = `
// Portfolio Service - Fetches token balances and portfolio data
// /scripts/services/portfolio.js

class PortfolioService {
  constructor() {
    this.cache = new Map();
    this.cacheDuration = 60 * 1000; // 1 minute
    this.isDemo = !this.hasApiKeys();
    this.supportedIndexers = this.detectAvailableIndexers();
  }

  hasApiKeys() {
    const E = window.ENV || {};
    return Boolean(
      E.COVALENT_API_KEY ||
      E.MORALIS_API_KEY ||
      E.ALCHEMY_API_KEY ||
      E.QUICKNODE_ENDPOINT ||
      E.BITQUERY_API_KEY ||
      E.RPC_URL_MAINNET || E.RPC_URL_POLYGON || E.RPC_URL_ARBITRUM || E.RPC_URL_BASE
    );
  }

  detectAvailableIndexers() {
    const E = window.ENV || {};
    const indexers = [];
    if (E.COVALENT_API_KEY) indexers.push('covalent');
    if (E.MORALIS_API_KEY) indexers.push('moralis');
    if (E.ALCHEMY_API_KEY) indexers.push('alchemy');
    if (E.QUICKNODE_ENDPOINT) indexers.push('quicknode');
    if (E.BITQUERY_API_KEY) indexers.push('bitquery');
    // RPC fallback (native balance only)
    if (E.RPC_URL_MAINNET || E.RPC_URL_POLYGON || E.RPC_URL_ARBITRUM || E.RPC_URL_BASE) indexers.push('rpc');
    return indexers;
  }

  async getPortfolio(address, chainId = 1) {
    if (!address) return this.getDemoPortfolio();

    const cacheKey = \`portfolio-\${address}-\${chainId}\`;
    const cached = this.getFromCache(cacheKey);
    if (cached) return cached;

    try {
      const portfolio = await this.fetchPortfolio(address, chainId);
      this.setCache(cacheKey, portfolio);
      return portfolio;
    } catch (error) {
      console.error('Portfolio fetch failed:', error);
      return this.getDemoPortfolio();
    }
  }

  async fetchPortfolio(address, chainId) {
    if (this.isDemo) return this.getDemoPortfolio();

    // Try available indexers in order of preference
    for (const indexer of this.supportedIndexers) {
      try {
        switch (indexer) {
          case 'covalent':
            return await this.fetchFromCovalent(address, chainId);
          case 'moralis':
            return await this.fetchFromMoralis(address, chainId);
          case 'alchemy':
            return await this.fetchFromAlchemy(address, chainId);
          case 'quicknode':
            return await this.fetchFromQuickNode(address, chainId);
          case 'bitquery':
            return await this.fetchFromBitquery(address, chainId);
          case 'rpc':
            return await this.fetchFromRPC(address, chainId);
        }
      } catch (error) {
        console.warn(\`Indexer \${indexer} failed, trying next...\`);
        continue;
      }
    }

    return this.getDemoPortfolio();
  }

  getRpcUrl(chainId) {
    const E = window.ENV || {};
    switch (Number(chainId)) {
      case 1:
        return E.RPC_URL_MAINNET || E.QUICKNODE_ENDPOINT || E.ALCHEMY_RPC || 'https://eth.llamarpc.com';
      case 137:
        return E.RPC_URL_POLYGON || 'https://polygon-rpc.com';
      case 42161:
        return E.RPC_URL_ARBITRUM || 'https://arb1.arbitrum.io/rpc';
      case 8453:
        return E.RPC_URL_BASE || 'https://mainnet.base.org';
      default:
        return E.RPC_URL_MAINNET || 'https://eth.llamarpc.com';
    }
  }

  getNativeSymbol(chainId) {
    switch (Number(chainId)) {
      case 1:
        return 'ETH';
      case 137:
        return 'MATIC';
      case 42161:
        return 'ETH';
      case 8453:
        return 'ETH';
      default:
        return 'ETH';
    }
  }

  async jsonRpc(url, method, params) {
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: 1, jsonrpc: '2.0', method, params })
    });
    const j = await res.json();
    if (j.error) throw new Error(j.error.message || 'RPC Error');
    return j.result;
  }

  async fetchFromRPC(address, chainId) {
    const url = this.getRpcUrl(chainId);
    if (!url) throw new Error('No RPC URL configured');

    const balanceHex = await this.jsonRpc(url, 'eth_getBalance', [address, 'latest']);
    const balance = this.formatBalanceHex(balanceHex);
    const symbol = this.getNativeSymbol(chainId);

    const holdings = [{
      chainId,
      symbol,
      name: symbol,
      address: 'native',
      decimals: 18,
      balance,
      valueUSD: null
    }];

    holdings.__limited = true;
    return holdings;
  }

  async fetchFromCovalent(address, chainId) {
    const apiKey = window.ENV.COVALENT_API_KEY;
    const url = \`https://api.covalenthq.com/v1/\${chainId}/address/\${address}/balances_v2/?key=\${apiKey}\`;

    const response = await fetch(url);
    if (!response.ok) throw new Error('Covalent API error');

    const data = await response.json();
    return this.parseCovalentData(data);
  }

  async fetchFromMoralis(address, chainId) {
    const apiKey = window.ENV.MORALIS_API_KEY;
    const chainMap = { 1: 'eth', 137: 'polygon', 56: 'bsc', 43114: 'avalanche' };
    const chain = chainMap[chainId] || 'eth';

    const response = await fetch(
      \`https://deep-index.moralis.io/api/v2.2/\${address}/erc20?chain=\${chain}\`,
      {
        headers: { 'X-API-Key': apiKey }
      }
    );

    if (!response.ok) throw new Error('Moralis API error');
    const data = await response.json();
    return this.parseMoralisData(data);
  }

  async fetchFromAlchemy(address, chainId) {
    const apiKey = window.ENV.ALCHEMY_API_KEY;
    const networks = { 1: 'eth-mainnet', 137: 'polygon-mainnet', 42161: 'arb-mainnet' };
    const network = networks[chainId] || 'eth-mainnet';

    const url = \`https://\${network}.g.alchemy.com/v2/\${apiKey}\`;
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0',
        method: 'alchemy_getTokenBalances',
        params: [address],
        id: 1
      })
    });

    if (!response.ok) throw new Error('Alchemy API error');
    const data = await response.json();
    return this.parseAlchemyData(data);
  }

  async fetchFromQuickNode(address, chainId) {
    const endpoint = window.ENV.QUICKNODE_ENDPOINT;
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        method: 'qn_getWalletTokenBalance',
        params: { wallet: address },
        id: 1,
        jsonrpc: '2.0'
      })
    });

    if (!response.ok) throw new Error('QuickNode API error');
    const data = await response.json();
    return this.parseQuickNodeData(data);
  }

  async fetchFromBitquery(address, chainId) {
    const apiKey = window.ENV.BITQUERY_API_KEY;
    const networks = { 1: 'ethereum', 56: 'bsc', 137: 'matic' };
    const network = networks[chainId] || 'ethereum';

    const query = \`
      {
        \${network}(network: \${network}) {
          address(address: {is: "\${address}"}) {
            balances {
              currency {
                symbol
                name
                address
                decimals
              }
              value
            }
          }
        }
      }
    \`;

    const response = await fetch('https://graphql.bitquery.io', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-API-KEY': apiKey
      },
      body: JSON.stringify({ query })
    });

    if (!response.ok) throw new Error('Bitquery API error');
    const data = await response.json();
    return this.parseBitqueryData(data, network);
  }

  parseCovalentData(data) {
    if (!data?.data?.items) return [];

    return data.data.items
      .filter(item => Number(item.balance) > 0)
      .map(item => ({
        symbol: item.contract_ticker_symbol || 'Unknown',
        name: item.contract_name || 'Unknown Token',
        address: item.contract_address,
        balance: this.formatBalance(item.balance, item.contract_decimals),
        valueUSD: item.quote || 0,
        price: item.quote_rate || 0,
        change24h: item.quote_24h || 0,
        logo: item.logo_url || null
      }));
  }

  parseMoralisData(data) {
    if (!Array.isArray(data)) return [];

    return data
      .filter(token => Number(token.balance) > 0)
      .map(token => ({
        symbol: token.symbol || 'Unknown',
        name: token.name || 'Unknown Token',
        address: token.token_address,
        balance: this.formatBalance(token.balance, token.decimals),
        valueUSD: 0, // Moralis doesn't provide USD value directly
        price: 0,
        change24h: 0,
        logo: token.logo || null
      }));
  }

  parseAlchemyData(data) {
    if (!data?.result?.tokenBalances) return [];

    return data.result.tokenBalances
      .filter(token => token.tokenBalance !== '0x0')
      .map(token => ({
        symbol: 'TOKEN', // Alchemy requires additional calls for metadata
        name: 'Token',
        address: token.contractAddress,
        balance: this.formatBalanceHex(token.tokenBalance),
        valueUSD: 0,
        price: 0,
        change24h: 0,
        logo: null
      }));
  }

  parseQuickNodeData(data) {
    if (!data?.result?.result) return [];

    return data.result.result.map(token => ({
      symbol: token.symbol,
      name: token.name,
      address: token.address,
      balance: this.formatBalance(token.amount, token.decimals),
      valueUSD: token.totalBalance || 0,
      price: 0,
      change24h: 0,
      logo: null
    }));
  }

  parseBitqueryData(data, network) {
    if (!data?.data?.[network]?.address?.[0]?.balances) return [];

    return data.data[network].address[0].balances
      .filter(item => Number(item.value) > 0)
      .map(item => ({
        symbol: item.currency.symbol,
        name: item.currency.name,
        address: item.currency.address,
        balance: item.value,
        valueUSD: 0,
        price: 0,
        change24h: 0,
        logo: null
      }));
  }

  formatBalance(balance, decimals) {
    const divisor = Math.pow(10, Number(decimals) || 18);
    return (Number(balance) / divisor).toFixed(4);
  }

  formatBalanceHex(hexBalance) {
    const balance = parseInt(hexBalance, 16);
    return this.formatBalance(balance.toString(), 18);
  }

  getDemoPortfolio() {
    const holdings = [
      {
        symbol: 'ETH',
        name: 'Ethereum',
        address: '0x0000000000000000000000000000000000000000',
        balance: (Math.random() * 5 + 1).toFixed(4),
        valueUSD: 0,
        price: 1850.25,
        change24h: 2.34,
        logo: '/assets/ethereum_logo.png'
      },
      {
        symbol: 'USDC',
        name: 'USD Coin',
        address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
        balance: (Math.random() * 5000 + 1000).toFixed(2),
        valueUSD: 0,
        price: 1.00,
        change24h: 0.01,
        logo: '/assets/usdc_logo.png'
      },
      {
        symbol: 'WBTC',
        name: 'Wrapped Bitcoin',
        address: '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599',
        balance: (Math.random() * 0.1 + 0.01).toFixed(6),
        valueUSD: 0,
        price: 35420.50,
        change24h: 3.12,
        logo: '/assets/wbtc_logo.png'
      },
      {
        symbol: 'LINK',
        name: 'Chainlink',
        address: '0x514910771af9ca656af840dff83e8264ecf986ca',
        balance: (Math.random() * 100 + 10).toFixed(2),
        valueUSD: 0,
        price: 14.85,
        change24h: -1.23,
        logo: '/assets/link_logo.png'
      }
    ];

    // Calculate USD values
    holdings.forEach(token => {
      token.valueUSD = Number(token.balance) * token.price;
    });

    return holdings;
  }

  async getPerformanceHistory(address, days = 30) {
    const cacheKey = \`performance-\${address}-\${days}\`;
    const cached = this.getFromCache(cacheKey);
    if (cached) return cached;

    if (this.isDemo || !address) {
      return this.getDemoPerformance(days);
    }

    try {
      // Fetch historical data from indexer
      const history = await this.fetchHistoricalData(address, days);
      this.setCache(cacheKey, history);
      return history;
    } catch (error) {
      console.error('Failed to fetch performance history:', error);
      return this.getDemoPerformance(days);
    }
  }

  getDemoPerformance(days) {
    const data = [];
    const now = Date.now();
    const interval = 24 * 60 * 60 * 1000; // 1 day in ms
    let value = 10000;

    for (let i = days; i >= 0; i--) {
      const change = (Math.random() - 0.5) * 500;
      value = Math.max(value + change, 1000);
      data.push({
        timestamp: now - (i * interval),
        value: value,
        date: new Date(now - (i * interval)).toLocaleDateString()
      });
    }

    return data;
  }

  async fetchHistoricalData(address, days) {
    // Implementation depends on the indexer being used
    // This would fetch historical balance snapshots
    return this.getDemoPerformance(days);
  }

  getFromCache(key) {
    const cached = this.cache.get(key);
    if (!cached) return null;

    if (Date.now() - cached.timestamp > this.cacheDuration) {
      this.cache.delete(key);
      return null;
    }

    return cached.data;
  }

  setCache(key, data) {
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  }

  clearCache() {
    this.cache.clear();
  }
}

// Export for use
const portfolioService = new PortfolioService();
window.portfolioService = portfolioService;
`;
</file>

<file path="packages/ui-frontend/app/lib/templates/web3-vanilla.js">
// Web3 Service Template for Vanilla JS
// This template provides real wallet connection functionality

export const web3VanillaTemplate = `
// Web3 Configuration and Wallet Connection Service
// Using Reown AppKit for vanilla JavaScript

class Web3Service {
  constructor() {
    this.appKit = null;
    this.address = null;
    this.chainId = 1;
    this.provider = null;
    this.isDemo = !this.hasRequiredEnvVars();

    if (typeof window.IS_DEMO_MODE !== 'undefined') {
      this.isDemo = window.IS_DEMO_MODE;
    }

    if (this.isDemo) {
      console.log('Running in demo mode - configure .env for live data');
      this.showDemoBanner();
    }

    this.init();
  }

  hasRequiredEnvVars() {
    return window.ENV?.WALLETCONNECT_PROJECT_ID &&
           window.ENV?.WALLETCONNECT_PROJECT_ID !== 'your-project-id-here';
  }

  showDemoBanner() {
    const banner = document.createElement('div');
    banner.className = 'demo-banner';
    banner.innerHTML = \`
      <div style="background: linear-gradient(90deg, #f59e0b, #ef4444); color: white; padding: 12px; text-align: center; position: fixed; top: 0; left: 0; right: 0; z-index: 9999;">
        <strong>Demo Mode</strong> - Configure .env.local with your WalletConnect Project ID for live wallet connections
      </div>
    \`;
    document.body.prepend(banner);
    document.body.style.paddingTop = '48px';
  }

  async init() {
    if (typeof window.createAppKit === 'undefined') {
      await this.loadAppKitFromCDN();
    }

    const projectId = window.ENV?.WALLETCONNECT_PROJECT_ID || 'demo-project-id';
    const chains = this.getChainConfig();

    try {
      this.appKit = window.createAppKit({
        projectId,
        chains,
        metadata: {
          name: document.title || 'Web3 App',
          description: 'Web3 Application with Wallet Connection',
          url: window.location.origin,
          icons: ['/logo.png']
        },
        themeMode: document.documentElement.getAttribute('data-theme') || 'light',
        featuredWalletIds: [
          'c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96', // MetaMask
          'e7c4d26541d0c4cc2c67c55e8a56c5e328e5bad5f8e1ca7a92ea9db546b87816', // Coinbase
          '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0'  // Trust
        ]
      });

      this.setupEventListeners();
      await this.checkConnection();
    } catch (error) {
      console.error('Failed to initialize AppKit:', error);
      if (!this.isDemo) {
        alert('Failed to initialize wallet connection. Please check your configuration.');
      }
    }
  }

  async loadAppKitFromCDN() {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.type = 'module';
      script.onload = resolve;
      script.onerror = reject;
      script.textContent = \`
        import { createAppKit } from 'https://cdn.jsdelivr.net/npm/@reown/appkit@latest/+esm';
        window.createAppKit = createAppKit;
      \`;
      document.head.appendChild(script);
    });
  }

  getChainConfig() {
    const mainnetRpc = window.ENV?.RPC_URL_MAINNET || 'https://eth.llamarpc.com';
    const polygonRpc = window.ENV?.RPC_URL_POLYGON || 'https://polygon-rpc.com';
    const arbitrumRpc = window.ENV?.RPC_URL_ARBITRUM || 'https://arb1.arbitrum.io/rpc';

    return [
      {
        chainId: 1,
        name: 'Ethereum',
        currency: 'ETH',
        explorerUrl: 'https://etherscan.io',
        rpcUrl: mainnetRpc
      },
      {
        chainId: 137,
        name: 'Polygon',
        currency: 'MATIC',
        explorerUrl: 'https://polygonscan.com',
        rpcUrl: polygonRpc
      },
      {
        chainId: 42161,
        name: 'Arbitrum',
        currency: 'ETH',
        explorerUrl: 'https://arbiscan.io',
        rpcUrl: arbitrumRpc
      }
    ];
  }

  setupEventListeners() {
    if (!this.appKit) return;

    this.appKit.subscribeProvider(state => {
      if (state.isConnected) {
        this.address = state.address;
        this.chainId = state.chainId;
        this.updateUI();
        this.fetchAndDispatchPortfolio();
      } else {
        this.address = null;
        this.updateUI();
      }
    });
  }

  async checkConnection() {
    if (!this.appKit) return;

    const state = await this.appKit.getState();
    if (state.isConnected) {
      this.address = state.address;
      this.chainId = state.chainId;
      this.updateUI();
    }
  }

  async connect() {
    if (this.isDemo && !window.ethereum) {
      alert('Please install MetaMask or another Web3 wallet to connect');
      return;
    }

    if (!this.appKit) {
      console.error('AppKit not initialized');
      return;
    }

    try {
      await this.appKit.open();
    } catch (error) {
      console.error('Failed to open wallet modal:', error);
    }
  }

  async disconnect() {
    if (!this.appKit) return;

    try {
      await this.appKit.disconnect();
      this.address = null;
      this.updateUI();
    } catch (error) {
      console.error('Failed to disconnect:', error);
    }
  }

  async switchNetwork(chainId) {
    if (!this.appKit) return;

    try {
      await this.appKit.switchNetwork(chainId);
      this.chainId = chainId;
      this.updateUI();
      this.fetchAndDispatchPortfolio();
    } catch (error) {
      console.error('Failed to switch network:', error);
      alert('Failed to switch network. Please try manually in your wallet.');
    }
  }

  async getBalance(address) {
    if (this.isDemo || !address) {
      return this.getDemoBalance();
    }

    try {
      const provider = await this.getProvider();
      const balance = await provider.getBalance(address);
      return this.formatEther(balance);
    } catch (error) {
      console.error('Failed to get balance:', error);
      return this.getDemoBalance();
    }
  }

  getDemoBalance() {
    return (Math.random() * 10).toFixed(4);
  }

  async getProvider() {
    if (!this.provider) {
      this.provider = await this.appKit.getProvider();
    }
    return this.provider;
  }

  formatEther(wei) {
    return (Number(wei) / 1e18).toFixed(4);
  }

  formatAddress(address) {
    if (!address) return '';
    return address.slice(0, 6) + '...' + address.slice(-4);
  }

  updateUI() {
    const connectBtn = document.getElementById('connect-wallet');
    const addressDisplay = document.getElementById('wallet-address');
    const balanceDisplay = document.getElementById('wallet-balance');
    const networkDisplay = document.getElementById('network-name');

    if (connectBtn) {
      if (this.address) {
        connectBtn.textContent = this.formatAddress(this.address);
        connectBtn.classList.add('connected');
      } else {
        connectBtn.textContent = 'Connect Wallet';
        connectBtn.classList.remove('connected');
      }
    }

    if (addressDisplay) {
      addressDisplay.textContent = this.address || 'Not connected';
    }

    if (balanceDisplay && this.address) {
      this.getBalance(this.address).then(balance => {
        balanceDisplay.textContent = balance + ' ETH';
      });
    }

    if (networkDisplay) {
      const chainName = this.getChainName(this.chainId);
      networkDisplay.textContent = chainName;
    }

    document.dispatchEvent(new CustomEvent('walletStateChanged', {
      detail: { address: this.address, chainId: this.chainId }
    }));
  }

  async fetchAndDispatchPortfolio() {
    try {
      if (!this.address || !window.portfolioService?.getPortfolio) return;
      const key = this.address + '-' + this.chainId;
      if (this._lastPortfolioKey === key) return;
      this._lastPortfolioKey = key;

      const portfolio = await window.portfolioService.getPortfolio(this.address, this.chainId);
      window.dispatchEvent(new CustomEvent('portfolio-update', {
        detail: { address: this.address, chainId: this.chainId, portfolio }
      }));
    } catch (err) {
      console.warn('Failed to load portfolio:', err);
    }
  }

  getChainName(chainId) {
    const chains = {
      1: 'Ethereum',
      137: 'Polygon',
      42161: 'Arbitrum',
      10: 'Optimism',
      56: 'BSC',
      43114: 'Avalanche'
    };
    return chains[chainId] || 'Unknown';
  }
}

// Initialize Web3 Service
const web3Service = new Web3Service();

// Export for use in other modules
window.web3Service = web3Service;

// Setup connect button if it exists
document.addEventListener('DOMContentLoaded', () => {
  const connectBtn = document.getElementById('connect-wallet');
  if (connectBtn) {
    connectBtn.addEventListener('click', () => {
      if (web3Service.address) {
        web3Service.disconnect();
      } else {
        web3Service.connect();
      }
    });
  }

  const networkSelector = document.getElementById('network-selector');
  if (networkSelector) {
    networkSelector.addEventListener('change', (e) => {
      const chainId = parseInt(e.target.value);
      web3Service.switchNetwork(chainId);
    });
  }
});
`;
</file>

<file path="packages/ui-frontend/app/lib/web3/config.ts">
import { createAppKit } from '@reown/appkit/react';
import { mainnet, arbitrum, bsc, solana } from '@reown/appkit/networks';
import { WagmiAdapter } from '@reown/appkit-adapter-wagmi';
import type { AppKitNetwork } from '@reown/appkit/networks';

const projectId =
  (typeof process !== 'undefined' && process.env && (process.env.WALLETCONNECT_PROJECT_ID as string)) ||
  '0ab3f2c9a30c1add3cff35eadf12cfc7';

const metadata = {
  name: 'EITHERWAY',
  description: 'Build dApps with AI in 5 minutes',
  url: typeof window !== 'undefined' ? window.location.origin : '',
  icons: ['/icons/logo.svg'],
};

const networks: [AppKitNetwork, ...AppKitNetwork[]] = [mainnet, bsc, solana, arbitrum];

const wagmiAdapter = new WagmiAdapter({
  networks,
  projectId,
});

export const appKit = createAppKit({
  adapters: [wagmiAdapter],
  networks,
  metadata,
  projectId,
  features: {
    analytics: true,
  },
});

export { wagmiAdapter };
</file>

<file path="packages/ui-frontend/app/lib/web3/hooks.ts">
import { useAppKitAccount } from '@reown/appkit/react';
import { appKit } from './config';

export function useWalletConnection() {
  const { isConnected, address } = useAppKitAccount();

  const connectWallet = async () => {
    console.log('connectWallet called, appKit:', appKit);

    try {
      await appKit.open({ view: isConnected ? 'Account' : 'Connect' });
    } catch (error) {
      console.error('Failed to connect wallet:', error);
    }
  };

  const disconnectWallet = async () => {
    try {
      await appKit.open({ view: 'Account' });
    } catch (error) {
      console.error('Failed to open account modal:', error);
    }
  };

  const formatAddress = (addr: string) => {
    return `${addr.slice(0, 6)}...${addr.slice(-4)}`;
  };

  return {
    connectWallet,
    disconnectWallet,
    isConnected,
    address,
    formatAddress,
  };
}
</file>

<file path="packages/ui-frontend/app/lib/web3/index.ts">
export { Web3Provider } from './Web3Provider';
export { useWalletConnection } from './hooks';
export { appKit } from './config';
</file>

<file path="packages/ui-frontend/app/lib/web3/Web3Provider.tsx">
import { WagmiProvider } from 'wagmi';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import type { ReactNode } from 'react';
import { wagmiAdapter } from './config';

const queryClient = new QueryClient();

interface Web3ProviderProps {
  children: ReactNode;
}

export function Web3Provider({ children }: Web3ProviderProps) {
  return (
    <WagmiProvider config={wagmiAdapter.wagmiConfig}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </WagmiProvider>
  );
}
</file>

<file path="packages/ui-frontend/app/lib/webcontainer/auth.client.ts">
/**
 * This client-only module that contains everything related to auth and is used
 * to avoid importing `@webcontainer/api` in the server bundle.
 */

export { auth, type AuthAPI } from '@webcontainer/api';
</file>

<file path="packages/ui-frontend/app/lib/crypto.ts">
const encoder = new TextEncoder();
const decoder = new TextDecoder();
const IV_LENGTH = 16;

export async function encrypt(key: string, data: string) {
  const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH));
  const cryptoKey = await getKey(key);

  const ciphertext = await crypto.subtle.encrypt(
    {
      name: 'AES-CBC',
      iv,
    },
    cryptoKey,
    encoder.encode(data),
  );

  const bundle = new Uint8Array(IV_LENGTH + ciphertext.byteLength);

  bundle.set(new Uint8Array(ciphertext));
  bundle.set(iv, ciphertext.byteLength);

  return decodeBase64(bundle);
}

export async function decrypt(key: string, payload: string) {
  const bundle = encodeBase64(payload);

  const iv = new Uint8Array(bundle.buffer, bundle.byteLength - IV_LENGTH);
  const ciphertext = new Uint8Array(bundle.buffer, 0, bundle.byteLength - IV_LENGTH);

  const cryptoKey = await getKey(key);

  const plaintext = await crypto.subtle.decrypt(
    {
      name: 'AES-CBC',
      iv,
    },
    cryptoKey,
    ciphertext,
  );

  return decoder.decode(plaintext);
}

async function getKey(key: string) {
  return await crypto.subtle.importKey('raw', encodeBase64(key), { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);
}

function decodeBase64(encoded: Uint8Array) {
  const byteChars = Array.from(encoded, (byte) => String.fromCodePoint(byte));

  return btoa(byteChars.join(''));
}

function encodeBase64(data: string) {
  return Uint8Array.from(atob(data), (ch) => ch.codePointAt(0)!);
}
</file>

<file path="packages/ui-frontend/app/lib/fetch.ts">
type CommonRequest = Omit<RequestInit, 'body'> & { body?: URLSearchParams };

export async function request(url: string, init?: CommonRequest) {
  if (import.meta.env.DEV) {
    const nodeFetch = await import('node-fetch');
    const https = await import('node:https');

    const agent = url.startsWith('https') ? new https.Agent({ rejectUnauthorized: false }) : undefined;

    return nodeFetch.default(url, { ...init, agent });
  }

  return fetch(url, init);
}
</file>

<file path="packages/ui-frontend/app/routes/_index.tsx">
import { redirect } from '@remix-run/node';

export const loader = () => {
  return redirect('/chat');
};
</file>

<file path="packages/ui-frontend/app/routes/chat._index.tsx">
import { json, type LoaderFunctionArgs, type MetaFunction } from '@remix-run/node';
import { ClientOnly } from 'remix-utils/client-only';
import { BaseChatFallback } from '~/components/chat/BaseChatFallback';
import { Chat } from '~/components/chat/Chat.client';
import { HeaderWithGlow } from '~/components/HeaderWithGlow';

export const meta: MetaFunction = () => {
  return [
    { title: "Eitherway - Don't just imagine it. Launch it." },
    {
      name: 'description',
      content:
        'Eitherway turns your ideas into fully working, monetizable mobile apps with a single prompt. No coding. No delays. Just build, publish, and earn  either way.',
    },
  ];
};

export const loader = ({ request }: LoaderFunctionArgs) => {
  const url = new URL(request.url);
  const headers = new Headers();

  //     WASM   SharedArrayBuffer
  if (url.pathname.endsWith('.wasm') || url.pathname.includes('action-runner')) {
    headers.set('Cross-Origin-Opener-Policy', 'same-origin');
    headers.set('Cross-Origin-Embedder-Policy', 'require-corp');
  }

  return json({}, { headers });
};

export default function ChatPage() {
  return (
    <ClientOnly fallback={<BaseChatFallback />}>
      {() => (
        <HeaderWithGlow>
          <Chat />
        </HeaderWithGlow>
      )}
    </ClientOnly>
  );
}
</file>

<file path="packages/ui-frontend/app/routes/chat.$id.tsx">
import { json, type LoaderFunctionArgs, type MetaFunction } from '@remix-run/node';
import { ClientOnly } from 'remix-utils/client-only';
import { BaseChatFallback } from '~/components/chat/BaseChatFallback';
import { Chat } from '~/components/chat/Chat.client';
import { HeaderWithGlow } from '~/components/HeaderWithGlow';

export const meta: MetaFunction = () => {
  return [
    { title: 'EITHERWAY  - Chat with AI' },
    {
      name: 'description',
      content: 'Chat with AI to build your next app. Start building with EITHERWAY.',
    },
  ];
};

export async function loader({ request, params }: LoaderFunctionArgs) {
  const url = new URL(request.url);
  const headers = new Headers();

  //     WASM   SharedArrayBuffer
  if (url.pathname.endsWith('.wasm') || url.pathname.includes('action-runner')) {
    headers.set('Cross-Origin-Opener-Policy', 'same-origin');
    headers.set('Cross-Origin-Embedder-Policy', 'require-corp');
  }

  return json({ id: params.id }, { headers });
}

export default function ChatPageWithId() {
  return (
    <ClientOnly fallback={<BaseChatFallback />}>
      {() => (
        <HeaderWithGlow>
          <Chat />
        </HeaderWithGlow>
      )}
    </ClientOnly>
  );
}
</file>

<file path="packages/ui-frontend/app/routes/playmarket.tsx">
import React from 'react';
import { GooglePlayMock } from '~/components/GooglePlayMock';

export default function PlayMarketPage() {
  return (
    <div className="min-h-screen bg-gray-50">
      <GooglePlayMock />
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/styles/components/code.scss">
.actions .shiki {
  background-color: var(--eitherway-elements-actions-code-background) !important;
}

.shiki {
  &:not(:has(.actions), .actions *) {
    background-color: var(--eitherway-elements-messages-code-background) !important;
  }
}
</file>

<file path="packages/ui-frontend/app/styles/components/editor.scss">
:root {
  --cm-backgroundColor: var(--eitherway-elements-editor-backgroundColor, var(--eitherway-elements-bg-depth-1));
  --cm-textColor: var(--eitherway-elements-editor-textColor, var(--eitherway-elements-textPrimary));

  /* Gutter */

  --cm-gutter-backgroundColor: var(--eitherway-elements-editor-gutter-backgroundColor, var(--cm-backgroundColor));
  --cm-gutter-textColor: var(--eitherway-elements-editor-gutter-textColor, var(--eitherway-elements-textSecondary));
  --cm-gutter-activeLineTextColor: var(--eitherway-elements-editor-gutter-activeLineTextColor, var(--cm-gutter-textColor));

  /* Fold Gutter */

  --cm-foldGutter-textColor: var(--eitherway-elements-editor-foldGutter-textColor, var(--cm-gutter-textColor));
  --cm-foldGutter-textColorHover: var(--eitherway-elements-editor-foldGutter-textColorHover, var(--cm-gutter-textColor));

  /* Active Line */

  --cm-activeLineBackgroundColor: var(--eitherway-elements-editor-activeLineBackgroundColor, rgb(224 231 235 / 30%));

  /* Cursor */

  --cm-cursor-width: 2px;
  --cm-cursor-backgroundColor: var(--eitherway-elements-editor-cursorColor, var(--eitherway-elements-textSecondary));

  /* Matching Brackets */

  --cm-matching-bracket: var(--eitherway-elements-editor-matchingBracketBackgroundColor, rgb(50 140 130 / 0.3));

  /* Selection */

  --cm-selection-backgroundColorFocused: var(--eitherway-elements-editor-selection-backgroundColor, #42b4ff);
  --cm-selection-backgroundOpacityFocused: var(--eitherway-elements-editor-selection-backgroundOpacity, 0.3);
  --cm-selection-backgroundColorBlured: var(--eitherway-elements-editor-selection-inactiveBackgroundColor, #c9e9ff);
  --cm-selection-backgroundOpacityBlured: var(--eitherway-elements-editor-selection-inactiveBackgroundOpacity, 0.3);

  /* Panels */

  --cm-panels-borderColor: var(--eitherway-elements-editor-panels-borderColor, var(--eitherway-elements-borderColor));

  /* Search */

  --cm-search-backgroundColor: var(--eitherway-elements-editor-search-backgroundColor, var(--cm-backgroundColor));
  --cm-search-textColor: var(--eitherway-elements-editor-search-textColor, var(--eitherway-elements-textSecondary));
  --cm-search-closeButton-backgroundColor: var(--eitherway-elements-editor-search-closeButton-backgroundColor, transparent);

  --cm-search-closeButton-backgroundColorHover: var(
    --eitherway-elements-editor-search-closeButton-backgroundColorHover,
    var(--eitherway-elements-item-backgroundActive)
  );

  --cm-search-closeButton-textColor: var(
    --eitherway-elements-editor-search-closeButton-textColor,
    var(--eitherway-elements-item-contentDefault)
  );

  --cm-search-closeButton-textColorHover: var(
    --eitherway-elements-editor-search-closeButton-textColorHover,
    var(--eitherway-elements-item-contentActive)
  );

  --cm-search-button-backgroundColor: var(
    --eitherway-elements-editor-search-button-backgroundColor,
    var(--eitherway-elements-item-backgroundDefault)
  );

  --cm-search-button-backgroundColorHover: var(
    --eitherway-elements-editor-search-button-backgroundColorHover,
    var(--eitherway-elements-item-backgroundActive)
  );

  --cm-search-button-textColor: var(--eitherway-elements-editor-search-button-textColor, var(--eitherway-elements-textSecondary));

  --cm-search-button-textColorHover: var(
    --eitherway-elements-editor-search-button-textColorHover,
    var(--eitherway-elements-textPrimary)
  );

  --cm-search-button-borderColor: var(--eitherway-elements-editor-search-button-borderColor, transparent);
  --cm-search-button-borderColorHover: var(--eitherway-elements-editor-search-button-borderColorHover, transparent);

  --cm-search-button-borderColorFocused: var(
    --eitherway-elements-editor-search-button-borderColorFocused,
    var(--eitherway-elements-borderColorActive)
  );

  --cm-search-input-backgroundColor: var(--eitherway-elements-editor-search-input-backgroundColor, transparent);
  --cm-search-input-textColor: var(--eitherway-elements-editor-search-input-textColor, var(--eitherway-elements-textPrimary));
  --cm-search-input-borderColor: var(--eitherway-elements-editor-search-input-borderColor, var(--eitherway-elements-borderColor));

  --cm-search-input-borderColorFocused: var(
    --eitherway-elements-editor-search-input-borderColorFocused,
    var(--eitherway-elements-borderColorActive)
  );

  /* Tooltip */

  --cm-tooltip-backgroundColor: var(--eitherway-elements-editor-tooltip-backgroundColor, var(--cm-backgroundColor));
  --cm-tooltip-textColor: var(--eitherway-elements-editor-tooltip-textColor, var(--eitherway-elements-textPrimary));

  --cm-tooltip-backgroundColorSelected: var(
    --eitherway-elements-editor-tooltip-backgroundColorSelected,
    theme('colors.alpha.accent.30')
  );

  --cm-tooltip-textColorSelected: var(
    --eitherway-elements-editor-tooltip-textColorSelected,
    var(--eitherway-elements-textPrimary)
  );

  --cm-tooltip-borderColor: var(--eitherway-elements-editor-tooltip-borderColor, var(--eitherway-elements-borderColor));

  --cm-searchMatch-backgroundColor: var(--eitherway-elements-editor-searchMatch-backgroundColor, rgba(234, 92, 0, 0.33));
}

html[data-theme='light'] {
  --eitherway-elements-editor-gutter-textColor: #237893;
  --eitherway-elements-editor-gutter-activeLineTextColor: var(--eitherway-elements-textPrimary);
  --eitherway-elements-editor-foldGutter-textColorHover: var(--eitherway-elements-textPrimary);
  --eitherway-elements-editor-activeLineBackgroundColor: rgb(50 53 63 / 5%);
  --eitherway-elements-editor-tooltip-backgroundColorSelected: theme('colors.alpha.accent.20');
  --eitherway-elements-editor-search-button-backgroundColor: theme('colors.gray.100');
  --eitherway-elements-editor-search-button-backgroundColorHover: theme('colors.alpha.gray.10');
}

html[data-theme='dark'] {
  --cm-backgroundColor: var(--eitherway-elements-bg-depth-2);
  --eitherway-elements-editor-gutter-textColor: var(--eitherway-elements-textTertiary);
  --eitherway-elements-editor-gutter-activeLineTextColor: var(--eitherway-elements-textSecondary);
  --eitherway-elements-editor-selection-inactiveBackgroundOpacity: 0.3;
  --eitherway-elements-editor-activeLineBackgroundColor: rgb(50 53 63 / 50%);
  --eitherway-elements-editor-foldGutter-textColorHover: var(--eitherway-elements-textPrimary);
  --eitherway-elements-editor-matchingBracketBackgroundColor: rgba(66, 180, 255, 0.3);
  --eitherway-elements-editor-search-button-backgroundColor: theme('colors.gray.800');
  --eitherway-elements-editor-search-button-backgroundColorHover: theme('colors.alpha.white.10');
}
</file>

<file path="packages/ui-frontend/app/styles/components/resize-handle.scss">
[data-resize-handle] {
  position: relative;

  &[data-panel-group-direction='horizontal']:after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: -6px;
    right: -5px;
    z-index: $zIndexMax;
  }

  &[data-panel-group-direction='vertical']:after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    top: -5px;
    bottom: -6px;
    z-index: $zIndexMax;
  }

  &[data-resize-handle-state='hover']:after,
  &[data-resize-handle-state='drag']:after {
    background-color: #8882;
  }
}
</file>

<file path="packages/ui-frontend/app/styles/components/terminal.scss">
.xterm {
  padding: 1rem;
}
</file>

<file path="packages/ui-frontend/app/styles/components/toast.scss">
.Toastify__toast {
  --at-apply: shadow-md;

  background-color: var(--eitherway-elements-bg-depth-2);
  color: var(--eitherway-elements-textPrimary);
  border: 1px solid var(--eitherway-elements-borderColor);
}

.Toastify__close-button {
  color: var(--eitherway-elements-item-contentDefault);
  opacity: 1;
  transition: none;

  &:hover {
    color: var(--eitherway-elements-item-contentActive);
  }
}
</file>

<file path="packages/ui-frontend/app/styles/animations.scss">
.animated {
  animation-fill-mode: both;
  animation-duration: var(--animate-duration, 0.2s);
  animation-timing-function: cubic-bezier(0, 0, 0.2, 1);

  &.fadeInRight {
    animation-name: fadeInRight;
  }

  &.fadeOutRight {
    animation-name: fadeOutRight;
  }
}

@keyframes fadeInRight {
  from {
    opacity: 0;
    transform: translate3d(100%, 0, 0);
  }

  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
}

@keyframes fadeOutRight {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    transform: translate3d(100%, 0, 0);
  }
}

.dropdown-animation {
  opacity: 0;
  animation: fadeMoveDown 0.15s forwards;
  animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes fadeMoveDown {
  to {
    opacity: 1;
    transform: translateY(6px);
  }
}

.animate-barbershop {
  animation: barbershop 2s ease-in-out infinite alternate;
}

@keyframes barbershop {
  0% {
    transform: translateX(-50%);
  }
  100% {
    transform: translateX(0%);
  }
}
</file>

<file path="packages/ui-frontend/app/styles/index.scss">
@import './variables.scss';
@import './z-index.scss';
@import './animations.scss';
@import './components/terminal.scss';
@import './components/resize-handle.scss';
@import './components/code.scss';
@import './components/editor.scss';
@import './components/toast.scss';

html {
  height: 100%;
  width: 100%;
  font-family: var(--font-mono); /* Azeret Mono      */
  background-color: #000000;
  color: #ffffff;
  position: relative;
  overflow-x: hidden;
  overflow-y: auto;
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE and Edge */
  scroll-behavior: smooth; /*      */
}

body {
  height: 100%;
  width: 100%;
  position: relative;
}

/* Hide scrollbar for Chrome, Safari and Opera */
html::-webkit-scrollbar,
body::-webkit-scrollbar {
  display: none;
}

/* Font loading optimization */
.fonts-loading * {
  visibility: hidden;
}

.fonts-loaded * {
  visibility: visible;
  transition: visibility 0.1s ease-in-out;
}

/* Prevent header flickering during hydration */
.header-transition {
  transition: transform 0.5s ease-in-out;
}

/* Smooth mounting transition */
.mounting {
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
}

.mounted {
  opacity: 1;
}

.font-syne {
  font-family:
    'Syne',
    -apple-system,
    BlinkMacSystemFont,
    'Segoe UI',
    Roboto,
    sans-serif;
  font-display: block;
}

.font-montserrat {
  font-family:
    'Montserrat',
    -apple-system,
    BlinkMacSystemFont,
    'Segoe UI',
    Roboto,
    sans-serif;
  font-display: block;
}

.font-righteous {
  font-family:
    'Righteous',
    -apple-system,
    BlinkMacSystemFont,
    'Segoe UI',
    Roboto,
    sans-serif;
  font-display: block;
}

.font-mono {
  font-family: 'Azeret Mono', 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
  font-display: block;
}

/* Prevent FOUT (Flash of Unstyled Text) */
.fonts-loading .font-syne,
.fonts-loading .font-montserrat,
.fonts-loading .font-righteous {
  visibility: hidden;
}

.fonts-loaded .font-syne,
.fonts-loaded .font-montserrat,
.fonts-loaded .font-righteous {
  visibility: visible;
}

/* Connect Wallet Button -     */
.connect-wallet {
  padding: 0 20px;
  height: 32px; /*       */
  border: 1px solid #333333;
  border-radius: 12px;
  background: transparent;
  font-family: 'Azeret Mono', monospace;
  font-size: 12px;
  line-height: 14px;
  color: #ffffff;
  cursor: pointer;
  transition: all 0.2s ease;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  white-space: nowrap;

  &:hover {
    background: rgba(255, 255, 255, 0.05);
  }
}
</file>

<file path="packages/ui-frontend/app/styles/variables.scss">
/* Color Tokens Light Theme */
:root,
:root[data-theme='light'] {
  /* Primary Brand Colors */
  --eitherway-primary: #0d00ff;
  --eitherway-primary-hover: #0b00e6;
  --eitherway-primary-light: rgba(13, 0, 255, 0.1);
  --eitherway-primary-dark: #0800cc;

  --eitherway-elements-borderColor: #e6e6e6;
  --eitherway-elements-borderColorActive: #21c352;

  --eitherway-elements-bg-depth-1: #ffffff;
  --eitherway-elements-bg-depth-2: #ffffff;
  --eitherway-elements-bg-depth-3: #f8f8f8;
  --eitherway-elements-bg-depth-4: rgba(0, 0, 0, 0.02);

  --eitherway-elements-textPrimary: #000000;
  --eitherway-elements-textSecondary: #666666;
  --eitherway-elements-textTertiary: #999999;

  --eitherway-elements-code-background: #e0e0e0;
  --eitherway-elements-code-text: #000000;

  --eitherway-elements-button-primary-background: rgba(255, 255, 255, 0.1);
  --eitherway-elements-button-primary-backgroundHover: rgba(255, 255, 255, 0.2);
  --eitherway-elements-button-primary-text: #000000;

  --eitherway-elements-button-secondary-background: rgba(0, 0, 0, 0.05);
  --eitherway-elements-button-secondary-backgroundHover: rgba(0, 0, 0, 0.1);
  --eitherway-elements-button-secondary-text: #000000;

  --eitherway-elements-button-danger-background: rgba(255, 82, 82, 0.1);
  --eitherway-elements-button-danger-backgroundHover: rgba(255, 82, 82, 0.2);
  --eitherway-elements-button-danger-text: #ff5252;

  --eitherway-elements-item-contentDefault: rgba(0, 0, 0, 0.5);
  --eitherway-elements-item-contentActive: #000000;
  --eitherway-elements-item-contentAccent: #000000;
  --eitherway-elements-item-contentDanger: #ff5252;
  --eitherway-elements-item-backgroundDefault: rgba(0, 0, 0, 0);
  --eitherway-elements-item-backgroundActive: rgba(0, 0, 0, 0.05);
  --eitherway-elements-item-backgroundAccent: rgba(165, 165, 165, 0.1);
  --eitherway-elements-item-backgroundDanger: rgba(255, 82, 82, 0.1);

  --eitherway-elements-loader-background: rgba(255, 255, 255, 0.1);
  --eitherway-elements-loader-progress: #ffffff;

  --eitherway-elements-artifacts-background: #000000;
  --eitherway-elements-artifacts-backgroundHover: rgba(255, 255, 255, 0.02);
  --eitherway-elements-artifacts-borderColor: var(--eitherway-elements-borderColor);
  --eitherway-elements-artifacts-inlineCode-background: #000000;
  --eitherway-elements-artifacts-inlineCode-text: var(--eitherway-elements-textPrimary);

  --eitherway-elements-actions-background: #000000;
  --eitherway-elements-actions-code-background: #000000;

  --eitherway-elements-messages-background: #000000;
  --eitherway-elements-messages-linkColor: #ffffff;
  --eitherway-elements-messages-code-background: #000000;
  --eitherway-elements-messages-inlineCode-background: #000000;
  --eitherway-elements-messages-inlineCode-text: #ffffff;

  --eitherway-elements-icon-success: #000000;
  --eitherway-elements-icon-error: #ff5252;
  --eitherway-elements-icon-primary: #ffffff;
  --eitherway-elements-icon-secondary: #666666;
  --eitherway-elements-icon-tertiary: #999999;

  --eitherway-elements-dividerColor: #333333;

  --eitherway-elements-prompt-background: rgba(0, 0, 0, 0.8);

  --eitherway-elements-sidebar-dropdownShadow: rgba(255, 255, 255, 0.1);
  --eitherway-elements-sidebar-buttonBackgroundDefault: rgba(59, 59, 59, 0.1);
  --eitherway-elements-sidebar-buttonBackgroundHover: rgba(85, 85, 85, 0.2);
  --eitherway-elements-sidebar-buttonText: #000000;

  --eitherway-elements-preview-addressBar-background: #000000;
  --eitherway-elements-preview-addressBar-backgroundHover: rgba(255, 255, 255, 0.05);
  --eitherway-elements-preview-addressBar-backgroundActive: #000000;
  --eitherway-elements-preview-addressBar-text: var(--eitherway-elements-textSecondary);
  --eitherway-elements-preview-addressBar-textActive: var(--eitherway-elements-textPrimary);

  --eitherway-elements-terminals-background: #000000;
  --eitherway-elements-terminals-buttonBackground: var(--eitherway-elements-bg-depth-4);

  --eitherway-elements-cta-background: #000000;
  --eitherway-elements-cta-text: #ffffff;

  /* Terminal Colors */
  --eitherway-terminal-background: var(--eitherway-elements-terminals-background);
  --eitherway-terminal-foreground: #ffffff;
  --eitherway-terminal-selection-background: rgba(255, 255, 255, 0.2);
  --eitherway-terminal-black: #000000;
  --eitherway-terminal-red: #ff5252;
  --eitherway-terminal-green: #ffffff;
  --eitherway-terminal-yellow: #ffc107;
  --eitherway-terminal-blue: #2196f3;
  --eitherway-terminal-magenta: #e91e63;
  --eitherway-terminal-cyan: #00bcd4;
  --eitherway-terminal-white: #ffffff;
  --eitherway-terminal-brightBlack: #ffffff;
  --eitherway-terminal-brightRed: #ff5252;
  --eitherway-terminal-brightGreen: #ffffff;
  --eitherway-terminal-brightYellow: #ffc107;
  --eitherway-terminal-brightBlue: #2196f3;
  --eitherway-terminal-brightMagenta: #e91e63;
  --eitherway-terminal-brightCyan: #00bcd4;
  --eitherway-terminal-brightWhite: #ffffff;
}

/* Color Tokens Dark Theme */
:root,
:root[data-theme='dark'] {
  /* Primary Brand Colors */
  --eitherway-primary: #0d00ff;
  --eitherway-primary-hover: #0b00e6;
  --eitherway-primary-light: rgba(13, 0, 255, 0.1);
  --eitherway-primary-dark: #0800cc;

  --eitherway-elements-borderColor: #333333;
  --eitherway-elements-borderColorActive: #21c352;

  --eitherway-elements-bg-depth-1: #000000;
  --eitherway-elements-bg-depth-2: #000000;
  --eitherway-elements-bg-depth-3: #000000;
  --eitherway-elements-bg-depth-4: rgba(255, 255, 255, 0.02);

  --eitherway-elements-textPrimary: #ffffff;
  --eitherway-elements-textSecondary: #ffffff;
  --eitherway-elements-textTertiary: #ffffff;

  --eitherway-elements-code-background: #000000;
  --eitherway-elements-code-text: #ffffff;

  --eitherway-elements-button-primary-background: rgba(255, 255, 255, 0.1);
  --eitherway-elements-button-primary-backgroundHover: rgba(255, 255, 255, 0.2);
  --eitherway-elements-button-primary-text: #ffffff;

  --eitherway-elements-button-secondary-background: rgba(255, 255, 255, 0.05);
  --eitherway-elements-button-secondary-backgroundHover: rgba(255, 255, 255, 0.1);
  --eitherway-elements-button-secondary-text: #ffffff;

  --eitherway-elements-button-danger-background: rgba(255, 82, 82, 0.1);
  --eitherway-elements-button-danger-backgroundHover: rgba(255, 82, 82, 0.2);
  --eitherway-elements-button-danger-text: #ff5252;

  --eitherway-elements-item-contentDefault: rgba(255, 255, 255, 0.5);
  --eitherway-elements-item-contentActive: #ffffff;
  --eitherway-elements-item-contentAccent: #ffffff;
  --eitherway-elements-item-contentDanger: #ff5252;
  --eitherway-elements-item-backgroundDefault: transparent;
  --eitherway-elements-item-backgroundActive: rgba(255, 255, 255, 0.05);
  --eitherway-elements-item-backgroundAccent: rgba(255, 255, 255, 0.1);
  --eitherway-elements-item-backgroundDanger: rgba(255, 82, 82, 0.1);

  --eitherway-elements-loader-background: rgba(255, 255, 255, 0.1);
  --eitherway-elements-loader-progress: #ffffff;

  --eitherway-elements-artifacts-background: #000000;
  --eitherway-elements-artifacts-backgroundHover: rgba(255, 255, 255, 0.02);
  --eitherway-elements-artifacts-borderColor: var(--eitherway-elements-borderColor);
  --eitherway-elements-artifacts-inlineCode-background: #000000;
  --eitherway-elements-artifacts-inlineCode-text: var(--eitherway-elements-textPrimary);

  --eitherway-elements-actions-background: #000000;
  --eitherway-elements-actions-code-background: #000000;

  --eitherway-elements-messages-background: #000000;
  --eitherway-elements-messages-linkColor: #ffffff;
  --eitherway-elements-messages-code-background: #000000;
  --eitherway-elements-messages-inlineCode-background: #000000;
  --eitherway-elements-messages-inlineCode-text: #ffffff;

  --eitherway-elements-icon-success: #ffffff;
  --eitherway-elements-icon-error: #ff5252;
  --eitherway-elements-icon-primary: #ffffff;
  --eitherway-elements-icon-secondary: #ffffff;
  --eitherway-elements-icon-tertiary: #ffffff;

  --eitherway-elements-dividerColor: #333333;

  --eitherway-elements-prompt-background: rgba(0, 0, 0, 0.8);

  --eitherway-elements-sidebar-dropdownShadow: rgba(255, 255, 255, 0.1);
  --eitherway-elements-sidebar-buttonBackgroundDefault: rgba(255, 255, 255, 0.1);
  --eitherway-elements-sidebar-buttonBackgroundHover: rgba(255, 255, 255, 0.2);
  --eitherway-elements-sidebar-buttonText: #ffffff;

  --eitherway-elements-preview-addressBar-background: #000000;
  --eitherway-elements-preview-addressBar-backgroundHover: rgba(255, 255, 255, 0.05);
  --eitherway-elements-preview-addressBar-backgroundActive: #000000;
  --eitherway-elements-preview-addressBar-text: var(--eitherway-elements-textSecondary);
  --eitherway-elements-preview-addressBar-textActive: var(--eitherway-elements-textPrimary);

  --eitherway-elements-terminals-background: #000000;
  --eitherway-elements-terminals-buttonBackground: var(--eitherway-elements-bg-depth-4);

  --eitherway-elements-cta-background: #000000;
  --eitherway-elements-cta-text: #ffffff;

  /* Terminal Colors */
  --eitherway-terminal-background: var(--eitherway-elements-terminals-background);
  --eitherway-terminal-foreground: #ffffff;
  --eitherway-terminal-selection-background: rgba(255, 255, 255, 0.2);
  --eitherway-terminal-black: #000000;
  --eitherway-terminal-red: #ff5252;
  --eitherway-terminal-green: #ffffff;
  --eitherway-terminal-yellow: #ffc107;
  --eitherway-terminal-blue: #2196f3;
  --eitherway-terminal-magenta: #e91e63;
  --eitherway-terminal-cyan: #00bcd4;
  --eitherway-terminal-white: #ffffff;
  --eitherway-terminal-brightBlack: #ffffff;
  --eitherway-terminal-brightRed: #ff5252;
  --eitherway-terminal-brightGreen: #ffffff;
  --eitherway-terminal-brightYellow: #ffc107;
  --eitherway-terminal-brightBlue: #2196f3;
  --eitherway-terminal-brightMagenta: #e91e63;
  --eitherway-terminal-brightCyan: #00bcd4;
  --eitherway-terminal-brightWhite: #ffffff;
}

/*
 * Element Tokens
 *
 * Hierarchy: Element Token -> (Element Token | Color Tokens) -> Primitives
 */
:root {
  /* Font Families */
  --font-righteous: 'Righteous', cursive;
  --font-mono: 'Azeret Mono', ui-monospace, 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', 'Liberation Mono',
    'Courier New', monospace;

  --header-height: 128px;
  --chat-max-width: 37rem;
  --chat-min-width: 640px;
  --workbench-min-width: 600px;

  /*  1280px -    (full width) */
  /* Toasts */
  --toastify-color-progress-success: #ffffff;
  --toastify-color-progress-error: #ff5252;

  /* Terminal */
  --eitherway-elements-terminal-backgroundColor: var(--eitherway-terminal-background);

  @media (max-width: 1279px) {
    --workbench-width: calc(100vw - 48px);
    --workbench-inner-width: var(--workbench-width);
    --workbench-left: 24px;
    --chat-width: 100%;
  }

  /*  1280px -   */
  @media (min-width: 1280px) {
    --workbench-width: max(min(calc(100% - var(--chat-min-width)), 1536px), var(--workbench-min-width));
    --workbench-inner-width: var(--workbench-width);
    --workbench-left: calc(100% - var(--workbench-width));
    --chat-width: var(--chat-min-width);
  }
  --eitherway-elements-terminal-textColor: var(--eitherway-terminal-foreground);
  --eitherway-elements-terminal-cursorColor: var(--eitherway-terminal-foreground);
  --eitherway-elements-terminal-selection-backgroundColor: var(--eitherway-terminal-selection-background);
  --eitherway-elements-terminal-color-black: var(--eitherway-terminal-black);
  --eitherway-elements-terminal-color-red: var(--eitherway-terminal-red);
  --eitherway-elements-terminal-color-green: var(--eitherway-terminal-green);
  --eitherway-elements-terminal-color-yellow: var(--eitherway-terminal-yellow);
  --eitherway-elements-terminal-color-blue: var(--eitherway-terminal-blue);
  --eitherway-elements-terminal-color-magenta: var(--eitherway-terminal-magenta);
  --eitherway-elements-terminal-color-cyan: var(--eitherway-terminal-cyan);
  --eitherway-elements-terminal-color-white: var(--eitherway-terminal-white);
  --eitherway-elements-terminal-color-brightBlack: var(--eitherway-terminal-brightBlack);
  --eitherway-elements-terminal-color-brightRed: var(--eitherway-terminal-brightRed);
  --eitherway-elements-terminal-color-brightGreen: var(--eitherway-terminal-brightGreen);
  --eitherway-elements-terminal-color-brightYellow: var(--eitherway-terminal-brightYellow);
  --eitherway-elements-terminal-color-brightBlue: var(--eitherway-terminal-brightBlue);
  --eitherway-elements-terminal-color-brightMagenta: var(--eitherway-terminal-brightMagenta);
  --eitherway-elements-terminal-color-brightCyan: var(--eitherway-terminal-brightCyan);
  --eitherway-elements-terminal-color-brightWhite: var(--eitherway-terminal-brightWhite);
}
</file>

<file path="packages/ui-frontend/app/styles/z-index.scss">
$zIndexMax: 999;

.z-logo {
  z-index: $zIndexMax - 1;
}

.z-sidebar {
  z-index: $zIndexMax - 2;
}

.z-port-dropdown {
  z-index: $zIndexMax - 3;
}

.z-iframe-overlay {
  z-index: $zIndexMax - 4;
}

.z-prompt {
  z-index: 2;
}

.z-workbench {
  z-index: 3;
}

.z-file-tree-breadcrumb {
  z-index: $zIndexMax - 1;
}

.z-max {
  z-index: $zIndexMax;
}
</file>

<file path="packages/ui-frontend/app/templates/webcontainer-server.template.js">
const http = require('http');
const fs = require('fs');
const path = require('path');

const BASE_DIR = '__BASE_DIR__';
const PORT = __PORT__;
const DEFAULT_FILE = '__HTML_FILE__';

const mimeTypes = {
  '.html': 'text/html; charset=utf-8',
  '.css': 'text/css; charset=utf-8',
  '.js': 'application/javascript; charset=utf-8',
  '.mjs': 'application/javascript; charset=utf-8',
  '.json': 'application/json; charset=utf-8',
  '.png': 'image/png',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.webp': 'image/webp',
  '.gif': 'image/gif',
  '.svg': 'image/svg+xml',
  '.ico': 'image/x-icon',
  '.bmp': 'image/bmp',
  '.woff': 'font/woff',
  '.woff2': 'font/woff2',
  '.ttf': 'font/ttf',
};

const server = http.createServer(async (req, res) => {
  const url = new URL(req.url, `http://localhost:${PORT}`);

  // Regular static file serving - no proxying, external resources load directly
  let reqPath = url.pathname === '/' ? DEFAULT_FILE : url.pathname;
  // Strip leading slashes to ensure relative paths for WebContainer
  reqPath = reqPath.replace(/^\/+/, '');

  // If the request targets a conventional top-level static dir, resolve from project root
  // This ensures paths like "/public/*" work even when index.html is nested (e.g., src/index.html)
  const topDir = reqPath.split('/')[0];
  const treatAsRoot = ['public', 'assets', 'static', 'images', 'media'].includes(topDir);

  const filePath = BASE_DIR === '.' || treatAsRoot ? reqPath : path.join(BASE_DIR, reqPath);
  const extname = path.extname(filePath);
  const contentType = mimeTypes[extname] || 'application/octet-stream';

  console.log('[Server] Request:', req.url, '-> File:', filePath);

  const tryServeFile = (attemptPath, isRetry) => {
    fs.readFile(attemptPath, (error, content) => {
      if (error) {
        if (
          !isRetry &&
          (contentType.startsWith('image/') || contentType.startsWith('video/') || contentType.startsWith('audio/'))
        ) {
          const filename = path.basename(filePath);
          const roots = ['public', 'assets', 'images', 'media', 'static'];
          const fallbackPaths = [
            // Prefer project-root fallbacks first
            ...roots.map((dir) => path.join(dir, filename)),
            // Then try baseDir fallbacks (for nested setups)
            ...roots.map((dir) => (BASE_DIR === '.' ? path.join(dir, filename) : path.join(BASE_DIR, dir, filename))),
          ];

          const tryNext = (index) => {
            if (index >= fallbackPaths.length) {
              console.error('[Server] Error: File not found after fallback search:', filePath);
              res.writeHead(404, { 'Access-Control-Allow-Origin': '*' });
              res.end('File not found: ' + filePath);
              return;
            }

            fs.readFile(fallbackPaths[index], (err, data) => {
              if (!err) {
                console.log('[Server] Found file at fallback path:', fallbackPaths[index]);
                res.writeHead(200, {
                  'Content-Type': contentType,
                  'Access-Control-Allow-Origin': '*',
                  'Cross-Origin-Resource-Policy': 'cross-origin',
                });
                res.end(data);
              } else {
                tryNext(index + 1);
              }
            });
          };

          tryNext(0);
        } else {
          console.error('[Server] Error:', error.message);
          res.writeHead(404, { 'Access-Control-Allow-Origin': '*' });
          res.end('File not found: ' + attemptPath);
        }
      } else {
        const ct = contentType.toLowerCase();
        const isBinaryContent =
          ct.startsWith('image/') ||
          ct.startsWith('video/') ||
          ct.startsWith('audio/') ||
          ct === 'application/octet-stream';

        console.log(
          '[Server] Serving file:',
          attemptPath,
          'Type:',
          contentType,
          'Binary:',
          isBinaryContent,
          'Content type:',
          content.constructor.name,
          'Length:',
          content.length,
        );

        const contentStr = content.toString('utf-8');
        let bodyBuf;

        if (contentStr.startsWith('__BASE64__')) {
          // Decode base64 to binary Buffer
          const base64Data = contentStr.substring(10); // Remove __BASE64__ prefix
          console.log('[Server] Detected base64 marker, decoding...');
          bodyBuf = Buffer.from(base64Data, 'base64');
          console.log('[Server] Decoded from base64, buffer length:', bodyBuf.length);
        } else {
          // Regular content
          bodyBuf = Buffer.isBuffer(content) ? content : Buffer.from(content);
        }

        const headers = {
          'Content-Type': contentType,
          'Access-Control-Allow-Origin': '*',
          'Cross-Origin-Resource-Policy': 'cross-origin',
          'X-Content-Type-Options': 'nosniff',
          'Cache-Control': 'no-store',
          'Content-Length': String(bodyBuf.length),
        };

        res.writeHead(200, headers);

        if (isBinaryContent) {
          // Debug: log magic bytes for verification
          try {
            const head = Array.from(bodyBuf.slice(0, 8))
              .map((b) => b.toString(16).padStart(2, '0'))
              .join(' ');
            console.log('[Server] Binary head:', head);
          } catch {}
          res.end(bodyBuf);
        } else {
          res.end(bodyBuf.toString('utf-8'));
        }
      }
    });
  };

  tryServeFile(filePath, false);
});

server.listen(PORT, () => {
  console.log('[Server] Static server with proxy running on port ' + PORT);
});
</file>

<file path="packages/ui-frontend/app/types/actions.ts">
export type ActionType = 'file' | 'shell';

export interface BaseAction {
  content: string;
}

export interface FileAction extends BaseAction {
  type: 'file';
  filePath: string;
}

export interface ShellAction extends BaseAction {
  type: 'shell';
}

export type EitherwayAction = FileAction | ShellAction;

export type EitherwayActionData = EitherwayAction | BaseAction;
</file>

<file path="packages/ui-frontend/app/types/artifact.ts">
export interface EitherwayArtifactData {
  id: string;
  title: string;
}
</file>

<file path="packages/ui-frontend/app/types/terminal.ts">
export interface ITerminal {
  readonly cols?: number;
  readonly rows?: number;

  reset: () => void;
  write: (data: string) => void;
  onData: (cb: (data: string) => void) => void;
}
</file>

<file path="packages/ui-frontend/app/types/theme.ts">
export type Theme = 'dark' | 'light';
</file>

<file path="packages/ui-frontend/app/types/webcontainer.ts">
/**
 * Type definitions for WebContainer API
 */

import type { WebContainer } from '@webcontainer/api';

/**
 * WebContainer process returned by spawn()
 */
export interface WebContainerProcess {
  exit: Promise<number>;
  output: ReadableStream<string>;
  kill: () => void;
}

/**
 * Extended WebContainer with undocumented origin properties
 * (used for manual preview registration fallback)
 */
export interface ExtendedWebContainer extends WebContainer {
  origin?: string;
  serverOrigin?: string;
}
</file>

<file path="packages/ui-frontend/app/utils/buffer.ts">
export function bufferWatchEvents<T extends unknown[]>(timeInMs: number, cb: (events: T[]) => unknown) {
  let timeoutId: number | undefined;
  let events: T[] = [];

  // keep track of the processing of the previous batch so we can wait for it
  let processing: Promise<unknown> = Promise.resolve();

  const scheduleBufferTick = () => {
    timeoutId = self.setTimeout(async () => {
      // we wait until the previous batch is entirely processed so events are processed in order
      await processing;

      if (events.length > 0) {
        processing = Promise.resolve(cb(events));
      }

      timeoutId = undefined;
      events = [];
    }, timeInMs);
  };

  return (...args: T) => {
    events.push(args);

    if (!timeoutId) {
      scheduleBufferTick();
    }
  };
}
</file>

<file path="packages/ui-frontend/app/utils/classNames.ts">
/**
 * Copyright (c) 2018 Jed Watson.
 * Licensed under the MIT License (MIT), see:
 *
 * @link http://jedwatson.github.io/classnames
 */

type ClassNamesArg = undefined | string | Record<string, boolean> | ClassNamesArg[];

/**
 * A simple JavaScript utility for conditionally joining classNames together.
 *
 * @param args A series of classes or object with key that are class and values
 *   that are interpreted as boolean to decide whether or not the class
 *   should be included in the final class.
 */
export function classNames(...args: ClassNamesArg[]): string {
  let classes = '';

  for (const arg of args) {
    classes = appendClass(classes, parseValue(arg));
  }

  return classes;
}

function parseValue(arg: ClassNamesArg) {
  if (typeof arg === 'string' || typeof arg === 'number') {
    return arg;
  }

  if (typeof arg !== 'object') {
    return '';
  }

  if (Array.isArray(arg)) {
    return classNames(...arg);
  }

  let classes = '';

  for (const key in arg) {
    if (arg[key]) {
      classes = appendClass(classes, key);
    }
  }

  return classes;
}

function appendClass(value: string, newClass: string | undefined) {
  if (!newClass) {
    return value;
  }

  if (value) {
    return value + ' ' + newClass;
  }

  return value + newClass;
}
</file>

<file path="packages/ui-frontend/app/utils/debounce.ts">
export function debounce<Args extends any[]>(fn: (...args: Args) => void, delay = 100) {
  if (delay === 0) {
    return fn;
  }

  let timer: number | undefined;

  return function <U>(this: U, ...args: Args) {
    const context = this;

    clearTimeout(timer);

    timer = window.setTimeout(() => {
      fn.apply(context, args);
    }, delay);
  };
}
</file>

<file path="packages/ui-frontend/app/utils/diff.ts">
import { createTwoFilesPatch } from 'diff';
import type { FileMap } from '~/lib/stores/files';
import { MODIFICATIONS_TAG_NAME } from './constants';

export const modificationsRegex = new RegExp(
  `^<${MODIFICATIONS_TAG_NAME}>[\\s\\S]*?<\\/${MODIFICATIONS_TAG_NAME}>\\s+`,
  'g',
);

interface ModifiedFile {
  type: 'diff' | 'file';
  content: string;
}

type FileModifications = Record<string, ModifiedFile>;

export function computeFileModifications(files: FileMap, modifiedFiles: Map<string, string>) {
  const modifications: FileModifications = {};

  let hasModifiedFiles = false;

  for (const [filePath, originalContent] of modifiedFiles) {
    const file = files[filePath];

    if (file?.type !== 'file') {
      continue;
    }

    const unifiedDiff = diffFiles(filePath, originalContent, file.content);

    if (!unifiedDiff) {
      // files are identical
      continue;
    }

    hasModifiedFiles = true;

    if (unifiedDiff.length > file.content.length) {
      // if there are lots of changes we simply grab the current file content since it's smaller than the diff
      modifications[filePath] = { type: 'file', content: file.content };
    } else {
      // otherwise we use the diff since it's smaller
      modifications[filePath] = { type: 'diff', content: unifiedDiff };
    }
  }

  if (!hasModifiedFiles) {
    return undefined;
  }

  return modifications;
}

/**
 * Computes a diff in the unified format. The only difference is that the header is omitted
 * because it will always assume that you're comparing two versions of the same file and
 * it allows us to avoid the extra characters we send back to the llm.
 *
 * @see https://www.gnu.org/software/diffutils/manual/html_node/Unified-Format.html
 */
export function diffFiles(fileName: string, oldFileContent: string, newFileContent: string) {
  let unifiedDiff = createTwoFilesPatch(fileName, fileName, oldFileContent, newFileContent);

  const patchHeaderEnd = `--- ${fileName}\n+++ ${fileName}\n`;
  const headerEndIndex = unifiedDiff.indexOf(patchHeaderEnd);

  if (headerEndIndex >= 0) {
    unifiedDiff = unifiedDiff.slice(headerEndIndex + patchHeaderEnd.length);
  }

  if (unifiedDiff === '') {
    return undefined;
  }

  return unifiedDiff;
}

/**
 * Converts the unified diff to HTML.
 *
 * Example:
 *
 * ```html
 * <eitherway_file_modifications>
 * <diff path="/home/project/index.js">
 * - console.log('Hello, World!');
 * + console.log('Hello, eitherway!');
 * </diff>
 * </eitherway_file_modifications>
 * ```
 */
export function fileModificationsToHTML(modifications: FileModifications) {
  const entries = Object.entries(modifications);

  if (entries.length === 0) {
    return undefined;
  }

  const result: string[] = [`<${MODIFICATIONS_TAG_NAME}>`];

  for (const [filePath, { type, content }] of entries) {
    result.push(`<${type} path=${JSON.stringify(filePath)}>`, content, `</${type}>`);
  }

  result.push(`</${MODIFICATIONS_TAG_NAME}>`);

  return result.join('\n');
}
</file>

<file path="packages/ui-frontend/app/utils/easings.ts">
import { cubicBezier } from 'framer-motion';

export const cubicEasingFn = cubicBezier(0.4, 0, 0.2, 1);
</file>

<file path="packages/ui-frontend/app/utils/markdown.ts">
import rehypeRaw from 'rehype-raw';
import remarkGfm from 'remark-gfm';
import type { PluggableList, Plugin } from 'unified';
import rehypeSanitize, { defaultSchema, type Options as RehypeSanitizeOptions } from 'rehype-sanitize';
import { SKIP, visit } from 'unist-util-visit';
import type { UnistNode, UnistParent } from 'node_modules/unist-util-visit/lib';

export const allowedHTMLElements = [
  'a',
  'b',
  'blockquote',
  'br',
  'code',
  'dd',
  'del',
  'details',
  'div',
  'dl',
  'dt',
  'em',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'hr',
  'i',
  'ins',
  'kbd',
  'li',
  'ol',
  'p',
  'pre',
  'q',
  'rp',
  'rt',
  'ruby',
  's',
  'samp',
  'source',
  'span',
  'strike',
  'strong',
  'sub',
  'summary',
  'sup',
  'table',
  'tbody',
  'td',
  'tfoot',
  'th',
  'thead',
  'tr',
  'ul',
  'var',
];

const rehypeSanitizeOptions: RehypeSanitizeOptions = {
  ...defaultSchema,
  tagNames: allowedHTMLElements,
  attributes: {
    ...defaultSchema.attributes,
    div: [...(defaultSchema.attributes?.div ?? []), 'data*', ['className', '__eitherwayArtifact__']],
  },
  strip: [],
};

export function remarkPlugins(limitedMarkdown: boolean) {
  const plugins: PluggableList = [remarkGfm];

  if (limitedMarkdown) {
    plugins.unshift(limitedMarkdownPlugin);
  }

  return plugins;
}

export function rehypePlugins(html: boolean) {
  const plugins: PluggableList = [];

  if (html) {
    plugins.push(rehypeRaw, [rehypeSanitize, rehypeSanitizeOptions]);
  }

  return plugins;
}

const limitedMarkdownPlugin: Plugin = () => {
  return (tree, file) => {
    const contents = file.toString();

    visit(tree, (node: UnistNode, index, parent: UnistParent) => {
      if (
        index == null ||
        ['paragraph', 'text', 'inlineCode', 'code', 'strong', 'emphasis'].includes(node.type) ||
        !node.position
      ) {
        return true;
      }

      let value = contents.slice(node.position.start.offset, node.position.end.offset);

      if (node.type === 'heading') {
        value = `\n${value}`;
      }

      parent.children[index] = {
        type: 'text',
        value,
      } as any;

      return [SKIP, index] as const;
    });
  };
};
</file>

<file path="packages/ui-frontend/app/utils/mobile.ts">
export function isMobile() {
  // we use sm: as the breakpoint for mobile. It's currently set to 640px
  return globalThis.innerWidth < 640;
}
</file>

<file path="packages/ui-frontend/app/utils/promises.ts">
export function withResolvers<T>(): PromiseWithResolvers<T> {
  if (typeof Promise.withResolvers === 'function') {
    return Promise.withResolvers();
  }

  let resolve!: (value: T | PromiseLike<T>) => void;
  let reject!: (reason?: any) => void;

  const promise = new Promise<T>((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });

  return {
    resolve,
    reject,
    promise,
  };
}
</file>

<file path="packages/ui-frontend/app/utils/react.ts">
import { memo } from 'react';

export const genericMemo: <T extends keyof JSX.IntrinsicElements | React.JSXElementConstructor<any>>(
  component: T,
  propsAreEqual?: (prevProps: React.ComponentProps<T>, nextProps: React.ComponentProps<T>) => boolean,
) => T & { displayName?: string } = memo;
</file>

<file path="packages/ui-frontend/app/utils/shell.ts">
import type { WebContainer } from '@webcontainer/api';
import type { ITerminal } from '~/types/terminal';
import { withResolvers } from './promises';

export async function newShellProcess(webcontainer: WebContainer, terminal: ITerminal) {
  const args: string[] = [];

  // we spawn a JSH process with a fallback cols and rows in case the process is not attached yet to a visible terminal
  const process = await webcontainer.spawn('/bin/jsh', ['--osc', ...args], {
    terminal: {
      cols: terminal.cols ?? 80,
      rows: terminal.rows ?? 15,
    },
  });

  const input = process.input.getWriter();
  const output = process.output;

  const jshReady = withResolvers<void>();

  let isInteractive = false;

  output.pipeTo(
    new WritableStream({
      write(data) {
        if (!isInteractive) {
          const [, osc] = data.match(/\x1b\]654;([^\x07]+)\x07/) || [];

          if (osc === 'interactive') {
            // wait until we see the interactive OSC
            isInteractive = true;

            jshReady.resolve();
          }
        }

        terminal.write(data);
      },
    }),
  );

  terminal.onData((data) => {
    if (isInteractive) {
      input.write(data);
    }
  });

  await jshReady.promise;

  return process;
}
</file>

<file path="packages/ui-frontend/app/utils/stripIndent.ts">
export function stripIndents(value: string): string;
export function stripIndents(strings: TemplateStringsArray, ...values: any[]): string;
export function stripIndents(arg0: string | TemplateStringsArray, ...values: any[]) {
  if (typeof arg0 !== 'string') {
    const processedString = arg0.reduce((acc, curr, i) => {
      acc += curr + (values[i] ?? '');
      return acc;
    }, '');

    return _stripIndents(processedString);
  }

  return _stripIndents(arg0);
}

function _stripIndents(value: string) {
  return value
    .split('\n')
    .map((line) => line.trim())
    .join('\n')
    .trimStart()
    .replace(/[\r\n]$/, '');
}
</file>

<file path="packages/ui-frontend/app/utils/terminal.ts">
const reset = '\x1b[0m';

export const escapeCodes = {
  reset,
  clear: '\x1b[g',
  red: '\x1b[1;31m',
};

export const coloredText = {
  red: (text: string) => `${escapeCodes.red}${text}${reset}`,
};
</file>

<file path="packages/ui-frontend/app/utils/unreachable.ts">
export function unreachable(message: string): never {
  throw new Error(`Unreachable: ${message}`);
}
</file>

<file path="packages/ui-frontend/app/entry.client.tsx">
import { RemixBrowser } from '@remix-run/react';
import { startTransition } from 'react';
import { hydrateRoot } from 'react-dom/client';

startTransition(() => {
  hydrateRoot(document.getElementById('root')!, <RemixBrowser />);
});
</file>

<file path="packages/ui-frontend/app/entry.server.tsx">
import type { AppLoadContext, EntryContext } from '@remix-run/node';
import { RemixServer } from '@remix-run/react';
import { renderToString } from 'react-dom/server';
import { renderHeadToString } from 'remix-island';
import { Head } from './root';
import { themeStore } from '~/lib/stores/theme';

export default async function handleRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext,
  _loadContext: AppLoadContext,
) {
  const html = renderToString(<RemixServer context={remixContext as any} url={request.url} />);

  const head = renderHeadToString({ request, remixContext, Head });

  const body = `<!DOCTYPE html><html lang="en" data-theme="${themeStore.get()}"><head>${head}</head><body><div id="root" class="w-full h-full">${html}</div></body></html>`;

  responseHeaders.set('Content-Type', 'text/html');

  //     WASM   SharedArrayBuffer
  const url = new URL(request.url);

  if (url.pathname.endsWith('.wasm') || url.pathname.includes('action-runner')) {
    responseHeaders.set('Cross-Origin-Opener-Policy', 'same-origin');
    responseHeaders.set('Cross-Origin-Embedder-Policy', 'require-corp');
  }

  return new Response(body, {
    headers: responseHeaders,
    status: responseStatusCode,
  });
}
</file>

<file path="packages/ui-frontend/cloudflare/src/worker.ts">
interface ExecutionContext {
  waitUntil(promise: Promise<any>): void;
  passThroughOnException(): void;
}

export default {
  async fetch(req: Request, env: Record<string, string>, ctx: ExecutionContext): Promise<Response> {
    const url = new URL(req.url);
    const ua = req.headers.get('user-agent') || '';
    const isSafari = /Safari\//.test(ua) && !/Chrome\//.test(ua) && !/Chromium\//.test(ua);
    const isMobile = /iPhone|iPad|iPod|Android/i.test(ua);
    const isAsset =
      url.pathname.startsWith('/build/client/') ||
      url.pathname.startsWith('/assets/') ||
      /\.(css|js|mjs|wasm|png|jpg|jpeg|gif|svg|ico|webp|avif|woff2?)$/i.test(url.pathname);
    const isApi = url.pathname.startsWith('/api');
    const host = url.hostname;
    const isPreviewHost = host.startsWith('preview.') || host.startsWith('dev-preview.');

    const upstreamHeaders = new Headers(req.headers);

    if (isApi) {
      upstreamHeaders.set('Accept-Encoding', 'identity');
      upstreamHeaders.set('Cache-Control', 'no-cache, no-transform');
    }

    const fetchInit: RequestInit = { method: req.method, headers: upstreamHeaders, body: req.body };

    if (isAsset) {
      (fetchInit as any).cf = { cacheTtl: 31536000, cacheEverything: true };
    } else if (isApi) {
      (fetchInit as any).cf = { cacheTtl: 0, cacheEverything: false, minify: { javascript: false } } as any;
    }

    const upstream = await fetch(req.url, fetchInit as any);
    const resHeaders = new Headers(upstream.headers);

    //     WASM   SharedArrayBuffer
    if (url.pathname.endsWith('.wasm') || url.pathname.includes('action-runner')) {
      resHeaders.set('Cross-Origin-Opener-Policy', 'same-origin');
      resHeaders.set('Cross-Origin-Embedder-Policy', 'require-corp');
    }

    if (isAsset) {
      resHeaders.set('Cache-Control', 'public, max-age=31536000, immutable');
    } else if (isApi) {
      resHeaders.set('Cache-Control', 'no-cache, no-transform');
      resHeaders.set('Vary', 'Accept');

      const ct = resHeaders.get('Content-Type') || '';

      if (ct.includes('event-stream')) {
        resHeaders.set('X-Accel-Buffering', 'no');
      }
    } else {
      resHeaders.set('Cache-Control', 'no-cache');
    }

    return new Response(upstream.body, { status: upstream.status, headers: resHeaders });
  },
};
</file>

<file path="packages/ui-frontend/cloudflare/wrangler.toml">
name = "eitherway-proxy"
main = "src/worker.ts"
compatibility_date = "2024-11-01"
account_id = "18a6d34511186eed9ebc4a93a46a1f7f"

routes = [
  { pattern = "eitherway.ai/*", zone_id = "9f95dbfa3ac569902533b7a38a5a319b" },
  { pattern = "preview.eitherway.ai/*", zone_id = "9f95dbfa3ac569902533b7a38a5a319b" }
]
</file>

<file path="packages/ui-frontend/public/icons/block1/bgauth.svg">
<svg width="485" height="652" viewBox="0 0 485 652" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<path d="M0 16C0 7.16345 7.16344 0 16 0H469C477.837 0 485 7.16344 485 16V636C485 644.837 477.837 652 469 652H16C7.16344 652 0 644.837 0 636V16Z" fill="white" fill-opacity="0.05"/>
<path d="M16 0.5H469C477.56 0.5 484.5 7.43959 484.5 16V636C484.5 644.56 477.56 651.5 469 651.5H16C7.43959 651.5 0.5 644.56 0.5 636V16C0.500004 7.43959 7.43959 0.5 16 0.5Z" stroke="white" stroke-opacity="0.15"/>
<rect x="82.5" width="320" height="320" fill="url(#pattern0_215_464)"/>
<rect x="82.5" y="332" width="320" height="320" fill="url(#pattern1_215_464)"/>
<defs>
<pattern id="pattern0_215_464" patternContentUnits="objectBoundingBox" width="1" height="1">
<use xlink:href="#image0_215_464" transform="scale(0.0014881)"/>
</pattern>
<pattern id="pattern1_215_464" patternContentUnits="objectBoundingBox" width="1" height="1">
<use xlink:href="#image1_215_464" transform="scale(0.00132275)"/>
</pattern>
<image id="image0_215_464" width="672" height="672" preserveAspectRatio="none" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAqAAAAKgCAYAAABEPM/FAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAJgbSURBVHgB7b0JvH1ZVd+5zquiihqoAqoKFYqyAGUWhyiTOIHGCXBoFdOftGI60URjBpMYh5iEjsZW0/an1cTWTjSa7kSNqBExEXDACREVQaHAialAqCooqAmqKOr1We/u/X/rrrf2Pvvce8695/3f9/v5nHvPuPc+++zhd9YejggAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATEYnAKeIw8PDA1lPt3n90GwfrXdd9yEBAACAxXGhAJwuLpb1dKtisyts3y4AAACwOBCgcNroCut2H5Z9AACABYMAhdNKbmq3/wAAAHAKOBCA04W1cHZy0uJp+4ICAADAAkGAwmmkK/zndcQnAADAghlsgj88PNTK/NLCYT8C+bDrursENN7u3/9dUDh8bqR24gOM2B5NFppYPAEAAE4ZLX1Au3SeFZvFfne98LqnF1P3yhkmTRV0ceUU+i9ORzQCnjgFAABYMK1N8L7fnf23aMV/fwGNg66yiNTjEcpE/T4zB+YcAAAAWChjBGj+7yrH1b0LewvgmR1dn+79Ire7q2wjlsZTEvaH7jgAAAAskE0HIQ1Z9C6Vs8tlsh431io3NIIbhukGjhGfAAAAC2eMAC1Z8SIRekFvCbxIzhj9PWu/Tx14VJoWKBKg9FccT/QCBAAAAKeEVgFqrXj2W9y+KTmLqSMraBqMc5a4xKzXRJIf0AXtlOIrp0uEKQAAwMJpFYiHwT4vPn2lPzQS/LwiWT9tfA71mxVBJG2Kj1uNdy/miVsAAICFsskgJP9fEqK6XHKGrKDa7zWKD7teWmA8NVFPnAIAACyYMeLQNnFahvqGnvdW0DTpvI3LyBJq1xGfm9MV9vk4J24BAAAWSosAjQYZ2aZPu+3PUy47n62g/b3poCPt+1mKI9t9YagrA7RRSmsITwAAgFPAWGF4WNiuWUGV83laJrXw5nlPS9bOA/PvRTuMJ+oCQlwCAACcEjadiD7qw1jbviRZCs8r0j1dljZLoshbQWEabNyW+toCAADAAtmkD2hmbNPnA+T8I1t2h0SPP1Zah2F8fJWmBQMAAICF0vrJzFyxD01147ft+Rf1FsP7dV33QTkPMH0/z+2S+v2X9jEX6DismD+U9blnLVidAQAAFsrYPqBjz/fC4HI5f7jMrNt+nlZQlkZsS+U4tBNZP2mCBwAAWDhjLKB+wFGr5c6edz/9RGdvBb1HTjGB9fPcIVmfFN3/53PEbO90hoA0I0EeOHVB+s8C+txp/XJfv3worevz+uCCrNdD3RnOrFVZWxn6P10ukOPnK2ndos9X4yk/43v7RZ/vvf1z/pDAOdJnhS80i+YVH58fSkuOxw/tMr+kMuniEWE8WpbeIpXKq5ym87qfhSWT07Km7XvT9r2nvb4BOF9pFaDKpv3svEBQK+h75HRzRWF/aSBS/j+sbM9GKsS1v6oW3hc1+JtH6+cK7OLkjhboWmHd0SJSUsWd48q+xEiw767ezbtkM0pif1ZSpX+lrM9scFgJn0UrxvfK9mFQv3UeWn1GuXIu+WnDk8N8gT+3d1Mrb620P7BkgZK+Ppb7lvuXZHvvun17fy8fkEZMnskfmJCC25ks+C/K56V4vFtWaXtyUZ/CeElavNj0L2OHJozn0knK07OFcRNSuXFxWux9DeWvC81x+xxUkB6lZ/3v7/M+AYC9M0aAKlGhFln4auvaF/SSvhB4v5xCNOxycnL9Wl9P+5/ZVMyPIgkkFfz5M6G2v2Q0hZYPsz+WrSs6q4E+vxYheoGULZN2e5PuHWO2JyXF7YNldX+lNL92iRyHS0XdbbKd/1rBqji6SOJnJQNhivJvvk6fsYqUy5KIunOh+dVb+Ur35OOniMkz95dy/JXyut+XWxkuG5FfWsJoxXHO1+LCa8MaxYV91hemMOoL4J37EKJGTGu830+GXyRb839ulcovad2UzwIANmfsICRfiHWFc6NC3/cFPZUCVOJ+rF1lnxVYJYvUpKTCXMN56UCYpOF46dwj8dP79d4BK1lJ+ETHWhgSE7PHsxGf2eLSEl95v1pi3rupFSYJz/xSUbL4+TiohWko7CoGruz9VT/vWKAQjcomv79JgPb3qP26L5e6mKnl9VK4FM0vF/d+3LGFpT8KY0t4usK/R8N4/94PFaF3yg4IxPTRbjn5XMVs1/Bp37qZj6nQvTQJboQowJ4YawFVWt9Ka9bSC7RC6zP+HXKK6MOshWSOsyGrVyQOStbGKcOob/q2WTj75f2PwhVZKA8L1ygaF1cnETokTLqK/yLtYtRacIb+J6e/V73nB8l63imF3cenNnO+TzbzN79U+MFvJTEfxYEXaRJcW3reKrofmJq9b19QpZ3DGLXGWIrpIcWtPtOLzLlDwm6T/H/UZUPTUB9/oyzgKYza3eBSaX/picIiQbjsfWgYr9CXrLFhHEt6mbpS1ruBdC48nlq9MpT/fbwdtWZt+1IAAJsx1gLaejwqHP3/UZPPKeuPky0PvikrsroNVRBD1ohRuApKpCxOhkTLOSdl+L4yKky6oBC31qeSVaJW2dToGv8nwzW7+3BETCU+VfTll4qScG8VltvkZUUrbbV8v3sBIjR61iUhHt53eqZXybhnum3+P/o8cWsf4JS3NYxR07TPz0Mvvq35/9IxYRyDKavsJ4y9/3m79CzG5v9SGax14AOT4L5dAGBnjP0SUl6PCgbd/lBwTSdxIWO/IrR4nPXT3pO/z7x9j9TjoBSPm4RNw6XCyMdnJ7FfLesHgTs1Nx+QRmCHQZST93oo5fhpoRb/k8SrJd3bNXI8a0DrotyxhfjUijqLXtuPV5w/B1J+ptG+WvxEadVuaxxcU3neu2QorEUK4jNyfygu7b7I/2i/CrwHyQBJrF0tJ8VnFIZS2DvZLP9rGB8oE5LKKo3zS6Ucfrs/KjtE2vJ/qTzw16ofD5j6XgGgzpiBH6VCwH7f/Gi6HokLFl9Baqa/LBWwiyYVmmO+5KTN0VmAlirITZqfS2FTgXK/wI8hfNhsU2bpHJGT1p48GOTBwfPsCv74tNNKqfKfjSS0rFBp9U/v845NLSu9v2r1fIC037OP64Ngf5Qeh0RKye2rFiRCo/u2x9cwwq72QlF1oyE8Q/n/ktSns8ZVsv7iK3IyLIcFP4Zoyf+XNoSxCZOP7NRvPo22pO+x+b+Tuvt5vemlAACmYRMBGr092rfUWwvni5ysJHQ5DVZQbSrKhaYnqrRvd8ej8w5kXGVxAmNNsHPj+bBFfpfCncPlr5fCuXnJz18FWk2oR4X/2KZ3GwYphGsyUqWpQsXP72r9lsL2nVuIT7XG5C4fpWdVEiKl51YKa8l9GdivcfLglA73jU+PVthEaDq9oHB9bSn5K4Vzh/L/FaX4Sy8gF1Xcy5TKkpLftXBH+f8B2z5jk4/srBhHh5x/PpwHsln6tMdq+dVfd0mKdwCYmU37gJYqNdF+YTqKUtZHi3eV9ct1Woz+untlgaSC195LaZR1vq+7UhxEx6bGDoaJKpb7JH5Wdl27Tai1Nk/cfJiuU3Kzb5478OLgeu+3Pk+dP/JuF56hSqAVW6lYf/321jjxGYXBr9vt2zcdxJGa3aMXs25gn42DPGfrPWk9f1jAioz8TPNUPFJwq/a8j/rQ9cstsh98eoiezVr4U3ca259b3HpEzh/2vPtJW5qrHdNncSL+zGj3yJ1SnrZhPHJG4pfToXV7j1kAbvyMzYtyZPDw5UP201ti8+TyuZUtp+k8cCpfp4K9paySQljUPS3D7h4zbywAjGfbb8GXLEJq9cnTakTH7XbukH6rLBMNW81S7OPmNrffr5euH0WykEXzkdr/qHBXtPDWAUN3jRH+Zq4+O//kidNkNfn8zSYMpXRiw9saD6V7i0b9b4yz2JQGS5VEyzbiU+Ou9KGDUrcNu1/zXutz1ZeEO5K/mpb0uV4mJwfWDOV/HUl82a6m7nHY9BUJKHteFkNXSJwe7X2q0DnqSlP7ko75Us/RNEuyPkuGOHdL4df4uzi/tJkuP1EYz3ltwnh3bSq0IIwnPj5Q2Lbxcn8bxlZcV4eh/B/lJb1HTaN3Vwas2rT+fuOvzghyhZTruej+cznyoN6NdzFpPcB8bDsRffQmrlbQ+5IV9IrouJwUZ3lE/KjCbW5SReC/hCJSFiO3uZHBUcW9keB04YqsI5HbtnJWNGzv23Qux1QY63O90zX/ez8vdn1BowreW2WagyHD4n6rOE5TWWm/2ugLR0MWlVs3FWJGHJ04JHWBddTXVFb9TTeqMFPeu7sPgwpnbYL0I5RF6vn/ytSSsY8Ku5QGfPpXVNhdWLlOX8xu7xq/AJXuN8ddHliZBW5mKP8fCbzkjsi6aIrO1/R1x4ZhzGXaFTKcli1HfVblOIyt6Iuyv5ehgUWKCs/bNq0T0j0fvWQni/eVsi6CvX8+fEfTUfXL5LMAAMCKlj6gQwVFqWDVCvGw4Zq8XrL67JOokBY5DrddslVx6LwovpoFk7PgWD8ify36PG6aaiJxtbD1y7v6VR3dHVmSLg/CktftgLSNgyAn41QK+5pJ4v4aiWcBGOofu7H4TFwtcTrx8WUFjVbQ+lxvm0L86QtUv+inclWI3ift+X+o/++clNKC2O2Udy5z+308vqfb8POjKe403jRf3Cfj8v/RgEz30uvP1zCqVe7WLcJ4bwrjTVLvtlAMozSShN9l0p7/dZ/Gm84rfPNUBok0PZze713GHwnWM/keL19I/2aA85JNByHVCtPVjlVleJvEAsRfc2QBSM2Ai8BUVqV7Frd+m2v2zNaXNWfdsa5wXg1vwfFN0lEFrGHb+Os7NdIgG61wP2T8U0r916J90bGqt4V9Y91ZI4nPBzv3fBijNKDxevM24jM1vUcjykvdKpQ7UkU9ef/p9Fy10r7X+VvL/5cf7n5WizFp4QqJw50FT7GpfVSAVuJQ+0v6/FbK/4oK+Euk/NJ7awrjRsIzCKPe680mjNE0XjaMWThe0uJ+Kj/tYJ6h/K+LliG3zPGBkvRy8G5Z7yLl/Y/2nZqpAgFOG2MFqN+OKufjE1aV2L2l4wFLmoctW2RbRlB+qCA+SiM4/fVNBAOiomfgua2b+YsmSQBpZWYrLK1Q/cwBPoy+gmvyrrI9Ok7PBeSk+Iz+JfBL72Era42rrH36OHD/maOXCpmR9Fy10o766EZpL/fn3hXdwH5//P5mf352N80keI6akKU9/x+9hMtxGDM5fc0ZxuyPx6e5HMYW8gtVa/7XtHbTVC8BJVJZeKcJTylv5/99vFQBnAnGTEQfVe4tfRtvDY53heXi1P9uryRLrAq9oSlAMkOTjEdxVCuYS1wp5Tf1LnDz9k0nQB+LEaHWf/tVpvzvLSqt977mncTpyZ/TRPrO+VUSi6pSuj26VKapNL1lrkQ+57YdPlcvpGr5X5ddN8PXBJ3dr+WKfSFSy99Nc/Y7Ty/gH5D2/H+ZC+PhjsJ4t8TlsQ1f3h5spSq8KIuU839uQdjVTCj64ub76pfSz6n6YArAaWKTNzs7UjDKsGukqSxsAVqrZPXYg2X/XJ3+I8uP5ejNfaDp1VqHosK9Cdd/zbudrTli3P/Q3BYyT6oo7byXtkk5uufR8SD1SjL6r5LE54ODayJBa61EWlm+c1vxWfjIQVcJw727Ep/nPF1ZjfKUNEP5/2APL5G++dj+5/U8qCrvn93alsh9rsfmfz1nV2FsmW4oh7ulT+SVhetL+27dofjM3cPeEx0qrDd1OwCAcYyxgDbPsxfwPim/YfvtC6f68sYmJL+tFaKrLMp7Ck5FlbO47dbKSLl/4H9kgc7H9jWtlR2UZOcg9GmolKbG4N0amnx8jTSV1VWBmyV/sohQ68lNE1WaKj6jUeVR+juyiMl+sHk4U0rfu6qwo/BEVlklzxWpx9+7I2Gn3CnD+T/Kw7sM4x0yXM6d++BIbWBOaq62LR9D+f/Obg/TdxnDSOnZWC6hGR5gejbpAxpV8r6wWr9wXGbPX1fZV4Z/oAtLRL7XO7v6ZMXhXITG7THCKxpNGlVcksJ1l+yBZF1QK2j0iT2fdiLL1aAXlf3NgjZ97cT2u7Rz1h6IFKcaU9H5rgktNnm+XBuOjI+v9+3SUmRJ6fxeGc7/zQNVJsQ+p6jfov2/a+4+0ZaUHz7gwqCUwqn779xDGKPyWUyYbBzXrKA5Pbfkf2Wn1nyH7Qs6lP8vFQCYlE36gNb21bilcF1Uyec52HZKao69n5TFnb/XoSbuqNktisehcGmBr5W6nxA9cleXyQcsjEQrT/tFFuWcBUWmIbrvpnhNls8HFa47KLiv6D1NJj5TU/X9nH8lEZ3nYN0ndgqvWv6/3x5fIKPZAtYsi7J7Pij1/O+tgvsI4z1BeETifFYj952PPlrg9921rxeq7L+05/+LBAAmZdNR8F1hX7FwSgXNbXIyY0dTkyhX7KESaxmFn8N3xw4Lz4uc37X1e7s9f0LOTAK9tlviik0Z+5yjSkKC9RMk8dn6nK1bWkG/c+JnfmnB32h7CZ+r9ZY8H+/5ueRPIu6CaL5Wv565Y09x2OKntdAuJYzRc1ZqFtDc/zf6fK1/Pnud5D2VU6VuDj79LGaKQIDzhTEW0PxfExJD81lqgXOfnBQfkZtqBb1SdkQSJheKFK2Kfrul8Owqbvj1GvcvXCtyUgTsrOluANv3LRJVPl5asS8q1mooMhCvgeUzCkvkxhziU7m44H/0jPdt1VY0Hobyf97el8XIP/uxeXYObJk3VL7s6+XxPik/V6nsP0ey6Of8KQNufWABL1RKtk4PldP3EwCYlLGWp5qQiI6vn3w8OX3Jf3/9Tqyg7tvLNix+O9MyajOKk03v5WI5aemx/3Z9r9bPTLLCRhVvqRm+kxHOB9vV6/tnrMLzQe76rsF9raDe2c3zicnaaHEbxr1btY8CcjLN1/L/LitsHw6Rk2G6cwGC57QMZMlxVuqnWuLi4LxS/t93d5JMNMVVVA9cwEAkgGlp/cyYf6v1ImKMeNBO52rZzP2EatfrOTol0twjfzU8ta/Q2IJHBUlr4WkL3+heW+PtYon7VPlncd8OR862oGHxA1JKcTGGKA6L/UuT+HygjI97nUf1ZpmBPkwXSfw8/bqiUxs9VOIWhk6GWx7yedav0vVD7rXm/119wrAbOJbvZba5NEeyabm5K1peDkvhvv/A8XxMn8kVqc/9GGz+2ASbdv1MHSVs31VN00sqXwFONWMqiVrBGVVKsSO9JakveHSKoKsrp9kmVv0SxcbfPh7CfIWm9LUXz3s3CEtLoR6S3rptn8dS85b+L6WSzWhhbfs51r4qtS02DZ6LJ2f59OfW3JlNfCbu5/yr5a8L5HgaIXHntVbG0bljrvfXDbmzC2tRScD7c3SZw4LdSg6D37ckojCKjAtnNLNH9OKj+y5252wqKsW5v5b/C7Tkf7ud0TyLAAWYiLECtGQpaRKf5y7suvf1wkCbvH3Hbm9xzNvX9Ms7ZB5sn8CogrZhuzd9OaQF72YUP74vY8TF0mDlS3xIloUPz1RC0/5Hx/J8hWr1tB828HNEliqh96XvRs+Jn2vWMvScvfU7ypdDYqIlXbb4Y8+37KoPaA5HJHhHlUsz0xLP+yYqr0ppIWLIAjp0j9ZPKfhXS7dD5WRr/o/cUy4QAJiMVitFNKdbtD2GqILv5GTTvC46EfDkcwsm6+cVzv/SPen2mMndfSEqgXubVjqla5fQqd/iP3c3ZJVopSts+3+dNui+geuiZ74La9kFJgzi1kuVZ+k8H/5a3+qhPBtV3nPk/ykp+X/QcM6+8PG4FIbmUa2F9QKpi8+h/N8V1kvnicRhq4UhcquUrqWwDQAT0CpAS5VflHGb6C1MKg7eX/ArqkAfJNPzYInDHxXAY6yfIicFwaaFmJ+YvKv4tc9mxogsiHPlExXsY4kqDW+hO9qfPg36Dud3SUDZ/Velpvs5KU0f5LeH0tDYijP3aROJn8VB4N6Y/L+PyrqTYTExZO2am1q8bFSGzoS3EkZxevKi4wE6UVrcJP8PHRvM/zJ8H7X9rWEBgA3ZZCJ6m1F9YTWWW6WtcFAundIK2rulTdve+ikSF6AaT5sOhPIFbnSPNS6QuHDMcW8L/qUJUKVUIQ1WaiPd9n6sdqxEqO3LWWvCs/uvSk34c1F7mRjaF8XdUKXZSXnKM2lYH5v/t3muYxg7ldw+qeX/bfPCFPjyxFNrfr/AuePXh/K/Pxa9NLZYZ4fSYWv+j8K3q4F1AGeClsK7VlFFnyxrJllBW76VnLlKpuOawC/vZ/5/XwrrWIYK1U3cK/XRWiK1OI3OG+tmtP/EdrJc5y9xeRHWVdy9phehc32Rq1QZ2zB5q+dQWi3FrT/mzzsYCIdIW/7fNF1vSvTMh+5jH7Tk/6VZaGtxW3MjOrcl/7fkxzEvPKXzxuR/f3xpXZwATjWbTERfGoW9KbVPdGZyoXHJFIIguXGJxPclZl/+H9P3M7q+Vmi2xF9UKC6lcq1RGt0dNfOOuY9aJRG61YtQnYT8PTLsnnfz6mQtn5raPUcvFT6tRvFq3S1VrmPjvZPx+X/XadLfx77FXIlSOltaXo5eLFpfdLvKdi3/iww3oZfc7CrXRftbwmzDZNM9AEzE2CaFqBDYaiSnTmnUV/AqDB5s3K2NvNSm0Tu2nBj8KikXer6guW3DKaCiQUile6rxoSBsXcG/pX2to9TMrExVqJfiIhKh7+nTjq5e7c61bvl0rU2L1/bX3Zia86fig8ZP65/dl/fXvm41R+UYpdmx1+6qO0gUPv9ivRTxUMv/S7WA5rBWjRWpHPf3VSrjNO3fJePDt0k63PT6iFmmAgQ4q4yZiN6v+6b30eLToBZGHfQRdWS3/4qKLBWrt8gGJOtnFmo1S1PmPbIZpbgZG1+52WdIsOqxpfVRiqbi2bbfcMt1xeNJhGq4rhg414ZR0+VDkwidqhKynz6sVdq6/p655sE9D/BxWJpxYp+UrHL+nCXRFdZraJq+QE5+1tOiz0e/d/8uAYAzzSYd+G0zij+20RtmsmbeWvHT88AtPot2dYMfef+7t6z4S1aF6LwS9wXnlCqvfX1/u4T9ykg3sLRSu66p0uyf6TtlZVXsgvBF7h2ke1FL6FRW5vxcfVNnNAPEHF0Azge8aK+N7l8CQy+QS6Alb5XIabo02C0vlwkAnHnGiDhfmPj/sULCowL0XikXWna/vmU/WEbSi4f8yc0hMXSYwnKbTEPtnuoXHgvgWoGet+8vyyL6NrRlqiZ4+9xa06HOavAB40bknrh/FfgPn+ib0B+Qcli9GL1UoIbPE1O2zkxFLf9PUX5OjX8xEhkO591STs+W+/FddQAYK0Cj9by9VQGarKDvluECLPvzoDGFWLJcXV1wN7qfW2a0fnaFc0p8SOIw+vUL+vtcklhRQVxKK0qtj2iNKD34/XUHVuntRolHttbSxVQitCVtZYGOBbRMlM+6wvo+Gcr/Y16e5qIUX61h0jQ9NEgt+8FLFcAZZ5NR8LO9tesnOmXVOb3FSqBhv0baUevnhVIOt92nk85PYf0s3YPIuIrxrsI1kXuLKNiTELZf+4mEgrjjLXSFazqJ003Zoa5TYf9WWbe81+I4V646g8KHyRYkAez9jcKv6fwyLEZF/CBCvy7Snrbmppa+liCQozCNKa90qrr8Ulma0D7zAAGAM83YSq0b2J6C1sFFGvYHtfTJS+dcI/Egp6iA3WiAU+S11IVWa/zdXXHD7tNldNeEmbjSbefwTSmkanHb5sDKyq0i9IMNbtt9V/bpaisR2nOHc/9E8ORYYC3luS6JkkgSt71vcZdZqjBWWrrDDIX3TinP1OHz/wN4qQI424z9EtLQ/IRb0wsCtfZFVtCSWGyxgkYDj7rCvnuTJXYKahXjmHi7XeLKKxIuS2mG1zCUwlh7pi349NgSL2XHjkXofVIWCZE158F9XI+xwnvyc5XA7S7wa+8VtoZBX+gall2FtfZ87P4l4cMX5YddUwpPtC8MY7Lq3yXlZ2H90taRKT8ssjGN6XlpU9wBnHrGTttjJyhu2b8paoG8XNqmVFFLlH6p6M7IoTTlzgML7lgBk/36S5mGbmB7aP/xCas59rS59kJpi2MVRW+RPZE+Yanx7gViNFp5m3ST050E7o0a4JTiWEXoR0r5c4Rd4JdOVK/X3yzjUcv2fbLebGn9sfeQK+xN/JkSjR8/2C2Kb83Duwpr5L9PC/sUojVhOTqtzkjXuK+GWvUvN9dGU4yds+r3eefdW87pvBW9/9oV4FpZv8/S87hBAGAyNhmEVHobnqyAT1bQ90q7dahmhbpa6mG260UhuwUtloSWuHuvlMPt17XP4F6abJPl65oUjjzV0dEhOfk88/+YtNMVrt9aaPTPXkemv0vqcRuF95o0w8JY/7QPqrW2R2LdLg/epyWm91unz7lEpMlKNnai8U2Jygh/bOM0MTGl/C8yPh/MSTew1HifcWNoflt9qXqI7Jcr5eQ9Rfl/V+kZ4MywyTygebsbOGdb1HpyX6Nfl6bKcQ1j/SxVRN7tqS02voLehtvT/4FzP1pXHpLuf9eolS5PdWUL7ZJYERkvQKO5Mu2/X293fPXJzndKOZ59OPKxh0VpsAHfDF/zUyvsh8n+yH1eW/LkB2S3WP/97ApLEHZdw7F9h3Pr8iq9VNW6DNn1/FK1l3lBk7/Ri6MvY3R7yq+gAYBsNxG9XZ+8AE398t4jbVYDXSIr6EOlHEYf1vfN+LWZqOCN7qfswMo6d1fgpvcnL/psr5UdkpqzHpL81xGxH5T4mZ27RDb0SsoidlS8RujXkmQ1T6h3U+Rk+O0xnZ5p1FysyeLe0uc5L5du2e90I3o/9cXCT6tVivvbkxCZm5a8tHE6mJCW/L8U8VlKd9F2ifdUzo/y/8N2/bLc+2df5mr1S/6/XQBgUradiN7vn7ovk84L+iHnV2mU5eX2TTqtX+aulcK1Gg83ybT4Qs1+HeRcMGUcNxu3peJu3r6kj4ediNBUgVi//CdMbfgOzH+pv2WNbuT+0aQ+nTfLsODK/3ofWqldt0FlWrO8d8G2Wrd31nTZ+6XN7h8uw/k/s6vK2vf/tf+19X1Qy/9LCWdX2W4OV3qpur3ils//2mJy/Y5F6EfI8SeZa2i475mhaxbAmWfsKPiS0LHbk5GsKPZt2v77cCm2efJhUn+Dt/tumsn66ePDz1k4aiJ2Zy3L7kTWQOuHfrZ01mbbJFCul/V5P+904YjiXcx6qxiPnmXNn43p41tfSrIVvhQO5VCOn4NWoqMq0/Rca9b+aHsnItQ829b8/8HUjWEX1MI0aVqYiFL+X1I4S2EZG0YdzHmftOf/nYnQ3g8Vn1dKe37b98A/gPOSTecBLRVQc6BW0HudvyX/L9Kmwn55kLR9F13vX4XnrTIfXbC+TVz9ZcGtmts6X+pHzVG4p6bZR8hxfKv/txYEfany8fuGKPUBnXw0cX8fGt95AFipEvXpUePiEamZrxUVuzbOhuZTVFSEPmKuSjvlo+tl/cXCh0HcsalbElpZioCrUUvrSw17STTWL1rl/5sCt+y/36df/HpUKlMmR/Oj5hc5Hpga4fffu8MXKoAzRYsAjSwMLdMjTUKygr5LhsOU/3WgxEOk/kZrmcv6mf0tCYnSvrqDq76g7zbXW/FVumdd1JL1iCQqtkZFT788Ulb9bC9wfmWLwQelTbSNiYccp12weIvSVKgIvdv4b8N9UAjLKBGa0vmNsn4vUnDb3r92M/moCSbFP0eqqHW6JbWc+6m/avn/g3uqrEtpapP0NRe1/G+f6b7pKv+jwtinBS2nbP9m7160rvnloVO/MPduXdH/fZSsTxFVKivt/n29UAGc94yZB7QrrEvD/q3QSi1NK3R5g196TxcE50UFqPbtmcv6GVV+dn2buVO1UNQCNc+1GfkTuX3UTzM13aobd/b3f4+MoL9Wn4HOLPBg47f1670j3MzhHBsPXcWtyVFx2N/3X8iqAssj/K0YLKGDdrRf7FukzZ87e3/0ZcuONpfAH/+sj6azSfOvat+7W8Y+VyU9Wx1Ipi8ptZHkpWfVdJ8T043c3iel/L+UMHaN/2PQl6pHSNwiFeX//K8vzI/p06R2T7l1k3I6vfxpWtayUtP2fc7fvC6FsN05Y/0AcOYZOxG9UqsM50Qr5ssKYcj7xB2PhJi9du63W+uvn3zdT8rc7uhKEL2pX/1oaZs03Re22tT1cDkqow/VoqqTR6u1Mk+do+LlgrRclPzQuL/c+FcSjZG1ujYh+KYVcGfC4f2aHBPnavW9n9TzQd6vcXWFDgTrr79R2vy5KVWc18i6wBc5WXH656rPSpsvtRuKWmzV+vSBtESC9KK0aHq4Uk6+0BwW7jO673cl6/y+aM3/+2br/D8zUTq2x8Z+4OEeV1bV8n80b6iWOTrAVFtadGYNFaQ5PfuZFnJ5pflTReclsv6Rhyz6S2nD3puWh015FgA2o1WAemuP37bnzUKyDmmFakWo5dCFKxI29tg9O3q7zQVf6a17ozhLBbsWkB9Z8LMbWM9+X5KWQS8ltniKrIuQe1wY7fGp0kfNvTnT4D3JEqoi9CKpW08y+ux1rkNtnn6XNKD9TpMIfbDUhbtIOV/eX05+sShjK2O/3z/XIX+U21rvbQZ82q7l/31i4zvKO0sIa1fZ3ljMu3xzQaP/Pr1p/F0uJ1vBxgxe9GGPvqSWecsmrQgA0M6YQUi1JsBdYb9Sk/32iz3mC3x73txvt9lPX/FE4d1UhOpXR24M3D5oWB8ST2NFXklgfUhO3mu03cpQ2GdNj6lS0sr0Pudv9G+Pf/iYfprJYqqfs7Si3+bBknUyWvdhOyicH8Wdt8L669Qa9TbZH2Py/74Zyv9LEqGThqlPz2q91Hzj5waOnpstO/362Pxvr/Hp4VDi5/C2FF4AmJEppmESGS4YJqEvFLSpuGS1jMJSKuRvTW7NTU2QSOHYOA9Wk6ZvKqZLcWWP5//Dwvm66CwFf17wIxJqkf9jqaW9WdNiEqF6v3maGZH4WfswqAi9Wtr9eYccT4hfS9el+22J35JbtSWjzaF/vqNJ5yOGyqJZ08EWlMLtj+2Ssfl/vAcrUaf55h7n55DfIuXWtlr+L5U3ip+XNd/jjfT7BNgN234JKdqeG/1MYu0TnaVmYjHb75Td4Au4/B91ut/ck5UI/RM5nsZnjJAoba95IeVwqp9/Vmmu+lDBnW3SUdfwP2u6TJXpOySOP6U0x+PD0oC6Vn80rb5Z1qdoOnfY/EcVsN+ujayPrqmt60CnfYrPiFr+33U5Jc7vofy/z/BZxub/cY6vygktq24J/IhEYWn/0P9Q+vZo/vrTVJYCwA7Y5EtI/k14p/2tUgF2i8SFjVTClo/fuoe+PVHlM2mcJUH0Z3I8AXyJUlOq3Y4K7agwHxKfIsNTMY1lyA0rQmYlVVZvTZu2X6UNU9T94mFpgvdWf7SrhT7bW6Ucl96PWj/oCB/O0roKTm2ifLssg9b8vwRK+X+b/DAlrfl/O0/6l5aUfrTrxj0DYYm6UUX/9jrfVcUf911QtMz8M5rdAXbL2InolVIFtUt0nklveYkKzOjNeVfWT08Ogx1Fbvdv70EvBPtFhYqKoqivlUhcuYjE4Sidq2gXhj9rEPOlPqAim1VqXWX/ZJVkK0mEvlOGxYVd18F/Hz3ya0n6bPW5vlFWcT94SWG7lHdbygK919cv1ErUkv/3yez5fwZmzVOajvrl9bLKP/dIvQyy21I5r5Su7f5zA1H75U1aZjLgCGD3jBkFn/9Lb6Q7I02Jo1bQDy+dUtj3lzsuaGyBZ7dnjTMt2Pv4UZGiU/no3JD2K0ViwhRVLFHY7Lna3/Od6VvpLZQm+d8mDqzYKx3fGdpMnkb7f4Q/FJ2e/nU0sIrQPx2TJrOlO83ZqfO5Xint1ERxaVvRuUXfuaN+02MoCaPWfbumlP+XHDYlmmFgOo9X+UdfajQta5l1cXSaWx+T/23YVZBqGaZ9q29eWBcSgDPFGAHqR+Ha/bMUTANoAaJ96S6WepNrDpPOi7hLy03NuhSNYJ7W85WoeXtfsKtQzGLlUokrk0gg27Bp+HW0szYB3zSy0K6JK281bKWruLUXUiWq+emaICylFxF9MVARqhaYu2WcfyoG70hWVK24df7PS4z7pbxq12v594603LTwSnrouS9F3EUvfz6N7LoMtfh+qT7/z2qxTeWVllU392la07Mu+vJ8oZQHIPl9tXSgolNf3v5ygS9SAGeSJRTOsCOSWMlfu9F1FSyllxAVRCo61fp1F4X28knPV5/pA9J/nmR+6CVRBaY+b33GOtfuHTRJwhJIln59cdb//OGEXGZF/a2tweH9adEy7P1YOwGWBQIUtJC3IuVeCurzi/R8tcnf9ofTZ6xWoQ/xvOE0kT7SoCI0f7nLik7h5QkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYBY6mZnDw8OH9H8PNMtF/XJp8vswnfbBfrkz/b+3X27Speu6D8p5josfXb+frOIoc48cx8+tsoqfm/u4uVPOc/q40bjQOLmmXy6XVRwpNv3o/51ynH5u7pdb+/i5Sc5jUtxc2y9X9stl/fKgdOjS9J/j5y5ZxY2mI40bTTu3yikn5Ru9Z73/XK5EeeeOfrlXVnlH7/9MlCsAAEtnFgGaKofrZVVB3m/o9Eo4VES8qa8w3ixt/j5DjkVKxgrdc/t6XiR1tx7T/320tPFbYyr13m2tOB/aL+rHUPyUUP/+VFYV6nkjRpOweqSs4uchaXf0DM9dInH60TjR9PO61vjp/X72wCk5HBrnvzvg1mfIShgO8ccj0rfGzSP65WFyHDebMDpuxtCHU8P38S3n9v7/gjSSyhV1W+Ngm3JFhaiWK28SAADYCxfKhPQVhFYMKtoenHelfy8grPWqM+d27roP06V394myqiyHKgy1fgxV+jUxY7mfc8tWZj6sTSKyvw9178myuq8oPuy29UuCYypin7Jy9lDj5XWnWYgmcfWYtGi6tPFbSjv6fxA5JyuLqcb3I3q33ywroTcUP5cV/BHn5+UyzOXGvcMg3M1upbh5tBy/sHhhFeWzyL/MUbz0yyN7t/9Cpk87mg8vl7b8P0h6YVNBa0V3KV8cum0JzlOL+jW9u0+QtnIFAAAmZhIBmiwTKoa8+Ovcf+nYfe4cf75WZk/RiqivLP5A6tQqXpERFZ/UK7Ghc9Y9PTzUCvQxcrKCbKkwTzgnK+GV70UthirU//i0VaZGeKrAuig4ZSjt5P+SgNd1FVsP6f36gz5+3i5lOjkp4kp+tnIocXjtf/nilfhSy37txSp6iVMOJE7vdlvTziPTS8wfTyxEW/J/lfTy+cQR14/J/w+QVbmi7p+6vAMAcJrZSoAm8fA0WTWLlawdIrF102Irysiykfc9JondXx7ox9U5d/2xMSKiJABLx9ZPXFk9VUA8qBCmkpiNKtEoHq0l7anqXx83fyyngPQsnyonLYUnTg322XThr/PPp0t+fErvp1q8/kgqwaoc6waO+3OVUhocdCd1A1FxdD8ZzhvdwLHSi0/mEdIm0jehmP9Tej0helPZ8imy3loQuVGKF6WW/w9NuDRtPDWlx6lFOAAABBzIhvSFtVYMnyMr8al4Yde5xe+3fkeWG3udrTRUyD0rVVAlWsMyRDfC/RMk8fksWXVJsPfQNYTLVqJ+n7/GVsIf0/v7FFk4yer0TDkeNKN4UWn35/+usi3Bfv+cntj7/TES0w0sIu1pqBROH56wCT7FzyfIyirc4o5IPaxDeSKH5VMr8TOGMfl/jZRvPldW4tNecxi4XduuhSV6jmoNfmbyHwAAZmQjAZosMyqstMLyhbr9L1E7P1c0XeE6XVTQ/ZXKce92F5zXSq2yFxkWn5dX3JKaG4XjpUr3wOx/VO//X5EF0ofron5Rq6eKnCExZTkYOKe0Hl2vIv2RwTlD7pWeX4musr/oTupL/aRGtw4KbkYCc4h83hNnTj9D5YRaPi8vXDd0T6353+cdK8I/N3V9AACAmRgtQJN1JFdOQ8LIWjtKYmOoUikde2QSwhHdQPhaKIU1U+xL2odLK7HPlOOBGNaC4+PEul/yx++36/647a5Qip+9oOJTVlZPFX/+mdbSgr0vG49i9smAe74p9hPSc/J0sl26KbkX3dMJUpg+UdbTSjfSrXy/te4nkVv2/EenF4VNGJP/1+j9VKvvgypuRX5FLSYibc/R37dua+vKMxGhAADzMUqAJvFZa77M/6XKooVSBRu59zFORETCLrIQbRo2H0aR2C0V6JcHx4cqRL9+IMPh9+LBHntSEn1LIXdHqFESKV7E1MSG3faiP8enxstTC/6PWa9RSyM5TP75qPXvfiacpf7CJX8i4SeF453zw8f1I7ewhLbG0bn8mwTf46Q9/+dj9oVkbP73AjYvF8uqqw8iFABgBpoHIfUFsc7p+aSB02rWBV3XiaFvTUueHDt3+L9IjqdR0rk8teC/fMD9+8tKRLys4J+/rrVSzOcOnX9iIEkS6dcaN6JrfHh0suy7nHt6/xcF7pTWo/vW6/WZ/Z7smSRkIvFZGqASxZ3G0TvleOJ5Mf+aVvLUWepPnpy8JDoUnTngw7que5fb78VrLUwlrFveCm45J0BTt4Cr3DleiGZ3NQ9puKN8pHGgcaF9KG068mETGRZ3j+3DdWcfR2+Q8ZTyY4lPc+eWXir0fnUeU40DzTsfTPuUy8yi6eBBUk8DpXArKkI/rb//l/X3f4cAAMBkNAlQ0yxYEgrRSG1b8bytX94oqy/U3CONJOvDY2U1/9/lEldoXkSURpm3WJI80bX+WGfCq2F8nNlfiicN6436X5vAPg20+vB+ebisRilLwb08LVMUVm2Kf+2YeJ+a3n8VwY8tHPbWKh9+DbemnT8fGJ38rsBfFWCPlOMmf582lY9x144RmS20CJ2Mf8Gz8aHnqujSvPTnjV/zORrtb+JB09FFEufR2ovbX+nduNXksSGGXphO+JXE92VBeDKaDnTO0htHhCP3xc73/2GB+1E+zWHU9aPZJeT4JRcAACag1QL6WbKqHKL+jCInrTx535/3y2s3ndYkibNX6HpfkaiA0Qo6V6DnTpNVxepFhJ+ix1YshzIyKI37P8aEz4dRK1C1It3Q+inAdJ4KjrepiEzuZzElUo9/i8bda2UPJFGeBxytHZI4rPle9N41vt6wqXhOQuVdKe407TzK+JGxLzBRuvbhHTMNU8nyNiTAxF37nn75/THCay0gx/GgglTTQp6PtiS+ovWn99e/eMSzaBHeefowDd+T3DF7vT6/5nyz5tGq7FHh+hdJiOu0cZdJWXTncNl9H67lz4ZWYAAACBjsA5qsV9Yykf9LzWOKNle9tC+wXzHVnHqp8P9FWVVWvpJ6ZOrr6MPn+4OJrPcD3Cgo0c4ktB7l/Mjh0DD/Yn8Pr930O9TaBKjxKUmQB2GKRGmmZH3cBfryEsV3Lf2opS/H19aWW02DKe5+W1Zp0/v7JLdt/6P9NXE1GBxZTx8PSPsfJQXx1Yf9FzcVn2ser9KQdsf4b7LqzjCUbixaBmybjrx/R+t93lErv+Yf219T0bJjq3yz5nkfh/3yc5Isw1IuB6I4eFJh0BoAAGxAVYiZJuWSNUfMsbxopfGyKSpMT6pAXyori4gNj/bVerjZ9v9DlWvRSylX0v7Yk+SkxUwrzd/TME/Vh6x3R605v+38j6zPNpwXJ+vPTun9VFEVTUPVVbbfMGV8WVLcaVPqnc7vB5sXmJbn3ZKOSveqrFnIUz77cHeepp2Xq/iSiUlxq/no1iCM0VybedlEhNXi69wLpJyMcy0/1OL6HpmYFKe/L3H4Ss8896cGAIAJGLIE5ibvjC+o/bZW7LOIB0uqQN4g65XFh7mw2PVW0SDuutq23Wetn3mfWpheOkezXRJSN0gsbkpcJ7vHNqu2xOdrkoVuNoz4spZ5TeN+gFQkRMZ23cgcBNvW2net80utvpp23iYzkeLhJXIcDy1pSfd/ojR6IbGwU7yl88Pc8RvTS8hs/ZZ7tzX//LYJR+llQcy+R+3jRQ4A4Hyk9jWSLKq6xkUri5d0Oxot2vvzKjlujldhULKArl0m48RoyRriBYn/YouKz5fMYb0xqAi/R05WnCJxZbrT6WSM9bMWh2L+3zWHtS/CiK8PmrA8XE4+W2+xjLp0VL1ybln3xBy7Ttbdfe3MaWfl+UrgaTzkdJTD5IWjXa7rn+3QVFoi5TTp41bzzgPMOSqIf0t2QH//2kf9NSLVeWXzf14+VgAAYGtqFlDbpFz6t7ym2/1UJVpR5cpTm+Ef4I7XKpVWanGUK6WPlGN3NTy/tAMrsPpzgwuL/ff7WkTDlGhFHX29KGNFmYqO35Ydkp7Pa2X9JaIm4MemmzXvzHoWsdlfTbe2+f01yTq3E1I8vNz4L2a9lO8fJQPOSnkwl9+2lvn8EruzGRvSS89NabPUZ9zy4QubWxcA4FRSE1daKZYqXW/RuXWXlWYmVZ43mLBEnwb1i0i7mKi5Yxfbf/BVOxTify51i5WY/4t2VXGmQSX+ZSDqp5rXX7uHlxdNP6+XY/GhAj2yhJWWQeclvt8sPO2E+OeEeB+m18iO6f3UuVXfJu355FEDaclai2t50OedfbzEKr8l66I5Et52eZwAAMBWhALUCIjIihF9XeVXZX+oAI0sJl1hvZVIaERu2n6BN6RmvZ2QKus7KmHy4d2V5cb2h41Em+0DqaLrz2R/qOCLwjj0/MdQctfnpZ2LT4N2abH5yAoykfUw20F/EUPxZIV4PveOfbzEHgVglY/+UE5a7EvP//ECAABbUbKAfpQ5XrNeKO/ak9ViFZDjpuiStSIK81ghUbrW+qHNyK+X3eO/4qMcBPuUXQlQbz338WdHgf+h7JFk/Xtn3nT/ed0K+zFpZ8iaZvfvVYinPGytoEot/390m8vVdGD37VN8K1qG1OZEteG9KL2kAwDAhpQE6IOlba5MLYz3ab3KZOFXslj4SnUM3cC+vP6HexLiKsD9964j4b0TC2gaoOKnXvLrOTwf3LP1M5OFl8hJ8SXBdosILd136fhehXhCn0VrPhnqU1wScHbbWj/3mg7Si+xNEof1xOly3G8XAAA24EQlk/p22cqlJGqUe5YgIFLloVasyNIWXiKNTktdNCyhAtWR3Lbvmr3vSIDPzUdIXajZfW+VZZCfnY9Dn37GWj/FueuP2f+9x0WyBt/ud0uc/y8aGA0flRd+f+adsgxenf5L+cauI0ABALYgsnJcJXUBYZl8svktsBV4SwXSShZ33spo3dxnBXqHxJbfXQlOz4dL2QLrrYuLEB7pBeZWv1tOhltkXNy2XKvbf7nLkd8DRNbgEh9R2F8S2yUr6BKs4Iqd+iqHtZT/rxIAANiYSICqVaNmubAiYimWC8VXHjXx0CIgWkRsXl9CBVq6rzGCaQoucv5GYjRX6ktKP3+Z/kvhtv+tlMSn/59twvkNyC0JIsP5v6UZvuTGuSVZXvdOegnwfapL+f8iPs0JALA5kQC1k0Ln/1JFOvtk2SPIYZlKhPmK0o8IthXxvhmq5EU2i4NNsBZ0iw/jPfscvBZwZ2H/piJ0SMDY/3fLcshhacn/Q32KS0LWdm/4S1kWWo74ey/lf6ygAAAbEoknP5dmJqpEb5eFkKwX9ss25w7JZuLLfwknqpBzxbQ0usL6LrAW0PwfPY8lvbwoKoajKcby/1xCvpP1qbT2SnopyPlo7VCwfnXNqWDbCrl8fCldDzKlac2i53+xAADARlwY7MsCIppyZk14LcyCpWh4cqVgw+4rvRa8yKxt71rkeVQ4HVb27SR8qUnSVtpRGHLcLU14WCtkV1kf88LRNRxfYj66u1/uJwP5P51Twl9bSotLfBGJnnmU/2mCBwDYkMgCGgm4vG33fVCWh7fcdMEiMl6IlpoS/b59UZu/MFqfG2/tsvtzmluaAM3UrJ1jXjaGWhEUjZ8lxkPLwDZdH2MBLOWdpZUj/nnU8v8SWz8AAE4FJQtoVMl6MbFEAVqyskRNaS10A+4tQXwqLc2lu+ABMhxneX1pVj8VHi3ifYwIFRkWoUvMR9E9Ri8ThwNuRBw6t5YowLvG7aXkfwCAU0dpAE3JWtHJMgbdlPBh3caCVXO/tL1k9hFWm2ZKVsVFkPoQt4RxG/E59vgSKOX/obKgFIdjJ/RfEqc5/wMALIrIAlqzYNm+lEvsgN9iuREZ14zq3fLHliKoamHYVVOhbbo9DPy3YXyALIjDw0MNT04rvs/wWMu5GHfyeuitLFPElLoPtPalLp0b9QdeajkS4fM/TfAAABsSWTD8KFBbidiCeVffFR9DVCFsKhQ7KVtQlyQ+WyxRpW/Dz4mPp4Pg+JKwXU8iS7q4fUN4y2/pnEUJ8UQ0l6vIZvlHJM4veX2J5UimJf8DAMAGRMLF94UTiSvkLlmNloROCxNVct5asYk1K1qWRK2y3xV3y0mLV0mILG0OxZLoKn3mdAxRmszran1dmhXQ5+sw/0u9H29X+Pf7llaG5HlsS8LTLouZhg4A4LRREqD2WOltf1EiIn3DXivyUoWXl236sO5T3LXgPxcYVfqzkfpR3iPHlr/SoixReERp3sfbkFVT3LVROhS3fzFxYfJRS/4fEmC1NJjXlzaVUe1Z+HSx1JkcAAAWTyTGdD7EqLJZuojI1k+Lr/D9CNwa0T3bPoLS6M4uiETOodveVVjvCcJxGITn4oVZ0K9I//Y5520rqMdaQGsvRHl96JOWu6SWj3xaGhrBH+U3n5eulmVhW1GG8v/SZnIAADg1RAI0WzVKosXuu16WQ7bGRoMfvOWihVJ/Ui8e9j0rQCRwou1d4T+taAWcyHq4HirLIYcleqZTdN8QKT+jh8lyuD79t+T/WyTGtjaU8sriXkSS9Teng8H831v8bxEAANiIIQtoyfKR169eUP+1R0jZciGFfTVK1y115LISWZr8/rm5RWLBH4XtelkASQB5S1wpDdn/Gvmc6KtZfrlelsP10p7/x3zHvWYFvV6WgYpPK55Fyvkf8QkAsAUnBGj/Vq8W0LulDRWfj5E9kwSEtWBNRRds70PUDRGJA3tM2ZWl9t0V/3ycPWwhLzBDaWfT516b89K6qVbAvVuD+zCoCL9ixCXvrhzzAk6C/3zOI2QZ5HC0PLOlfUIUAOBUURIlb5Z2S+ISKg9beUcCrHQvQ5SsH7KBW3NTquh3HUYVJbYfqLiw2HUVn0+S/fNJ6b8Uf+L2t2DTS+TuoTv+SNk/HyPl/OLj5N39y2rtRbXUB/nAnaP79/4ikl5i7ct0dP82/79JAABgY0oC9B2F/ZFF4CMWYL35JFmv5EoTZo8VELV91q99UxI5OyeJEmsZs82ZedvypH2Kj95v7X+p4iOH2QsNMfvzf2vcHhSut+7kqaseved40Dh47MBp9r6Hmt+jNOmPa/zkPuf7fhH5RBl+tmPuHwAAKtQsoKVPE0YWjWftq/Ls/dWKS5sNNbzvkJPhy2wizEpu6T1nkbK0T5NGz2nXYvQNEr8QROHSgR/7FB+fkcKR+z5Hi8hm6UfkZPx7tzXdvl1W1uBPlP1hrcAlq6ddf03FrS5Yj+JAyS+7n9Tn5THN/5NhxHfpvv0zf/OA9RcAAAYIxVMqXHMTk684ssXPWv60AN955Zkqjo9NmxreSCwcyPYiIl8TCRK/vmui5sGSxWlXvFmO+xGX4kzMvk9K/Q93inl5UWyTaumrTWNfXvx26f7zi9OTkkV2p/R+atOzCrDoi1lR/n9H6iteo/QS6PfpvefpnJ4p++ELJQ6r387LGwUAALaiZr3TQjay3hwU9n9sX5Htuh/b58lK/Kr/b3LhkWC79VvW9pqSRWQbMTs1+bnkdQnWo+1ZSC8wr3V+doX1zOft0gKWXl6enDbv7sP8Jomfa+n5j6WUXnTbWoyfuYd4eEreFClaKvO2prM3SBul+PTH8v0/tA/PJ8kOSf5F8V16/nektAIAAFtQFKB9IavNgrpEle5hsF/deuauLFm9P8+Q40mjbzeVQg5T9MWascKhJuasX/vEi2u7L6/vI5yvlXJ4MvZlRoXQ5+2iK0cSXWr1yl/OenPDZdn6N5bo3m0azTNP5LymYmiX8fBFcvwSVwtr3ta81ipAj7yRsgjNx2zefXIfrsfJDkjiM7+EDL1c5vXfFQAA2Jqh/ouvkngkb6mgvn+/fNHcIrR3/1PkuOldebs/ReJ+hyLbWa+8W9mvfRKNNj4nbmRPAtRYQWv++hcZ/ZjAF85pAUxuq+iyfnhBZV+qROrCpIR9CfLdQKwAy1gL7C7jwU4CH92jz/+vkjbsvZfczwJc86/tsvGs1D1iNnr3VXg+2e3uBtbHim8AAChQFaCpYoiatn3llNd1UcvNl6cCflLUYtMvWml+rKyLgleZcJXEwiYitCtcL5V9u2ZIYO5TIKu16ANy8rnUwnyNrF5iJhdfqX+lWj6vMH6/O6VzkXK6Obpctn/etRcZFTZWhGk8fOGM8fA8OY6HTmLB5ferALtBhhnKJ1EcvtYGsV8+dY7meLUspxfYJ0u5bCiVI63iGwAABmgZwf2bcjxVTEmQRce0Ke0zp6pAU7Pcl/fLte7QDX2leFtav834X2KsiOgK20sZ/R59JtJbmbYRTRuTrKCvkrKoy+veaqtWua/on/lTpkg/RnR8sayLT/3/Q3f6GLFco5Q3Ij9yXL3GXath/UqNB5kAEw/6Ehc18ZdesvL/z8lmdANuK3rv97hz9fl/xYRliApvLUM+Tuplly62ZUG5oVF8AwBAAxcOnaDiri+4VYR+pt0drEeVy+P75XH99Vpw32AsTU2kfnA6OvfjZSVKfKWg269yfkZh25TICmb9WdocoH7/Nt8wn4T+mb+mf46PktXHAlrCY/erleqx/fWabn7XvGg00V+nLyuP6Bd9ebk4cN83qba8uIx55t3AtkdFmIqji925+jKn+UDDesMG8aDCS5/BY+U4HmqflI3C/cqR/pbiq4v8VgHeh1OtoN4ymUW4poE/7M/7CxlBKkP0+esAyYcFYTl3qpTLDu2ji/UTAGBCBgWoom/+qV/nx9nd/jQ5WdnkQl0rgMf3bqiV50ZZfUdZl7vNohWNVhY6L6Q2P6p/Dwv8sv68oVApdpUwefdKeGFXm5x8CfiKvfRisA9eLCvL05VpO4fTCvrSvivSoi8y+qxViOT0o2gT/z1ynH7yd92vlePBNWL8zai11Q8ouVvWhWopPbemH78d3ePxCSsRpiL0ycF1V6T9ahW8WVb3n/9z2G0+0nvXfKTC6yIpCD+JX1T8favo3WTwzWHgb034qjX6cXL83Gx86/PULybps9b7fnv6z1/d0rRxsazfuy1DLNE9Hkj5+bx4rOgHAIA6TQJU6Qvg3+gLfy3UbRN4rZLN2G2tHB6VlrF4d9Uq4StFOzfhgdTDMpZI1JYq9V1Ts/rmMO7NWpuE1c/2q39N1q17JcutFI5fKccitoXI+pZ5fdCkqmLm/oXzrZutz7v0wlK8xz5Mr0zTmV0j5fR1TVoeVwhT6cWrFLZanKvw+g0ZhxXpNcvi+kWrdPLr/eqzg3OzO5p+VFReK3HcWNFaeoEQieM2ej6/3ofrFgEAgEkZ249RLVk3u322orHbeX3oc4T+Gqm4Y8+PmgTvlmP/prBYRpWTv88D2W9TvK3sO7fPW5H2JpTTs/oZOR5oc7TbLNH8slLYrt2HPX5QOK5hiSx6Q1+3GROPm4pU5WUpLK1puCTC8rFafvP3Y9Py0TPb4qs/rfn/+IRVE/sfynD+F4mf75j8X0pbeb+WMb6PMAAATMAoAZoqIhURahHwFZsVEDXR4CdMj0RTdJ3d98rCgAC1YJUm0+4qbtaoiaJiRboH/H22NnvujP6Z6cuLpp/bK+Hx/Wzteum5ltJddN5RGi40qd5e8NeLnzEvHAeVsIZupXj6DSnffzfimATr/jwJwqV5/Gcmanpuyf+WV8rqRbdWlpTyYGv+H3oWWsa8UgAAYBZGj+RWEdov/7lffbWsF/qR21Hl0VJ5R1/1ydQqhtukXrGNEWFR5V0SOUsgEhR2/yLCncTVC+WkCLXhjERKi4CqHc+8tCKq7pGTQimiNS59em8No8bT62UlxErX2etLYqx0bi2PKGqFfOGW4rM1/0cCXF8SfkHWu9R4d0rbm+b/nO7U75ciPgEA5mXjqYT6Alr7ar1cTk6d4kVpyQIhUrZESOFfxefvSJnbpN3i0YK9lzEV+K4pCTmRcfe7E5Kw+f/6RUWWtz4NiamusC9at/s0naqo+nMpc1vh2pLfNYbS3GAaSmn91wP3ROJ4yP/RYKnD4PooXWufxxdt0exu/RsKdzE+Uxr5aTkeZNWSrg+kPf9Hz0Zfjv5zEv8AADAjzYOQIvqC+tWHh4daoT9VVlMunTvUcnllv7caaWX4O+qf1PH9C6fACyS/fyp/pqI0UntpIlSf1Uv69KOzImj6qX2P+3BgX+m6jAqLFzVY9O4O3NlmwNm21+c8pnH0HDmOIx8HUZ6xRCO87Xn6/7Z+eXmyUE9Bt+Xxcy8q/f1/Wv//CWl3dSaBMe4b9Lm/euDlFgAAJmQrAaqkSuIlSYhqJVEanWppqYjzca0YX9LSHJhG0XqrUDR36Bgr1tA1+xyAlBkK574HShVJ1qbX989NX2BUiPpR7tFUPucurxzX7SNhIStx0WLRu1vqwn2MiPRhK13XIsRu7uNHrYFPk+OR71HYonXvt/fvfbJ6uZva6rdt/j92qOtenqae8umj9vztcZFyHnmdrO6faZYAAHbI1gI0k5o2/zxN/q1i4qNk/WsrtjKIBJE9nuf6e0Xv7o0yDq1IrDXN+zVWfEZuiDs2yqo1MZHwOBzYXhxOiOry8HxIhkWhYq18OjfoH0i78MwMWf+isLSca9c3ehFIAumX+vh5hayE2BPcKdH0Q150Wr81X/3BQJeEKRnK//WL19OHCnFvDS49lyj/a5rQ9PF6hCcAwH6YVZAkMapCQv9VjF7j/M2VplYIaonRSlFFwJ9N0AcNTjHp84uaXh4ux/Ne2jlEreVLB6vclJYbN3hpmZw+/H9T1l+ESnNW3taH9z/IePfV7Zy3NG4eUvFHUaH1Vlnlr9fPmb+SSPwcia3SIuvPUFs3XicjcWWLTRtRE72+kNwsx2XL3tMHAMBZZzILaEQq6NcK+/RpvIvNOVgg4AQpXeiyZqFz3wW/+xS9qFjrpP3f6CUwxc/r0nJEihv7tamjryPtIY+VrJJ2/6hm+BMeuLLFlCs2feh9n6Y0AgBwZphVgEakyoAKATbiFL2w1ETYLP1xjWjfN0PN4tJ4vN3D43KFF1oAgFPAzgUowBmnG9g+HxgzyPB8vH8AABhg43lAAaBK5xaR8kj1841u4BjiEwDgjIMFFGA+8gjs6POQImdXhLYcBwCA8xgsoADzYacdUoamlDrf6Br/AQDgjIEFFGAevNjceuT7KaUkOhf7cQQAAJgfLKAA82NF11kRoNEk/Fg8AQDgCCygAPPhJ0T3x6L95wv+gwFnbSAWAABUwAIKMA/RKHiRsyO6agK7FDcAAHBGwAIKMC/6knefnLQIZs5HATbm/ugHCgBwBsECCjAPJRF2IGfH6mfLl1ITPBZQAIAzCBZQgPkYaoYuHTsfsKP+7T57DAAAzihYQAHmoTbf51kZgFT6z+tYPwEAzihYQAHmY0iEtnwz/TQzJLrP9/sHAIACWEAB5qWr7D+fxVfU19ULUsofAIAzChZQgPkYGg1+FpqhbX/P0pyoAABwxsACATAPVlzab8FLsH4+0wULAACccbCAAsxLaQDO+U5p3lMAAAAsoAAz0g3sO5/7QZZG+jMVEwAAYAEFmAkvtEpWwLMiwiKL6FmalB8AAAwU/gAzcHh4+Jj+7+KGU+/uuu6Nch7R3/sD+7/rGk9/S3//7xMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2DmdnEIODw8f2v9dqqtD53Zd9+cCAAB7oS+vH9z/PajlXMprgLPDhXI6+YJ+eVTDebf2y3cIAADsi7/aL5/YeO4/FgA4ExzI6aSTY+ut/5fCNgAA7IdO1sttkbgcB4Azwmm1gGZs4dUF+wEAYL+UjAP6fyiIUIAzyWkXoJZckB3Kcd9QCjQAgP3jxaYUtgHgjHCaBah/i/b7AQBgOUQiFADOKOdDH9BDWe9fROEGALAcbLls65wDWTcknNb6CAA24HzpA2qhTxEAwPLoKutYRgHOGFsJ0MPDw0v6vy+Uk9ZICbb/qOu6P5J5KTXLw3lOnxYf1v99qpS7ZNh9r+rT4p8JAOyarrCPMhvgjLGtBVQF6FPcPjsYyBYs7+mXqQRoram9azgHzj+itFiCya4BdosXmb5sRnwCnDGmboKP5njbZdMKb9Fnl6hfsJhtex4A7J5IfJIfAc4oUwjQrnF7yoKmNI9c3ocQPXvkdHCfxAPU8rYIlR7ALimVyQhRgDPMVAJ0H2KvJmwRGmeP2qTWu7bEA8A6Pl/SKgFwxpmqCT7qzxMVNFMR9e8cesOGs0GpGV45ECzjAPuglO9q+RUAzmOmtoCWRjjOgRe4h5Vz4GwQNelZ6yeVHMB+8C9/Q123AOA8Zy4L6C7eav0o+1pTPJwNSmmBPqAA+6PUXYr8CHCGmfvLE3N1Mu9kvRm+NPUSBdvZI6fpSISSHgD2Q23+T/IlwBlkWwvovgqPaOT7YWUbzgaMtAVYLrVp0sibAGeMqS2g3YbHxnIQuHswo39wOtBn7r8vbY+RJgB2T9e4Tf4EOEPMNQ+o79uzC2skkxyDZag/KADsBgQmAJxgCgtoaeTx3EIw+3Hg1uHs0mJZoRIE2D3kOwBYY8pR8Iey+9HotcnGdR1BevYopT8qQID9EfX5tK1W5FGAM8aU84DusoN5ycLqp2XaWPgeHh5e2v99dFqu7peH9csl/XKpOe2ufrm1X97dL2/rl7f3y590XXeXLJD+nq6S1f08vF903d9Tjje9n/f0y42S7qu/p7fJsin192QwGmxNKg+ulVWeuU5W+Sbnn8tkPZ1p/tf8835Z5aFbZJWH/kTOE/r4eHT/97GyKkc0Xh7UL/0tdl/bcHmeE/RMtky4tPTwtK7p6CpzmsbHnbJKR7po+atp6U+XWr8AjGVNgPYZ4x/KKhNEfThLBYSf5Ls03cYze/efNuCeH8n+QxXhUxMYGxdmqWD9fFkVDrliKYX10nSOFiAfa9zQiuZ3+rC/QvZMKuw+o18+TlbhPHFK+rfi/aq0fHQ+1rujleiLZVUAvluG/dX4+BIZTkO6/6d7N19jrlW//6HUJ66OiOYZjPz/kt6PZ8u4dP1/ttz3EL2/WuF8zdBpxm9NRy+WHdCH7VtklaZb878KrP9zFxViKjs+PzoksQXth7Z9aUp55ylynHcudf6KxN08crmg53y0cU/j6c/6RdP6a+aMt96vvy1xfj9xah+Ob2s4z5YlutTKxhJRi5XfPyupbNH8l9N5a/5XNP//0CbPzaWlUt3i67JL06LP8Ulpn5bFmn5eYctMgNOIt4Cqpe/BZnuMFbEb2J8zU4lILFwy4KZfr51XxQjPR1fcsl9dqrmtbjy6d1PdUwHxC7JjzP08Ju8qnFrqN2m7MOi6po2vTG6/uOGeLk3XFINo/IvSxVWyOZEgseuXpSXvv092VAmqKOrjT8N2jdTzVr4HFV6zC9CUXq6T8dOZaeW4C8uexoOmiRbL9nu2EZ+uLPAfvBAZzv9Ri4yiae5j06L+/E7/9wtTvNgEZItaS3wN0of1mbKKE5tXW/NMZJjYl/jMRhYx/rfkf31GPz5WfCbhqXGnot23NHla6jW99igN9W5rmF68BEMHwCZ4AeqbrmtvaL6pOzqvC7Zb3prHFGyHlf2D7qRCSYWVFZ418RJZPErXqQD7/GS9+d6ZKpr1AKzu50tl9aY9JHDOXRZs20/n+Xh+duM9lfyw7g+9uET9xUSk2Trqr/Vx4u91F7yyX55ttqN7yutX6zPdQdp5mmyW/zWdzSpATXcYTyn/bxSeJDyfnfyaIv/bfT79KxrnT+v9VQExtRCdpIxNcf8VYlp4pFzWD+WhUv6fXYymcvEbZN3A4sNSQrtWfe8G4lPTkorPqFXBUsv/Pl7tS82RUSCl21/YRf0CMCVegNYK17z/UE6+4UvBncPgnCHBIeZaqZxbCusY8akZV5uqLpVyQdhSQEb3aa/Xwu87ev/+a19I/LLMRLJSaKF3qfFbgnW7L4qrKG59IX1kTej9bG3q9GnC7itRO3foWi+g7XW1F5ddkAXS0PexMyryZks3icfIZvlfRdRPybw8WoYFod3+FRlBEifPl2GRu2n+99f6vDCXEG3N/yFGtF0lbS9vQy+C+RofJ7PmO3cf2b/W/K/9LkeJz+Tf35H1LhDRs2jN/zm8pbjW9KMtbt+LCIXTRMvk7ZGAjCxbUUVwUHCrxaIwVCh1Ert3WNi/RhJr/0hOik/rvgRuRW4fSNs9fWnv73NkYtRK0S9a4H2ZrDct5/+hZxid5/+jgk/fwL8h9WuMiOK/dWaCnH5q6aOWZmpW7CiNVNPLlKTBKO+R4ZeszMfJjKQXMdtc68NRSzuXpOvnJLK+lfL/LWOa31M58M/kpPicI/9LcJ1FhYTmpyme99j8v4YRbbkbTellrsk9w05nJgnu42i3tOV/zadjxee1yb+HSz3tRHWOJXpeUR2Vz9P7/EfpfgFOBVFhUCrYI2FS2le77rDx+lqBVrLaRWL05MUrEfg8c13J71olJFIv2Ds5WdDpos3Xz5KJSAWOVqAf5/y04RQXRv/v46x2D+K2VcBrwVfq79nJcEE8hL2u9lJTCmu2HBy4c70bkX9jwjmGVwTul+Lp0akpdC6ebtZL91xLNx8v8/Jxsv7cavn/d1ocNC9tWg5cKuX4l4b9EmyX8r9IPS9oPvo7E72odpV9XeUc5WtTWIbyf2s4avdsz5uMVDaqkSH3tx6T/3WQzyaWz0i0l1rkWvO/SDkN2ueTRWit7z3AYii9jZYK94OCG6VmhFqBU8pkLQwVop0J2xp95tTK8tkyntaKqRs4X/myitWwGVPAXlUJj/0/MNuH0lbAHcjw/WkFHk2/Ej2frnJey/6W/rmR35271lZGloPArTn47YZzbBjmtII+Rsr+5u1a/n+azESfxjVsWSBm/2r5f3BAhntpa2XK/F/zI6Mvql8m2zEm/58jid+Hm2ta7i90qxImv6/1+iZM2Xi18aM1/6v4/DHZzL/LZP1+bL4ZKgc9pXOse97Nc4NFAZZOyZpk10uV0ZB4idYjP31n61LB4MOQr+2k3jx07NHxAJ3oPmqL97vWb9Ku+3iw/B3ZAlfA1iq7ISEmhfXSW/th4ZxrndWmq7g99Hxr1w+lv27gWnsfkbs19yYj9dX6UxlOd3n9MTIDSeD5FxiRevr3xy5N7szB05zf9t/n/xv7eL2l5lgh3wwt4sIwRf6vnZeXZ/Xh/SrZji74L+VtjR+1htemKCvlfym5WQhLLW9uRSA+Iz9K+f9FfRr6jzKe58hxmrLu+vWhcqYbOKfktn2uj54xPwJMRjQRvU3I0ajXTc/LDA1MGmpCttdEhWltdPU/lpMd0X34omO+8D4oXCNyUgxHBbYuOrr5OX1h9yIZSWqOtffiwy2V/TZe8kTzb5XVnI665Canq8yi0/NcG1zvn5NWmL9smq1K/kbPrRTmrnJcpPwcRE7GvT8enb9LtI/ZYyROI/5/Lgvo02RY2IkM53/tB/pGmR47OEqkno6qA7WSMMn5Zpv8/4F+ebWs8o7mmXenJX/UQZc8wbjGS+6XbfN/9vOg4Ne5AUo6a1efp35UxhHFk98fbT8nCGMt/kXKeXEoPD5et8Y8Y9t9wIatdv8/v2F5rGn06QX3T5xu1rWc1DJA88170nZOR/kDB5p+NO+XmtXtVHk2LT2/X75ZABaMF6A6mvUSaUcL2i8P9keZXAvsP5RxtI7oGxSwqd/l1YXjtkDMBYJWLm/zFpUk/h6eFm3Of7Tzt1bA+YL2M51ga+V5Ui6QIv/tPHd6f/osfnuD/k25oLVv1/Z+tMD8zH75+Up4hio1RSv1sRWuiuRnSfkFxq5rM+1YsTTHpOEvk+MKv5Z+9NiRlbF/ZlOLPCuAa0JMJA5b3vfJ/TK68q5hrLMlcWbDoQxNv/R1sj7YKsr/UjimaVLTzasbn8GrZf0+np4WL+Lt/7lL3L6n65yPvb8/L+PIz8fPcxmKpNSCcXXhvJKw0vJR4+ZtDeE48sbsK52zEalbU+676v2I1m1/4hdtIj4TOQ+L8+O+wn4tS/Rl6WUNZbCmo59Maej5EgtrG3c5vV49U3kBMBlrArRPrK+WESRRogLUFy7nnJT15rGWfm9jsG/qRaGXwvlZaTPqs6qfPGsqENLxN6blZcnt58qqAo6sn7XwqpjVSull0kjv32cav6KK+cQl6biK+R/dtEBKTcb6/H47FYZfJScrc/VLraAvk3JlMljJpDgelVbSpMzPkpMVWVTh/8kMaXE0ep/pq1lRc5m/D13XF57JKpT0HH1l7YVoiyjQc7TCe/jEn2zV+7UDyEROCuIc3j+pNb/3YdM8+nCJ7y8S//mcMWIhJOW5N/ZhUIGj4bBWZxuOaD3znP76N26Qf33ZGJ+0GrjydFmPj6g80zj4w7S8cYM46Qr7shjciCQ+1fJp+wsfHXL+2P15+0UbiPvsr5aBj5WTYS/Fu5ZT/2aoq4gnPfdvTl0yokGD0X1qWvseAVgoU06JYQtx/0bWUomNoWQlEudv5gtkVdH6ztu6qFj6Zi2ANqlgVJil5rFvklXh4iuSTo77tR4G/jePIE6VxHONG1Jx1y5qZf2mqd6G1R11T1YWL3+/agXNlp5uYBGZJ22UKveNK7gZ0Yrcx5VIHC9TN8N/spTjq5aXo2v0HqYeDf8Y468Pm7h9v1VwQ/ONCgTNN1H+FymLIn05+Feblg0nHOxFR7/8SL/672TV5OrvpRTPefkbI2ZDsNcdSD0PKhrX1xTcUPT+Nb9rWakvsq8eESct+T96rk0E4nMo/9swbCw+E48J3CwtG4lPS6pr/kSG86Yujzmcd/YMgK2YUoCWpnSai2juvRMZMmXAyMKkhcH39Bn6J6aqXPq/fyPH3QZsWA6DfZkxhYRWonmU5Zr3Uo5rrSx+QmYgFdz6hv1+Ew7lEyphKlWAU+CtZFElvDRUOJUqZXHHrp54ipXHOH9KcXSLlJ9l5kAmHCiV7rM2U4QPa635/atkGF9+qej8nm3EQonU0qT5JluLW/KE7ldr2xfIRMGQdf+e645Z9CXpmyYS4pPm/yQ+/0m/XC7t+T+Xxz+ypfhUrms4J/v7oonSk4rQuwb8yjAYCRbLtgLUi6yocJlDaEQVdA6DP65WGd9UrAX/C6buH5MKlyzIaoNvFFsgDhYSponMujX0Fqzi87dkRlIc5nvO/mql4L/GVBOjkwZJpndzNkyXjuglxf7n45NYQVPF7cWs7RNn/f63Zt2G0ee9x04okD/e+eX9FbOv2Pzeh0cF21UVN7xbys9PIEyqJGvoC+RkV5Oh+/3MZNEd9ELqZcO585J7panc9AX9ByYSni1hbMaIz8sCN4f40Ym64Vzn/C3FszJVC5SmdT/grvSsEaCwWKawgNq3y1qhPqpwafAzEqFdcN4nu/3adPSCKayeYcBWhcPLJC4Q7LoVHC2V9nOlXLhGcfzzc4vPc56v+v2plTXfUx6oFQmptUtlwmAE61GFsNMvsTSiFqahr+kcpOUTZBqeYdwvVZz6/8b0fP/E7BN3rc3/UzXDf7zE8WH9zYTpPIlhn/8lcMc2zc8uPh2ab24M9tcE23NlPKW4VJ4uJ+NUy0e1ADf3T2/wuxsRpipJfH6jrIvPyD+/6AwG3zNh2ej7nEb+Ku+f2Jr+B1Kv9/I/k9LDYpmyMo7ERhZaowqXBoZGkuZ1LRwea7a1Iv0RmZ+XynqzdKlAzPuqk9IHFWlXcDv/q2j4b7JDUoH+ajkpRLrKIjK9CB1yd4n9QDXuov5pIifDO1W/rk8I/InybK6oXy0n4zfKh1sL5JTeHytx5ZrDav0tDZ5UN+zcjFE+zO7p+m/uWHxmC/gPyHoLQum+877HjpjnsZYn8rHHun0alu+euIVoKP+X7vkE/b1rWfgvZb07Uku5onH9XRPfV+krWpYcp5ORXgrfLeV4VY5GwwvAQplKgLYUmlNSKrSsFUnXbUWtmXWKpqRBkh/+DbvWR3aokPgCiSuPknu7ENkR6m+OX2+ZmCMd1LDpwO7bdTgGSeklDyxYOyQnw2zF/Ub0Fbg2G14V+BOt58r6t9xxOzLdhnMKgeybmK37/ss8tcEwUb/GSEDrulqndio+M8ky5vNsTVgoQ0I/EiMisUDzk/L/yMSzGXj/xhxbI4nP/1VO5uuSm/m8bNGd+r5q9Yl9BlfPMCDojRI/T+s3g5BgsVwo2zNkQYmmOJmCrrIe9b/8+TkGFFRQq8xfdft8nGSukTreQhFNwZT5rR3f5znStELaZJe7C0SV3i7TRsnfqf2bAm1Sy1a/0nReeVvFxzZNiJ9s3Dt06zZtvTqnpfRstcLzI9OjZ6nuv1Q25+NdmGw4xRxTQutn6tc4lK+siPlv+8o3Su/3H6T4zVP61NKArj+jP/+/DbxQl8rI7F60T938A5mWofyf16sY8Rnl41qrmD7X757p+epsBh9ZOW7DqN1eXiLToa1cQ+XA7AYXgE2Zugl+VxW8ryxLYcnHtGntN2W3vNWslypPv36CZK26RuL4jd56d9r0HvASWQ/fUP9gW9luS03MLrHvp0UrEvsFKR9PdvuxW1pTcvO7d7tzy6uDMPq8FYXxr8iGpPvS8PnvZ/twapq5s5KvnyFtoku5ZVf9pQfIedfmm9IUXRpPLSOwPSXxpts6pdzPyTzU8r9SnaWiTxf6PP+mlPNxKV3OKT6Vmwv7ozLts6acxSINZHvDwPJWAVgoUzbBK6W30DkEqW9u935Zi8HORVmyTOR+XaXKtCVe7CTHXWVR3rBPK46S7vsNcvL+fOWfj089PVJX2Z4jHU5CijfbPFjKP7qu3Rs2ER+lFxrvpz6rWwJxp5ax9w9cp2zTDG/7bNdEsqab2pfVHhNce1Bwb98vbUeoYJCTI6WtSPN5vqUZ3l8XtQTkePkumY+N838Sn9nyeRi4IcG/omXhd81cJua+0T5M0Yu35rt/OvFUagCnlqlGwed/L4jGCK1t/C4Vbspv7lGU2eaPqICUyr5MbTCGd2PXVt4Svr+gSFlQTYn1w/cVlGB9aejzi+JM5GS8bTrYJ+pf6f91OTFQI4nkP3DnlfL/M2QzPqEQPr8uJixrpAr+moo7dt9de2gdqaEWyFqZaqmlAS8u/X7/P3fXnZb8f2J//yy1G9PflHXx7N2I7kmbxr9rB2W/WhjvqoTJr2u6/Df9fX0hQhTOOlMJ0BahMXXF30m9gM779tm0ZkcpysB6iaE5/6wbb5BlMNSHbO50YdfHxvc+sRbGUp7K/5sKvE8J3Ios9CVR9psS5z0fxk2b4T9hwP3Muyt9Fa+rXOu3l/atbCtohhga2BKJtpIQ/1nZHTXxeA4Vaf3f/yz1uiVKfxqH37kLw0N6KXuJ8XvtcGX5Ill9WvNvIUThrDJ1v7ioMMnrU/Xz8+7n7ejtWK0bN8gyKI3aLFY0qXLJU40MVfpv3XfzeyYVyv6LUFGYSxXixl6b/6g7SHRsMaR4e0vpsPu/rHFC8nP056v15Trjhs//OQ/dnJqDozDq/qGvsOj/db1/l8m48On91K7J6UXDXXvZ+kh3jb3W7h9yZ+ekNJD77XUNS0m8dIV/Cdz+jR1YP2v5/0QY+7SgAu2LZT2/Rs/Q1i9ZfP7vOy4LVYBGX8DL26XyRp+dvkj+H/39/qt++RTEKJwlpraA1gTFlEIjIrLiTDr32oZ0wXpX2O/5yAY3M4sQnwatCEqVRev9j8W6479/XTpvaeQmWCsSS3H3OBnHx8tJkW79yX4NWQV/U8pCIu/Pg4nG8CmF/dG915rNr5NyWeTFzltkedhPdEbY/bUR2CU3fLm/i1aiofx/bl8Sn2r9tAOUDgrnW8ODxtt37mKqPUvy7/+SuMtVNF2ZXc/bmmb/lqzE6DcnMTo0iwPAqWaKaZgi5q7g/Zuv3W//982Q0BoK56XSVgkpSxvtaAWxryzs/qmInn320+9fMvoc75T1SbYj9NgoC2jPp5pro//ML0kdbfr+bBlOmxq+35B2HufcLE03dstAy8alhfBktw7kOF1MPS/kFNiXt6E4HmqCL+W3c+s7aiVqyv+96NJ09UUVN0r7tA/rD8ue0NHmfdi/s1/9Zjm24g/GfeHY49Ki8aHPRl+2dIBpacQ9wKlkykFIdrv0ljcl3kIkgZ9LEqJ+u0WI+S99SMWdd8uyUAHqLRUi86aNTsrWEZFlpYmQZE2x0x/Z+/Fp/XGtzdzJmuKtZVF8vHVo6pYkWOyUUSU3P3FE+DRs1xTc8nlgSDA9RMrpy7qlXXTulOXh845IOf+XrGSlF/Shl485aMn/ef335fj+xV0TbS8mP6d8oyLUhz88PVhETqbZx/fLV/fL9/Z55Kv7ZeMpzgCWxhxfQooKmrmIhKfIMvv4WUHk95e4Wk5OmxJVrLq+tIrUN4OVBIHIfGlkkRVVA2o1LMWV7+v8KdJGbg63Ytaj+4esnxk/32uU/8fMVfkpLhwHElfK+j80aj2adzeKyyV00YnIli5fZkT5/5KCGyWBI1IWO3PSlP9T381/LavyrKtc79d1Yv6/LnsmiVANv52KLnp+Jy5tOE/zyN/v71PF6BfRRA+nnannAY0qDgnWp/AvKlwjf/eJD99BYXvIDb8eFU5L++JFLay7qvjGVABL4i2yPhLa5y9Laz/LT5X1+7YizabD1kE5N0g5fHa7VSA/zoQlhy9K+7c0NBmXyp+llQ8tDOX/sffi0/8uXtaH8v/acSNCNQ8cNLqr5312L8q+WPZMmiD+O/rV/0fWrdlrp8lwWVTKXyo89T5ViP6DfhnbFxxgEUzVBD9k2Zu7wC9ZCZZEDs+2fRJLnfGXyJAAmDrs0UvJqSM1w+e+kzauotaF64eauV3zexcsOf809zNLIvAGGc7/nzjklglfSWBZt1s+E3lpcH2U75acRkphO2g4Jx+Lluj4LhjK/2thSZbE/ze4vnQfef2L+/T0ObIA+nv49X75h/2q9k1VIZpfzmpzs0ZxlP+j/K/561v7e/7W1I0F4NSwrQAtFSi7LNSsv37/EvBhORg4LsH51nJaErCjprzZEUMVzpx++u2ppxybm993277iyvfV0sydB/cMiZoxA4aUG1xYovx/aYOFZui4df/XZZj3u2tt3M2d/qbAW/Za8r+nNA2Z395FPAzl/zAMvXjT9PjDEqfdWtn/1/s096myEIwQ/SGp91+u1Z+l/J/RvqLf0d/319A0D6eFqSygUVNyqYCYglJhXHoz3hddsIjEhWZEHkl+KHWrgS7bfBt8DjQ80Wf/8noejTzlMyoJoTnT4iwUBvpE8yFmK0iNT3XX+imq8rHfl3H8D2nL/y3hi56df146+fxbpI0xomVp+E+l1vJ/rR9rqayw27togo+6U/j8Hz4TFW/9388E50RlqD2mQuzxsiCSENWm+X8gq77W9kMl/llE5ddh5Zii8al5CWsonAqmsgpFnf69+3MU+KWKbymVS1TA2/C1xH9UEUcs7a3Xj+D392GnwpmC1nhaStpowQ9G8veX00/R2pOsId4CGqXJ3xg7Ijx1FbhBhvN/S/jsdaF3shK8LbR8Ale3l2opsgOLhtJ17aMAtWtL8TIHLfm/WBb06UwF6M8492r+ZP7hEoWYdnPpl//UL3+/3/x2WaXr3ES/dqq05X+frzVd/7P+3q8XgAUz9Sh4v+9Q5heE2X3fTDW3vy3UPoNXWre8xRwvCdm8LK0ytX0OLX5uxymfUclCUIv7JaMWyZKIt/dwWcXa4+fW7ApLS9/KiN+T4fy/Sfgk+P89aePmijtr+xfaXOktoLX8P/RVKp8n9l1GRvnflt8hvVh7oRxb3EuC2t+rtsJ8w5KbpLWlw4hRXbSZXvO9b/2o5f8T6VpWBoB/RnM8LJkp5wGNMsFchVvN7X0UqiW6Lc/xI6GjOM4sbSSkFny+qVekXpBuS0lw+OO7aHbcmr5Ser3UZzew91d6/p+W/mt9INUi8yrZDG0ivUuG83+pGf4TC+f7cL51xETc0VfBSmltiSOIrVgfyv9vGXAret6lMmQuWvN/NSwq1OS4D7AVraW0rf86J+ypEGLJMqrN9N/bL/pVpH8lq/stfeUuStN2WwX43xaAhTLlpzjtelc4NiU1QRYVbvtkKF7CcKYK986Ce56HjP329lykwv76wuE5n4m37vj9fv00oBWQn74rqrRPWBjTc3i8xPnDXr/xl3Aq3y4Xt/6JQfgulXUBKlIuT1qb30WOvyRUKgfsvutleVxv1qOXJXs/b5EypXLRr89NbUDU0H7Pj8v6PUdpxed/FaHftpTysZVkHf2/++XvyfoApij/53W/PH5JA7IALFML0OjYVP5sE4594sM1tl9srkxLIsTuW0pBEzW3+oJxzv7BPo6ksH0a0Gbnoc/N5orGV7ClZm/vRsvI8hq/KHV/9Fk/JGiGf7ysN70eVML4emnnLYVwRH4MThO1S8wXoWw+KeX/myv9dkvpZB/lZCSM7HNoHoyYXnjUMvjWwA+/bvdpnJ46EZrp7/vl/aL3rc30uYvJucNSL+s+TwAWyNSDkHwhY/v7TI3PgFEYdiF8a5QKieitvcSbJRabkR+fJMtAw1G638wcfdCiePXLqcI0w3cyfF/+BST69rvNl8otyY9tKIXR9/fzAvSTgnDlbft/w5jvYPfnvlmOJzGv3bvykIWNls5ioVZeZN4i7dj49f0vd8VQ/h8jQv8POTnJ+1D+v75fvkJOMamZXi2i+tLon2HpmV6/tBkBAJS5ByHNVchFBXLkxxL6+kXh8+K4Fj+/V3AzKniesO+CJjX7WqtSlC6UuV4OSp+YjNZPC/+94Ry9ryfnjfQcniDl9Jf/Wwf2lD1eCYLfC8Ljxah/QXp84RqR9fC+XMbzFqk3X9s8+GmyAIIuEyVyPP3ewDkHcnIeUZH95oFJ8n96Ifnf5PizpVJx197vp/Xx/JWyJb0b+uJyjVtO7JOZ6O//B2W9VSB6pvaZMy0TLI4LZXtyAi8V9tFXUqai5O5SRsGLnKz4o+bUmlDWilTn+rPzfNYmo/7SfnmB7A/1X8OlTYPa3FV7/lNWiL6CjfqBRuunAa1ohtK68pHaxJiaZa34rKW5UvP5WFQkeiFnn8NhCt81Kh76fw3fQ+TkPUStJptYaFWcPUHqeSXvV1Hy02OsrDPx6XIcJzXyPbXES8mqvEtKZbHPr6MMBikdqQj9Lln/EMdQ/v+8/rq7+uv/q2zO9wf7Dp3/+mL2N2Q+frpf/rmcjFt/77p9vQAsjCmtUF2wZD+mFoND7u2zsLWUrE6HlfPWD6zExKtaz5dVX8C9WEHVAiDHIiSLpsgCOnV6WAuG8ee8IDWRl8SRvU+thPOzt2IwyoO6/papRFcK4/ulnv91+fQgfDXrzQ0bhvHlst4toORP3v+1skdS3vmSwuEoD72+MV5KfWz3RZT/N86zxhJ650i3vqSP8y+V7fF5yqa1y9OL1ly8RerCPnPUB1sAFsbUTfC+cJlTBHQDi7KkJni77ivloXh6eeBG7dqv21Nne61Ac5iydcbfZ80ysS3q1oHzV+RknJ1GNA1Ez97f4yclMfN4iUWn3dfStL9JGEv5v5Njgfz4Qri8WP412YD04ubDc1gJn3Zf2edgjX8hbeVBPvZyGab2HHadF1ry/0bhSX1+f1Da839OY1/aP/NPl83ILzdDI/xnMwakNO7nC7XrNg6YDxQWx5TzgFqWIvx2WcDW2KqQ7Qua18nx226p875dtLB5vuyQviD/fDm2bv2uxAVj3i5VjFNRKoyVJaTNTfi19D8kTrSfZdSPMKosXyfTki31URznsuYJpvm9RWxt00f1Vc6tSJyIWX/+zBarkGSJ8wIhesHIz1AHjr18wFkfrweF/bsuI2vCcHNHV/PY/jvnrvdD8U39X9vH/yaDN3P5FvWvtdufN7MxwHc9iES+cpcALIw55gHN7nbBMhVR4Vzbvy9KYfT/LeH8RSlXSt5P5dMnamIaJH3y7SuN37/nwhKlgTmeUc0KYK0fp47U1Oj7gkb3eLmsXj6itGHz5eu7ifs8phelm2XYwv+PpZwe7Pqrxn4eNAjPq5ybvoL2Yfwnu/yEYcqjXyZxfiil4da+i/a+/D3743PSmv+3FaG/Jsdx05r/dd/XbfDMo25RUbxqfvx8mYE+zI9w/kVLBgEKi2Pbyrhr3DcH+U02Ksii7X1Squxs5VB3YFW43iTlOPdTzihf1hdSXyYzkixG/9L4eXMKawkb/pJVZhui+K2tnyZ8twa/nrncbUfn/JrMw8srx6xI9vui9V+T7fkxWfVNHfIvb6tF6V9uaBUbhRGf0UChUrl2y0D+iojc21ceiPL/gUz0YpgGFnkRGq3bOMnPfEw/yVdJvZyxddOXzvRS85EixRdNcWFCgMLi2DbTHw64NWchF1UkUWbcJyXhKQP7S/w7KRd6hwX3VYR+48jCtYnU7P4CWRXg+T58s2fpGc1ZEbaI0NPIr6b/oXTVki83/fTmEL/q/Ckx9Hzu2uLzoMcOdp2+tP2UlAVIFEZNz98418tbmq7nX/arz5Pjl0cfLims/wtpp5Tn/PFdsLP8n0ToLwbul/JNfilqFqHJum4/lbx2OPB30jI4ufU8ac//U3e3AdiaKSygJZERbU+Fb+LzYRLZXcE6RGsBNezQqtD7XTlZkNeaFBWdH1IL18+QCVCrZ7+8oF/9KuNnLvRenP5rzbs2bFP2ybTxkbftv18/VZhm+KNNf1jKTd9++9e2adoeGcbSInIyfHbfZAK5D5OmyddJ+dnnuLNhyS9vP9gvT5YJ0L6ASdT+m355YhCG0nZe/6kR3SZq5Y6N7330iS7l/8nyZh9PPypxv+laPH9Yv7xghFB8sXFjKM+pm98zVRksq242tt/wUP5/swAsjDn6w3XG7cgqNyc1EbYPhgTQJuH7txJPvjxUgWnh+ndThfoZm7yNG+GpyxOdPxqGXwsqyKhgtAOp5pgKLGraX0J6mIKoT2OLmLBx80qZl1dJOf+Xtn3F+asyLTnflNJBqTuPVvL/1OSb0QNKjPDUFgy1Wl3q/CmJRbuu/WF/SjYjEvh5fRd9oksvzL5smNbTrtNn/mYXBgm2/fP+xsbnrAL0TinXO/6+1cqq/U3/rum/OYpkPX9Bv/oU58fR4cJlNyfjBcCimHIi+mifrYSmLmBsJm+eV3MPlAr+aH3Ysd5y1RdAPyCrue+GKvgoblR4fp0e693RQulNsiqks3DUJsvL0nK1rITr9bKa1DsXylF856bOjJ2DcR/Pp1S5LyltbIIKs69K69Gz9vfn9900RdP2ADmMXoSW5mj025NXmNoU36f375ZVvrlUhtOBPa7hPnqBkyMNcKgW3px3NJ3f5K7VfHJ9v6jIeEJaL7k9lE4Pk/s/IOMo5T17fF/s0m/tsvACWT0L73fpOei5/1RWk7wXSWWxNvd/lRzH9VCa1/9n9ou+zGiZqy+DR4P3evfe5P1IhgJNT5qOnpz+S+Ev5f+58zvARkwhQDP7KOysn0MV777xFZovoNod6ivnvmD6j7Iq+HwTVq0iy2SrxxPT4r/gUbvW7rf/P5X622XurFxbemZTUIvXWho9FaRKTyusaLoga82yL372nme3hJgweiu5zwPRPt3e9tv0pXC9qQ+XigoVofYrXT79+zAdmHN0PecbkXpaLjUvt+T/fI7mqX+xYZeJknVs1zNBRELJ7rdxO63Hq7SoLx4vkNVLhH3mpXJN92trz9/tr/+BAfd/IXXR0Px4ELh5YNzs3LpaW5/TL88+2nl4GKXF0FupT3Vm/VCR+wsCsECmnoYp2jdXpW8ri65wfAn48NVEYrujXfei/u8njXve3VIBG4kBK1Qit+y+qK/cr/bh+VXn151B2LogHFNSCnPpvk8ruR+wSDmfdcG6/v+a7AbbVWDoxdT//6rMRLIyqQi1TadRGOz+SDDZfZGwtsda8n+0ZPHpLayttOb/XVDL/3OVByvHV/H3L2R9FhFfpkXheWYvCp/X4IV+CvRmc6249fwScyJowXr0jGwYDyrnRPn/F7ZIPwCzMtenOP3+qd9sdyVopqBW4EeFX7vDXacCNItQ75/vd1nqhynBtSLlMJ1o0u2XH5GTYRuy2ExdEbZUaEtOJ2PIAs0+a/tfqti0me+PZTf8ihx3w4imhSn1/Zs9jEmE/iM5Fg1R+Hwc+k9alsq0SMyItOV/+69x8I+2EA9ezLbk/10SCcG5Rai+eGiaLFlgI/+fNyRCU1mnbmeBW0sDUdqq3bu1oOZ/H95S/v9dtdAKwEKZYyL6WuU/NzspzEbQVf4nCV8Sod8v61OCRJXeoVsvVQAtBWTe1gr8n1fE5s2Va0WkWjlvQi3sUYVwKknxnUd1t6SxvP4rsiNSGN9kd8m6+DlxSVp2MlgiCZJvk5WYH7L8i9S7qZREx5j8b4+9qA/fP59gpoLW/D83Q/Eihe1pA3H8zN8vJ5+FF282nF/ei9DnNLidRai3jvvn4PeXymIp7O8G3FDeLKt6AWCxzNUXKCqQ5/AjKshFdlu41qhVNNN50nUqLL5BTg6GsP5ZC0hkfSoVfBKcI8mvbxuw0NzZ4PYcz2jfz30X/K6MZ7am7QI/adZtGig1Iyovkh2habdftJLWfn6ljzyIxJV9JCxK19a2LSrYNU/9iGyPj9uh/D83Lfl/jq5a64FYWb//9+BQqUtFriP/Ri9Cnyl1tzUNaTn8YinHbcnifcI5qZfFNbQ++La5ploDmIq5LKD+2NQFXemNsRaWfRH1U/Xh3fo5pMr0a+Rkv9DDIDxrl0pZaEYFpS4qZL6hoXnw5oKbOVxzpItSmP36aUcrmdZ0r9uv20NfsDxKPIpz34yo/+FI4LlJL3BqGfsJKcep51CG47+TtvyvcfQjfTi+YeLuB635fxfU8r+Pw3kDsorj75fhusNv/69D0yep6OuX/5Dcv1na0kj+L1nRfToqLSo4NR19P+ITTgNT9wHd5vhU1CqNfRAVKJ7J3vz7gkcr0a+W4+ZW7+eBC090jgTn6HVaqH1n78f3NRZw0Rx5eX1OC3mUBpaWLrYixb8XK/5+raVrZ83v5wKwCqPtr1qr4JW55yctkl7gct5RAZHFehTmUvodsm75fPam5NdXp0GFc9CS/3fBLvP/IOml4yeiQ5XLdOaEb2+Zw1Pd7xdNS98nJ1umaqPv7XZ0ToTmM00/XzNjOgKYnLnmAVWi6UymIhJMUb+mfYsNH45SATNpOJOl6/v6glILWJ0u5svleAoSJZouxIfThkmFzu/0y6+MfLPOFoDIj9L2NrS6ve90MRVaifqpjvyzy+u7GnzkUVGp/eeiaaF8Gtx75ZnyjobjRX3+0cm+nyqrSb/ztE1Hp6X/2pQ50fPQdc0/v9wvr5x5sFVUBg7l/7nD4tfztp8OayfoC0f/jHX1r/lD6T9qpdHJ5L+lv+5bW1oUktD9ldR8/yw5+QUs72fJ3+j8d8qqDHgRFk84jZwvFTEMkCY01sJPK9SHpCV/w90W/HemRStHtdD8DtN4wFmnzz+adx4pqzxk80/G5qNcrt4hK+vXm9LyR/voYgDLIX1hSdPQx8hqwvuclpSaCPfl8h/3aekvBOAUgwA947hPct7JmzRAG0lM6LKWh/JCXoJW+rSkLVSali41u7VvsL7EkJYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOA08QA5PNRFAAAAzhAHAgAAAACwQxCgAAAAALBTEKAAAAAAsFMQoAAAAACwUxCgAAAAALBTEKAAAAAAsFMQoAAAAACwUxCgAAAAALBTEKAAAAAAsFMQoAAAAACwUxCgAAAAALBTEKAAAAAAsFMQoAAAAACwUxCgAAAAALBTEKAAAAAAsFMQoAAAAACwUxCgAAAAALBTEKAAAAAAsFMuFICZOTw8fED/9+jG0/+y67p3tJzYu/vQ/u8jpI0/6d29XQAAAGDvIEBhF6j4/KHK8cN+6dL6D6elha/ul2cX3PE8t18QoAAAAAsAAQq7JIvDLBQP3f5t3PTuR9sAAACwABCgsAs6iYWiX4+2Wzl0fh1O4CYAAADMAAIU9sm24rNz/34dAAAAFggCFHZFJAxrfTbHuttVjgEAAMCCQIDCPrHicZN+mr5pf4o+pQAAADAzCFDYJX4QUu2cFg6DaxGhAAAAC4eJ6GFXDPXT7GSzPqBTDWICAACAHYEAhV1hm9s7Odl3c5vR75HbkR8AAACwABCgsEtK1sqDwvExbnaN+wEAAGDP0AcUdkXun2n/o3O2EaEZJqIHAABYMFhAYZf4Ue++6XwbN6Xg3hRTPQEAAMCEIEBhV/gm8SnSXksz+4EgQAEAABYFTfCwC2oDjlQgbmOlrLlNP1AAAIAFggUUdoUflT5F/8yhfqT0AQUAAFggWEBh13gL5aHEVstN3BPjHtZPAACAhYIAhV0SfTbTNsFva6lk8BEAAMApAAEKu6L2xaJtRsP7kfV+P0IUAABgYSBAYRd4YRl9wz3a3+Ju9G/dop8zAADAwkCAwj4oWSRzc/wmbvlJ7msWVwAAANgjCFDYJd5Cue0gJH9dJ9P0JQUAAIAZQYCecg4PDx/X/31Svzy0Xx7WL7p9mNbtJylv75fb+uXt/XJHv9zQL2/Qpeu6t8v8ROLT79/U3aifJxZPAACAhXJOgPZC5sdkJVqONqVurbq9Fy1fJDugD9c393/PlHGDSr6lD9/vysz0YXtA//ezeVPKYigLwZ/rw/VvZTs/r+j/vrBfntUvj+2XB6RD/lvreV9Gz9Nr8zM+F6e9mypGX5XCd4PMz4ELYzR4aAyITwAAgFOEtYCqAHmy2S6J0NXG4eGTdyHyZCW0HiZl4RmFU8XxLsL2mbKyPLYIHg3Xq2RDNL7lWHhekXaXxFtJCEth3+PS8hW9P2oN/bf9s/1ZmZZiWpLtvoJUmgeU0e8AAAALxY4QfplZjyby9pX9k2Vmkui61vjvw1EabPKZyVI4N9Yy68OQ//P6OzYR7BoHyTqtyxfLsfg8Oly59MCFJ4q3KOwa3/+69/Nl/TKlldv6N9XIdG/p7YzbiE8AAICFck4I9OJI+wOqha70pRovXmYXoLKyZIqcFBXe6ucXbW5+rMzPU1wYRGKRpftGWT9VQKfuBz+e/KkJ8Gjx5645X3Ej71Or83f2YdDlYTIdPn0dSF0QD7nl4/1QyvEBAAAAC8BboqyFbqjyfsoOrIxZ5EbzRnZSnk/yyAoqM5Kss3r/Vhzb+PRh+3EZ5/bP9ctXVk6zws1i90UW0lLcRecpanX98YlFqHU/6q86hbsAAACwULwA1X5/VnhGcyraa2YbiNQLHrX6XWv894KrZD3r5g5b4otlPY6i5uC8/vbWwT39favo/E9yPFhIAvekcMxbAUvN8NHLRVf4V7f0OfxcGnG/Ca1W2rHWypJbpTQBAAAAC2BNgKbpeCIrqF23zbdzWhm/0PgrQZi6geNXJBE7F7b53f77fbr8sjTQh/fr+79vde5EQntIUEXC0277/0jc+2vV2vufthShLfs2pRu5HwAAAPZENBhExVLNsiRm32NnbIZ/qvOrJvC81TYfe5bMQBK2D5NYDEZx92MNbqrw/Hrnhkjd/dIiUn52Uf/Pmtt2vz5rbY6/VsZz2OD+JmKxdr+lOAQAAIA9Ek1E/zP98i1mO4s6+5+5UlbT97xSJqQXOI+XY4E3NEdkbdodbSb/1zI93vJbsu5pmG4Ymug9WT6fLyfnxszzZfp4iMjWa23qf1+/vKNfbpSVaMwvCfqsdHBWFtAt+M9jPrBfdC7TL5Bx1CyULffX4nY38hgAAADsgRMCtBdLt/WCSIVMrfnaCj4VY5MKUIn7V3qRGQ1e8eddqdbK/p6mDt9nVcLnw/QzNYf68D2///t70j43pt2vXzb6sX55ZeUerfh9pfFXxejzZRXXR7uM+yXRm/c9XkVz7+f3Szs1Adgqskvu1ib/9+kFAAAA9kxpPsaXue1as+YXy/Q8y/kRWbEOJG4+9udP2g/UWGetP1EY8vbLKm5pU/a3FtwSt1//8/PSz2qq+PuMXgR+3yYCWwdF9cs/7Vc/XVYiuRR/Iutxnf+fv0FTfK2LgPen1T2RsuWzRdADAADAjikJUC9IFGtRshX/lVMO9kkC7+FmVyR8S8JT3Hka5qkF8pODsJTC97sDze//b3BN5K49rk3sz03C8zbZEg1fEqLfJCthm/2XwnpetFn/62WEV2691hd1DD5+lAN3DAAAABZEKECTsLFWtSER+FSZji8u+OG3VdiVRnvb/2u3GLkd8VnOPy+kLMXm9z5M2ux+rZQF3trp6f8/9s9GxeeNMjG9my/s/54rq3iNwpHv1W7/TyMHoQ315x1LLY1EghQAAAAWQK1i1qbj3Oxbs1Tp9pTTMX2WxGLX9+n70X75HRkOWyfHonErUpPzU0WaLLJdCl/Jnb/f4I7d//29SPx2mZEkbP+6rPqWWr8jYZ/5Kml0XoY/kzmlxdK6Rf9PAACABVEToC8cONdW8I/fcGqeNVLz+7XOD+9ftji+TI77Vw5ZEaey0NpPYlr/rL+ZWvP735MykQhVy+f/JTsgidDvk9jiGQnm58s47PXbfIbTu1lyZ0pRCwAAABNQFKBBM3xplPaUVkZr/ayJiVcmofRCt18ktiQ+dQqB3PM/GTftvwThfGF0IIXjSySOy2j97XNbPj29f2pd1mfvLZZR3OqE/60Cv+SOP95KzfosMvycAAAAYA8M9Y1TEdUVFpH1in0qAWop+XnUtzKJZP/lJn9tye1RpL6OT5PyJzd9OEsj0+2ArXx+9CWivP4/y374PjkOi/3P63b/UNza86MuHWNHv5fcj4Q84hMAAGBhDAnQl8rxyGglGkSS/5+2zVeRkmXwCTJsGdN127fypyUOk7/mr8p26PXRgKPImvfSykChfyB1oWTde+EcA45a6P3VOH6lTCNA7XV+vSscb8WG5bByDgAAACyEqgBNFkad9mfIApr3bSPy8rX2k42RHy9xoiyL5E7iidPz9U/d8rOhTwncLImyl0YOFKaYymH2963PZif9PitkK25NbCsPb4jbfK95iY6X3G9hyCINAAAAC6Flepqfdts1y9U284HmfpGRaCiKuySSXyrrzbn+us74sSmfLfWmcvv/koIb2lfy0IWzJO7+676sn4ZsaY5EnL+Hln6gNXEYvUCMcU8kTpsAAACwMFoEqIqpbGEcquA/WzYgNb8/3oTJWgOtXzog56cDJ37ahaskYjey0KZBNlc4tyIBrv8vrEwQ/1cltppGYX2h7J/XSz28tkvC0CCvmvDsJP6c5hgiMVqKXwAAANgjgwI0ials0atV8LqMGRFtscLwUOJPPyq/Uwij7o9En3dj02Z4bzmNBiLl/5eUnTkS2SVronXjtnRPeyU9+xyv0UAhu/0EaXRW4heFbQciZfdKfgEAAMBCuLDxPLXGfakci0OR2GKl22oFHSuevjRwy/eJ1O2flnoY/4bUp4vKfv0HGcdTnRtScF+FYyhAU//PKwJ3wq8D9ef/pMRE8X4YuNk1XjvkxpXuvJK7NWFfsvIOrQ8RuZst6EPnAQAAwJ5oFaCvk5UlTMVIrtxLFb0K0BdII6b5PTfDWrcs7xiwCv6SrASoFYSRe2ptbRagffh06qXr8qY7bP0Ysn5q3B24863os8f0XDvlU40ucFMK27Vr/X6R9j6Zev7YeVbHhjXCW6LtPgAAAFgoTd/ITk2xfroj30/zXF/AXrQ9XNp5msRNst4q9gqph1HF6Y1SbuLNPGFkM/xnu3Cc8Nrsr1loHxacL8F6rZvD0L4WN1qOy8CxaNtbSj01dzb9VntX2VdKSwAAALBnxlT8LzHX1ISJMmYw0pcE10fCocVqGQlAH8YrRobvqQPu5fUbexFcE8nXOTfs/0FwLKKTzcVUN+L4UBik8dyha/O+0qCzVjeHRD0AAAAsiGYBmsSVWkJ9s2ee19GKqqbR5slS+jRzvW3et8Li9b3/r29w0jaBR2Im73uatIUvT44vUhbbOcwt/V6HrIiZ6GtBInWr5dAyFBa773ADv4as3pHQ7IJjY7DhjY7ZcwAAAGAhjG36VAtjZG3y7jy9sZn7qRKLMi8omvps9iJV+6rar/fYMFo+uzF8n1O43louc3j/q9S5Nrjeu+lFbRdcUxJTLfsjQRqJwSHxuik1MbxpM7zI+nykpRkUAAAAYCGMrfR/KdgXWcyUz5FhvkzKFjG7jBlV/wrjhhTc1P6KLdMGfbacDJcE7r59oPk9YhMxqBxKXbQPxWfpHJGyRbImTltFahR+f1/bULoPfwwAAAD2zCgBmkSWnZS+c+7Yir46H2hqfn+6nBQHfvsVvb9vk3b+vQtPV/DjS2U4fE9z14jE81W2COTbZFjMSsM+uz+6z03cjfYfNF6XGfpq05BgbRWy0XX5/6CwHwAAABZE6zRMlp/ql7+Z1r1Vy66rBfQbKu48TeI5O/2+oabtNXTEfi8eXyFxP0/rbkv4ovBEbrV0Ebg9uC6KP0Utze+Tcf0iW+cCHXPtYSGc0VRS72v0w/cZ3obSy0X2z4YRAAAAFsImAlQH+vwtWa/o/eczdf2BOodmpWn6yyS2Uvn5Rf+HjEcF3NMqbipX9uF7eh++35Zy+HzYJNj3tt6NP5ZhbpN20fW9jW6eFrzltzRoaKww7RrdwQoKAACwIEYP/EiCLX+e0QsJbzEL+4Ga5u2aSNDtn6p8V72GfkUodxXw4bLLZxfCpwOUni7DfR11u9VC+z45KcRKXRgeL+cf/iWjFq+buGtffvwxAAAAWBCbjjz+9+m/JKgypYFITy9c5/9/STYgidY/du5HYuR5Ug5f0XlZd++npI3XBW6InBThurR+V/20Ufve+zZCNIrDWroEAACAPbKpANVm9VLzp63wr+utiU8MzrPffu+Ca3XRid03aX7PfK/E4bL+XaHN8MG10fRLUXhfN2KA1NukLobs/s+V85PIEp23N+0XGonNyH0AAABYCBsJ0NQMbz97WWqeVtasoKn5/ZPNOSVRNnZaI49aQG0zfBS2E+FLfK60WWj/vTTirLLi3PZ+PHzk50xPCwcSj67fVCx2hXVp2A8AAAB7YpvJv38y/ZdEVF73o9Gfbs5Roj57nXF/I5Lg+0k5KXB9OL1A1vBdYY77f3t9aQBTiSyqa9NE5fXnyflFtnL6fsKdTDcHaO2FBgAAABbCNgJUxZet6Etf7/lk99Wh50m5yTTve1tldPoY/ocLSycnm4Gvc83wGr5oPkkfV2PnJ83hqTU3W7++uvFrTbOiYVBrbMMyFNaa2D6Q2DraQsnyHqUtAAAAWAAbC9AkELMI7aQ+CfiX608vUvQLRJ8sw02n/10mwI3Yj4Rk3vfJZp+ul77WY68bbaFN4bHdAqz7Nlzqv8bVV8v++Y/98qq0/J77t8s/lnZ8ujt0/2Owz9WnO78OAAAAC2AbC6iSm5SjZnTbzJwH1XxOcJ4E+/4fmY7cDO/9OdEMnwZMPVzqVrNNm98zPyR1UWSF1Ffvsy9o0F+39K/LUJ9dK7Yjgb+JpTISnNFxAAAAWBDbCtCfSP+RgLAi44mpifZz5aT4y+HIwuv1GzRt17DW1FJz7ccksfXlZn8kiHJ8/fYWYfR9Z6Pw5HW1gn6f7I9vl2PrbM26qP+tgjzqcqH4b9xvgr3WzjW6bToHAACACdmqYk4izAqPkjUrN71/XnBuJltRf1gmJDV7v02GrW1fLutN8faTkV4wbTxAysSZF3KRUMp9aL9ddkzv59fIyemgoq4DuvxWf1+1T3H6+LZW0Oj4WCJBm+EznAAAAAtjCstQnhO0JCLyvm932z4M2WL1WzI91upo/+26iq0nSiyyPNv2Uf17Zt33/fT7FG2K/yeyI3q/ruv/1L9a0/ZYQV6yfEbntRIJ22gfAAAALIgpBKjt01ibaPw6icWdtVD95sTN75mfkLLVLW8/MdgfnfvfB6x9g6R7/GEpWxSj5Rt3IUJ7Pz6m//tZWU1FVYuvfOyt/f38hIzD35ttLh8VXOeGFfAtYhcAAAD2wNYCNImx3AyfhUBej/7zehdcs9Xcn5Uw5mbv0v12Eo+Oj5hkhH7P98iqa0BENKWVoiL0V5OFcnJ6d7UbgorP/LJwICfjJpOPfY+0UbOQl+63xc2MFcteOAMAAMCCmGpwxi+mf2/R7Nz+kmUxr08l7kphjCy0pfDkbWtNu20Da19IEu5fL2VLayTYdVFL7a9MaQ3V6bH65Qf6VV0eKHXRZsM21vrZFbY3sX5G19fiDQAAABbCVAI0N3HXBJ0dSR0NDPkv2zZtN4TxQOqiJwq7DeukArm/X+3v+s/SZn4Wh1IX6bqoSPymXjS+WoXjphbR/rpn9Mt39KuvltUgrEjQ5e2omfzrZRwloejPGcPBBG4AAADADrlQJkCFYy9kVEw9Q2KR2RXWbVPpnNZPG8ZP9ofcdumLTrr/F2X6cP3faQqov512RV0BDiWOwzx11Jf3buh35vPyR/3y1uD669LyhH75/H65VoaFYFfY911JQLcQiXkx+7YVjNH1pTgDAACAPTOJAE2ogHyG2a4JG98Urk25k4u7APXjGVKfmicPZvHi6G1zhbF391vTV6L+mpSF2tC6Dh56Ulov3Z93299jJAaj8Oi0S98t4/GidluRONRVAAAAABbIlBN0/xdp64sXTTg+x9RLUgjj+1yYRGJrn7jzpvg2fZFe0P1dWc0oUOqnGu2LBF1NfIpzJ6/bOU/9ud4NtbD+LzKeyNLs72WbT3Ha7Si+AAAAYCFMJkBT/00vJEtC1G6r6PgvsgNSGP9IpNisbPf5sM4exj5839L/fXclTOFl5t+H235hSsy+yI3OHff7svh87hZ9dSN//PFt3G2dyQAAAAD2yNSfKHyx1C120b4be0Hzm7I7vtuFQ+Rk2BRriXzbrsLY+/Nd/d9zZTVFU2kezppFtCbGaiJ7SICrdfY5E4nPUrxvIhr9Mxt6uQAAAIA9M7UAVSvhbTJuHsadWD8NagG9zWzXxFBedtVFYBWAldh9jqxG7pcG6YwVVZEw890hfHrQ47f3y7f0YfrmiWYp6Jz724hDf08HhXUAAABYEJMKUNfEHVkSI7H3n2WHpDDm/qo2XCVroIZ/p2E8CkDX6cCsr+1XP07WBfCQJbF0TrQ/d4GIrtVF4+lJfTh+ULank1gw1uJ+jLve7SjdAQAAwAKY2gKqqFiLrIgZu08/vflW2T0vNmHxWCGk8bOz5veIJESfLSuLqB2FXxJufj5RkbJAKz0jvd9n9/5+3Qxzs3YbHms9v3TPAAAAsBCmnIYpo+JORcsDzT5rkRI5Fj87tyweBaYXlIeHhzaMpWmPdP+LZQEkEfybadL5z0+LnXdVqX2Fyu6z4jMf0xeB/69ffnAm0dkF+2xY8voY7H21Tj0FAAAAewYL0SkmiVGd//NT0r9OTP+R9hSJn/F7ZSU4tbvEkbDdkyX6zPOA/inq/+39K4YAAACcEaj0zkOSML0yLRm1aurgq/fO/MlTGAECFAAAAAB2igrQLEIBAADOCnMMQgIAAAAAKIIABQAAAICdggAFAAAAgJ2CAAUAAACAnYIABQAAAICdggAFAAAAgJ2CAAUAAACAnYIABQAAAICdggAFAAAAgJ2CAAUAAACAnYIABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhD/P+NoqRkccduFgAAAABJRU5ErkJggg=="/>
<image id="image1_215_464" width="756" height="756" preserveAspectRatio="none" xlink:href="data:image/png;base64,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"/>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/block1/builtForWeb3&Beyond.svg">
<svg width="336" height="336" viewBox="0 0 336 336" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g clip-path="url(#clip0_188_200)">
<rect x="24" y="0"  width="288" height="336" fill="url(#pattern0_188_200)"/>
<rect x="24" y="0"  width="288" height="336" fill="url(#paint0_linear_188_200)"/>
</g>
<defs>
<pattern id="pattern0_188_200" patternContentUnits="objectBoundingBox" width="1" height="1">
<use xlink:href="#image0_188_200" transform="scale(0.00156294 0.00127877)"/>
</pattern>
<linearGradient id="paint0_linear_188_200" x1="168" y1="32" x2="168" y2="336" gradientUnits="userSpaceOnUse">
<stop offset="0.5" stop-color="#0D0D0D" stop-opacity="0"/>
<stop offset="1" stop-color="#0D0D0D"/>
</linearGradient>
<clipPath id="clip0_188_200">
<rect width="336" height="336" fill="white"/>
</clipPath>
<image id="image0_188_200" width="640" height="782" preserveAspectRatio="none" xlink:href="data:image/png;base64,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AggArCuvDUzj8jAt3BoCIACwIXlaWBBsB1PAAMCW1L0D96cxFzSKRtAAwEjqNYJ55/BVYZ1gIwiAAMDYpFgwly65MnhlGnuCqSQAAgATUVcG5+qxOwTCqSEAAgDbJsWGHAI70Q2Dl9Ufzw4MJkwABACYcuPKW73n0QYGAKAwAiAAQGEEQACAwlwUI7LmDwBgssadt1QAAQAKIwACABRGAAQAKIwACABQGAEQAKAwAiAAQGEEQACAwozcB9BZwAAAkzXuvKUCCABQGAEQAKAwAiAAQGEEQACAwgiAAACFEQABAAojAAIAFGbkPoD6/gEATNa485YKIABAYQRAAIDCCIAAAIURAAEACiMAAgAURgAEACiMAAgAUJiR+wBWSf9tfQEBAMZr3HlLBRAAoDACIABAYQRAAIDCCIAAAIURAAEACiMAAgAURgAEACjMyH0A9f0DAJiscectFUAAgMIIgAAAhREAAQAKIwACABRGAAQAKIwACABQGAEQAKAwI/cBrJL+2/oCAgCM17jzlgogAEBhBEAAgMIIgAAAhREAAQAKIwACABRGAAQAKIwACABQmJH7AOr7BwAwWePOWyqAAACFEQABAAojAAIAFEYABAAojAAIAFAYARAAoDACIABAYUbuA1gl/bf1BQQAGK9x5y0VQACAwgiAAACFEQABAAojAAIAFEYABAAojAAIAFAYARAAoDAj9wHU9w8AYLLGnbdUAAEACiMAAgAURgAEACiMAAgAUBgBEACgMAIgAEBhBEAAgMKM3AewSvpv6wsIADBe485bKoAAAIURAAEACiMAAgAURgAEACiMAAgAUBgBEACgMAIgAEBhRu4DqO8fAMBkjTtvqQACABRGAAQAKIwACABQGAEQAKAwAiAAQGEEQACAwgiAAACFGbkPYJX039YXEABgvMadt1QAAQAKIwACABRGAAQAKIwACABQGAEQAKAwAiAAQGEEQACAwozcB1DfPwCAyRp33lIBBAAojAAIAFAYARAAoDACIABAYQRAAIDCCIAAAIURAAEACjNyH8Aq6b+tLyAAwHiNO2+pAAIAFEYABAAojAAIAFAYARAAoDACIABAYQRAAIDCCIAAAIUZuQ+gvn8AAJM17rylAggAUBgBEACgMAIgAEBhBEAAgMIIgAAAhREAAQAKIwACABRm5D6AVdJ/W19AAIDxGnfeUgEEACiMAAgAUBgBEACgMAIgAEBhBEAAgMIIgAAAhREAAQAKM3IfQH3/AAAma9x5SwUQAKAwAiAAQGEEQACAwgiAAACFEQABAAojAAIAFEYABAAozMh9AKuk/7a+gAAA4zXuvKUCCABQGAEQAKAwAiAAQGEEQACAwowjAK7036iqqhMAAIxFylazA3etxIjyLuDlNDo5uM3MzCzH5i2nkV/YqTROjONFAQBwjuvT2J3Gnthi1uor0i3nGyerrj0BAMBUG1IR3Ojj5urMdzJPAS/X9wuAAABTLs3YbnW2tRccb88B8Pb6hgAIANBevax3KgfAU/WNToxJLk1utTwJAMCZPNWJ8bmyvp5aXRBYzwefjjFIz7MvP1cahwMAgC3JWSqNpTTmYwzqfFadCZX1k2dzsUV1Sj1WnetgAACwKTlDDWSqhVFmV/s2gCz133mkvvNQbFEdAJeq8x2uTAcDAFxQnacOD8lTSyMGwF7WW+i/c24c08D1dPLSkBfcCQAA1lUHwNPjzlLVWrO9fd9sLkaQHr9nIATOD/kam0QAgKLVhbPZIffvGwh/I3VqqYZM/870ffJQuuQ1e4szMzN7YwR1Sj1eP9e1Qz5/qP5e50lfPxPrP3e13uc93uM93uM93uM93uMb9Pjr0kOPDPn6Y9Ft27J3iye19T9XzmRzaVybnutovq//LOD8zXNjwblRq4D1C70ijevW+JLdAQDA3Br35wLaFWMIf536e+SMt9i7/0wArLtK31DfHHn3bn6+mbU7VWs6DQCwRlHsAjlqM3pt+W7sD5P3G/iisVUB11LPda/EFg8yBgBoiYnmoXofxr7oHvt75EJffKBv0aGNGgAADVOd25llfqMPOl4/wGkeAAANU3UbR5+z83cjD8qpsdcW5kAAANAIKbvtrzPc6Wqz/QP7poIzmzYAAKZc1e3HXI1UxKvOHhuy+QQJAMC2GVj3dyhGkZ7gaN+mkE4AADBVBsLf0RiH9EQn+0Kg6WAAgClRT/v29m6cjHHqqwTaGAIAMAX6NnyMr/I35Jsc6vsmC6aEAQC2X8pgs7ldX18uOxKTVO8OPt03JTwfAABsi5S95vrW+53etpnZgYWG2THVQACAyamD3/G+/HV8R/JXrv4NBMH8QuYCAICxGBL8tq/qt86LytXAI9XZaeHe1PBhYRAAYPPq0HdwIF+drvdjzMaIZmJM6hLkXBoH0+j0fWoljVNpnKiv+fbyzMzMcgAAFKzOTznQ5TZ7u6Oboebq+3pydrohjSMpP63EGIwtAParK3/zaVwZ54ZBAAAubDmNm9O4KYW+xRiziQTAfnWy3RPnJtvZEAwBAJajnh1N4/bozpYuTnqm9H8CNtgfEAWYwIAAAAAASUVORK5CYII="/>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/block1/noCodeJustAi.svg">
<svg width="336" height="336" viewBox="0 0 336 336" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M27.664 82.976H25.368L43.232 49.656H48.608V86H43.232V58.112L44.408 58.392L29.344 86H23.688L8.624 58.448L9.8 58.168V86H4.424V49.656H9.8L27.664 82.976ZM65.3109 86.56C62.9215 86.56 60.7375 85.944 58.7589 84.712C56.7802 83.48 55.2122 81.7813 54.0549 79.616C52.8975 77.4133 52.3189 74.8933 52.3189 72.056C52.3189 69.2187 52.8975 66.7173 54.0549 64.552C55.2495 62.3493 56.8735 60.632 58.9269 59.4C60.9802 58.1307 63.2762 57.496 65.8149 57.496C68.6149 57.496 70.7802 58.1493 72.3109 59.456C73.8789 60.7627 74.9615 62.5173 75.5589 64.72C76.1935 66.9227 76.5109 69.368 76.5109 72.056C76.5109 73.5493 76.3242 75.136 75.9509 76.816C75.5775 78.496 74.9802 80.0827 74.1589 81.576C73.3375 83.0693 72.1989 84.2827 70.7429 85.216C69.2869 86.112 67.4762 86.56 65.3109 86.56ZM66.8229 81.912C68.8015 81.912 70.4629 81.4827 71.8069 80.624C73.1882 79.728 74.2149 78.5333 74.8869 77.04C75.5589 75.5467 75.8949 73.8853 75.8949 72.056C75.8949 70.0773 75.5402 68.3413 74.8309 66.848C74.1589 65.3547 73.1322 64.1973 71.7509 63.376C70.4069 62.5547 68.7642 62.144 66.8229 62.144C63.9109 62.144 61.6522 63.0773 60.0469 64.944C58.4789 66.8107 57.6949 69.1813 57.6949 72.056C57.6949 73.9973 58.0869 75.7147 58.8709 77.208C59.6549 78.664 60.7189 79.8213 62.0629 80.68C63.4442 81.5013 65.0309 81.912 66.8229 81.912ZM75.8949 58.056H81.2709V86H76.3429C76.3429 86 76.3055 85.664 76.2309 84.992C76.1562 84.2827 76.0815 83.4427 76.0069 82.472C75.9322 81.5013 75.8949 80.6427 75.8949 79.896V58.056ZM86.1547 46.856H91.4747V86H86.1547V46.856ZM111.635 58.056L96.8507 72.112L96.9627 68.752L112.699 86H105.923L91.5867 70.376L104.187 58.056H111.635ZM134.211 76.928H139.307C139.009 78.7573 138.299 80.4 137.179 81.856C136.059 83.312 134.585 84.4693 132.755 85.328C130.926 86.1867 128.779 86.616 126.315 86.616C123.403 86.616 120.809 86 118.531 84.768C116.254 83.536 114.462 81.8373 113.155 79.672C111.849 77.5067 111.195 74.9867 111.195 72.112C111.195 69.2 111.83 66.6613 113.099 64.496C114.369 62.2933 116.123 60.576 118.363 59.344C120.603 58.112 123.161 57.496 126.035 57.496C129.059 57.496 131.598 58.0933 133.651 59.288C135.705 60.4827 137.217 62.256 138.187 64.608C139.195 66.9227 139.606 69.816 139.419 73.288H116.515C116.702 74.968 117.206 76.4613 118.027 77.768C118.886 79.0747 120.006 80.1013 121.387 80.848C122.806 81.5947 124.43 81.968 126.259 81.968C128.313 81.968 130.03 81.5013 131.411 80.568C132.793 79.6347 133.726 78.4213 134.211 76.928ZM126.091 62.088C123.665 62.088 121.649 62.7413 120.043 64.048C118.438 65.3173 117.374 67.016 116.851 69.144H134.043C133.894 66.8667 133.073 65.1307 131.579 63.936C130.086 62.704 128.257 62.088 126.091 62.088ZM151.786 58.056H157.162V86H151.786V58.056ZM167.802 57.496C169.37 57.496 170.788 57.72 172.058 58.168C173.327 58.616 174.41 59.288 175.306 60.184C176.202 61.0427 176.892 62.1253 177.378 63.432C177.9 64.7013 178.162 66.1573 178.162 67.8V86H172.842V68.976C172.842 66.7733 172.3 65.1307 171.218 64.048C170.172 62.928 168.567 62.368 166.402 62.368C164.722 62.368 163.191 62.76 161.81 63.544C160.428 64.328 159.29 65.3733 158.394 66.68C157.535 67.9493 157.012 69.3867 156.826 70.992L156.77 67.912C156.956 66.4187 157.348 65.0373 157.946 63.768C158.58 62.4987 159.364 61.3973 160.298 60.464C161.268 59.4933 162.388 58.7653 163.658 58.28C164.927 57.7573 166.308 57.496 167.802 57.496ZM188.298 57.496C189.866 57.496 191.284 57.72 192.554 58.168C193.823 58.616 194.906 59.288 195.802 60.184C196.698 61.0427 197.388 62.1253 197.874 63.432C198.396 64.7013 198.658 66.1573 198.658 67.8V86H193.338V68.976C193.338 66.7733 192.796 65.1307 191.714 64.048C190.668 62.928 189.063 62.368 186.898 62.368C185.218 62.368 183.687 62.76 182.306 63.544C180.924 64.328 179.786 65.3733 178.89 66.68C178.031 67.9493 177.508 69.3867 177.322 70.992L177.266 67.856C177.452 66.3627 177.844 65 178.442 63.768C179.076 62.4987 179.879 61.3973 180.85 60.464C181.82 59.4933 182.94 58.7653 184.21 58.28C185.479 57.7573 186.842 57.496 188.298 57.496ZM224.468 76.928H229.564C229.265 78.7573 228.556 80.4 227.436 81.856C226.316 83.312 224.841 84.4693 223.012 85.328C221.182 86.1867 219.036 86.616 216.572 86.616C213.66 86.616 211.065 86 208.788 84.768C206.51 83.536 204.718 81.8373 203.412 79.672C202.105 77.5067 201.452 74.9867 201.452 72.112C201.452 69.2 202.086 66.6613 203.356 64.496C204.625 62.2933 206.38 60.576 208.62 59.344C210.86 58.112 213.417 57.496 216.292 57.496C219.316 57.496 221.854 58.0933 223.908 59.288C225.961 60.4827 227.473 62.256 228.444 64.608C229.452 66.9227 229.862 69.816 229.676 73.288H206.772C206.958 74.968 207.462 76.4613 208.284 77.768C209.142 79.0747 210.262 80.1013 211.644 80.848C213.062 81.5947 214.686 81.968 216.516 81.968C218.569 81.968 220.286 81.5013 221.668 80.568C223.049 79.6347 223.982 78.4213 224.468 76.928ZM216.348 62.088C213.921 62.088 211.905 62.7413 210.3 64.048C208.694 65.3173 207.63 67.016 207.108 69.144H224.3C224.15 66.8667 223.329 65.1307 221.836 63.936C220.342 62.704 218.513 62.088 216.348 62.088ZM15.064 153.56C12.6747 153.56 10.4907 152.944 8.512 151.712C6.53333 150.48 4.96533 148.781 3.808 146.616C2.65067 144.413 2.072 141.893 2.072 139.056C2.072 136.219 2.65067 133.717 3.808 131.552C5.00267 129.349 6.62667 127.632 8.68 126.4C10.7333 125.131 13.0293 124.496 15.568 124.496C18.368 124.496 20.5333 125.149 22.064 126.456C23.632 127.763 24.7147 129.517 25.312 131.72C25.9467 133.923 26.264 136.368 26.264 139.056C26.264 140.549 26.0773 142.136 25.704 143.816C25.3307 145.496 24.7333 147.083 23.912 148.576C23.0907 150.069 21.952 151.283 20.496 152.216C19.04 153.112 17.2293 153.56 15.064 153.56ZM16.576 148.912C18.5547 148.912 20.216 148.483 21.56 147.624C22.9413 146.728 23.968 145.533 24.64 144.04C25.312 142.547 25.648 140.885 25.648 139.056C25.648 137.077 25.2933 135.341 24.584 133.848C23.912 132.355 22.8853 131.197 21.504 130.376C20.16 129.555 18.5173 129.144 16.576 129.144C13.664 129.144 11.4053 130.077 9.8 131.944C8.232 133.811 7.448 136.181 7.448 139.056C7.448 140.997 7.84 142.715 8.624 144.208C9.408 145.664 10.472 146.821 11.816 147.68C13.1973 148.501 14.784 148.912 16.576 148.912ZM25.648 125.056H31.024V153H26.096C26.096 153 26.0587 152.664 25.984 151.992C25.9093 151.283 25.8347 150.443 25.76 149.472C25.6853 148.501 25.648 147.643 25.648 146.896V125.056ZM35.2358 125.056H40.6118V153H35.2358V125.056ZM51.2518 124.496C52.8198 124.496 54.2385 124.72 55.5078 125.168C56.7771 125.616 57.8598 126.288 58.7558 127.184C59.6518 128.043 60.3425 129.125 60.8278 130.432C61.3505 131.701 61.6118 133.157 61.6118 134.8V153H56.2918V135.976C56.2918 133.773 55.7505 132.131 54.6678 131.048C53.6225 129.928 52.0171 129.368 49.8518 129.368C48.1718 129.368 46.6411 129.76 45.2598 130.544C43.8785 131.328 42.7398 132.373 41.8438 133.68C40.9851 134.949 40.4625 136.387 40.2758 137.992L40.2198 134.912C40.4065 133.419 40.7985 132.037 41.3958 130.768C42.0305 129.499 42.8145 128.397 43.7478 127.464C44.7185 126.493 45.8385 125.765 47.1078 125.28C48.3771 124.757 49.7585 124.496 51.2518 124.496ZM86.8906 153.56C84.5012 153.56 82.3172 152.944 80.3386 151.712C78.3599 150.48 76.7919 148.781 75.6346 146.616C74.4772 144.413 73.8986 141.893 73.8986 139.056C73.8986 136.219 74.4772 133.717 75.6346 131.552C76.8292 129.349 78.4532 127.632 80.5066 126.4C82.5599 125.131 84.8559 124.496 87.3946 124.496C90.1946 124.496 92.3599 125.149 93.8906 126.456C95.4586 127.763 96.5412 129.517 97.1386 131.72C97.7732 133.923 98.0906 136.368 98.0906 139.056C98.0906 140.549 97.9039 142.136 97.5306 143.816C97.1572 145.496 96.5599 147.083 95.7386 148.576C94.9172 150.069 93.7786 151.283 92.3226 152.216C90.8666 153.112 89.0559 153.56 86.8906 153.56ZM88.4026 148.912C90.3812 148.912 92.0426 148.483 93.3866 147.624C94.7679 146.728 95.7946 145.533 96.4666 144.04C97.1386 142.547 97.4746 140.885 97.4746 139.056C97.4746 137.077 97.1199 135.341 96.4106 133.848C95.7386 132.355 94.7119 131.197 93.3306 130.376C91.9866 129.555 90.3439 129.144 88.4026 129.144C85.4906 129.144 83.2319 130.077 81.6266 131.944C80.0586 133.811 79.2746 136.181 79.2746 139.056C79.2746 140.997 79.6666 142.715 80.4506 144.208C81.2346 145.664 82.2986 146.821 83.6426 147.68C85.0239 148.501 86.6106 148.912 88.4026 148.912ZM97.4746 125.056H102.851V153H97.9226C97.9226 153 97.8852 152.664 97.8106 151.992C97.7359 151.283 97.6612 150.443 97.5866 149.472C97.5119 148.501 97.4746 147.643 97.4746 146.896V125.056ZM123.022 153.616C120.857 153.616 119.046 153.149 117.59 152.216C116.134 151.283 114.996 150.069 114.174 148.576C113.353 147.083 112.756 145.496 112.382 143.816C112.009 142.136 111.822 140.549 111.822 139.056C111.822 137.04 111.99 135.155 112.326 133.4C112.7 131.645 113.297 130.096 114.118 128.752C114.94 127.408 116.078 126.363 117.534 125.616C118.99 124.869 120.82 124.496 123.022 124.496C125.449 124.496 127.633 125.131 129.574 126.4C131.516 127.632 133.065 129.349 134.222 131.552C135.417 133.755 136.014 136.256 136.014 139.056C136.014 141.931 135.417 144.469 134.222 146.672C133.028 148.837 131.441 150.536 129.462 151.768C127.521 153 125.374 153.616 123.022 153.616ZM121.51 148.912C123.302 148.912 124.889 148.501 126.27 147.68C127.652 146.821 128.716 145.664 129.462 144.208C130.246 142.715 130.638 140.997 130.638 139.056C130.638 136.181 129.836 133.811 128.23 131.944C126.662 130.077 124.422 129.144 121.51 129.144C119.756 129.144 118.188 129.555 116.806 130.376C115.462 131.197 114.398 132.355 113.614 133.848C112.83 135.341 112.438 137.077 112.438 139.056C112.438 140.923 112.774 142.603 113.446 144.096C114.156 145.552 115.182 146.728 116.526 147.624C117.87 148.483 119.532 148.912 121.51 148.912ZM107.062 125.056H112.214L112.438 131.384V164.2H107.062V125.056ZM154.785 153.616C152.62 153.616 150.809 153.149 149.353 152.216C147.897 151.283 146.758 150.069 145.937 148.576C145.116 147.083 144.518 145.496 144.145 143.816C143.772 142.136 143.585 140.549 143.585 139.056C143.585 137.04 143.753 135.155 144.089 133.4C144.462 131.645 145.06 130.096 145.881 128.752C146.702 127.408 147.841 126.363 149.297 125.616C150.753 124.869 152.582 124.496 154.785 124.496C157.212 124.496 159.396 125.131 161.337 126.4C163.278 127.632 164.828 129.349 165.985 131.552C167.18 133.755 167.777 136.256 167.777 139.056C167.777 141.931 167.18 144.469 165.985 146.672C164.79 148.837 163.204 150.536 161.225 151.768C159.284 153 157.137 153.616 154.785 153.616ZM153.273 148.912C155.065 148.912 156.652 148.501 158.033 147.68C159.414 146.821 160.478 145.664 161.225 144.208C162.009 142.715 162.401 140.997 162.401 139.056C162.401 136.181 161.598 133.811 159.993 131.944C158.425 130.077 156.185 129.144 153.273 129.144C151.518 129.144 149.95 129.555 148.569 130.376C147.225 131.197 146.161 132.355 145.377 133.848C144.593 135.341 144.201 137.077 144.201 139.056C144.201 140.923 144.537 142.603 145.209 144.096C145.918 145.552 146.945 146.728 148.289 147.624C149.633 148.483 151.294 148.912 153.273 148.912ZM138.825 125.056H143.977L144.201 131.384V164.2H138.825V125.056ZM1.568 192.056H19.656V196.704H1.568V192.056ZM7.952 184.664H13.272V220H7.952V184.664ZM43.6188 220V203.144C43.6188 201.651 43.3761 200.419 42.8908 199.448C42.4054 198.477 41.6774 197.749 40.7068 197.264C39.7361 196.741 38.5041 196.48 37.0108 196.48C35.3681 196.48 33.8561 196.872 32.4748 197.656C31.1308 198.403 30.0294 199.429 29.1708 200.736C28.3121 202.005 27.7894 203.443 27.6028 205.048L27.5468 201.856C27.7334 200.4 28.1254 199.037 28.7228 197.768C29.3574 196.499 30.1414 195.397 31.0748 194.464C32.0454 193.531 33.1654 192.803 34.4348 192.28C35.7041 191.757 37.0854 191.496 38.5788 191.496C40.1468 191.496 41.5654 191.72 42.8348 192.168C44.1041 192.579 45.1868 193.232 46.0828 194.128C47.0161 194.987 47.7254 196.051 48.2108 197.32C48.6961 198.552 48.9388 199.971 48.9388 201.576V220H43.6188ZM22.6188 220V180.856H27.9388V220H22.6188ZM64.7531 220.56C62.3637 220.56 60.1797 219.944 58.2011 218.712C56.2224 217.48 54.6544 215.781 53.4971 213.616C52.3397 211.413 51.7611 208.893 51.7611 206.056C51.7611 203.219 52.3397 200.717 53.4971 198.552C54.6917 196.349 56.3157 194.632 58.3691 193.4C60.4224 192.131 62.7184 191.496 65.2571 191.496C68.0571 191.496 70.2224 192.149 71.7531 193.456C73.3211 194.763 74.4037 196.517 75.0011 198.72C75.6357 200.923 75.9531 203.368 75.9531 206.056C75.9531 207.549 75.7664 209.136 75.3931 210.816C75.0197 212.496 74.4224 214.083 73.6011 215.576C72.7797 217.069 71.6411 218.283 70.1851 219.216C68.7291 220.112 66.9184 220.56 64.7531 220.56ZM66.2651 215.912C68.2437 215.912 69.9051 215.483 71.2491 214.624C72.6304 213.728 73.6571 212.533 74.3291 211.04C75.0011 209.547 75.3371 207.885 75.3371 206.056C75.3371 204.077 74.9824 202.341 74.2731 200.848C73.6011 199.355 72.5744 198.197 71.1931 197.376C69.8491 196.555 68.2064 196.144 66.2651 196.144C63.3531 196.144 61.0944 197.077 59.4891 198.944C57.9211 200.811 57.1371 203.181 57.1371 206.056C57.1371 207.997 57.5291 209.715 58.3131 211.208C59.0971 212.664 60.1611 213.821 61.5051 214.68C62.8864 215.501 64.4731 215.912 66.2651 215.912ZM75.3371 192.056H80.7131V220H75.7851C75.7851 220 75.7477 219.664 75.6731 218.992C75.5984 218.283 75.5237 217.443 75.4491 216.472C75.3744 215.501 75.3371 214.643 75.3371 213.896V192.056ZM82.9649 192.056H101.053V196.704H82.9649V192.056ZM89.3489 184.664H94.6689V220H89.3489V184.664ZM143.48 215.632L142.024 215.576L149.36 192.056H155.184L145.496 220H140.456L132 196.088H133.512L124.944 220H119.904L110.328 192.056H116.208L123.32 215.576L121.864 215.632L129.592 192.056H135.92L143.48 215.632ZM169.482 220.616C166.756 220.616 164.255 220.037 161.978 218.88C159.7 217.723 157.89 216.061 156.546 213.896C155.202 211.731 154.53 209.136 154.53 206.112C154.53 203.051 155.202 200.437 156.546 198.272C157.89 196.069 159.7 194.389 161.978 193.232C164.255 192.075 166.756 191.496 169.482 191.496C172.207 191.496 174.69 192.075 176.93 193.232C179.17 194.389 180.962 196.069 182.306 198.272C183.65 200.437 184.322 203.051 184.322 206.112C184.322 209.136 183.65 211.731 182.306 213.896C180.962 216.061 179.17 217.723 176.93 218.88C174.69 220.037 172.207 220.616 169.482 220.616ZM169.482 215.968C171.162 215.968 172.711 215.595 174.13 214.848C175.586 214.064 176.743 212.944 177.602 211.488C178.498 209.995 178.946 208.203 178.946 206.112C178.946 203.984 178.498 202.173 177.602 200.68C176.743 199.187 175.586 198.048 174.13 197.264C172.711 196.48 171.162 196.088 169.482 196.088C167.802 196.088 166.234 196.48 164.778 197.264C163.322 198.011 162.146 199.131 161.25 200.624C160.354 202.117 159.906 203.947 159.906 206.112C159.906 208.203 160.335 209.995 161.194 211.488C162.09 212.944 163.266 214.064 164.722 214.848C166.178 215.595 167.764 215.968 169.482 215.968ZM187.147 192.056H192.523V220H187.147V192.056ZM201.987 196.816C200.045 196.816 198.384 197.264 197.003 198.16C195.659 199.056 194.576 200.157 193.755 201.464C192.971 202.771 192.448 204.021 192.187 205.216L192.131 202.024C192.168 201.651 192.261 201.072 192.411 200.288C192.597 199.467 192.915 198.552 193.363 197.544C193.811 196.536 194.408 195.584 195.155 194.688C195.901 193.755 196.835 192.989 197.955 192.392C199.075 191.795 200.419 191.496 201.987 191.496V196.816ZM204.706 180.856H210.026V220H204.706V180.856ZM230.186 192.056L215.402 206.112L215.514 202.752L231.25 220H224.474L210.138 204.376L222.738 192.056H230.186ZM231.01 210.928H235.938C236.125 212.421 236.797 213.653 237.954 214.624C239.111 215.557 240.735 216.024 242.826 216.024C244.17 216.024 245.215 215.875 245.962 215.576C246.709 215.24 247.231 214.792 247.53 214.232C247.866 213.672 248.034 213.056 248.034 212.384C248.034 211.525 247.81 210.872 247.362 210.424C246.914 209.939 246.279 209.547 245.458 209.248C244.637 208.912 243.666 208.595 242.546 208.296C241.314 207.96 240.082 207.568 238.85 207.12C237.618 206.672 236.479 206.131 235.434 205.496C234.426 204.861 233.605 204.077 232.97 203.144C232.373 202.173 232.074 200.997 232.074 199.616C232.074 198.459 232.317 197.376 232.802 196.368C233.325 195.36 234.053 194.501 234.986 193.792C235.957 193.045 237.077 192.485 238.346 192.112C239.615 191.701 241.015 191.496 242.546 191.496C244.674 191.496 246.466 191.888 247.922 192.672C249.378 193.419 250.479 194.483 251.226 195.864C252.01 197.245 252.421 198.832 252.458 200.624H247.754C247.493 199.056 246.951 197.917 246.13 197.208C245.309 196.461 244.077 196.088 242.434 196.088C240.829 196.088 239.597 196.405 238.738 197.04C237.879 197.675 237.45 198.533 237.45 199.616C237.45 200.437 237.749 201.109 238.346 201.632C238.943 202.117 239.746 202.547 240.754 202.92C241.762 203.293 242.901 203.685 244.17 204.096C245.365 204.507 246.503 204.936 247.586 205.384C248.706 205.795 249.695 206.299 250.554 206.896C251.45 207.456 252.141 208.203 252.626 209.136C253.149 210.032 253.41 211.152 253.41 212.496C253.41 214.139 252.999 215.576 252.178 216.808C251.357 218.003 250.162 218.936 248.594 219.608C247.063 220.28 245.197 220.616 242.994 220.616C240.978 220.616 239.261 220.373 237.842 219.888C236.461 219.403 235.285 218.768 234.314 217.984C233.381 217.2 232.653 216.379 232.13 215.52C231.645 214.624 231.309 213.765 231.122 212.944C230.973 212.123 230.935 211.451 231.01 210.928ZM34.16 282.632L32.704 282.576L40.04 259.056H45.864L36.176 287H31.136L22.68 263.088H24.192L15.624 287H10.584L1.008 259.056H6.888L14 282.576L12.544 282.632L20.272 259.056H26.6L34.16 282.632ZM68.2255 277.928H73.3215C73.0228 279.757 72.3135 281.4 71.1935 282.856C70.0735 284.312 68.5988 285.469 66.7695 286.328C64.9402 287.187 62.7935 287.616 60.3295 287.616C57.4175 287.616 54.8228 287 52.5455 285.768C50.2682 284.536 48.4762 282.837 47.1695 280.672C45.8628 278.507 45.2095 275.987 45.2095 273.112C45.2095 270.2 45.8442 267.661 47.1135 265.496C48.3828 263.293 50.1375 261.576 52.3775 260.344C54.6175 259.112 57.1748 258.496 60.0495 258.496C63.0735 258.496 65.6122 259.093 67.6655 260.288C69.7188 261.483 71.2308 263.256 72.2015 265.608C73.2095 267.923 73.6202 270.816 73.4335 274.288H50.5295C50.7162 275.968 51.2202 277.461 52.0415 278.768C52.9002 280.075 54.0202 281.101 55.4015 281.848C56.8202 282.595 58.4442 282.968 60.2735 282.968C62.3268 282.968 64.0442 282.501 65.4255 281.568C66.8068 280.635 67.7402 279.421 68.2255 277.928ZM60.1055 263.088C57.6788 263.088 55.6628 263.741 54.0575 265.048C52.4522 266.317 51.3882 268.016 50.8655 270.144H68.0575C67.9082 267.867 67.0868 266.131 65.5935 264.936C64.1002 263.704 62.2708 263.088 60.1055 263.088ZM76.8552 247.856H82.2312V287H76.8552V247.856ZM87.6724 247.856H93.0484V287H87.6724V247.856Z" fill="url(#paint0_linear_188_190)"/>
<line x1="112.5" y1="238" x2="112.5" y2="294" stroke="#0D00FF"/>
<defs>
<linearGradient id="paint0_linear_188_190" x1="128" y1="34" x2="128" y2="302" gradientUnits="userSpaceOnUse">
<stop stop-color="white" stop-opacity="0"/>
<stop offset="1" stop-color="white"/>
</linearGradient>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/block1/readyInMinutes.svg">
<svg width="336" height="336" viewBox="0 0 336 336" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g clip-path="url(#clip0_188_187)">
<rect x="-2" y="59" width="340" height="445" fill="url(#pattern0_188_187)"/>
<rect x="-2" y="59" width="340" height="445" fill="url(#paint0_linear_188_187)"/>
</g>
<defs>
<pattern id="pattern0_188_187" patternContentUnits="objectBoundingBox" width="1" height="1">
<use xlink:href="#image0_188_187" transform="scale(0.00147059 0.0011236)"/>
</pattern>
<linearGradient id="paint0_linear_188_187" x1="168" y1="59" x2="168" y2="336" gradientUnits="userSpaceOnUse">
<stop offset="0.5" stop-color="#0D0D0D" stop-opacity="0"/>
<stop offset="1" stop-color="#0D0D0D"/>
</linearGradient>
<clipPath id="clip0_188_187">
<rect width="336" height="336" fill="white"/>
</clipPath>
<image id="image0_188_187" width="680" height="890" preserveAspectRatio="none" xlink:href="data:image/png;base64,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"/>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/block1/visibility.svg">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_211_359)">
<path d="M12 4C7 4 2.73 7.11 1 11.5C2.73 15.89 7 19 12 19C17 19 21.27 15.89 23 11.5C21.27 7.11 17 4 12 4ZM12 16.5C9.24 16.5 7 14.26 7 11.5C7 8.74 9.24 6.5 12 6.5C14.76 6.5 17 8.74 17 11.5C17 14.26 14.76 16.5 12 16.5ZM12 8.5C10.34 8.5 9 9.84 9 11.5C9 13.16 10.34 14.5 12 14.5C13.66 14.5 15 13.16 15 11.5C15 9.84 13.66 8.5 12 8.5Z" fill="white" fill-opacity="0.5"/>
</g>
<defs>
<clipPath id="clip0_211_359">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/chat/brackets.svg">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_40_203)">
<path d="M9.4 16.6L4.8 12L9.4 7.4L8 6L2 12L8 18L9.4 16.6ZM14.6 16.6L19.2 12L14.6 7.4L16 6L22 12L16 18L14.6 16.6Z" fill="white" fill-opacity="1"/>
</g>
<defs>
<clipPath id="clip0_40_203">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/chat/deploy.svg">
<svg width="25" height="24" viewBox="0 0 25 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_6_360)">
<path d="M9.5 16H15.5V10H19.5L12.5 3L5.5 10H9.5V16ZM5.5 18H19.5V20H5.5V18Z" fill="white"/>
</g>
<defs>
<clipPath id="clip0_6_360">
<rect width="24" height="24" fill="white" transform="translate(0.5)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/chat/download.svg">
<svg width="25" height="24" viewBox="0 0 25 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_6_357)">
<path d="M19.5 9H15.5V3H9.5V9H5.5L12.5 16L19.5 9ZM5.5 18V20H19.5V18H5.5Z" fill="white"/>
</g>
<defs>
<clipPath id="clip0_6_357">
<rect width="24" height="24" fill="white" transform="translate(0.5)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/chat/eye.svg">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_42_150)">
<path d="M12 4.5C7 4.5 2.73 7.61 1 12C2.73 16.39 7 19.5 12 19.5C17 19.5 21.27 16.39 23 12C21.27 7.61 17 4.5 12 4.5ZM12 17C9.24 17 7 14.76 7 12C7 9.24 9.24 7 12 7C14.76 7 17 9.24 17 12C17 14.76 14.76 17 12 17ZM12 9C10.34 9 9 10.34 9 12C9 13.66 10.34 15 12 15C13.66 15 15 13.66 15 12C15 10.34 13.66 9 12 9Z" fill="white"/>
</g>
<defs>
<clipPath id="clip0_42_150">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/chat/loader.svg">
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<mask id="path-1-inside-1_130_309" fill="white">
<path d="M16 8C16 6.20305 15.395 4.45843 14.2825 3.04725C13.1701 1.63607 11.6149 0.640531 9.86756 0.221041C8.12026 -0.198449 6.28261 -0.0174567 4.65072 0.734854C3.01883 1.48717 1.68775 2.76698 0.871948 4.36808C0.0561492 5.96917 -0.19685 7.7983 0.153718 9.56072C0.504285 11.3231 1.438 12.9162 2.80441 14.0832C4.17083 15.2503 5.89035 15.9233 7.68592 15.9938C9.48149 16.0644 11.2485 15.5284 12.7023 14.4721L12.091 13.6308C10.8262 14.5497 9.28889 15.016 7.72675 14.9546C6.16461 14.8933 4.66862 14.3077 3.47984 13.2924C2.29106 12.2771 1.47873 10.8911 1.17373 9.35783C0.86874 7.82452 1.08885 6.23318 1.79859 4.84023C2.50834 3.44727 3.66639 2.33383 5.08613 1.67932C6.50587 1.02481 8.10463 0.867349 9.62478 1.23231C11.1449 1.59726 12.4979 2.46338 13.4658 3.69111C14.4337 4.91883 14.96 6.43665 14.96 8H16Z"/>
</mask>
<path d="M16 8C16 6.20305 15.395 4.45843 14.2825 3.04725C13.1701 1.63607 11.6149 0.640531 9.86756 0.221041C8.12026 -0.198449 6.28261 -0.0174567 4.65072 0.734854C3.01883 1.48717 1.68775 2.76698 0.871948 4.36808C0.0561492 5.96917 -0.19685 7.7983 0.153718 9.56072C0.504285 11.3231 1.438 12.9162 2.80441 14.0832C4.17083 15.2503 5.89035 15.9233 7.68592 15.9938C9.48149 16.0644 11.2485 15.5284 12.7023 14.4721L12.091 13.6308C10.8262 14.5497 9.28889 15.016 7.72675 14.9546C6.16461 14.8933 4.66862 14.3077 3.47984 13.2924C2.29106 12.2771 1.47873 10.8911 1.17373 9.35783C0.86874 7.82452 1.08885 6.23318 1.79859 4.84023C2.50834 3.44727 3.66639 2.33383 5.08613 1.67932C6.50587 1.02481 8.10463 0.867349 9.62478 1.23231C11.1449 1.59726 12.4979 2.46338 13.4658 3.69111C14.4337 4.91883 14.96 6.43665 14.96 8H16Z" stroke="white" stroke-width="2" mask="url(#path-1-inside-1_130_309)"/>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/chat/sendMessage.svg">
<svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="48" height="48" rx="24" fill="#0D00FF"/>
<g clip-path="url(#clip0_98_661)">
<path d="M13.3333 24L15.2133 25.88L22.6666 18.44V34.6667H25.3333V18.44L32.7733 25.8934L34.6666 24L23.9999 13.3334L13.3333 24Z" fill="white"/>
</g>
<defs>
<clipPath id="clip0_98_661">
<rect width="32" height="32" fill="white" transform="translate(8 8)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/chat/sidebar.svg">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_224_172)">
<path d="M20 4H4C2.9 4 2.01 4.9 2.01 6L2 18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V6C22 4.9 21.1 4 20 4ZM15 18H4V14H15V18ZM15 13H4V9H15V13ZM20 18H16V9H20V18Z" fill="#ffffff"/>
</g>
<defs>
<clipPath id="clip0_224_172">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/chat/stopStreaming.svg">
<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="40" height="40" rx="20" fill="#0D00FF
"/>
<g clip-path="url(#clip0_18_426)">
<path d="M16 16H24V24H16V16Z" fill="white"/>
</g>
<defs>
<clipPath id="clip0_18_426">
<rect width="16" height="16" fill="white" transform="translate(12 12)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/deploy/addImage.svg">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.5" clip-path="url(#clip0_111_196)">
<path d="M19 7V9.99C19 9.99 17.01 10 17 9.99V7H14C14 7 14.01 5.01 14 5H17V2H19V5H22V7H19ZM16 11V8H13V5H5C3.9 5 3 5.9 3 7V19C3 20.1 3.9 21 5 21H17C18.1 21 19 20.1 19 19V11H16ZM5 19L8 15L10 18L13 14L17 19H5Z" fill="white"/>
</g>
<defs>
<clipPath id="clip0_111_196">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/deploy/apple.svg">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_76_212)">
<path d="M21.3636 8.1816C21.2211 8.2896 18.7052 9.6744 18.7052 12.7536C18.7052 16.3152 21.9066 17.5752 22.0025 17.6064C21.9877 17.6832 21.4939 19.332 20.3145 21.012C19.2629 22.4904 18.1646 23.9664 16.4939 23.9664C14.8231 23.9664 14.3931 23.0184 12.4644 23.0184C10.5848 23.0184 9.91646 23.9976 8.38821 23.9976C6.85995 23.9976 5.79361 22.6296 4.56757 20.9496C3.14742 18.9768 2 15.912 2 13.0032C2 8.3376 5.10565 5.8632 8.16216 5.8632C9.78624 5.8632 11.14 6.9048 12.1597 6.9048C13.1302 6.9048 14.6437 5.8008 16.4914 5.8008C17.1916 5.8008 19.7076 5.8632 21.3636 8.1816ZM15.6143 3.8256C16.3784 2.94 16.9189 1.7112 16.9189 0.4824C16.9189 0.312 16.9042 0.1392 16.8722 0C15.629 0.0456 14.1499 0.8088 13.258 1.8192C12.5577 2.5968 11.9042 3.8256 11.9042 5.0712C11.9042 5.2584 11.9361 5.4456 11.9509 5.5056C12.0295 5.52 12.1572 5.5368 12.285 5.5368C13.4005 5.5368 14.8034 4.8072 15.6143 3.8256Z" fill="white"/>
</g>
<defs>
<clipPath id="clip0_76_212">
<rect width="20" height="24" fill="white" transform="translate(2)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/deploy/chrome.svg">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_76_231)">
<g clip-path="url(#clip1_76_231)">
<path d="M12 17.9973C15.3137 17.9973 18 15.311 18 11.9973C18 8.68361 15.3137 5.99731 12 5.99731C8.68629 5.99731 6 8.68361 6 11.9973C6 15.311 8.68629 17.9973 12 17.9973Z" fill="white"/>
<path d="M11.9997 6.00002H22.3903C21.3374 4.17571 19.8228 2.66077 17.9987 1.60752C16.1746 0.554277 14.1053 -0.000146935 11.999 2.92099e-08C9.8926 0.000146994 7.82342 0.55486 5.99946 1.60836C4.17549 2.66186 2.66105 4.17702 1.6084 6.00147L6.8037 15L6.80835 14.9988C6.27985 14.0875 6.00095 13.0529 5.99977 11.9994C5.99858 10.9458 6.27515 9.91062 6.8016 8.99807C7.32805 8.08552 8.08577 7.32789 8.99838 6.80153C9.91099 6.27518 10.9462 5.99872 11.9997 6.00002Z" fill="url(#paint0_linear_76_231)"/>
<path d="M12 16.75C14.6234 16.75 16.75 14.6234 16.75 12C16.75 9.37665 14.6234 7.25 12 7.25C9.37665 7.25 7.25 9.37665 7.25 12C7.25 14.6234 9.37665 16.75 12 16.75Z" fill="#1A73E8"/>
<path d="M17.1955 15.0015L12.0002 24C14.1065 24.0003 16.1758 23.446 18 22.3929C19.8242 21.3398 21.339 19.825 22.392 18.0008C23.445 16.1766 23.9992 14.1072 23.9988 12.0009C23.9985 9.89455 23.4435 7.82543 22.3898 6.00159H11.9993L11.998 6.00624C13.0516 6.0042 14.087 6.27995 15 6.80568C15.9129 7.3314 16.6712 8.08853 17.1983 9.00073C17.7253 9.91293 18.0026 10.948 18.0021 12.0015C18.0016 13.055 17.7234 14.0898 17.1955 15.0015Z" fill="url(#paint1_linear_76_231)"/>
<path d="M6.80444 15.0016L1.60914 6.00305C0.555698 7.82705 0.00105507 9.89626 0.000976571 12.0026C0.000898074 14.109 0.555387 16.1782 1.60869 18.0023C2.66199 19.8264 4.17698 21.341 6.00132 22.3938C7.82565 23.4467 9.89504 24.0007 12.0014 24.0001L17.1967 15.0015L17.1933 14.9981C16.6683 15.9115 15.9118 16.6703 15 17.1981C14.0882 17.7259 13.0534 18.004 11.9999 18.0043C10.9464 18.0047 9.91138 17.7273 8.99925 17.2001C8.08711 16.6729 7.33007 15.9146 6.80444 15.0016Z" fill="url(#paint2_linear_76_231)"/>
</g>
</g>
<defs>
<linearGradient id="paint0_linear_76_231" x1="1.6084" y1="7.50002" x2="22.3903" y2="7.50002" gradientUnits="userSpaceOnUse">
<stop stop-color="#D93025"/>
<stop offset="1" stop-color="#EA4335"/>
</linearGradient>
<linearGradient id="paint1_linear_76_231" x1="10.3608" y1="23.8396" x2="20.7518" y2="5.84189" gradientUnits="userSpaceOnUse">
<stop stop-color="#FCC934"/>
<stop offset="1" stop-color="#FBBC04"/>
</linearGradient>
<linearGradient id="paint2_linear_76_231" x1="13.2992" y1="23.2508" x2="2.90819" y2="5.25305" gradientUnits="userSpaceOnUse">
<stop stop-color="#1E8E3E"/>
<stop offset="1" stop-color="#34A853"/>
</linearGradient>
<clipPath id="clip0_76_231">
<rect width="24" height="24" fill="white"/>
</clipPath>
<clipPath id="clip1_76_231">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/deploy/google.svg">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_76_205)">
<path d="M22.56 12.25C22.56 11.47 22.49 10.72 22.36 10H12V14.26H17.92C17.66 15.63 16.88 16.79 15.71 17.57V20.34H19.28C21.36 18.42 22.56 15.6 22.56 12.25Z" fill="#4285F4"/>
<path d="M11.9997 23C14.9697 23 17.4597 22.02 19.2797 20.34L15.7097 17.57C14.7297 18.23 13.4797 18.63 11.9997 18.63C9.13969 18.63 6.70969 16.7 5.83969 14.1H2.17969V16.94C3.98969 20.53 7.69969 23 11.9997 23Z" fill="#34A853"/>
<path d="M5.84 14.0899C5.62 13.4299 5.49 12.7299 5.49 11.9999C5.49 11.2699 5.62 10.5699 5.84 9.90995V7.06995H2.18C1.43 8.54995 1 10.2199 1 11.9999C1 13.7799 1.43 15.4499 2.18 16.9299L5.03 14.7099L5.84 14.0899Z" fill="#FBBC05"/>
<path d="M11.9997 5.38C13.6197 5.38 15.0597 5.94 16.2097 7.02L19.3597 3.87C17.4497 2.09 14.9697 1 11.9997 1C7.69969 1 3.98969 3.47 2.17969 7.07L5.83969 9.91C6.70969 7.31 9.13969 5.38 11.9997 5.38Z" fill="#EA4335"/>
</g>
<defs>
<clipPath id="clip0_76_205">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/deploy/mozilla.svg">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_76_353)">
<g clip-path="url(#clip1_76_353)">
<path d="M22.4398 7.79786C21.9502 6.62017 20.9585 5.34873 20.1798 4.94687C20.8136 6.18929 21.1804 7.43561 21.3205 8.36575C21.3205 8.36758 21.3212 8.37212 21.3227 8.3845C20.0489 5.20951 17.889 3.92926 16.1252 1.1417C16.0361 1.00075 15.9468 0.85942 15.8598 0.710452C15.8155 0.634372 15.7742 0.556628 15.7358 0.477389C15.6625 0.335913 15.606 0.186371 15.5674 0.0317953C15.5676 0.0244774 15.5652 0.017323 15.5604 0.0117374C15.5557 0.00615177 15.549 0.00253868 15.5418 0.00160783C15.5349 -0.000373182 15.5275 -0.000373182 15.5206 0.00160783C15.519 0.00217033 15.5167 0.00399845 15.515 0.0046547C15.5125 0.00563908 15.5094 0.00788908 15.5068 0.0093422C15.508 0.0076547 15.5107 0.00385783 15.5115 0.0029672C12.6816 1.66028 11.7216 4.72614 11.6334 6.26003C10.5034 6.33772 9.42293 6.75406 8.53298 7.45478C8.43981 7.37608 8.3424 7.30253 8.24119 7.23447C7.98442 6.33615 7.97351 5.38538 8.20959 4.4814C7.05234 5.00833 6.15225 5.84125 5.49787 6.57672H5.49267C5.04609 6.01108 5.07759 4.14517 5.10305 3.75559C5.0977 3.73145 4.76991 3.92575 4.72697 3.95504C4.3329 4.23633 3.96449 4.55194 3.62606 4.89817C3.24095 5.28871 2.88907 5.71069 2.57409 6.15972C2.57409 6.16028 2.57377 6.16094 2.57358 6.1615C2.57358 6.16089 2.57391 6.16028 2.57409 6.15972C1.8497 7.18625 1.33595 8.34618 1.06252 9.57245C1.05713 9.59687 1.05258 9.62219 1.04733 9.64679C1.02614 9.74598 0.949828 10.2421 0.936469 10.3499C0.935438 10.3582 0.934969 10.3662 0.933984 10.3745C0.835324 10.8874 0.774224 11.4069 0.751172 11.9287C0.751172 11.9479 0.75 11.967 0.75 11.9862C0.750188 18.2072 5.79394 23.2501 12.0154 23.2501C17.5872 23.2501 22.2135 19.2053 23.1192 13.8924C23.1383 13.7482 23.1536 13.6033 23.1704 13.4578C23.3943 11.5261 23.1456 9.49572 22.4398 7.79786ZM9.45563 16.6148C9.50831 16.6399 9.55781 16.6674 9.61191 16.6916C9.61416 16.6931 9.61725 16.6949 9.61955 16.6963C9.56449 16.67 9.50984 16.6428 9.45563 16.6148ZM21.3236 8.38726L21.3221 8.37634C21.3227 8.38033 21.3234 8.3845 21.324 8.38848L21.3236 8.38726Z" fill="url(#paint0_linear_76_353)"/>
<path d="M22.4397 7.79776C21.9501 6.62007 20.9584 5.34864 20.1797 4.94678C20.8135 6.1892 21.1803 7.43551 21.3204 8.36565C21.3204 8.36293 21.321 8.3679 21.3221 8.37625C21.3227 8.38023 21.3234 8.3844 21.324 8.38839C22.3869 11.2698 21.8078 14.1999 20.9734 15.9903C19.6825 18.7607 16.5571 21.5999 11.6652 21.4614C6.37978 21.3117 1.7235 17.39 0.854297 12.2536C0.695906 11.4436 0.854297 11.0323 0.933984 10.3746C0.836906 10.8816 0.799922 11.0281 0.751172 11.9289C0.751172 11.9481 0.75 11.9671 0.75 11.9864C0.750094 18.2071 5.79384 23.25 12.0153 23.25C17.5871 23.25 22.2134 19.2052 23.1191 13.8923C23.1382 13.7481 23.1535 13.6032 23.1703 13.4577C23.3942 11.526 23.1455 9.49562 22.4397 7.79776Z" fill="url(#paint1_radial_76_353)"/>
<path d="M22.4397 7.79776C21.9501 6.62007 20.9584 5.34864 20.1797 4.94678C20.8135 6.1892 21.1803 7.43551 21.3204 8.36565C21.3204 8.36293 21.321 8.3679 21.3221 8.37625C21.3227 8.38023 21.3234 8.3844 21.324 8.38839C22.3869 11.2698 21.8078 14.1999 20.9734 15.9903C19.6825 18.7607 16.5571 21.5999 11.6652 21.4614C6.37978 21.3117 1.7235 17.39 0.854297 12.2536C0.695906 11.4436 0.854297 11.0323 0.933984 10.3746C0.836906 10.8816 0.799922 11.0281 0.751172 11.9289C0.751172 11.9481 0.75 11.9671 0.75 11.9864C0.750094 18.2071 5.79384 23.25 12.0153 23.25C17.5871 23.25 22.2134 19.2052 23.1191 13.8923C23.1382 13.7481 23.1535 13.6032 23.1703 13.4577C23.3942 11.526 23.1455 9.49562 22.4397 7.79776Z" fill="url(#paint2_radial_76_353)"/>
<path d="M16.9655 9.12184C16.9901 9.13909 17.0124 9.15625 17.0355 9.1734C16.7528 8.67164 16.4007 8.21224 15.9897 7.80878C12.4879 4.3074 15.0715 0.216811 15.5072 0.00906055C15.5084 0.00737305 15.5111 0.00357617 15.5119 0.00268555C12.682 1.66 11.722 4.72586 11.6338 6.25975C11.765 6.25065 11.8959 6.23964 12.0295 6.23964C14.1413 6.23964 15.9806 7.40073 16.9655 9.12184Z" fill="url(#paint3_radial_76_353)"/>
<path d="M12.0361 9.82097C12.0176 10.1012 11.0276 11.0675 10.6814 11.0675C7.47799 11.0675 6.95801 13.0051 6.95801 13.0051C7.0999 14.6368 8.23587 15.9805 9.61165 16.6915C9.67441 16.7239 9.73793 16.7532 9.80149 16.7822C9.91047 16.8304 10.0208 16.8756 10.1324 16.9175C10.6041 17.0845 11.0982 17.1798 11.5982 17.2002C17.2129 17.4635 18.3007 10.488 14.2488 8.4623C15.2864 8.28183 16.3635 8.69915 16.965 9.12169C15.9801 7.40072 14.1408 6.23962 12.0291 6.23962C11.8955 6.23962 11.7647 6.25064 11.6334 6.25973C10.5033 6.33742 9.42291 6.75376 8.53296 7.45448C8.70471 7.5998 8.89859 7.79405 9.30705 8.19642C10.0712 8.94956 12.0319 9.72947 12.0361 9.82097Z" fill="url(#paint4_radial_76_353)"/>
<path d="M12.0361 9.82097C12.0176 10.1012 11.0276 11.0675 10.6814 11.0675C7.47799 11.0675 6.95801 13.0051 6.95801 13.0051C7.0999 14.6368 8.23587 15.9805 9.61165 16.6915C9.67441 16.7239 9.73793 16.7532 9.80149 16.7822C9.91047 16.8304 10.0208 16.8756 10.1324 16.9175C10.6041 17.0845 11.0982 17.1798 11.5982 17.2002C17.2129 17.4635 18.3007 10.488 14.2488 8.4623C15.2864 8.28183 16.3635 8.69915 16.965 9.12169C15.9801 7.40072 14.1408 6.23962 12.0291 6.23962C11.8955 6.23962 11.7647 6.25064 11.6334 6.25973C10.5033 6.33742 9.42291 6.75376 8.53296 7.45448C8.70471 7.5998 8.89859 7.79405 9.30705 8.19642C10.0712 8.94956 12.0319 9.72947 12.0361 9.82097Z" fill="url(#paint5_radial_76_353)"/>
<path d="M8.00787 7.07982C8.08633 7.13043 8.16417 7.18199 8.24136 7.23451C7.98459 6.33619 7.97368 5.38542 8.20977 4.48145C7.05252 5.00837 6.15242 5.84129 5.49805 6.57676C5.55219 6.57521 7.1862 6.54582 8.00787 7.07982Z" fill="url(#paint6_radial_76_353)"/>
<path d="M0.854464 12.2536C1.72367 17.3901 6.37995 21.3118 11.6653 21.4614C16.5573 21.5999 19.6827 18.7605 20.9736 15.9904C21.808 14.1997 22.3871 11.2701 21.3242 8.38842L21.3238 8.3872L21.3223 8.37628C21.3211 8.36793 21.3204 8.36296 21.3206 8.36568C21.3206 8.36751 21.3213 8.37206 21.3228 8.38443C21.7224 10.9935 20.3952 13.5212 18.3204 15.2302L18.3142 15.2449C14.2714 18.5366 10.4029 17.2309 9.61962 16.6964C9.56457 16.67 9.50987 16.6427 9.45556 16.6147C7.09859 15.4884 6.1249 13.3411 6.33368 11.4996C4.34351 11.4996 3.6649 9.82101 3.6649 9.82101C3.6649 9.82101 5.45173 8.54699 7.80668 9.65503C9.98778 10.6813 12.0361 9.8211 12.0364 9.82101C12.0322 9.72951 10.0715 8.9496 9.30715 8.19651C8.89873 7.79414 8.70481 7.60012 8.53306 7.45457C8.43988 7.37587 8.34247 7.30232 8.24126 7.23426C8.16398 7.18188 8.08615 7.13031 8.00778 7.07957C7.18615 6.54557 5.55209 6.57496 5.49795 6.57637H5.49275C5.04617 6.01073 5.07767 4.14482 5.10312 3.75524C5.09778 3.7311 4.76998 3.9254 4.72704 3.9547C4.33297 4.23598 3.96457 4.55159 3.62614 4.89782C3.24101 5.28846 2.88913 5.71053 2.57417 6.15965C2.57417 6.16021 2.57384 6.16087 2.57365 6.16143C2.57365 6.16082 2.57398 6.16021 2.57417 6.15965C1.84978 7.18619 1.33602 8.34611 1.06259 9.57238C1.0572 9.59681 0.65712 11.3462 0.854464 12.2536Z" fill="url(#paint7_radial_76_353)"/>
<path d="M15.9894 7.80883C16.4004 8.21229 16.7525 8.67169 17.0352 9.17345C17.0972 9.22005 17.1552 9.2665 17.2043 9.31183C19.7582 11.665 18.4201 14.9931 18.3203 15.2303C20.395 13.5212 21.7222 10.9936 21.3227 8.38445C20.0489 5.20951 17.8889 3.92926 16.1251 1.1417C16.0361 1.00075 15.9468 0.85942 15.8598 0.710452C15.8155 0.634372 15.7741 0.556628 15.7357 0.477389C15.6625 0.335913 15.6059 0.186371 15.5673 0.0317953C15.5676 0.0244774 15.5651 0.017323 15.5604 0.0117374C15.5556 0.00615177 15.549 0.00253868 15.5417 0.00160783C15.5348 -0.000373182 15.5275 -0.000373182 15.5206 0.00160783C15.519 0.00217033 15.5166 0.00399845 15.515 0.0046547C15.5125 0.00563908 15.5093 0.00788908 15.5067 0.0093422C15.0712 0.216905 12.4876 4.3075 15.9894 7.80883Z" fill="url(#paint8_radial_76_353)"/>
<path d="M17.2038 9.31181C17.1546 9.26648 17.0967 9.22003 17.0347 9.17343C17.0118 9.15618 16.9893 9.13903 16.9647 9.12187C16.3632 8.69934 15.2861 8.28201 14.2484 8.46248C18.3004 10.4881 17.2126 17.4637 11.5979 17.2004C11.0979 17.18 10.6038 17.0847 10.1321 16.9177C10.0205 16.8757 9.91017 16.8306 9.80117 16.7824C9.73761 16.7534 9.67409 16.7241 9.61133 16.6917C9.61358 16.6932 9.61667 16.695 9.61897 16.6964C10.4022 17.2307 14.2708 18.5365 18.3135 15.2448L18.3198 15.2302C18.4196 14.9932 19.7577 11.665 17.2038 9.31181Z" fill="url(#paint9_radial_76_353)"/>
<path d="M6.95843 13.0051C6.95843 13.0051 7.47841 11.0675 10.6818 11.0675C11.0281 11.0675 12.0182 10.1012 12.0365 9.82096C12.0548 9.54074 9.98805 10.6812 7.80682 9.65497C5.45187 8.54694 3.66504 9.82096 3.66504 9.82096C3.66504 9.82096 4.34365 11.4995 6.33382 11.4995C6.12509 13.341 7.09877 15.4886 9.4557 16.6147C9.50838 16.6399 9.55788 16.6674 9.61198 16.6915C8.23629 15.9805 7.10032 14.6368 6.95843 13.0051Z" fill="url(#paint10_radial_76_353)"/>
<path d="M22.4396 7.79786C21.95 6.62017 20.9583 5.34873 20.1796 4.94687C20.8134 6.18929 21.1802 7.43561 21.3203 8.36575C21.3203 8.36758 21.321 8.37212 21.3225 8.3845C20.0487 5.20951 17.8888 3.92926 16.125 1.1417C16.0359 1.00075 15.9466 0.85942 15.8596 0.710452C15.8153 0.634372 15.774 0.556628 15.7356 0.477389C15.6623 0.335913 15.6058 0.186371 15.5672 0.0317953C15.5675 0.0244774 15.565 0.017323 15.5602 0.0117374C15.5555 0.00615177 15.5489 0.00253868 15.5416 0.00160783C15.5347 -0.000373182 15.5274 -0.000373182 15.5205 0.00160783C15.5189 0.00217033 15.5165 0.00399845 15.5148 0.0046547C15.5123 0.00563908 15.5092 0.00788908 15.5066 0.0093422C15.5078 0.0076547 15.5105 0.00385783 15.5113 0.0029672C12.6814 1.66028 11.7214 4.72614 11.6332 6.26003C11.7645 6.25094 11.8953 6.23992 12.0289 6.23992C14.1408 6.23992 15.9801 7.40101 16.9649 9.12198C16.3634 8.69945 15.2863 8.28212 14.2486 8.46259C18.3005 10.4882 17.2127 17.4638 11.598 17.2005C11.0981 17.1801 10.6039 17.0848 10.1322 16.9178C10.0207 16.8758 9.91033 16.8307 9.80133 16.7825C9.73777 16.7535 9.67425 16.7242 9.61148 16.6918C9.61374 16.6933 9.61683 16.6951 9.61913 16.6965C9.56407 16.67 9.50938 16.6427 9.45506 16.6148C9.50775 16.6399 9.55725 16.6674 9.61134 16.6916C8.23556 15.9806 7.09959 14.6369 6.9577 13.0052C6.9577 13.0052 7.47769 11.0676 10.6811 11.0676C11.0274 11.0676 12.0174 10.1013 12.0358 9.82108C12.0316 9.72958 10.0709 8.94967 9.30656 8.19658C8.89814 7.7942 8.70422 7.60019 8.53247 7.45464C8.43929 7.37594 8.34188 7.30239 8.24067 7.23433C7.98391 6.33601 7.973 5.38524 8.20908 4.48126C7.05183 5.00819 6.15173 5.84111 5.49736 6.57658H5.49216C5.04558 6.01094 5.07708 4.14503 5.10253 3.75545C5.09719 3.73131 4.76939 3.92561 4.72645 3.9549C4.33238 4.23619 3.96398 4.55179 3.62555 4.89803C3.24054 5.28863 2.88878 5.71066 2.57391 6.15972C2.57391 6.16028 2.57358 6.16094 2.57339 6.1615C2.57339 6.16089 2.57372 6.16028 2.57391 6.15972C1.84952 7.18625 1.33576 8.34618 1.06233 9.57245C1.05694 9.59687 1.05239 9.62219 1.04714 9.64679C1.02595 9.74598 0.930609 10.2493 0.917297 10.3572C0.916266 10.3655 0.918281 10.349 0.917297 10.3572C0.830351 10.8773 0.774875 11.4022 0.751172 11.929C0.751172 11.9482 0.75 11.9672 0.75 11.9865C0.75 18.2072 5.79375 23.2501 12.0152 23.2501C17.587 23.2501 22.2133 19.2053 23.119 13.8924C23.1381 13.7482 23.1534 13.6033 23.1702 13.4578C23.3941 11.5261 23.1454 9.49572 22.4396 7.79786ZM21.322 8.37634C21.3226 8.38033 21.3233 8.3845 21.3239 8.38848L21.3235 8.38726L21.322 8.37634Z" fill="url(#paint11_linear_76_353)"/>
</g>
</g>
<defs>
<linearGradient id="paint0_linear_76_353" x1="1963.89" y1="360.374" x2="155.045" y2="2105.27" gradientUnits="userSpaceOnUse">
<stop offset="0.05" stop-color="#FFF44F"/>
<stop offset="0.37" stop-color="#FF980E"/>
<stop offset="0.53" stop-color="#FF3647"/>
<stop offset="0.7" stop-color="#E31587"/>
</linearGradient>
<radialGradient id="paint1_radial_76_353" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(1573.81 -231.158) scale(2304.01 2342.81)">
<stop offset="0.13" stop-color="#FFBD4F"/>
<stop offset="0.28" stop-color="#FF980E"/>
<stop offset="0.47" stop-color="#FF3750"/>
<stop offset="0.78" stop-color="#EB0878"/>
<stop offset="0.86" stop-color="#E50080"/>
</radialGradient>
<radialGradient id="paint2_radial_76_353" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(904.672 737.074) scale(2361.61 2342.81)">
<stop offset="0.3" stop-color="#960E18"/>
<stop offset="0.35" stop-color="#B11927" stop-opacity="0.74"/>
<stop offset="0.43" stop-color="#DB293D" stop-opacity="0.34"/>
<stop offset="0.5" stop-color="#F5334B" stop-opacity="0.09"/>
<stop offset="0.53" stop-color="#FF3750" stop-opacity="0"/>
</radialGradient>
<radialGradient id="paint3_radial_76_353" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(270.915 -110.046) scale(756.236 1283.9)">
<stop offset="0.13" stop-color="#FFF44F"/>
<stop offset="0.53" stop-color="#FF980E"/>
</radialGradient>
<radialGradient id="paint4_radial_76_353" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(234.718 1213.9) scale(1000.7 1096.78)">
<stop offset="0.35" stop-color="#3A8EE6"/>
<stop offset="0.67" stop-color="#9059FF"/>
<stop offset="1" stop-color="#C139E6"/>
</radialGradient>
<radialGradient id="paint5_radial_76_353" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(474.591 368.177) scale(531.373 647.101)">
<stop offset="0.21" stop-color="#9059FF" stop-opacity="0"/>
<stop offset="0.97" stop-color="#6E008B" stop-opacity="0.6"/>
</radialGradient>
<radialGradient id="paint6_radial_76_353" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(581.594 -270.825) scale(795.561 798.388)">
<stop offset="0.1" stop-color="#FFE226"/>
<stop offset="0.79" stop-color="#FF7139"/>
</radialGradient>
<radialGradient id="paint7_radial_76_353" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(1773.28 -722.485) scale(3798.18 3188.36)">
<stop offset="0.11" stop-color="#FFF44F"/>
<stop offset="0.46" stop-color="#FF980E"/>
<stop offset="0.72" stop-color="#FF3647"/>
<stop offset="0.9" stop-color="#E31587"/>
</radialGradient>
<radialGradient id="paint8_radial_76_353" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(295.348 46.9808) rotate(77.3946) scale(1205.03 5212.78)">
<stop stop-color="#FFF44F"/>
<stop offset="0.3" stop-color="#FF980E"/>
<stop offset="0.57" stop-color="#FF3647"/>
<stop offset="0.74" stop-color="#E31587"/>
</radialGradient>
<radialGradient id="paint9_radial_76_353" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(182.495 -373.51) scale(2180.71 2142.4)">
<stop offset="0.14" stop-color="#FFF44F"/>
<stop offset="0.48" stop-color="#FF980E"/>
<stop offset="0.66" stop-color="#FF3647"/>
<stop offset="0.9" stop-color="#E31587"/>
</radialGradient>
<radialGradient id="paint10_radial_76_353" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(1337.26 -325.723) scale(2621.14 2344.92)">
<stop offset="0.09" stop-color="#FFF44F"/>
<stop offset="0.63" stop-color="#FF980E"/>
</radialGradient>
<linearGradient id="paint11_linear_76_353" x1="1800.75" y1="325.499" x2="354.302" y2="1905.91" gradientUnits="userSpaceOnUse">
<stop offset="0.17" stop-color="#FFF44F" stop-opacity="0.8"/>
<stop offset="0.6" stop-color="#FFF44F" stop-opacity="0"/>
</linearGradient>
<clipPath id="clip0_76_353">
<rect width="24" height="24" fill="white"/>
</clipPath>
<clipPath id="clip1_76_353">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/deploy/netlify.svg">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_76_269)">
<path d="M6.4877 18.4876H6.2627L5.1377 17.3726V17.1496L6.8627 15.4398H8.0627L8.23145 15.6071V16.7965L6.4877 18.4876Z" fill="#05BDBA"/>
<path d="M5.1377 5.79472V5.57171L6.2627 4.45667H6.4877L8.2127 6.1664V7.35578L8.0627 7.50445H6.8627L5.1377 5.79472Z" fill="#05BDBA"/>
<path d="M15.0938 14.8638H13.4437L13.3125 14.7337V10.9053C13.3125 10.2177 13.05 9.69738 12.225 9.6788C11.7937 9.66021 11.3062 9.6788 10.8 9.69738L10.725 9.77172V14.7151L10.5938 14.8452H8.94375L8.8125 14.7151V8.21066L8.94375 8.08057H12.6562C14.1 8.08057 15.2625 9.23278 15.2625 10.6638V14.7337L15.0938 14.8638Z" fill="#014847"/>
<path d="M6.7125 12.4106H0.13125L0 12.2805V10.6451L0.13125 10.515H6.7125L6.84375 10.6451V12.2805L6.7125 12.4106Z" fill="#05BDBA"/>
<path d="M23.8688 12.4106H17.2875L17.1562 12.2805V10.6451L17.2875 10.515H23.8688L24 10.6451V12.2805L23.8688 12.4106Z" fill="#05BDBA"/>
<path d="M11.0439 6.03628V1.13009L11.1939 1H12.8439L12.9752 1.13009V6.0177L12.8439 6.14779H11.1939L11.0439 6.03628Z" fill="#05BDBA"/>
<path d="M11.0439 21.7955V16.9079L11.1752 16.7778H12.8252L12.9564 16.9079V21.7955L12.8252 21.9256H11.1752L11.0439 21.7955Z" fill="#05BDBA"/>
</g>
<defs>
<clipPath id="clip0_76_269">
<rect width="24" height="21" fill="white" transform="translate(0 1)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/links/discord.svg">
<svg width="56" height="56" viewBox="0 0 56 56" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M39.0894 17.5408C37.0498 16.605 34.8626 15.9155 32.5759 15.5206C32.5342 15.513 32.4926 15.532 32.4712 15.5701C32.1899 16.0704 31.8783 16.723 31.6601 17.236C29.2005 16.8678 26.7536 16.8678 24.3444 17.236C24.1262 16.7116 23.8033 16.0704 23.5208 15.5701C23.4993 15.5333 23.4577 15.5142 23.4161 15.5206C21.1305 15.9142 18.9434 16.6037 16.9026 17.5408C16.8849 17.5484 16.8698 17.5611 16.8597 17.5776C12.7112 23.7754 11.5747 29.8209 12.1322 35.7914C12.1348 35.8206 12.1512 35.8486 12.1739 35.8664C14.9109 37.8764 17.5623 39.0967 20.1644 39.9055C20.206 39.9182 20.2501 39.903 20.2766 39.8687C20.8922 39.0281 21.4409 38.1418 21.9113 37.2098C21.9391 37.1552 21.9126 37.0904 21.8558 37.0688C20.9855 36.7387 20.1568 36.3362 19.3596 35.8791C19.2966 35.8422 19.2915 35.7521 19.3495 35.7089C19.5173 35.5832 19.6851 35.4524 19.8453 35.3203C19.8743 35.2962 19.9146 35.2911 19.9487 35.3064C25.1857 37.6974 30.8554 37.6974 36.0306 35.3064C36.0647 35.2899 36.1051 35.2949 36.1353 35.3191C36.2955 35.4511 36.4633 35.5832 36.6323 35.7089C36.6903 35.7521 36.6865 35.8422 36.6235 35.8791C35.8263 36.345 34.9976 36.7387 34.126 37.0676C34.0693 37.0892 34.044 37.1552 34.0718 37.2098C34.5523 38.1405 35.101 39.0268 35.7052 39.8674C35.7304 39.903 35.7758 39.9182 35.8175 39.9055C38.4322 39.0967 41.0835 37.8764 43.8206 35.8664C43.8446 35.8486 43.8597 35.8219 43.8622 35.7927C44.5294 28.8901 42.7447 22.8942 39.131 17.5789C39.1221 17.5611 39.107 17.5484 39.0894 17.5408ZM22.6934 32.156C21.1167 32.156 19.8175 30.7085 19.8175 28.9308C19.8175 27.1531 21.0915 25.7055 22.6934 25.7055C24.3078 25.7055 25.5944 27.1658 25.5692 28.9308C25.5692 30.7085 24.2952 32.156 22.6934 32.156ZM33.3263 32.156C31.7497 32.156 30.4505 30.7085 30.4505 28.9308C30.4505 27.1531 31.7244 25.7055 33.3263 25.7055C34.9408 25.7055 36.2274 27.1658 36.2022 28.9308C36.2022 30.7085 34.9408 32.156 33.3263 32.156Z" fill="white"/>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/links/tg.svg">
<svg width="534" height="534" viewBox="0 0 534 534" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M266.667 0C213.927 0 162.368 15.6397 118.515 44.9413C74.6616 74.243 40.4823 115.891 20.299 164.618C0.115651 213.343 -5.16536 266.963 5.12397 318.69C15.4133 370.42 40.811 417.933 78.105 455.23C115.399 492.523 162.914 517.92 214.643 528.21C266.37 538.5 319.99 533.217 368.717 513.033C417.443 492.85 459.09 458.673 488.393 414.82C517.693 370.967 533.333 319.41 533.333 266.667C533.333 195.942 505.237 128.115 455.23 78.105C405.22 28.095 337.39 0 266.667 0ZM397.667 182.667L354 389C350.667 403.667 342 407 329.667 400.333L263 351L229.667 382C228.097 384.05 226.08 385.717 223.77 386.873C221.46 388.027 218.917 388.64 216.333 388.667L221 322L344.333 210.333C350 205.667 344.333 203 336.333 207.667L185 302.667L118.333 282C104 277.667 103.667 267.667 121.333 261L378.333 161C391 157.333 401.667 164.667 397.667 182.667Z" fill="#F9F9F9"/>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/links/x.svg">
<svg width="56" height="56" viewBox="0 0 56 56" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M36.4352 14.5386H40.9332L31.1065 25.7699L42.6668 41.0532H33.6151L26.5255 31.784L18.4134 41.0532H13.9127L24.4234 29.04L13.3335 14.5386H22.615L29.0234 23.011L36.4352 14.5386ZM34.8566 38.3609H37.3489L21.2607 17.0894H18.5861L34.8566 38.3609Z" fill="white"/>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/android.svg">
<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_0_33)">
<path d="M23.4668 12.64L25.9202 8.40005C26.1335 7.98671 25.9735 7.48005 25.5735 7.26671C25.1868 7.06671 24.7068 7.18671 24.4668 7.56005L21.9602 11.88C18.1468 10.2667 13.8535 10.2667 10.0402 11.88L7.5335 7.56005C7.28016 7.17338 6.76016 7.05338 6.3735 7.29338C6.00016 7.53338 5.88016 8.01338 6.08016 8.40005L8.5335 12.64C4.40016 15 1.70683 19.2534 1.3335 24H30.6668C30.2935 19.2534 27.6002 15 23.4668 12.64ZM9.3335 20.3334C8.4135 20.3334 7.66683 19.5867 7.66683 18.6667C7.66683 17.7467 8.4135 17 9.3335 17C10.2535 17 11.0002 17.7467 11.0002 18.6667C11.0002 19.5867 10.2535 20.3334 9.3335 20.3334ZM22.6668 20.3334C21.7468 20.3334 21.0002 19.5867 21.0002 18.6667C21.0002 17.7467 21.7468 17 22.6668 17C23.5868 17 24.3335 17.7467 24.3335 18.6667C24.3335 19.5867 23.5868 20.3334 22.6668 20.3334Z" fill="black"/>
</g>
<defs>
<clipPath id="clip0_0_33">
<rect width="32" height="32" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/buyArrow.svg">
<svg width="19" height="19" viewBox="0 0 19 19" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.51472 0.514737V3.5058L13.3623 3.5164L0.454059 16.4246L2.57538 18.546L15.4836 5.63773L15.473 17.4853H18.4853V0.514737H1.51472Z" fill="white"/>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/chat-black.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="none"><path stroke="white" stroke-linecap="round" stroke-linejoin="round" d="m9.73 8.856-.015-.04-.009-.022.024.062Zm0 0c-.05.115-.104.223-.175.323a1.6 1.6 0 0 1-.377.377c-.1.07-.207.125-.323.175l-.04-.016-.022-.008s0 0 0 0L8.75 9.69l-.22-.085-.06-.023h0l-.127-.049-.18.467L9.73 8.856Zm-.98 1.454h0Zm0 0 .043-.017s0 0 0 0l-.044.017Zm-7.462-.567a.5.5 0 0 0-.027-.256A6.233 6.233 0 0 1 .75 7a6.25 6.25 0 1 1 12.459.724l-.483-.188A5.75 5.75 0 1 0 1.67 9.162v.001l.012.03h0c.044.107.078.193.093.263l.488-.11-.488.11c.016.07.023.127.023.2 0 .072-.013.153-.03.25h0l-.004.026h0l-.345 2.073a.5.5 0 0 0 .575.576l2.073-.346h0l.027-.004h0c.096-.017.177-.03.25-.03a.85.85 0 0 1 .2.023c.07.016.156.05.262.093h0l.03.012h.001a5.734 5.734 0 0 0 2.698.396l.188.484a6.233 6.233 0 0 1-3.074-.416l-.136-.055a.5.5 0 0 0-.257-.027l-.027.004h0l-.004.001-.075.012h-.001l-2.392.4h0a3.565 3.565 0 0 1-.293.04.605.605 0 0 1-.289-.037.583.583 0 0 1-.306-.307.604.604 0 0 1-.038-.289c.006-.08.023-.18.041-.292h0l.399-2.393h0l.013-.076h0V9.77l.004-.027Zm9.178-1.76a.5.5 0 0 0-.933 0l-.157.408.206.079-.206-.08-.017.046s0 0 0 0c-.084.218-.136.348-.211.453a1.1 1.1 0 0 1-.26.26c-.105.074-.234.127-.453.21h0l-.045.018h0l-.407.156a.5.5 0 0 0 0 .934l.407.156.079-.205-.079.205.045.018h0c.219.083.348.136.454.21.1.072.187.16.259.26.075.105.127.235.211.453l.246-.094-.246.094.017.045.157.407a.5.5 0 0 0 .933 0l.157-.407h0l.017-.045h0c.084-.218.136-.348.211-.453a1.1 1.1 0 0 1 .26-.26c.105-.074.234-.127.452-.21 0 0 0 0 0 0l.046-.018.407-.156a.5.5 0 0 0 0-.934l-.407-.156-.079.205.079-.205-.045-.018h0c-.219-.083-.348-.136-.454-.21a1.1 1.1 0 0 1-.259-.26c-.075-.105-.127-.235-.21-.453h0l-.018-.045h0l-.157-.407ZM10 6.5c.03 0 .056.018.066.046l.69 1.793c.096.249.142.37.212.467a.957.957 0 0 0 .225.226c.098.07.219.116.467.212l1.794.69a.071.071 0 0 1 0 .133l-1.794.69c-.248.095-.369.142-.467.211a.957.957 0 0 0-.225.226c-.07.097-.116.218-.212.467l-.69 1.793a.071.071 0 0 1-.133 0l-.69-1.793c-.096-.249-.142-.37-.212-.467a.957.957 0 0 0-.225-.226c-.098-.07-.219-.116-.467-.211l-1.794-.69a.071.071 0 0 1 0-.134l1.794-.69c.248-.095.369-.142.467-.211a.957.957 0 0 0 .225-.226c.07-.098.116-.218.212-.467l.69-1.793A.071.071 0 0 1 10 6.5Z"/></svg>
</file>

<file path="packages/ui-frontend/public/icons/chat.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="none"><path stroke="white" stroke-linecap="round" stroke-linejoin="round" d="m9.73 8.856-.015-.04-.009-.022.024.062Zm0 0c-.05.115-.104.223-.175.323a1.6 1.6 0 0 1-.377.377c-.1.07-.207.125-.323.175l-.04-.016-.022-.008s0 0 0 0L8.75 9.69l-.22-.085-.06-.023h0l-.127-.049-.18.467L9.73 8.856Zm-.98 1.454h0Zm0 0 .043-.017s0 0 0 0l-.044.017Zm-7.462-.567a.5.5 0 0 0-.027-.256A6.233 6.233 0 0 1 .75 7a6.25 6.25 0 1 1 12.459.724l-.483-.188A5.75 5.75 0 1 0 1.67 9.162v.001l.012.03h0c.044.107.078.193.093.263l.488-.11-.488.11c.016.07.023.127.023.2 0 .072-.013.153-.03.25h0l-.004.026h0l-.345 2.073a.5.5 0 0 0 .575.576l2.073-.346h0l.027-.004h0c.096-.017.177-.03.25-.03a.85.85 0 0 1 .2.023c.07.016.156.05.262.093h0l.03.012h.001a5.734 5.734 0 0 0 2.698.396l.188.484a6.233 6.233 0 0 1-3.074-.416l-.136-.055a.5.5 0 0 0-.257-.027l-.027.004h0l-.004.001-.075.012h-.001l-2.392.4h0a3.565 3.565 0 0 1-.293.04.605.605 0 0 1-.289-.037.583.583 0 0 1-.306-.307.604.604 0 0 1-.038-.289c.006-.08.023-.18.041-.292h0l.399-2.393h0l.013-.076h0V9.77l.004-.027Zm9.178-1.76a.5.5 0 0 0-.933 0l-.157.408.206.079-.206-.08-.017.046s0 0 0 0c-.084.218-.136.348-.211.453a1.1 1.1 0 0 1-.26.26c-.105.074-.234.127-.453.21h0l-.045.018h0l-.407.156a.5.5 0 0 0 0 .934l.407.156.079-.205-.079.205.045.018h0c.219.083.348.136.454.21.1.072.187.16.259.26.075.105.127.235.211.453l.246-.094-.246.094.017.045.157.407a.5.5 0 0 0 .933 0l.157-.407h0l.017-.045h0c.084-.218.136-.348.211-.453a1.1 1.1 0 0 1 .26-.26c.105-.074.234-.127.452-.21 0 0 0 0 0 0l.046-.018.407-.156a.5.5 0 0 0 0-.934l-.407-.156-.079.205.079-.205-.045-.018h0c-.219-.083-.348-.136-.454-.21a1.1 1.1 0 0 1-.259-.26c-.075-.105-.127-.235-.21-.453h0l-.018-.045h0l-.157-.407ZM10 6.5c.03 0 .056.018.066.046l.69 1.793c.096.249.142.37.212.467a.957.957 0 0 0 .225.226c.098.07.219.116.467.212l1.794.69a.071.071 0 0 1 0 .133l-1.794.69c-.248.095-.369.142-.467.211a.957.957 0 0 0-.225.226c-.07.097-.116.218-.212.467l-.69 1.793a.071.071 0 0 1-.133 0l-.69-1.793c-.096-.249-.142-.37-.212-.467a.957.957 0 0 0-.225-.226c-.098-.07-.219-.116-.467-.211l-1.794-.69a.071.071 0 0 1 0-.134l1.794-.69c.248-.095.369-.142.467-.211a.957.957 0 0 0 .225-.226c.07-.098.116-.218.212-.467l.69-1.793A.071.071 0 0 1 10 6.5Z"/></svg>
</file>

<file path="packages/ui-frontend/public/icons/dots.svg">
<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_0_34)">
<path d="M24.0002 17.3333C25.4668 17.3333 26.6668 18.5333 26.6668 20C26.6668 21.4666 25.4668 22.6666 24.0002 22.6666C22.5335 22.6666 21.3335 21.4666 21.3335 20C21.3335 18.5333 22.5335 17.3333 24.0002 17.3333ZM13.3335 20C13.3335 21.4666 14.5335 22.6666 16.0002 22.6666C17.4668 22.6666 18.6668 21.4666 18.6668 20C18.6668 18.5333 17.4668 17.3333 16.0002 17.3333C14.5335 17.3333 13.3335 18.5333 13.3335 20ZM5.3335 20C5.3335 21.4666 6.5335 22.6666 8.00016 22.6666C9.46683 22.6666 10.6668 21.4666 10.6668 20C10.6668 18.5333 9.46683 17.3333 8.00016 17.3333C6.5335 17.3333 5.3335 18.5333 5.3335 20ZM10.6668 12C10.6668 10.5333 9.46683 9.33329 8.00016 9.33329C6.5335 9.33329 5.3335 10.5333 5.3335 12C5.3335 13.4666 6.5335 14.6666 8.00016 14.6666C9.46683 14.6666 10.6668 13.4666 10.6668 12ZM13.3335 12C13.3335 13.4666 14.5335 14.6666 16.0002 14.6666C17.4668 14.6666 18.6668 13.4666 18.6668 12C18.6668 10.5333 17.4668 9.33329 16.0002 9.33329C14.5335 9.33329 13.3335 10.5333 13.3335 12ZM21.3335 12C21.3335 13.4666 22.5335 14.6666 24.0002 14.6666C25.4668 14.6666 26.6668 13.4666 26.6668 12C26.6668 10.5333 25.4668 9.33329 24.0002 9.33329C22.5335 9.33329 21.3335 10.5333 21.3335 12Z" fill="black"/>
</g>
<defs>
<clipPath id="clip0_0_34">
<rect width="32" height="32" fill="white" transform="translate(0 32) rotate(-90)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/LaunchDapp.svg">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_156_50)">
<path d="M19 9L20.25 6.25L23 5L20.25 3.75L19 1L17.75 3.75L15 5L17.75 6.25L19 9ZM11.5 9.5L9 4L6.5 9.5L1 12L6.5 14.5L9 20L11.5 14.5L17 12L11.5 9.5ZM19 15L17.75 17.75L15 19L17.75 20.25L19 23L20.25 20.25L23 19L20.25 17.75L19 15Z" fill="#323232"/>
</g>
<defs>
<clipPath id="clip0_156_50">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/logo.svg">
<svg width="202" height="32" viewBox="0 0 202 32" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_159_225)">
<path d="M4.58151 8.84128C8.41931 6.62553 13.194 7.50261 16.0195 10.6991L19.2375 8.84126C23.6186 6.31184 29.2208 7.81291 31.7502 12.194C34.2797 16.5752 32.7786 22.1773 28.3975 24.7068C24.5597 26.9225 19.7849 26.0455 16.9594 22.8489L13.7415 24.7068C9.36033 27.2363 3.75819 25.7352 1.22873 21.354C-1.30072 16.9729 0.200368 11.3707 4.58151 8.84128ZM20.2449 20.952C21.9657 22.4233 24.4931 22.7302 26.5655 21.5337C28.6378 20.3372 29.6357 17.995 29.2219 15.7692L20.2449 20.952ZM5.58907 20.952C7.30978 22.4233 9.83715 22.7302 11.9095 21.5337L27.3899 12.5961C25.6692 11.1248 23.1418 10.8179 21.0695 12.0144L5.58907 20.952ZM6.41351 12.0144C4.34117 13.2109 3.34324 15.553 3.75708 17.7789L12.7339 12.5961C11.0132 11.1248 8.48584 10.8179 6.41351 12.0144Z" fill="white"/>
<path d="M182.253 7.42794H186.448L193.534 24.2552L190.149 24.9593L182.253 7.42794ZM201.818 7.42794L190.537 32H186.413L191.242 22.3894L197.623 7.42794H201.818Z" fill="white"/>
<path d="M169.949 25.3465C168.351 25.3465 166.882 24.9593 165.542 24.1848C164.226 23.4103 163.168 22.3425 162.369 20.9813C161.594 19.5966 161.206 18.0125 161.206 16.2288C161.206 14.3982 161.605 12.8023 162.405 11.4411C163.204 10.0565 164.285 8.97689 165.648 8.20241C167.011 7.42793 168.539 7.0407 170.231 7.0407C172.111 7.0407 173.603 7.4514 174.708 8.27282C175.813 9.09423 176.6 10.1973 177.07 11.5819C177.54 12.9666 177.775 14.5156 177.775 16.2288C177.775 17.191 177.634 18.2119 177.352 19.2915C177.07 20.3476 176.623 21.3333 176.012 22.2486C175.425 23.1639 174.626 23.9149 173.615 24.5016C172.628 25.0649 171.406 25.3465 169.949 25.3465ZM171.147 22.1078C172.464 22.1078 173.58 21.8614 174.496 21.3685C175.437 20.8522 176.142 20.1481 176.612 19.2563C177.105 18.3645 177.352 17.3553 177.352 16.2288C177.352 14.985 177.105 13.9288 176.612 13.0605C176.118 12.1687 175.413 11.4881 174.496 11.0187C173.58 10.5258 172.464 10.2794 171.147 10.2794C169.267 10.2794 167.81 10.8309 166.776 11.934C165.742 13.037 165.225 14.4686 165.225 16.2288C165.225 17.3788 165.472 18.3997 165.965 19.2915C166.482 20.1833 167.187 20.8757 168.08 21.3685C168.973 21.8614 169.996 22.1078 171.147 22.1078ZM177.352 7.42793H181.3V24.9593H177.634C177.634 24.9593 177.611 24.7363 177.563 24.2904C177.516 23.8445 177.469 23.3047 177.422 22.6711C177.375 22.0139 177.352 21.392 177.352 20.8053V7.42793Z" fill="white"/>
<path d="M153.497 22.0022L152.334 21.967L157.445 7.42794H161.746L154.907 24.9593H151.206L145.741 10.3498H146.975L141.37 24.9593H137.668L130.97 7.42794H135.271L140.242 22.0022H139.078L144.084 7.42794H148.667L153.497 22.0022Z" fill="white"/>
<path d="M121.099 7.42793H125.012V24.9593H121.099V7.42793ZM131.358 10.7723C130.089 10.7723 128.996 11.0422 128.079 11.5819C127.186 12.1217 126.469 12.7789 125.929 13.5533C125.388 14.3278 125.012 15.0788 124.801 15.8064L124.766 13.835C124.789 13.5768 124.871 13.1896 125.012 12.6733C125.153 12.1335 125.365 11.5467 125.647 10.9131C125.952 10.2794 126.352 9.66922 126.845 9.0825C127.363 8.47231 127.985 7.97946 128.714 7.60395C129.466 7.22845 130.347 7.0407 131.358 7.0407V10.7723Z" fill="white"/>
<path d="M115.494 19.1859H119.266C119.078 20.3828 118.608 21.4507 117.856 22.3894C117.127 23.3047 116.128 24.0323 114.859 24.572C113.59 25.0884 112.074 25.3465 110.312 25.3465C108.314 25.3465 106.528 24.9827 104.953 24.2552C103.378 23.5042 102.145 22.4481 101.252 21.0869C100.358 19.7257 99.9119 18.1063 99.9119 16.2288C99.9119 14.3748 100.347 12.7554 101.216 11.3707C102.086 9.98606 103.284 8.91822 104.812 8.16721C106.363 7.4162 108.149 7.0407 110.171 7.0407C112.262 7.0407 114.001 7.4162 115.388 8.16721C116.798 8.89475 117.844 9.99779 118.526 11.4763C119.207 12.9314 119.489 14.7737 119.372 17.0033H103.896C104.013 17.989 104.33 18.8808 104.847 19.6788C105.388 20.4532 106.116 21.0634 107.033 21.5093C107.95 21.9318 109.019 22.143 110.241 22.143C111.604 22.143 112.744 21.8731 113.661 21.3333C114.601 20.7935 115.212 20.0777 115.494 19.1859ZM110.065 10.209C108.467 10.209 107.151 10.608 106.116 11.4059C105.082 12.1804 104.413 13.1778 104.107 14.3982H115.423C115.329 13.084 114.801 12.0631 113.837 11.3355C112.873 10.5845 111.616 10.209 110.065 10.209Z" fill="white"/>
<path d="M94.3298 24.9593V14.8207C94.3298 13.8819 94.1652 13.1074 93.8362 12.4972C93.5307 11.8636 93.0489 11.3825 92.3908 11.0539C91.7328 10.7253 90.8632 10.5611 89.7821 10.5611C88.701 10.5611 87.7139 10.7957 86.8208 11.2651C85.9277 11.711 85.1991 12.3095 84.6351 13.0605C84.071 13.8115 83.742 14.6447 83.648 15.56L83.6127 13.5886C83.7302 12.7437 83.9888 11.934 84.3883 11.1595C84.7878 10.3616 85.3166 9.6575 85.9747 9.0473C86.6328 8.43711 87.4083 7.95599 88.3014 7.60396C89.1945 7.22846 90.1816 7.0407 91.2627 7.0407C92.2733 7.0407 93.2016 7.18152 94.0477 7.46315C94.9173 7.74477 95.6576 8.16722 96.2687 8.73047C96.9033 9.27026 97.385 9.95086 97.7141 10.7723C98.0666 11.5702 98.2429 12.4972 98.2429 13.5534V24.9593H94.3298ZM79.9464 24.9593V0.387242H83.8595V24.9593H79.9464Z" fill="white"/>
<path d="M65.8698 7.42795H78.279V10.6315H65.8698V7.42795ZM70.1002 2.71068H74.0486V24.9593H70.1002V2.71068Z" fill="white"/>
<path d="M64.5671 0V3.76677H59.8784V0H64.5671ZM60.2309 7.42794H64.1793V24.9593H60.2309V7.42794Z" fill="white"/>
<path d="M54.3789 19.1859H58.151C57.963 20.3828 57.4929 21.4507 56.7409 22.3894C56.0123 23.3047 55.0134 24.0323 53.7443 24.572C52.4752 25.0884 50.9593 25.3465 49.1966 25.3465C47.1989 25.3465 45.4128 24.9827 43.8381 24.2552C42.2635 23.5042 41.0296 22.4481 40.1365 21.0869C39.2434 19.7257 38.7969 18.1063 38.7969 16.2288C38.7969 14.3748 39.2317 12.7554 40.1013 11.3707C40.9709 9.98606 42.1695 8.91822 43.6971 8.16721C45.2483 7.4162 47.0344 7.0407 49.0556 7.0407C51.1473 7.0407 52.8865 7.4162 54.2731 8.16721C55.6833 8.89475 56.7291 9.99779 57.4107 11.4763C58.0922 12.9314 58.3743 14.7737 58.2568 17.0033H42.7805C42.898 17.989 43.2153 18.8808 43.7324 19.6788C44.2729 20.4532 45.0015 21.0634 45.9181 21.5093C46.8347 21.9318 47.904 22.143 49.1261 22.143C50.4893 22.143 51.6291 21.8731 52.5457 21.3333C53.4858 20.7935 54.0969 20.0777 54.3789 19.1859ZM48.9499 10.209C47.3517 10.209 46.0356 10.608 45.0015 11.4059C43.9674 12.1804 43.2976 13.1778 42.992 14.3982H54.3084C54.2144 13.084 53.6856 12.0631 52.722 11.3355C51.7584 10.5845 50.501 10.209 48.9499 10.209Z" fill="white"/>
</g>
<defs>
<clipPath id="clip0_159_225">
<rect width="202" height="32" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/rainbowCircle.svg">
<svg width="208" height="208" viewBox="0 0 208 208" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="104" cy="104" r="104" fill="url(#paint0_radial_0_854)"/>
<circle cx="104" cy="104" r="103" stroke="black" stroke-opacity="0.05" stroke-width="2"/>
<circle cx="104" cy="104" r="84.6667" fill="url(#paint1_radial_0_854)" stroke="white" stroke-width="4"/>
<defs>
<radialGradient id="paint0_radial_0_854" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(208 1.30679e-05) rotate(135) scale(294.156 373.71)">
<stop stop-color="white"/>
<stop offset="0.15" stop-color="#9442FF"/>
<stop offset="0.3" stop-color="#429BFF"/>
<stop offset="0.5" stop-color="white"/>
<stop offset="0.7" stop-color="#FFD600"/>
<stop offset="0.85" stop-color="#FF5252"/>
<stop offset="1" stop-color="white"/>
</radialGradient>
<radialGradient id="paint1_radial_0_854" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(190.667 17.3334) rotate(135) scale(245.13 311.425)">
<stop stop-color="white"/>
<stop offset="0.15" stop-color="#9442FF"/>
<stop offset="0.3" stop-color="#429BFF"/>
<stop offset="0.5" stop-color="white"/>
<stop offset="0.7" stop-color="#FFD600"/>
<stop offset="0.85" stop-color="#FF5252"/>
<stop offset="1" stop-color="white"/>
</radialGradient>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/icons/stars.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M11.5 6a.5.5 0 0 1-.475-.342l-.263-.789a1 1 0 0 0-.632-.632l-.789-.263a.5.5 0 0 1 0-.949l.789-.263a1 1 0 0 0 .632-.632l.264-.79a.5.5 0 0 1 .948 0l.264.79a1 1 0 0 0 .632.632l.789.263a.5.5 0 0 1 0 .949l-.789.263a1 1 0 0 0-.632.632l-.264.789A.5.5 0 0 1 11.5 6ZM6 13a.667.667 0 0 1-.647-.505l-.23-.92a2.337 2.337 0 0 0-1.696-1.698l-.92-.23a.666.666 0 0 1 0-1.293l.92-.23a2.337 2.337 0 0 0 1.697-1.697l.23-.92a.667.667 0 0 1 1.293 0l.23.92a2.333 2.333 0 0 0 1.696 1.697l.92.23a.666.666 0 0 1 0 1.294l-.92.229a2.332 2.332 0 0 0-1.697 1.697l-.23.921A.667.667 0 0 1 6 13ZM13.5 23a.75.75 0 0 1-.72-.544l-.813-2.846a3.75 3.75 0 0 0-2.576-2.576l-2.846-.813a.75.75 0 0 1 0-1.442l2.846-.813a3.75 3.75 0 0 0 2.575-2.576l.814-2.846a.75.75 0 0 1 1.442 0l.813 2.846a3.75 3.75 0 0 0 2.575 2.576l2.846.813a.75.75 0 0 1 0 1.442l-2.846.813a3.749 3.749 0 0 0-2.575 2.576l-.813 2.846A.75.75 0 0 1 13.5 23Z" clip-rule="evenodd"/></svg>
</file>

<file path="packages/ui-frontend/public/icons/whitepaper.svg">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_156_118)">
<path d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM14 17H7V15H14V17ZM17 13H7V11H17V13ZM17 9H7V7H17V9Z" fill="#323232"/>
</g>
<defs>
<clipPath id="clip0_156_118">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/base.css">
* { box-sizing: border-box; }
html, body { height: 100%; }
body {
  margin: 0;
  font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
  color: var(--color-text);
  background: var(--color-bg);
}

:root {
  --radius-sm: 8px; --radius-md: 12px; --radius-lg: 16px; --radius-xl: 24px; --radius-pill: 9999px;
  --shadow-sm: 0 1px 2px rgba(0,0,0,0.06);
  --shadow-md: 0 3px 10px rgba(0,0,0,0.08);
  --shadow-lg: 0 8px 24px rgba(0,0,0,0.12);
  --shadow-xl: 0 12px 40px rgba(0,0,0,0.16);
  --focus-ring: 0 0 0 3px var(--color-focus);
}

.surface {
  background: var(--color-surface);
  color: var(--color-text);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-sm);
}

.card {
  background: var(--card-bg, var(--color-elevated));
  border: var(--card-border, 1px solid var(--color-border));
  border-radius: var(--card-radius, var(--radius-lg));
  box-shadow: var(--card-shadow, var(--shadow-md));
  backdrop-filter: var(--card-blur, none);
  padding: 16px;
}

.btn {
  display: inline-flex; align-items: center; justify-content: center; gap: 8px;
  padding: 12px 16px; border: 0; border-radius: var(--btn-radius, var(--radius-md));
  font-weight: 600; cursor: pointer; transition: transform 200ms, box-shadow 200ms, background 200ms;
}
.btn:focus-visible { outline: none; box-shadow: var(--focus-ring); }
.btn:active { transform: translateY(0) scale(0.99); }

.btn-primary { background: var(--btn-primary-bg); color: var(--btn-primary-fg); box-shadow: var(--btn-primary-shadow, var(--shadow-md)); }
.btn-primary:hover { transform: translateY(-1px); box-shadow: var(--btn-primary-hover-shadow, var(--shadow-lg)); }

.btn-ghost { background: transparent; color: var(--color-text); }
.btn-ghost:hover { background: rgba(0,0,0,0.04); }

.input {
  width: 100%;
  padding: 12px 14px;
  background: var(--input-bg, var(--color-elevated));
  color: var(--color-text);
  border: 1px solid var(--input-border, var(--color-border));
  border-radius: var(--radius-md);
  transition: box-shadow 200ms, border-color 200ms, background 200ms;
}
.input:focus-visible { outline: none; box-shadow: var(--focus-ring); border-color: var(--color-focus); }

.navbar {
  height: 64px; display: flex; align-items: center; gap: 12px;
  backdrop-filter: var(--navbar-blur, none);
  border-bottom: 1px solid var(--navbar-divider, var(--color-border));
  padding: 0 16px;
}
.sidebar {
  width: var(--sidebar-width, 280px);
  border-right: 1px solid var(--color-border);
  background: var(--color-surface);
}

.table { width: 100%; border-collapse: collapse; }
.table th, .table td { padding: 12px 16px; border-bottom: 1px solid var(--color-border); }
.table thead th { background: var(--table-header-bg, transparent); text-align: left; }

@media (prefers-reduced-motion: reduce) {
  * { transition: none !important; animation: none !important; }
}
</file>

<file path="packages/ui-frontend/public/favicon.svg">
<svg width="1080" height="1080" viewBox="0 0 1080 1080" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="1080" height="1080" rx="540" fill="#0D00FF"/>
<path d="M308.91 385.873C383.388 342.823 476.047 359.864 530.88 421.97L593.329 385.873C678.35 336.728 787.068 365.893 836.155 451.015C885.242 536.136 856.111 644.981 771.09 694.126C696.612 737.177 603.953 720.136 549.12 658.03L486.671 694.127C401.65 743.272 292.933 714.107 243.845 628.985C194.758 543.863 223.888 435.018 308.91 385.873ZM612.88 621.175C646.272 649.761 695.321 655.722 735.538 632.476C775.754 609.229 795.12 563.722 787.089 520.477L612.88 621.175ZM328.463 621.174C361.856 649.76 410.903 655.722 451.119 632.476L751.537 458.826C718.144 430.24 669.097 424.278 628.881 447.524L328.463 621.174ZM344.463 447.524C304.246 470.77 284.88 516.277 292.911 559.523L467.118 458.826C433.726 430.24 384.679 424.278 344.463 447.524Z" fill="white"/>
</svg>
</file>

<file path="packages/ui-frontend/public/logo.svg">
<svg width="56" height="56" viewBox="0 0 56 56" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="28" cy="28" r="26" fill="url(#paint0_radial_0_32)" stroke="black" stroke-width="4"/>
<defs>
<radialGradient id="paint0_radial_0_32" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(56 3.51829e-06) rotate(135) scale(79.196 100.614)">
<stop stop-color="white"/>
<stop offset="0.15" stop-color="#9442FF"/>
<stop offset="0.3" stop-color="#429BFF"/>
<stop offset="0.5" stop-color="white"/>
<stop offset="0.7" stop-color="#FFD600"/>
<stop offset="0.85" stop-color="#FF5252"/>
<stop offset="1" stop-color="white"/>
</radialGradient>
</defs>
</svg>
</file>

<file path="packages/ui-frontend/public/styles.css">
/* === THEME TOKENS: Web3 (Green) === */
:root,
html[data-pattern="web3"] {
  /* Core palette */
  --color-bg:        #064e3b; /* emerald-900 */
  --color-surface:   #065f46; /* emerald-800 */
  --color-elevated:  #047857; /* emerald-700 */
  --color-primary:   #10b981; /* emerald-500 */
  --color-border:    #059669; /* emerald-600 */
  --color-text:      #d1fae5; /* emerald-100 */
  --color-text-muted:#a7f3d0; /* emerald-200 */

  /* Cross-compat aliases used by some templates */
  --bg-primary:    var(--color-bg);
  --bg-secondary:  var(--color-surface);
  --text-primary:  var(--color-text);
  --text-secondary:var(--color-text-muted);
  --border:        var(--color-border);
  --accent:        var(--color-primary);

  /* Component tokens consumed by base.css */
  --btn-primary-bg:      var(--color-primary);
  --btn-primary-text:    #0b301f;  /* dark text on medium green for contrast */
  --btn-primary-border:  var(--color-border);

  --btn-ghost-text:      var(--color-text);
  --btn-ghost-border:    var(--color-border);

  --card-bg:             var(--color-surface);
  --card-border:         var(--color-border);

  --input-bg:            var(--color-elevated);
  --input-text:          var(--color-text);
  --input-border:        var(--color-border);

  --nav-bg:              var(--color-surface);
  --table-row-hover:     rgba(16,185,129,0.12);

  /* Shadows (kept neutral) */
  --shadow-sm:  0 1px 2px rgba(0,0,0,.20);
  --shadow-md:  0 6px 16px rgba(0,0,0,.25);
}
</file>

<file path="packages/ui-frontend/public/test-streaming.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fastify Streaming Test</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 2rem;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 2rem;
      text-align: center;
    }

    .header h1 {
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .header p {
      opacity: 0.9;
      font-size: 0.95rem;
    }

    .content {
      padding: 2rem;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    label {
      font-weight: 600;
      color: #374151;
      font-size: 0.875rem;
    }

    input[type="text"],
    input[type="number"],
    input[type="range"] {
      padding: 0.75rem;
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      font-size: 0.95rem;
      transition: border-color 0.2s;
    }

    input[type="text"]:focus,
    input[type="number"]:focus {
      outline: none;
      border-color: #667eea;
    }

    input[type="range"] {
      padding: 0;
      cursor: pointer;
    }

    .range-value {
      display: inline-block;
      background: #667eea;
      color: white;
      padding: 0.25rem 0.75rem;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    button {
      padding: 1rem;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .btn-success {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
    }

    .btn-success:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
    }

    .btn-warning {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      color: white;
    }

    .btn-warning:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
    }

    .btn-danger {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: white;
    }

    .btn-danger:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
    }

    .output-section {
      margin-top: 2rem;
    }

    .output-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .output-header h3 {
      font-size: 1.25rem;
      color: #1f2937;
    }

    .status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.875rem;
      font-weight: 600;
    }

    .status.idle {
      background: #f3f4f6;
      color: #6b7280;
    }

    .status.streaming {
      background: #dbeafe;
      color: #2563eb;
      animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .output {
      background: #1f2937;
      color: #f9fafb;
      padding: 1.5rem;
      border-radius: 8px;
      min-height: 300px;
      max-height: 500px;
      overflow-y: auto;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 0.875rem;
      line-height: 1.6;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .output::-webkit-scrollbar {
      width: 8px;
    }

    .output::-webkit-scrollbar-track {
      background: #374151;
      border-radius: 4px;
    }

    .output::-webkit-scrollbar-thumb {
      background: #667eea;
      border-radius: 4px;
    }

    .output::-webkit-scrollbar-thumb:hover {
      background: #5568d3;
    }

    .output.empty {
      display: flex;
      align-items: center;
      justify-content: center;
      color: #9ca3af;
      font-style: italic;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
      padding: 1rem;
      background: #f9fafb;
      border-radius: 8px;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      display: block;
      font-size: 1.5rem;
      font-weight: 700;
      color: #667eea;
      margin-bottom: 0.25rem;
    }

    .stat-label {
      font-size: 0.75rem;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1> Fastify Streaming Test</h1>
      <p>Test SSE (Server-Sent Events) streaming endpoints</p>
    </div>

    <div class="content">
      <!-- Controls -->
      <div class="controls">
        <div class="control-group">
          <label for="prompt">Prompt (for POST/Wizard):</label>
          <input type="text" id="prompt" value="Build a todo app" placeholder="Enter your prompt...">
        </div>

        <div class="control-group">
          <label for="chunkSize">
            Chunk Size: <span class="range-value" id="chunkSizeValue">20</span>
          </label>
          <input type="range" id="chunkSize" min="5" max="50" value="20">
        </div>

        <div class="control-group">
          <label for="delayMs">
            Delay (ms): <span class="range-value" id="delayMsValue">200</span>
          </label>
          <input type="range" id="delayMs" min="50" max="1000" step="50" value="200">
        </div>
      </div>

      <!-- Buttons -->
      <div class="buttons">
        <button class="btn-primary" id="btnGet">
          <span></span> GET Stream
        </button>
        <button class="btn-success" id="btnPost">
          <span></span> POST Agent
        </button>
        <button class="btn-warning" id="btnWizard">
          <span></span> Wizard Stream
        </button>
        <button class="btn-danger" id="btnStop" disabled>
          <span></span> Stop
        </button>
      </div>

      <!-- Output -->
      <div class="output-section">
        <div class="output-header">
          <h3>Output</h3>
          <div class="status idle" id="status">
            <span class="status-dot"></span>
            <span id="statusText">Idle</span>
          </div>
        </div>
        <div class="output empty" id="output">(Click a button above to start streaming...)</div>
      </div>

      <!-- Stats -->
      <div class="stats">
        <div class="stat">
          <span class="stat-value" id="statChunks">0</span>
          <span class="stat-label">Chunks</span>
        </div>
        <div class="stat">
          <span class="stat-value" id="statBytes">0</span>
          <span class="stat-label">Bytes</span>
        </div>
        <div class="stat">
          <span class="stat-value" id="statDuration">0s</span>
          <span class="stat-label">Duration</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    const BACKEND_URL = 'http://localhost:4000';
    let eventSource = null;
    let startTime = null;
    let chunkCount = 0;
    let byteCount = 0;

    // Elements
    const promptInput = document.getElementById('prompt');
    const chunkSizeInput = document.getElementById('chunkSize');
    const chunkSizeValue = document.getElementById('chunkSizeValue');
    const delayMsInput = document.getElementById('delayMs');
    const delayMsValue = document.getElementById('delayMsValue');
    const output = document.getElementById('output');
    const status = document.getElementById('status');
    const statusText = document.getElementById('statusText');
    const btnGet = document.getElementById('btnGet');
    const btnPost = document.getElementById('btnPost');
    const btnWizard = document.getElementById('btnWizard');
    const btnStop = document.getElementById('btnStop');
    const statChunks = document.getElementById('statChunks');
    const statBytes = document.getElementById('statBytes');
    const statDuration = document.getElementById('statDuration');

    // Update range values
    chunkSizeInput.addEventListener('input', (e) => {
      chunkSizeValue.textContent = e.target.value;
    });

    delayMsInput.addEventListener('input', (e) => {
      delayMsValue.textContent = e.target.value;
    });

    // Reset stats
    function resetStats() {
      chunkCount = 0;
      byteCount = 0;
      startTime = Date.now();
      statChunks.textContent = '0';
      statBytes.textContent = '0';
      statDuration.textContent = '0s';
      output.classList.remove('empty');
      output.textContent = '';
    }

    // Update stats
    function updateStats(text) {
      chunkCount++;
      byteCount += new Blob([text]).size;
      const duration = ((Date.now() - startTime) / 1000).toFixed(1);

      statChunks.textContent = chunkCount;
      statBytes.textContent = byteCount;
      statDuration.textContent = duration + 's';
    }

    // Set streaming state
    function setStreaming(isStreaming) {
      if (isStreaming) {
        status.classList.remove('idle');
        status.classList.add('streaming');
        statusText.textContent = 'Streaming...';
        btnGet.disabled = true;
        btnPost.disabled = true;
        btnWizard.disabled = true;
        btnStop.disabled = false;
      } else {
        status.classList.remove('streaming');
        status.classList.add('idle');
        statusText.textContent = 'Idle';
        btnGet.disabled = false;
        btnPost.disabled = false;
        btnWizard.disabled = false;
        btnStop.disabled = true;
      }
    }

    // Stop streaming
    function stopStreaming() {
      if (eventSource) {
        eventSource.close();
        eventSource = null;
      }
      setStreaming(false);
      output.textContent += '\n\n[Stream stopped by user]';
    }

    // GET Stream
    btnGet.addEventListener('click', () => {
      resetStats();
      setStreaming(true);

      const url = `${BACKEND_URL}/api/stream-test?chunkSize=${chunkSizeInput.value}&delayMs=${delayMsInput.value}`;

      eventSource = new EventSource(url);

      eventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);

          if (data.type === 'chunk') {
            output.textContent += data.data;
            updateStats(data.data);
          } else if (data.type === 'complete') {
            output.textContent += '\n\n Stream complete!';
            stopStreaming();
          } else if (data.type === 'error') {
            output.textContent += `\n\n Error: ${data.error}`;
            stopStreaming();
          }
        } catch (e) {
          console.error('Parse error:', e);
        }
      };

      eventSource.onerror = () => {
        output.textContent += '\n\n Connection error';
        stopStreaming();
      };
    });

    // POST Agent Stream
    btnPost.addEventListener('click', async () => {
      resetStats();
      setStreaming(true);

      const body = {
        prompt: promptInput.value,
        chunkSize: parseInt(chunkSizeInput.value),
        delayMs: parseInt(delayMsInput.value)
      };

      try {
        const response = await fetch(`${BACKEND_URL}/api/stream-test`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });

        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split('\n\n');

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const data = JSON.parse(line.substring(6));

                if (data.type === 'start') {
                  output.textContent += ` Agent started for: "${data.prompt}"\n\n`;
                } else if (data.type === 'chunk') {
                  output.textContent += data.data;
                  updateStats(data.data);
                } else if (data.type === 'complete') {
                  output.textContent += '\n\n Agent complete!';
                  setStreaming(false);
                }
              } catch (e) {
                console.error('Parse error:', e);
              }
            }
          }
        }
      } catch (error) {
        output.textContent += `\n\n Error: ${error.message}`;
        setStreaming(false);
      }
    });

    // Wizard Stream
    btnWizard.addEventListener('click', () => {
      resetStats();
      setStreaming(true);

      const url = `${BACKEND_URL}/api/wizard/stream?brief=${encodeURIComponent(promptInput.value)}&chunkSize=${chunkSizeInput.value}&delayMs=${delayMsInput.value}`;

      eventSource = new EventSource(url);

      eventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);

          if (data.type === 'suggestion') {
            output.textContent += data.data;
            updateStats(data.data);
          } else if (data.type === 'complete') {
            output.textContent += `\n\n Wizard complete! (${data.duration}ms)`;
            stopStreaming();
          } else if (data.type === 'error') {
            output.textContent += `\n\n Error: ${data.error}`;
            stopStreaming();
          }
        } catch (e) {
          console.error('Parse error:', e);
        }
      };

      eventSource.onerror = () => {
        output.textContent += '\n\n Connection error';
        stopStreaming();
      };
    });

    // Stop button
    btnStop.addEventListener('click', stopStreaming);
  </script>
</body>
</html>
</file>

<file path="packages/ui-frontend/types/istextorbinary.d.ts">
/**
 * @note For some reason the types aren't picked up from node_modules so I declared the module here
 * with only the function that we use.
 */
declare module 'istextorbinary' {
  export interface EncodingOpts {
    /** Defaults to 24 */
    chunkLength?: number;

    /** If not provided, will check the start, beginning, and end */
    chunkBegin?: number;
  }

  export function getEncoding(buffer: Buffer | null, opts?: EncodingOpts): 'utf8' | 'binary' | null;
}
</file>

<file path="packages/ui-frontend/.editorconfig">
root = true

[*]
indent_style = space
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true
max_line_length = 120
indent_size = 2

[*.md]
trim_trailing_whitespace = false
</file>

<file path="packages/ui-frontend/.gitignore">
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

.vscode/*
!.vscode/launch.json
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*

# Backups and archives
backups/
*.tar.gz

# Generated files
public/generated/
*.njsproj
*.sln
*.sw?

/.cache
/build
.env*
*.vars

eitherwayalmostdone/
</file>

<file path="packages/ui-frontend/.prettierignore">
pnpm-lock.yaml
.astro
</file>

<file path="packages/ui-frontend/.prettierrc">
{
  "printWidth": 120,
  "singleQuote": true,
  "useTabs": false,
  "tabWidth": 2,
  "semi": true,
  "bracketSpacing": true
}
</file>

<file path="packages/ui-frontend/.tool-versions">
nodejs 20.15.1
pnpm 9.4.0
</file>

<file path="packages/ui-frontend/eslint.config.mjs">
import blitzPlugin from '@blitz/eslint-plugin';
import { jsFileExtensions } from '@blitz/eslint-plugin/dist/configs/javascript.js';
import { getNamingConventionRule, tsFileExtensions } from '@blitz/eslint-plugin/dist/configs/typescript.js';

export default [
  {
    ignores: ['**/dist', '**/node_modules', '**/eitherway/build'],
  },
  ...blitzPlugin.configs.recommended(),
  {
    rules: {
      '@blitz/catch-error-name': 'off',
      '@typescript-eslint/no-this-alias': 'off',
      '@typescript-eslint/no-empty-object-type': 'off',
      'prettier/prettier': 'off',
      'eol-last': 'off',
      'no-trailing-spaces': 'off',
      indent: 'off',
      '@typescript-eslint/indent': 'off',
      'linebreak-style': 'off',
      'max-len': 'off',
      'no-multiple-empty-lines': 'off',
      'space-before-function-paren': 'off',
      'comma-dangle': 'off',
      semi: 'off',
      quotes: 'off',
      'object-curly-spacing': 'off',
      'array-bracket-spacing': 'off',
      'space-in-parens': 'off',
      'key-spacing': 'off',
      'keyword-spacing': 'off',
      'space-before-blocks': 'off',
      'space-infix-ops': 'off',
      'no-multi-spaces': 'off',
      'jsdoc/check-alignment': 'off',
      'jsdoc/check-indentation': 'off',
      'jsdoc/newline-after-description': 'off',
      'jsdoc/require-jsdoc': 'off',
      'jsdoc/valid-types': 'off',
      'valid-jsdoc': 'off',
      'require-jsdoc': 'off',
      'spaced-comment': 'off',
      'multiline-comment-style': 'off',
    },
  },
  {
    files: ['**/*.tsx'],
    rules: {
      ...getNamingConventionRule({}, true),
    },
  },
  {
    files: ['**/*.d.ts'],
    rules: {
      '@typescript-eslint/no-empty-object-type': 'off',
    },
  },
  {
    files: [...tsFileExtensions, ...jsFileExtensions, '**/*.tsx'],
    ignores: ['functions/*'],
    rules: {
      'no-restricted-imports': 'off',
    },
  },
];
</file>

<file path="packages/ui-frontend/LICENSE">
MIT License

Copyright (c) 2024 StackBlitz, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="packages/ui-frontend/uno.config.ts">
import { globSync } from 'fast-glob';
import fs from 'node:fs/promises';
import { basename } from 'node:path';
import { defineConfig, presetIcons, presetUno, transformerDirectives } from 'unocss';

const iconPaths = globSync('./public/icons/*.svg');

const collectionName = 'eitherway';

const customIconCollection = iconPaths.reduce(
  (acc, iconPath) => {
    const [iconName] = basename(iconPath).split('.');

    acc[collectionName] ??= {};
    acc[collectionName][iconName] = async () => fs.readFile(iconPath, 'utf8');

    return acc;
  },
  {} as Record<string, Record<string, () => Promise<string>>>,
);

const BASE_COLORS = {
  white: '#FFFFFF',
  gray: {
    50: '#FAFAFA',
    100: '#F5F5F5',
    200: '#E5E5E5',
    300: '#D4D4D4',
    400: '#A3A3A3',
    500: '#737373',
    600: '#525252',
    700: '#404040',
    800: '#262626',
    900: '#171717',
    950: '#0A0A0A',
  },
  accent: {
    50: '#f0fdf4',
    100: '#dcfce7',
    200: '#bbf7d0',
    300: '#86efac',
    400: '#4ade80',
    500: '#21c352',
    600: '#16a34a',
    700: '#15803d',
    800: '#166534',
    900: '#14532d',
    950: '#052e16',
  },
  green: {
    50: '#F0FDF4',
    100: '#DCFCE7',
    200: '#BBF7D0',
    300: '#86EFAC',
    400: '#4ADE80',
    500: '#22C55E',
    600: '#16A34A',
    700: '#15803D',
    800: '#166534',
    900: '#14532D',
    950: '#052E16',
  },
  orange: {
    50: '#FFFAEB',
    100: '#FEEFC7',
    200: '#FEDF89',
    300: '#FEC84B',
    400: '#FDB022',
    500: '#F79009',
    600: '#DC6803',
    700: '#B54708',
    800: '#93370D',
    900: '#792E0D',
  },
  red: {
    50: '#FEF2F2',
    100: '#FEE2E2',
    200: '#FECACA',
    300: '#FCA5A5',
    400: '#F87171',
    500: '#EF4444',
    600: '#DC2626',
    700: '#B91C1C',
    800: '#991B1B',
    900: '#7F1D1D',
    950: '#450A0A',
  },
};

const COLOR_PRIMITIVES = {
  ...BASE_COLORS,
  alpha: {
    white: generateAlphaPalette(BASE_COLORS.white),
    gray: generateAlphaPalette(BASE_COLORS.gray[900]),
    red: generateAlphaPalette(BASE_COLORS.red[500]),
    accent: generateAlphaPalette(BASE_COLORS.accent[500]),
  },
};

export default defineConfig({
  shortcuts: {
    'eitherway-ease-cubic-bezier': 'ease-[cubic-bezier(0.4,0,0.2,1)]',
    'transition-theme': 'transition-[background-color,border-color,color] duration-150 eitherway-ease-cubic-bezier',
    kdb: 'bg-eitherway-elements-code-background text-eitherway-elements-code-text py-1 px-1.5 rounded-md',
    'max-w-chat': 'max-w-[var(--chat-max-width)]',
  },
  rules: [
    /**
     * This shorthand doesn't exist in Tailwind and we overwrite it to avoid
     * any conflicts with minified CSS classes.
     */
    ['b', {}],
  ],
  theme: {
    fontFamily: {
      syne: ['Syne', 'ui-sans-serif', 'system-ui', 'sans-serif'],
      montserrat: ['Montserrat', 'ui-sans-serif', 'system-ui', 'sans-serif'],
      righteous: ['Righteous', 'cursive'],
      mono: [
        'Azeret Mono',
        'ui-monospace',
        'SFMono-Regular',
        'Menlo',
        'Monaco',
        'Consolas',
        'Liberation Mono',
        'Courier New',
        'monospace',
      ],
      sans: ['Azeret Mono', 'ui-monospace', 'system-ui', 'sans-serif'],
    },
    colors: {
      ...COLOR_PRIMITIVES,
      eitherway: {
        elements: {
          borderColor: 'var(--eitherway-elements-borderColor)',
          borderColorActive: 'var(--eitherway-elements-borderColorActive)',
          background: {
            depth: {
              1: 'var(--eitherway-elements-bg-depth-1)',
              2: 'var(--eitherway-elements-bg-depth-2)',
              3: 'var(--eitherway-elements-bg-depth-3)',
              4: 'var(--eitherway-elements-bg-depth-4)',
            },
          },
          textPrimary: 'var(--eitherway-elements-textPrimary)',
          textSecondary: 'var(--eitherway-elements-textSecondary)',
          textTertiary: 'var(--eitherway-elements-textTertiary)',
          code: {
            background: 'var(--eitherway-elements-code-background)',
            text: 'var(--eitherway-elements-code-text)',
          },
          button: {
            primary: {
              background: 'var(--eitherway-elements-button-primary-background)',
              backgroundHover: 'var(--eitherway-elements-button-primary-backgroundHover)',
              text: 'var(--eitherway-elements-button-primary-text)',
            },
            secondary: {
              background: 'var(--eitherway-elements-button-secondary-background)',
              backgroundHover: 'var(--eitherway-elements-button-secondary-backgroundHover)',
              text: 'var(--eitherway-elements-button-secondary-text)',
            },
            danger: {
              background: 'var(--eitherway-elements-button-danger-background)',
              backgroundHover: 'var(--eitherway-elements-button-danger-backgroundHover)',
              text: 'var(--eitherway-elements-button-danger-text)',
            },
          },
          item: {
            contentDefault: 'var(--eitherway-elements-item-contentDefault)',
            contentActive: 'var(--eitherway-elements-item-contentActive)',
            contentAccent: 'var(--eitherway-elements-item-contentAccent)',
            contentDanger: 'var(--eitherway-elements-item-contentDanger)',
            backgroundDefault: 'var(--eitherway-elements-item-backgroundDefault)',
            backgroundActive: 'var(--eitherway-elements-item-backgroundActive)',
            backgroundAccent: 'var(--eitherway-elements-item-backgroundAccent)',
            backgroundDanger: 'var(--eitherway-elements-item-backgroundDanger)',
          },
          actions: {
            background: 'var(--eitherway-elements-actions-background)',
            code: {
              background: 'var(--eitherway-elements-actions-code-background)',
            },
          },
          artifacts: {
            background: 'var(--eitherway-elements-artifacts-background)',
            backgroundHover: 'var(--eitherway-elements-artifacts-backgroundHover)',
            borderColor: 'var(--eitherway-elements-artifacts-borderColor)',
            inlineCode: {
              background: 'var(--eitherway-elements-artifacts-inlineCode-background)',
              text: 'var(--eitherway-elements-artifacts-inlineCode-text)',
            },
          },
          messages: {
            background: 'var(--eitherway-elements-messages-background)',
            linkColor: 'var(--eitherway-elements-messages-linkColor)',
            code: {
              background: 'var(--eitherway-elements-messages-code-background)',
            },
            inlineCode: {
              background: 'var(--eitherway-elements-messages-inlineCode-background)',
              text: 'var(--eitherway-elements-messages-inlineCode-text)',
            },
          },
          icon: {
            success: 'var(--eitherway-elements-icon-success)',
            error: 'var(--eitherway-elements-icon-error)',
            primary: 'var(--eitherway-elements-icon-primary)',
            secondary: 'var(--eitherway-elements-icon-secondary)',
            tertiary: 'var(--eitherway-elements-icon-tertiary)',
          },
          preview: {
            addressBar: {
              background: 'var(--eitherway-elements-preview-addressBar-background)',
              backgroundHover: 'var(--eitherway-elements-preview-addressBar-backgroundHover)',
              backgroundActive: 'var(--eitherway-elements-preview-addressBar-backgroundActive)',
              text: 'var(--eitherway-elements-preview-addressBar-text)',
              textActive: 'var(--eitherway-elements-preview-addressBar-textActive)',
            },
          },
          terminals: {
            background: 'var(--eitherway-elements-terminals-background)',
            buttonBackground: 'var(--eitherway-elements-terminals-buttonBackground)',
          },
          dividerColor: 'var(--eitherway-elements-dividerColor)',
          loader: {
            background: 'var(--eitherway-elements-loader-background)',
            progress: 'var(--eitherway-elements-loader-progress)',
          },
          prompt: {
            background: 'var(--eitherway-elements-prompt-background)',
          },
          sidebar: {
            dropdownShadow: 'var(--eitherway-elements-sidebar-dropdownShadow)',
            buttonBackgroundDefault: 'var(--eitherway-elements-sidebar-buttonBackgroundDefault)',
            buttonBackgroundHover: 'var(--eitherway-elements-sidebar-buttonBackgroundHover)',
            buttonText: 'var(--eitherway-elements-sidebar-buttonText)',
          },
          cta: {
            background: 'var(--eitherway-elements-cta-background)',
            text: 'var(--eitherway-elements-cta-text)',
          },
        },
      },
    },
  },
  transformers: [transformerDirectives()],
  presets: [
    presetUno({
      dark: {
        light: '[data-theme="light"]',
        dark: '[data-theme="dark"]',
      },
    }),
    presetIcons({
      warn: true,
      collections: {
        ...customIconCollection,
      },
    }),
  ],
});

/**
 * Generates an alpha palette for a given hex color.
 *
 * @param hex - The hex color code (without alpha) to generate the palette from.
 * @returns An object where keys are opacity percentages and values are hex colors with alpha.
 *
 * Example:
 *
 * ```
 * {
 *   '1': '#FFFFFF03',
 *   '2': '#FFFFFF05',
 *   '3': '#FFFFFF08',
 * }
 * ```
 */
function generateAlphaPalette(hex: string) {
  return [1, 2, 3, 4, 5, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100].reduce(
    (acc, opacity) => {
      const alpha = Math.round((opacity / 100) * 255)
        .toString(16)
        .padStart(2, '0');

      acc[opacity] = `${hex}${alpha}`;

      return acc;
    },
    {} as Record<number, string>,
  );
}
</file>

<file path="packages/ui-server/src/events/index.ts">
/**
 * @eitherway/ui-server/events - Streaming protocol types and utilities
 *
 * This module provides:
 * - Typed stream event definitions with zod validation
 * - Event senders with automatic validation and logging
 * - Event logger for observability
 */

export * from './types.js';
export * from './send.js';
export * from './logger.js';
</file>

<file path="packages/ui-server/src/security/ssrf-guard.ts">
/**
 * SSRF (Server-Side Request Forgery) Protection
 * Domain allow-list based validation for proxy requests
 */

/**
 * Allow-listed domains for CDN and API proxying
 * Extensible via PROXY_ALLOWED_DOMAINS environment variable (comma-separated)
 */
export const ALLOWED_DOMAINS = [
  // CDN providers
  'unpkg.com',
  'cdn.jsdelivr.net',
  'cdnjs.cloudflare.com',
  'esm.sh',
  'cdn.skypack.dev',

  // Google services
  'fonts.googleapis.com',
  'fonts.gstatic.com',
  'ajax.googleapis.com',

  // APIs
  'api.coingecko.com',
  'pro-api.coingecko.com',
  'api.coincap.io',
  'api.openweathermap.org',
  'api.github.com',

  // Image/asset CDNs
  'images.unsplash.com',
  'cdn.pixabay.com',
  'raw.githubusercontent.com',

  // Add custom domains from environment variable
  ...(process.env.PROXY_ALLOWED_DOMAINS?.split(',')
    .map((d) => d.trim())
    .filter(Boolean) || []),
];

export interface SecurityCheckResult {
  valid: boolean;
  errorCode?: string;
  errorMessage?: string;
}

/**
 * Validate URL against SSRF protection rules
 *
 * Blocks:
 * - Non-HTTP(S) protocols
 * - Localhost and loopback addresses (127.0.0.1, ::1)
 * - Private IP ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)
 * - Link-local addresses (169.254.0.0/16, fe80::/10)
 * - Domains not in allow-list
 */
export function isSecureUrl(url: URL): SecurityCheckResult {
  // Protocol check
  if (url.protocol !== 'http:' && url.protocol !== 'https:') {
    return {
      valid: false,
      errorCode: 'INVALID_PROTOCOL',
      errorMessage: 'Only HTTP and HTTPS protocols are allowed',
    };
  }

  const hostname = url.hostname.toLowerCase();

  // Localhost checks (IPv4 and IPv6)
  if (
    hostname === 'localhost' ||
    hostname === '127.0.0.1' ||
    hostname === '::1' ||
    hostname === '0.0.0.0' ||
    hostname === '::'
  ) {
    return {
      valid: false,
      errorCode: 'LOCALHOST_BLOCKED',
      errorMessage: 'Local addresses are not allowed',
    };
  }

  // Private IPv4 ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)
  if (hostname.match(/^10\.|^172\.(1[6-9]|2[0-9]|3[01])\.|^192\.168\./)) {
    return {
      valid: false,
      errorCode: 'PRIVATE_IP_BLOCKED',
      errorMessage: 'Private IP ranges are not allowed',
    };
  }

  // Link-local IPv4 (169.254.0.0/16) and IPv6 (fe80::/10, fc00::/7)
  if (hostname.match(/^169\.254\.|^fe80:|^fc00:|^fd/)) {
    return {
      valid: false,
      errorCode: 'LINK_LOCAL_BLOCKED',
      errorMessage: 'Link-local addresses are not allowed',
    };
  }

  // Domain allow-list check
  const isAllowed = ALLOWED_DOMAINS.some((allowedDomain) => {
    // Exact match or subdomain match
    return hostname === allowedDomain || hostname.endsWith('.' + allowedDomain);
  });

  if (!isAllowed) {
    return {
      valid: false,
      errorCode: 'DOMAIN_NOT_ALLOWED',
      errorMessage: `Domain '${hostname}' is not in the allow-list. Add to PROXY_ALLOWED_DOMAINS env var if needed.`,
    };
  }

  return { valid: true };
}
</file>

<file path="packages/ui-server/src/constants.ts">
/**
 * Server and Proxy Configuration Constants
 */

/**
 * Cache time-to-live for proxied API responses (milliseconds)
 * 30 seconds balances freshness with reduced upstream requests
 */
export const API_CACHE_TTL_MS = 30_000;

/**
 * Cache-Control max-age for CDN resources (seconds)
 * 24 hours is appropriate for immutable CDN assets
 */
export const CDN_CACHE_MAX_AGE_SECONDS = 86400;

/**
 * Default HTTP port for the server
 */
export const DEFAULT_SERVER_PORT = 3001;

/**
 * Default HTTPS port for the server
 */
export const DEFAULT_HTTPS_PORT = 3002;
</file>

<file path="packages/ui-server/workspace/src/App.jsx">
import { useState } from 'react'

export default function App() {
  const [count, setCount] = useState(0)

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
      <div className="bg-white rounded-2xl shadow-xl p-8 max-w-md w-full">
        <h1 className="text-4xl font-bold text-gray-800 mb-2 text-center">
          Welcome to React
        </h1>
        <p className="text-gray-600 text-center mb-8">
          Built with Vite + Tailwind CSS
        </p>

        <div className="flex flex-col items-center gap-4">
          <div className="flex items-center gap-4">
            <button
              onClick={() => setCount(count - 1)}
              className="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-6 rounded-lg transition-colors duration-200 shadow-md"
            >
              -
            </button>
            <span className="text-5xl font-bold text-indigo-600 min-w-[80px] text-center">
              {count}
            </span>
            <button
              onClick={() => setCount(count + 1)}
              className="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-6 rounded-lg transition-colors duration-200 shadow-md"
            >
              +
            </button>
          </div>

          <button
            onClick={() => setCount(0)}
            className="bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-8 rounded-lg transition-colors duration-200"
          >
            Reset
          </button>
        </div>

        <div className="mt-8 p-4 bg-indigo-50 rounded-lg">
          <p className="text-sm text-gray-700 text-center">
            Edit <code className="bg-white px-2 py-1 rounded font-mono text-xs">src/App.jsx</code> to get started
          </p>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="packages/ui-server/workspace/src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="packages/ui-server/workspace/src/main.jsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="packages/ui-server/workspace/package.json">
{
  "name": "react-app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "@vitejs/plugin-react": "^4.3.4",
    "autoprefixer": "^10.4.20",
    "postcss": "^8.4.49",
    "tailwindcss": "^3.4.17",
    "vite": "^6.0.5"
  }
}
</file>

<file path="packages/ui-server/workspace/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="packages/ui-server/workspace/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</file>

<file path="packages/ui-server/workspace/vite.config.js">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})
</file>

<file path="scripts/setup-https.sh">
#!/bin/bash
# Setup HTTPS certificates for local development using mkcert

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
CERTS_DIR="$PROJECT_ROOT/.certs"

echo " Setting up HTTPS for local development..."

# Check if mkcert is installed
if ! command -v mkcert &> /dev/null; then
    echo " mkcert is not installed."
    echo ""
    echo "Please install mkcert first:"
    echo ""
    echo "  macOS:   brew install mkcert"
    echo "  Linux:   curl -JLO \"https://dl.filippo.io/mkcert/latest?for=linux/amd64\""
    echo "           chmod +x mkcert-v*-linux-amd64"
    echo "           mkdir -p ~/.local/bin"
    echo "           mv mkcert-v*-linux-amd64 ~/.local/bin/mkcert"
    echo "           export PATH=\"\$HOME/.local/bin:\$PATH\""
    echo ""
    echo "  Windows: choco install mkcert  OR  scoop install mkcert"
    echo ""
    exit 1
fi

# Try to install local CA (may require sudo)
echo " Installing local CA..."
if mkcert -install 2>/dev/null; then
    echo " Local CA installed successfully"
else
    echo "  Could not install local CA (requires sudo on some systems)"
    echo "   Certificates will still be generated, but browsers may show security warnings."
    echo "   You can accept these warnings for localhost during development."
fi

# Create certificates directory
mkdir -p "$CERTS_DIR"

# Generate certificates for localhost
echo " Generating certificates for localhost..."
cd "$CERTS_DIR"
mkcert -key-file localhost-key.pem -cert-file localhost-cert.pem localhost 127.0.0.1 ::1

echo ""
echo " HTTPS setup complete!"
echo ""
echo "Certificates stored in: $CERTS_DIR"
echo "  - Certificate: localhost-cert.pem"
echo "  - Key:         localhost-key.pem"
echo ""
echo "Your backend will now serve over HTTPS when you start the server."
echo ""
echo "  Note: If your browser shows a security warning, click 'Advanced' > 'Proceed to localhost'"
echo "   This is normal for self-signed certificates in development."
echo ""
</file>

<file path=".eslintrc.json">
{
  "root": true,
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": 2022,
    "sourceType": "module",
    "project": "./tsconfig.json"
  },
  "plugins": ["@typescript-eslint"],
  "extends": ["eslint:recommended", "plugin:@typescript-eslint/recommended"],
  "rules": {
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/no-floating-promises": "error",
    "@typescript-eslint/no-unused-vars": ["warn", { "argsIgnorePattern": "^_" }],
    "no-console": ["warn", { "allow": ["warn", "error"] }]
  },
  "ignorePatterns": ["dist", "build", "node_modules", "workspace", "*.config.js", "*.config.ts"]
}
</file>

<file path=".prettierignore">
node_modules
dist
build
workspace
coverage
.next
.cache
*.min.js
*.min.css
package-lock.json
pnpm-lock.yaml
yarn.lock
</file>

<file path=".prettierrc">
{
  "printWidth": 120,
  "tabWidth": 2,
  "useTabs": false,
  "semi": true,
  "singleQuote": true,
  "quoteProps": "as-needed",
  "trailingComma": "all",
  "bracketSpacing": true,
  "arrowParens": "always",
  "endOfLine": "lf"
}
</file>

<file path="pnpm-workspace.yaml">
packages:
  - 'packages/*'
</file>

<file path="tsconfig.base.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "lib": ["ES2022"],
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "strict": false,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": false,
    "noImplicitReturns": false,
    "noImplicitOverride": false
  },
  "exclude": ["node_modules", "dist", "build"]
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "lib": ["ES2022"],
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="packages/database/src/migrations/007_plan_execution.sql">
-- Migration 007: Plan Execution System
-- Safe execution of AI-generated plans with validation, logging, and idempotency

-- ============================================================================
-- PLAN OPERATIONS LOG
-- ============================================================================
-- Tracks each individual operation within a plan execution

CREATE TABLE IF NOT EXISTS core.plan_operations (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id        UUID NOT NULL REFERENCES core.sessions(id) ON DELETE CASCADE,
  app_id            UUID REFERENCES core.apps(id) ON DELETE CASCADE,
  plan_id           UUID NOT NULL,  -- Client-generated plan identifier for idempotency
  operation_index   INT NOT NULL,   -- Execution order in plan (0-indexed)
  operation_type    TEXT NOT NULL CHECK (operation_type IN ('write', 'patch', 'package_install', 'package_remove')),
  operation_params  JSONB NOT NULL, -- Full operation parameters for replay/audit
  status            TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'running', 'success', 'failed', 'skipped')),
  result            JSONB,          -- Success result or error details
  started_at        TIMESTAMPTZ,
  completed_at      TIMESTAMPTZ,
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (plan_id, operation_index) -- Ensures idempotency per plan
);

-- Indexes for fast lookups
CREATE INDEX IF NOT EXISTS plan_operations_plan ON core.plan_operations(plan_id, operation_index);
CREATE INDEX IF NOT EXISTS plan_operations_session ON core.plan_operations(session_id, created_at DESC);
CREATE INDEX IF NOT EXISTS plan_operations_status ON core.plan_operations(status) WHERE status IN ('running', 'pending');
CREATE INDEX IF NOT EXISTS plan_operations_app ON core.plan_operations(app_id, created_at DESC) WHERE app_id IS NOT NULL;

-- ============================================================================
-- PLAN EXECUTION SUMMARY
-- ============================================================================
-- High-level tracking of entire plan execution

CREATE TABLE IF NOT EXISTS core.plan_executions (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  plan_id         UUID NOT NULL UNIQUE,  -- Globally unique plan identifier
  session_id      UUID NOT NULL REFERENCES core.sessions(id) ON DELETE CASCADE,
  app_id          UUID REFERENCES core.apps(id) ON DELETE CASCADE,
  total_ops       INT NOT NULL,
  succeeded_ops   INT NOT NULL DEFAULT 0,
  failed_ops      INT NOT NULL DEFAULT 0,
  skipped_ops     INT NOT NULL DEFAULT 0,
  status          TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'running', 'completed', 'failed', 'partial')),
  started_at      TIMESTAMPTZ,
  completed_at    TIMESTAMPTZ,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Indexes for reporting and dashboards
CREATE INDEX IF NOT EXISTS plan_executions_session ON core.plan_executions(session_id, created_at DESC);
CREATE INDEX IF NOT EXISTS plan_executions_status ON core.plan_executions(status, created_at DESC);
CREATE INDEX IF NOT EXISTS plan_executions_app ON core.plan_executions(app_id, created_at DESC) WHERE app_id IS NOT NULL;

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON TABLE core.plan_operations IS 'Individual operations within plan executions with full audit trail';
COMMENT ON TABLE core.plan_executions IS 'Summary of plan executions for monitoring and analytics';
COMMENT ON COLUMN core.plan_operations.plan_id IS 'Client-generated UUID for idempotent plan execution';
COMMENT ON COLUMN core.plan_operations.operation_index IS 'Zero-based index indicating execution order';
COMMENT ON COLUMN core.plan_operations.operation_params IS 'Full operation details stored as JSON for audit and replay';
COMMENT ON COLUMN core.plan_executions.status IS 'completed=all success, failed=all failed, partial=mixed results';
</file>

<file path="packages/database/src/migrations/009_security_audit.sql">
/**
 * Migration 009: Security Audit System
 *
 * Purpose:
 * - Track security-relevant events
 * - Monitor suspicious activity patterns
 * - Enable forensic analysis
 * - Support compliance requirements
 *
 * Tables:
 * - core.security_events: All security-related events
 * - core.rate_limit_violations: Detailed rate limit tracking
 */

-- ============================================================================
-- SECURITY EVENTS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.security_events (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Event classification
  event_type        TEXT NOT NULL CHECK (event_type IN (
    'auth.login_attempt',
    'auth.login_success',
    'auth.login_failure',
    'auth.logout',
    'auth.session_expired',
    'validation.plan_rejected',
    'validation.input_sanitized',
    'validation.file_blocked',
    'rate_limit.exceeded',
    'rate_limit.warning',
    'access.unauthorized',
    'access.forbidden',
    'injection.sql_attempt',
    'injection.xss_attempt',
    'injection.command_attempt',
    'upload.malicious_file',
    'upload.size_exceeded',
    'api.abuse_detected',
    'api.invalid_request',
    'system.config_changed',
    'system.admin_action'
  )),

  severity          TEXT NOT NULL DEFAULT 'info'
                    CHECK (severity IN ('debug', 'info', 'warning', 'error', 'critical')),

  -- Context
  user_id           UUID REFERENCES core.users(id) ON DELETE SET NULL,
  session_id        UUID REFERENCES core.sessions(id) ON DELETE SET NULL,
  app_id            UUID REFERENCES core.apps(id) ON DELETE SET NULL,

  -- Request context
  ip_address        INET,
  user_agent        TEXT,
  request_path      TEXT,
  request_method    TEXT,

  -- Event details
  event_data        JSONB NOT NULL DEFAULT '{}',

  -- Detection metadata
  risk_score        INT CHECK (risk_score >= 0 AND risk_score <= 100),
  is_blocked        BOOLEAN DEFAULT false,
  detection_rules   TEXT[],

  -- Timestamp
  occurred_at       TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- Indexes for common queries
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_security_events_event_type ON core.security_events(event_type);
CREATE INDEX idx_security_events_severity ON core.security_events(severity);
CREATE INDEX idx_security_events_user_id ON core.security_events(user_id);
CREATE INDEX idx_security_events_session_id ON core.security_events(session_id);
CREATE INDEX idx_security_events_ip_address ON core.security_events(ip_address);
CREATE INDEX idx_security_events_occurred_at ON core.security_events(occurred_at DESC);
CREATE INDEX idx_security_events_risk_score ON core.security_events(risk_score DESC) WHERE risk_score > 50;
CREATE INDEX idx_security_events_blocked ON core.security_events(is_blocked) WHERE is_blocked = true;

-- GIN index for JSONB queries
CREATE INDEX idx_security_events_event_data ON core.security_events USING GIN (event_data);

-- ============================================================================
-- RATE LIMIT VIOLATIONS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.rate_limit_violations (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Rate limit context
  limit_type        TEXT NOT NULL CHECK (limit_type IN (
    'message_sending',
    'file_operations',
    'plan_execution',
    'brand_kit_uploads',
    'api_requests',
    'auth_attempts',
    'session_creation'
  )),

  -- Identifier (user_id, IP, or composite)
  identifier        TEXT NOT NULL,
  identifier_type   TEXT NOT NULL CHECK (identifier_type IN ('user_id', 'ip_address', 'session_id', 'api_key')),

  -- Violation details
  limit_value       INT NOT NULL,
  current_count     INT NOT NULL,
  window_start      TIMESTAMPTZ NOT NULL,
  window_end        TIMESTAMPTZ NOT NULL,

  -- Context
  user_id           UUID REFERENCES core.users(id) ON DELETE SET NULL,
  session_id        UUID REFERENCES core.sessions(id) ON DELETE SET NULL,
  ip_address        INET,

  -- Request details
  request_path      TEXT,
  request_method    TEXT,
  user_agent        TEXT,

  -- Action taken
  action            TEXT NOT NULL CHECK (action IN ('blocked', 'throttled', 'logged', 'warned')),

  -- Timestamp
  violated_at       TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- Metadata
  metadata          JSONB DEFAULT '{}'
);

CREATE INDEX idx_rate_limit_violations_limit_type ON core.rate_limit_violations(limit_type);
CREATE INDEX idx_rate_limit_violations_identifier ON core.rate_limit_violations(identifier, identifier_type);
CREATE INDEX idx_rate_limit_violations_user_id ON core.rate_limit_violations(user_id);
CREATE INDEX idx_rate_limit_violations_ip_address ON core.rate_limit_violations(ip_address);
CREATE INDEX idx_rate_limit_violations_violated_at ON core.rate_limit_violations(violated_at DESC);

-- ============================================================================
-- SECURITY METRICS VIEW
-- ============================================================================

CREATE OR REPLACE VIEW core.security_metrics AS
SELECT
  date_trunc('hour', occurred_at) AS hour,
  event_type,
  severity,
  COUNT(*) AS event_count,
  COUNT(*) FILTER (WHERE is_blocked) AS blocked_count,
  AVG(risk_score) FILTER (WHERE risk_score IS NOT NULL) AS avg_risk_score,
  COUNT(DISTINCT user_id) AS unique_users,
  COUNT(DISTINCT ip_address) AS unique_ips
FROM core.security_events
WHERE occurred_at >= now() - interval '7 days'
GROUP BY date_trunc('hour', occurred_at), event_type, severity
ORDER BY hour DESC, event_count DESC;

-- ============================================================================
-- HIGH RISK USERS VIEW
-- ============================================================================

CREATE OR REPLACE VIEW core.high_risk_users AS
SELECT
  u.id AS user_id,
  u.email,
  COUNT(*) AS total_security_events,
  COUNT(*) FILTER (WHERE se.severity IN ('error', 'critical')) AS critical_events,
  COUNT(*) FILTER (WHERE se.is_blocked) AS blocked_attempts,
  AVG(se.risk_score) FILTER (WHERE se.risk_score IS NOT NULL) AS avg_risk_score,
  MAX(se.occurred_at) AS last_security_event,
  array_agg(DISTINCT se.event_type) FILTER (WHERE se.severity IN ('error', 'critical')) AS event_types
FROM core.users u
JOIN core.security_events se ON se.user_id = u.id
WHERE se.occurred_at >= now() - interval '30 days'
GROUP BY u.id, u.email
HAVING COUNT(*) FILTER (WHERE se.severity IN ('error', 'critical')) > 5
   OR AVG(se.risk_score) > 60
ORDER BY avg_risk_score DESC NULLS LAST, critical_events DESC;

-- ============================================================================
-- SUSPICIOUS IP ADDRESSES VIEW
-- ============================================================================

CREATE OR REPLACE VIEW core.suspicious_ips AS
SELECT
  ip_address,
  COUNT(*) AS total_events,
  COUNT(*) FILTER (WHERE severity IN ('error', 'critical')) AS critical_events,
  COUNT(*) FILTER (WHERE is_blocked) AS blocked_requests,
  COUNT(DISTINCT user_id) AS unique_users,
  AVG(risk_score) FILTER (WHERE risk_score IS NOT NULL) AS avg_risk_score,
  MAX(occurred_at) AS last_seen,
  array_agg(DISTINCT event_type) AS event_types
FROM core.security_events
WHERE ip_address IS NOT NULL
  AND occurred_at >= now() - interval '24 hours'
GROUP BY ip_address
HAVING COUNT(*) FILTER (WHERE severity IN ('error', 'critical')) > 10
   OR COUNT(*) FILTER (WHERE is_blocked) > 5
   OR AVG(risk_score) > 70
ORDER BY critical_events DESC, avg_risk_score DESC NULLS LAST;

-- ============================================================================
-- CLEANUP POLICY (Optional - for automated retention)
-- ============================================================================

-- Delete old security events (keep 90 days)
-- This should be run via a scheduled job, not a trigger
COMMENT ON TABLE core.security_events IS
'Security audit log - recommended retention: 90 days for info/debug, 1 year for warning/error/critical';

COMMENT ON TABLE core.rate_limit_violations IS
'Rate limit violation tracking - recommended retention: 30 days';

-- ============================================================================
-- FUNCTIONS FOR SECURITY ANALYSIS
-- ============================================================================

/**
 * Calculate risk score for an IP address based on recent activity
 */
CREATE OR REPLACE FUNCTION calculate_ip_risk_score(target_ip INET)
RETURNS INT AS $$
DECLARE
  risk INT := 0;
  event_count INT;
  blocked_count INT;
  critical_count INT;
BEGIN
  -- Count recent events from this IP
  SELECT
    COUNT(*),
    COUNT(*) FILTER (WHERE is_blocked),
    COUNT(*) FILTER (WHERE severity IN ('error', 'critical'))
  INTO event_count, blocked_count, critical_count
  FROM core.security_events
  WHERE ip_address = target_ip
    AND occurred_at >= now() - interval '1 hour';

  -- Calculate risk score
  risk := LEAST(100,
    (event_count * 2) +           -- 2 points per event
    (blocked_count * 10) +        -- 10 points per blocked request
    (critical_count * 20)         -- 20 points per critical event
  );

  RETURN risk;
END;
$$ LANGUAGE plpgsql;

/**
 * Check if an IP should be blocked
 */
CREATE OR REPLACE FUNCTION should_block_ip(target_ip INET)
RETURNS BOOLEAN AS $$
DECLARE
  risk_score INT;
  recent_blocks INT;
BEGIN
  risk_score := calculate_ip_risk_score(target_ip);

  -- Count blocks in last 10 minutes
  SELECT COUNT(*)
  INTO recent_blocks
  FROM core.security_events
  WHERE ip_address = target_ip
    AND is_blocked = true
    AND occurred_at >= now() - interval '10 minutes';

  -- Block if risk score > 80 OR 5+ blocks in 10 minutes
  RETURN risk_score > 80 OR recent_blocks >= 5;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON COLUMN core.security_events.risk_score IS 'Computed risk score 0-100, higher = more dangerous';
COMMENT ON COLUMN core.security_events.detection_rules IS 'Array of rule names that detected this event';
COMMENT ON COLUMN core.rate_limit_violations.action IS 'Action taken when limit was exceeded';
</file>

<file path="packages/database/src/migrations/010_preview_system.sql">
/**
 * Migration 010: Mobile Preview & PWA Validation System
 *
 * Purpose:
 * - Store preview configurations for different devices
 * - Track PWA validation results
 * - Store responsive breakpoint tests
 * - Enable preview URL generation
 *
 * Tables:
 * - core.preview_configs: Device preview configurations
 * - core.pwa_validations: PWA manifest and service worker validation results
 * - core.preview_sessions: Preview session tracking
 */

-- ============================================================================
-- PREVIEW CONFIGURATIONS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.preview_configs (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  app_id            UUID NOT NULL REFERENCES core.apps(id) ON DELETE CASCADE,
  user_id           UUID NOT NULL REFERENCES core.users(id) ON DELETE CASCADE,

  -- Device specification (iPhone 17 Pro Max only for this phase)
  device_name       TEXT NOT NULL DEFAULT 'iPhone 17 Pro Max',
  viewport_width    INT NOT NULL DEFAULT 430,  -- Logical pixels
  viewport_height   INT NOT NULL DEFAULT 932,  -- Logical pixels
  pixel_ratio       FLOAT NOT NULL DEFAULT 3.0,
  user_agent        TEXT NOT NULL DEFAULT 'Mozilla/5.0 (iPhone; CPU iPhone OS 18_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1',

  -- Preview settings
  is_default        BOOLEAN DEFAULT false,
  orientation       TEXT NOT NULL DEFAULT 'portrait' CHECK (orientation IN ('portrait', 'landscape')),

  -- Timestamps
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at        TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- Constraints
  CONSTRAINT preview_configs_dimensions_check CHECK (viewport_width > 0 AND viewport_height > 0),
  CONSTRAINT preview_configs_pixel_ratio_check CHECK (pixel_ratio > 0)
);

CREATE INDEX idx_preview_configs_app_id ON core.preview_configs(app_id);
CREATE INDEX idx_preview_configs_user_id ON core.preview_configs(user_id);
CREATE INDEX idx_preview_configs_is_default ON core.preview_configs(is_default) WHERE is_default = true;

-- Only one default config per app
CREATE UNIQUE INDEX idx_preview_configs_unique_default
  ON core.preview_configs(app_id)
  WHERE is_default = true;

-- ============================================================================
-- PWA VALIDATIONS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.pwa_validations (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  app_id            UUID NOT NULL REFERENCES core.apps(id) ON DELETE CASCADE,
  user_id           UUID NOT NULL REFERENCES core.users(id) ON DELETE CASCADE,

  -- Validation status
  status            TEXT NOT NULL DEFAULT 'pending'
                    CHECK (status IN ('pending', 'running', 'passed', 'failed', 'warning')),

  -- Overall scores
  manifest_score    INT CHECK (manifest_score >= 0 AND manifest_score <= 100),
  service_worker_score INT CHECK (service_worker_score >= 0 AND service_worker_score <= 100),
  icons_score       INT CHECK (icons_score >= 0 AND icons_score <= 100),
  overall_score     INT CHECK (overall_score >= 0 AND overall_score <= 100),

  -- Manifest validation
  manifest_valid    BOOLEAN DEFAULT false,
  manifest_url      TEXT,
  manifest_errors   JSONB DEFAULT '[]',
  manifest_warnings JSONB DEFAULT '[]',
  manifest_data     JSONB,

  -- Service Worker validation
  service_worker_registered BOOLEAN DEFAULT false,
  service_worker_url TEXT,
  service_worker_scope TEXT,
  service_worker_errors JSONB DEFAULT '[]',

  -- Icons validation
  icons_valid       BOOLEAN DEFAULT false,
  icons_found       JSONB DEFAULT '[]',  -- Array of { src, sizes, type }
  icons_missing     JSONB DEFAULT '[]',  -- Array of required but missing sizes

  -- Required PWA features
  has_name          BOOLEAN DEFAULT false,
  has_short_name    BOOLEAN DEFAULT false,
  has_start_url     BOOLEAN DEFAULT false,
  has_display       BOOLEAN DEFAULT false,
  has_theme_color   BOOLEAN DEFAULT false,
  has_background_color BOOLEAN DEFAULT false,
  has_icons         BOOLEAN DEFAULT false,

  -- Additional checks
  is_https          BOOLEAN DEFAULT false,
  has_viewport_meta BOOLEAN DEFAULT false,
  offline_ready     BOOLEAN DEFAULT false,

  -- Validation metadata
  validation_url    TEXT NOT NULL,
  validation_errors JSONB DEFAULT '[]',

  -- Timestamps
  validated_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_pwa_validations_app_id ON core.pwa_validations(app_id);
CREATE INDEX idx_pwa_validations_user_id ON core.pwa_validations(user_id);
CREATE INDEX idx_pwa_validations_status ON core.pwa_validations(status);
CREATE INDEX idx_pwa_validations_overall_score ON core.pwa_validations(overall_score DESC);
CREATE INDEX idx_pwa_validations_validated_at ON core.pwa_validations(validated_at DESC);

-- ============================================================================
-- PREVIEW SESSIONS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.preview_sessions (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  app_id            UUID NOT NULL REFERENCES core.apps(id) ON DELETE CASCADE,
  user_id           UUID NOT NULL REFERENCES core.users(id) ON DELETE CASCADE,
  preview_config_id UUID REFERENCES core.preview_configs(id) ON DELETE SET NULL,

  -- Preview URL
  preview_url       TEXT NOT NULL,
  preview_token     TEXT NOT NULL, -- Unique token for iframe access

  -- Session metadata
  is_active         BOOLEAN DEFAULT true,
  expires_at        TIMESTAMPTZ NOT NULL,
  last_accessed_at  TIMESTAMPTZ,
  access_count      INT DEFAULT 0,

  -- Timestamps
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- Constraints
  CONSTRAINT preview_sessions_token_unique UNIQUE (preview_token)
);

CREATE INDEX idx_preview_sessions_app_id ON core.preview_sessions(app_id);
CREATE INDEX idx_preview_sessions_user_id ON core.preview_sessions(user_id);
CREATE INDEX idx_preview_sessions_preview_token ON core.preview_sessions(preview_token);
CREATE INDEX idx_preview_sessions_is_active ON core.preview_sessions(is_active) WHERE is_active = true;
CREATE INDEX idx_preview_sessions_expires_at ON core.preview_sessions(expires_at);

-- ============================================================================
-- UPDATE TRIGGERS
-- ============================================================================

-- Auto-update updated_at for preview_configs
CREATE OR REPLACE FUNCTION update_preview_config_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER preview_configs_updated_at
  BEFORE UPDATE ON core.preview_configs
  FOR EACH ROW
  EXECUTE FUNCTION update_preview_config_timestamp();

-- ============================================================================
-- HELPER FUNCTIONS
-- ============================================================================

/**
 * Get or create default preview config for an app
 */
CREATE OR REPLACE FUNCTION get_or_create_default_preview_config(
  target_app_id UUID,
  target_user_id UUID
) RETURNS UUID AS $$
DECLARE
  config_id UUID;
BEGIN
  -- Try to find existing default config
  SELECT id INTO config_id
  FROM core.preview_configs
  WHERE app_id = target_app_id AND is_default = true
  LIMIT 1;

  -- If not found, create one
  IF config_id IS NULL THEN
    INSERT INTO core.preview_configs (app_id, user_id, is_default)
    VALUES (target_app_id, target_user_id, true)
    RETURNING id INTO config_id;
  END IF;

  RETURN config_id;
END;
$$ LANGUAGE plpgsql;

/**
 * Cleanup expired preview sessions
 */
CREATE OR REPLACE FUNCTION cleanup_expired_preview_sessions()
RETURNS INT AS $$
DECLARE
  deleted_count INT;
BEGIN
  DELETE FROM core.preview_sessions
  WHERE expires_at < now() AND is_active = true;

  GET DIAGNOSTICS deleted_count = ROW_COUNT;

  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- VIEWS
-- ============================================================================

/**
 * View: Active PWA validation summary
 */
CREATE OR REPLACE VIEW core.pwa_validation_summary AS
SELECT
  app_id,
  COUNT(*) AS total_validations,
  COUNT(*) FILTER (WHERE status = 'passed') AS passed_count,
  COUNT(*) FILTER (WHERE status = 'failed') AS failed_count,
  COUNT(*) FILTER (WHERE status = 'warning') AS warning_count,
  AVG(overall_score) FILTER (WHERE overall_score IS NOT NULL) AS avg_score,
  MAX(validated_at) AS last_validated_at,
  bool_or(manifest_valid) AS has_valid_manifest,
  bool_or(service_worker_registered) AS has_service_worker,
  bool_or(icons_valid) AS has_valid_icons
FROM core.pwa_validations
WHERE validated_at >= now() - interval '30 days'
GROUP BY app_id;

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON TABLE core.preview_configs IS 'Device preview configurations (iPhone 17 Pro Max for Phase 1)';
COMMENT ON TABLE core.pwa_validations IS 'PWA validation results including manifest, service worker, and icons';
COMMENT ON TABLE core.preview_sessions IS 'Active preview sessions with expiring tokens';

COMMENT ON COLUMN core.preview_configs.pixel_ratio IS 'Device pixel ratio (3x for iPhone 17 Pro Max)';
COMMENT ON COLUMN core.pwa_validations.overall_score IS 'Composite PWA score 0-100';
COMMENT ON COLUMN core.preview_sessions.preview_token IS 'Unique token for secure iframe access';
</file>

<file path="packages/database/src/migrations/011_deployment_export.sql">
/**
 * Migration 011: Deployment & Export System
 *
 * Purpose:
 * - Track GitHub Pages deployments
 * - Record ZIP export history
 * - Store build logs and deployment URLs
 * - Monitor deployment status
 *
 * Tables:
 * - core.deployments: Deployment history (GitHub Pages)
 * - core.exports: Export history (ZIP downloads)
 * - core.deployment_logs: Build and deployment logs
 */

-- ============================================================================
-- DEPLOYMENTS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.deployments (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  app_id            UUID NOT NULL REFERENCES core.apps(id) ON DELETE CASCADE,
  user_id           UUID NOT NULL REFERENCES core.users(id) ON DELETE CASCADE,
  session_id        UUID REFERENCES core.sessions(id) ON DELETE SET NULL,

  -- Deployment metadata
  deployment_type   TEXT NOT NULL DEFAULT 'github_pages'
                    CHECK (deployment_type IN ('github_pages', 'netlify', 'vercel', 'custom')),
  status            TEXT NOT NULL DEFAULT 'pending'
                    CHECK (status IN ('pending', 'building', 'deploying', 'success', 'failed', 'cancelled')),

  -- GitHub integration
  repository_url    TEXT,
  repository_owner  TEXT,
  repository_name   TEXT,
  branch            TEXT DEFAULT 'gh-pages',
  commit_sha        TEXT,

  -- Deployment URLs
  deployment_url    TEXT,
  preview_url       TEXT,

  -- Build configuration
  build_command     TEXT,
  output_directory  TEXT DEFAULT 'dist',
  environment_vars  JSONB DEFAULT '{}',

  -- Status tracking
  started_at        TIMESTAMPTZ,
  completed_at      TIMESTAMPTZ,
  duration_ms       INT,

  -- Error tracking
  error_message     TEXT,
  error_stack       TEXT,

  -- Timestamps
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at        TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- Constraints
  CONSTRAINT deployments_duration_check CHECK (duration_ms >= 0)
);

CREATE INDEX idx_deployments_app_id ON core.deployments(app_id);
CREATE INDEX idx_deployments_user_id ON core.deployments(user_id);
CREATE INDEX idx_deployments_session_id ON core.deployments(session_id);
CREATE INDEX idx_deployments_status ON core.deployments(status);
CREATE INDEX idx_deployments_created_at ON core.deployments(created_at DESC);
CREATE INDEX idx_deployments_repository ON core.deployments(repository_owner, repository_name) WHERE repository_owner IS NOT NULL;

-- ============================================================================
-- EXPORTS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.exports (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  app_id            UUID NOT NULL REFERENCES core.apps(id) ON DELETE CASCADE,
  user_id           UUID NOT NULL REFERENCES core.users(id) ON DELETE CASCADE,
  session_id        UUID REFERENCES core.sessions(id) ON DELETE SET NULL,

  -- Export metadata
  export_type       TEXT NOT NULL DEFAULT 'zip'
                    CHECK (export_type IN ('zip', 'tar', 'git_bundle')),
  status            TEXT NOT NULL DEFAULT 'pending'
                    CHECK (status IN ('pending', 'processing', 'success', 'failed')),

  -- File information
  file_count        INT,
  total_size_bytes  BIGINT,
  compressed_size_bytes BIGINT,
  file_path         TEXT, -- Storage path if persisted

  -- Export options
  include_node_modules BOOLEAN DEFAULT false,
  include_git_history BOOLEAN DEFAULT false,
  exclude_patterns  TEXT[] DEFAULT ARRAY['.git', 'node_modules', '.env', '.DS_Store'],

  -- Status tracking
  started_at        TIMESTAMPTZ,
  completed_at      TIMESTAMPTZ,
  duration_ms       INT,
  download_count    INT DEFAULT 0,
  last_downloaded_at TIMESTAMPTZ,

  -- Error tracking
  error_message     TEXT,

  -- Timestamps
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- Constraints
  CONSTRAINT exports_file_count_check CHECK (file_count >= 0),
  CONSTRAINT exports_size_check CHECK (total_size_bytes >= 0 AND compressed_size_bytes >= 0),
  CONSTRAINT exports_duration_check CHECK (duration_ms >= 0)
);

CREATE INDEX idx_exports_app_id ON core.exports(app_id);
CREATE INDEX idx_exports_user_id ON core.exports(user_id);
CREATE INDEX idx_exports_session_id ON core.exports(session_id);
CREATE INDEX idx_exports_status ON core.exports(status);
CREATE INDEX idx_exports_created_at ON core.exports(created_at DESC);

-- ============================================================================
-- DEPLOYMENT LOGS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.deployment_logs (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  deployment_id     UUID NOT NULL REFERENCES core.deployments(id) ON DELETE CASCADE,

  -- Log entry
  log_level         TEXT NOT NULL DEFAULT 'info'
                    CHECK (log_level IN ('debug', 'info', 'warning', 'error', 'critical')),
  message           TEXT NOT NULL,
  details           JSONB,

  -- Step tracking
  step_name         TEXT, -- e.g., 'build', 'deploy', 'verify'
  step_index        INT,

  -- Timestamps
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_deployment_logs_deployment_id ON core.deployment_logs(deployment_id);
CREATE INDEX idx_deployment_logs_log_level ON core.deployment_logs(log_level);
CREATE INDEX idx_deployment_logs_created_at ON core.deployment_logs(created_at);
CREATE INDEX idx_deployment_logs_step ON core.deployment_logs(step_name, step_index);

-- ============================================================================
-- UPDATE TRIGGERS
-- ============================================================================

-- Auto-update updated_at for deployments
CREATE OR REPLACE FUNCTION update_deployment_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();

  -- Auto-calculate duration if completed
  IF NEW.status IN ('success', 'failed', 'cancelled') AND NEW.started_at IS NOT NULL THEN
    NEW.completed_at = now();
    NEW.duration_ms = EXTRACT(EPOCH FROM (NEW.completed_at - NEW.started_at)) * 1000;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER deployments_updated_at
  BEFORE UPDATE ON core.deployments
  FOR EACH ROW
  EXECUTE FUNCTION update_deployment_timestamp();

-- ============================================================================
-- HELPER FUNCTIONS
-- ============================================================================

/**
 * Get latest deployment for an app
 */
CREATE OR REPLACE FUNCTION get_latest_deployment(target_app_id UUID)
RETURNS UUID AS $$
DECLARE
  deployment_id UUID;
BEGIN
  SELECT id INTO deployment_id
  FROM core.deployments
  WHERE app_id = target_app_id
    AND status = 'success'
  ORDER BY created_at DESC
  LIMIT 1;

  RETURN deployment_id;
END;
$$ LANGUAGE plpgsql;

/**
 * Get deployment success rate for an app
 */
CREATE OR REPLACE FUNCTION get_deployment_success_rate(target_app_id UUID)
RETURNS NUMERIC AS $$
DECLARE
  total_deployments INT;
  successful_deployments INT;
  success_rate NUMERIC;
BEGIN
  SELECT COUNT(*) INTO total_deployments
  FROM core.deployments
  WHERE app_id = target_app_id;

  IF total_deployments = 0 THEN
    RETURN 0;
  END IF;

  SELECT COUNT(*) INTO successful_deployments
  FROM core.deployments
  WHERE app_id = target_app_id
    AND status = 'success';

  success_rate = (successful_deployments::NUMERIC / total_deployments::NUMERIC) * 100;

  RETURN ROUND(success_rate, 2);
END;
$$ LANGUAGE plpgsql;

/**
 * Cleanup old failed deployments (keep last 10 per app)
 */
CREATE OR REPLACE FUNCTION cleanup_old_failed_deployments(target_app_id UUID)
RETURNS INT AS $$
DECLARE
  deleted_count INT;
BEGIN
  DELETE FROM core.deployments
  WHERE id IN (
    SELECT id FROM core.deployments
    WHERE app_id = target_app_id
      AND status = 'failed'
    ORDER BY created_at DESC
    OFFSET 10
  );

  GET DIAGNOSTICS deleted_count = ROW_COUNT;

  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- VIEWS
-- ============================================================================

/**
 * View: Deployment summary per app
 */
CREATE OR REPLACE VIEW core.deployment_summary AS
SELECT
  app_id,
  COUNT(*) AS total_deployments,
  COUNT(*) FILTER (WHERE status = 'success') AS successful_deployments,
  COUNT(*) FILTER (WHERE status = 'failed') AS failed_deployments,
  COUNT(*) FILTER (WHERE status IN ('pending', 'building', 'deploying')) AS in_progress_deployments,
  AVG(duration_ms) FILTER (WHERE status = 'success') AS avg_build_time_ms,
  MAX(created_at) FILTER (WHERE status = 'success') AS last_successful_deployment,
  get_deployment_success_rate(app_id) AS success_rate
FROM core.deployments
GROUP BY app_id;

/**
 * View: Recent deployments with logs
 */
CREATE OR REPLACE VIEW core.recent_deployments AS
SELECT
  d.id,
  d.app_id,
  d.user_id,
  d.deployment_type,
  d.status,
  d.deployment_url,
  d.branch,
  d.commit_sha,
  d.duration_ms,
  d.error_message,
  d.created_at,
  d.completed_at,
  a.name AS app_name,
  u.email AS user_email,
  (
    SELECT COUNT(*)
    FROM core.deployment_logs dl
    WHERE dl.deployment_id = d.id
      AND dl.log_level IN ('error', 'critical')
  ) AS error_count
FROM core.deployments d
JOIN core.apps a ON d.app_id = a.id
JOIN core.users u ON d.user_id = u.id
ORDER BY d.created_at DESC
LIMIT 100;

/**
 * View: Export statistics per app
 */
CREATE OR REPLACE VIEW core.export_statistics AS
SELECT
  app_id,
  COUNT(*) AS total_exports,
  COUNT(*) FILTER (WHERE status = 'success') AS successful_exports,
  SUM(download_count) AS total_downloads,
  AVG(total_size_bytes) FILTER (WHERE status = 'success') AS avg_export_size_bytes,
  MAX(created_at) AS last_export_at
FROM core.exports
GROUP BY app_id;

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON TABLE core.deployments IS 'Deployment history for apps (GitHub Pages, Netlify, Vercel, etc.)';
COMMENT ON TABLE core.exports IS 'Export history for ZIP/TAR downloads';
COMMENT ON TABLE core.deployment_logs IS 'Build and deployment logs with step tracking';

COMMENT ON COLUMN core.deployments.deployment_type IS 'Deployment target platform';
COMMENT ON COLUMN core.deployments.status IS 'Current deployment status';
COMMENT ON COLUMN core.deployments.deployment_url IS 'Live deployment URL (e.g., https://user.github.io/repo)';
COMMENT ON COLUMN core.deployments.duration_ms IS 'Total deployment time in milliseconds';

COMMENT ON COLUMN core.exports.export_type IS 'Export archive format';
COMMENT ON COLUMN core.exports.compressed_size_bytes IS 'ZIP/TAR archive size';
COMMENT ON COLUMN core.exports.download_count IS 'Number of times this export was downloaded';
</file>

<file path="packages/database/src/migrations/012_telemetry_observability.sql">
/**
 * Migration 012: Telemetry & Observability
 *
 * Purpose:
 * - Extend events table with typed metrics
 * - Add event schemas for different event types
 * - Create aggregation functions for analytics
 * - Build materialized views for dashboards
 *
 * Event Types:
 * - message.sent, message.received, message.streamed
 * - file.created, file.updated, file.deleted
 * - plan.applied, plan.failed
 * - brand_kit.uploaded, brand_kit.processed
 * - deployment.started, deployment.completed
 * - export.created, export.downloaded
 * - pwa.validated
 * - session.created, session.resumed
 */

-- ============================================================================
-- EXTEND EVENTS TABLE WITH TYPED METRICS
-- ============================================================================

ALTER TABLE IF EXISTS core.events
  ADD COLUMN IF NOT EXISTS user_id UUID REFERENCES core.users(id) ON DELETE SET NULL,
  ADD COLUMN IF NOT EXISTS event_type TEXT,
  ADD COLUMN IF NOT EXISTS event_category TEXT,
  ADD COLUMN IF NOT EXISTS metrics JSONB DEFAULT '{}',
  ADD COLUMN IF NOT EXISTS dimensions JSONB DEFAULT '{}',
  ADD COLUMN IF NOT EXISTS tags TEXT[] DEFAULT '{}';

-- Add check constraint for event categories
ALTER TABLE IF EXISTS core.events
  ADD CONSTRAINT events_category_check
  CHECK (event_category IN (
    'messaging', 'files', 'plans', 'brand_kits',
    'deployments', 'exports', 'pwa', 'sessions',
    'security', 'performance'
  ));

-- Add indexes for analytics queries
CREATE INDEX IF NOT EXISTS idx_events_user_id ON core.events(user_id);
CREATE INDEX IF NOT EXISTS idx_events_category ON core.events(event_category);
CREATE INDEX IF NOT EXISTS idx_events_type_category ON core.events(event_type, event_category);
CREATE INDEX IF NOT EXISTS idx_events_created_at_category ON core.events(created_at DESC, event_category);
CREATE INDEX IF NOT EXISTS idx_events_metrics ON core.events USING GIN (metrics);
CREATE INDEX IF NOT EXISTS idx_events_dimensions ON core.events USING GIN (dimensions);
CREATE INDEX IF NOT EXISTS idx_events_tags ON core.events USING GIN (tags);

COMMENT ON COLUMN core.events.event_category IS 'High-level event category for filtering';
COMMENT ON COLUMN core.events.metrics IS 'Numeric metrics (duration_ms, size_bytes, count, etc.)';
COMMENT ON COLUMN core.events.dimensions IS 'Categorical dimensions (status, source, target, etc.)';
COMMENT ON COLUMN core.events.tags IS 'Array of tags for flexible filtering';

-- ============================================================================
-- EVENT SCHEMAS (JSONB Validation)
-- ============================================================================

/**
 * Validate message event metrics
 */
CREATE OR REPLACE FUNCTION validate_message_metrics(data JSONB)
RETURNS BOOLEAN AS $$
BEGIN
  -- Required fields: token_count, duration_ms
  RETURN (
    data ? 'token_count' AND
    data ? 'duration_ms' AND
    (data->>'token_count')::int >= 0 AND
    (data->>'duration_ms')::int >= 0
  );
END;
$$ LANGUAGE plpgsql IMMUTABLE;

/**
 * Validate file event metrics
 */
CREATE OR REPLACE FUNCTION validate_file_metrics(data JSONB)
RETURNS BOOLEAN AS $$
BEGIN
  -- Required fields: size_bytes, operation
  RETURN (
    data ? 'size_bytes' AND
    data ? 'operation' AND
    (data->>'size_bytes')::bigint >= 0
  );
END;
$$ LANGUAGE plpgsql IMMUTABLE;

/**
 * Validate deployment event metrics
 */
CREATE OR REPLACE FUNCTION validate_deployment_metrics(data JSONB)
RETURNS BOOLEAN AS $$
BEGIN
  -- Required fields: duration_ms, status
  RETURN (
    data ? 'duration_ms' AND
    data ? 'status' AND
    (data->>'duration_ms')::int >= 0
  );
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ============================================================================
-- TELEMETRY LOGGING FUNCTIONS
-- ============================================================================

/**
 * Log telemetry event with typed metrics
 */
CREATE OR REPLACE FUNCTION log_telemetry_event(
  p_app_id UUID,
  p_user_id UUID,
  p_session_id UUID,
  p_event_type TEXT,
  p_event_category TEXT,
  p_metrics JSONB DEFAULT '{}',
  p_dimensions JSONB DEFAULT '{}',
  p_tags TEXT[] DEFAULT '{}'
)
RETURNS UUID AS $$
DECLARE
  event_id UUID;
BEGIN
  INSERT INTO core.events (
    app_id, user_id, session_id, event_type,
    event_category, metrics, dimensions, tags
  )
  VALUES (
    p_app_id, p_user_id, p_session_id, p_event_type,
    p_event_category, p_metrics, p_dimensions, p_tags
  )
  RETURNING id INTO event_id;

  RETURN event_id;
END;
$$ LANGUAGE plpgsql;

/**
 * Log message event
 */
CREATE OR REPLACE FUNCTION log_message_event(
  p_app_id UUID,
  p_user_id UUID,
  p_session_id UUID,
  p_token_count INT,
  p_duration_ms INT,
  p_role TEXT,
  p_model TEXT DEFAULT NULL
)
RETURNS UUID AS $$
BEGIN
  RETURN log_telemetry_event(
    p_app_id,
    p_user_id,
    p_session_id,
    'message.sent',
    'messaging',
    jsonb_build_object(
      'token_count', p_token_count,
      'duration_ms', p_duration_ms
    ),
    jsonb_build_object(
      'role', p_role,
      'model', p_model
    ),
    ARRAY['messaging', 'tokens']
  );
END;
$$ LANGUAGE plpgsql;

/**
 * Log file operation event
 */
CREATE OR REPLACE FUNCTION log_file_event(
  p_app_id UUID,
  p_user_id UUID,
  p_session_id UUID,
  p_operation TEXT,
  p_file_path TEXT,
  p_size_bytes BIGINT
)
RETURNS UUID AS $$
BEGIN
  RETURN log_telemetry_event(
    p_app_id,
    p_user_id,
    p_session_id,
    'file.' || p_operation,
    'files',
    jsonb_build_object(
      'size_bytes', p_size_bytes,
      'operation', p_operation
    ),
    jsonb_build_object(
      'file_path', p_file_path,
      'file_extension', regexp_replace(p_file_path, '.*\.', '')
    ),
    ARRAY['files', p_operation]
  );
END;
$$ LANGUAGE plpgsql;

/**
 * Log deployment event
 */
CREATE OR REPLACE FUNCTION log_deployment_event(
  p_app_id UUID,
  p_user_id UUID,
  p_deployment_id UUID,
  p_status TEXT,
  p_duration_ms INT,
  p_deployment_type TEXT DEFAULT 'github_pages'
)
RETURNS UUID AS $$
BEGIN
  RETURN log_telemetry_event(
    p_app_id,
    p_user_id,
    NULL,
    'deployment.' || p_status,
    'deployments',
    jsonb_build_object(
      'duration_ms', p_duration_ms,
      'deployment_id', p_deployment_id
    ),
    jsonb_build_object(
      'status', p_status,
      'deployment_type', p_deployment_type
    ),
    ARRAY['deployments', p_status]
  );
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- ANALYTICS AGGREGATION FUNCTIONS
-- ============================================================================

/**
 * Get event counts by category for a time range
 */
CREATE OR REPLACE FUNCTION get_event_counts_by_category(
  p_start_time TIMESTAMPTZ,
  p_end_time TIMESTAMPTZ,
  p_app_id UUID DEFAULT NULL
)
RETURNS TABLE (
  event_category TEXT,
  event_count BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    e.event_category,
    COUNT(*) as event_count
  FROM core.events e
  WHERE e.created_at BETWEEN p_start_time AND p_end_time
    AND (p_app_id IS NULL OR e.app_id = p_app_id)
  GROUP BY e.event_category
  ORDER BY event_count DESC;
END;
$$ LANGUAGE plpgsql;

/**
 * Get metric aggregates for a category
 */
CREATE OR REPLACE FUNCTION get_metric_aggregates(
  p_event_category TEXT,
  p_metric_name TEXT,
  p_start_time TIMESTAMPTZ,
  p_end_time TIMESTAMPTZ,
  p_app_id UUID DEFAULT NULL
)
RETURNS TABLE (
  total_count BIGINT,
  sum_value NUMERIC,
  avg_value NUMERIC,
  min_value NUMERIC,
  max_value NUMERIC,
  p50_value NUMERIC,
  p95_value NUMERIC,
  p99_value NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    COUNT(*) as total_count,
    SUM((metrics->>p_metric_name)::numeric) as sum_value,
    AVG((metrics->>p_metric_name)::numeric) as avg_value,
    MIN((metrics->>p_metric_name)::numeric) as min_value,
    MAX((metrics->>p_metric_name)::numeric) as max_value,
    PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY (metrics->>p_metric_name)::numeric) as p50_value,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY (metrics->>p_metric_name)::numeric) as p95_value,
    PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY (metrics->>p_metric_name)::numeric) as p99_value
  FROM core.events
  WHERE event_category = p_event_category
    AND created_at BETWEEN p_start_time AND p_end_time
    AND metrics ? p_metric_name
    AND (p_app_id IS NULL OR app_id = p_app_id);
END;
$$ LANGUAGE plpgsql;

/**
 * Get time-series data for a metric (hourly buckets)
 */
CREATE OR REPLACE FUNCTION get_metric_timeseries(
  p_event_category TEXT,
  p_metric_name TEXT,
  p_start_time TIMESTAMPTZ,
  p_end_time TIMESTAMPTZ,
  p_bucket_size INTERVAL DEFAULT '1 hour',
  p_app_id UUID DEFAULT NULL
)
RETURNS TABLE (
  time_bucket TIMESTAMPTZ,
  event_count BIGINT,
  avg_value NUMERIC,
  sum_value NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    date_trunc('hour', created_at) as time_bucket,
    COUNT(*) as event_count,
    AVG((metrics->>p_metric_name)::numeric) as avg_value,
    SUM((metrics->>p_metric_name)::numeric) as sum_value
  FROM core.events
  WHERE event_category = p_event_category
    AND created_at BETWEEN p_start_time AND p_end_time
    AND metrics ? p_metric_name
    AND (p_app_id IS NULL OR app_id = p_app_id)
  GROUP BY time_bucket
  ORDER BY time_bucket;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- MATERIALIZED VIEWS FOR ANALYTICS
-- ============================================================================

/**
 * Daily event summary (materialized for performance)
 */
CREATE MATERIALIZED VIEW IF NOT EXISTS core.daily_event_summary AS
SELECT
  DATE(created_at) as event_date,
  event_category,
  event_type,
  app_id,
  COUNT(*) as event_count,
  COUNT(DISTINCT user_id) as unique_users,
  COUNT(DISTINCT session_id) as unique_sessions,

  -- Messaging metrics
  SUM(CASE WHEN metrics ? 'token_count' THEN (metrics->>'token_count')::bigint ELSE 0 END) as total_tokens,
  AVG(CASE WHEN metrics ? 'duration_ms' THEN (metrics->>'duration_ms')::numeric ELSE NULL END) as avg_duration_ms,

  -- File metrics
  SUM(CASE WHEN metrics ? 'size_bytes' THEN (metrics->>'size_bytes')::bigint ELSE 0 END) as total_bytes,

  MIN(created_at) as first_event_at,
  MAX(created_at) as last_event_at
FROM core.events
GROUP BY DATE(created_at), event_category, event_type, app_id;

CREATE UNIQUE INDEX IF NOT EXISTS idx_daily_event_summary_unique
  ON core.daily_event_summary(event_date, event_category, event_type, app_id);

CREATE INDEX IF NOT EXISTS idx_daily_event_summary_date ON core.daily_event_summary(event_date DESC);
CREATE INDEX IF NOT EXISTS idx_daily_event_summary_category ON core.daily_event_summary(event_category);
CREATE INDEX IF NOT EXISTS idx_daily_event_summary_app_id ON core.daily_event_summary(app_id);

COMMENT ON MATERIALIZED VIEW core.daily_event_summary IS 'Daily aggregated event metrics for analytics dashboards';

/**
 * Hourly performance metrics (materialized)
 */
CREATE MATERIALIZED VIEW IF NOT EXISTS core.hourly_performance_metrics AS
SELECT
  date_trunc('hour', created_at) as hour_bucket,
  event_category,
  app_id,
  COUNT(*) as event_count,

  -- Duration metrics (p50, p95, p99)
  PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY (metrics->>'duration_ms')::numeric) as p50_duration_ms,
  PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY (metrics->>'duration_ms')::numeric) as p95_duration_ms,
  PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY (metrics->>'duration_ms')::numeric) as p99_duration_ms,
  AVG((metrics->>'duration_ms')::numeric) as avg_duration_ms,

  -- Token metrics
  SUM(CASE WHEN metrics ? 'token_count' THEN (metrics->>'token_count')::bigint ELSE 0 END) as total_tokens,
  AVG(CASE WHEN metrics ? 'token_count' THEN (metrics->>'token_count')::numeric ELSE NULL END) as avg_tokens
FROM core.events
WHERE metrics ? 'duration_ms'
GROUP BY hour_bucket, event_category, app_id;

CREATE UNIQUE INDEX IF NOT EXISTS idx_hourly_performance_unique
  ON core.hourly_performance_metrics(hour_bucket, event_category, app_id);

CREATE INDEX IF NOT EXISTS idx_hourly_performance_time ON core.hourly_performance_metrics(hour_bucket DESC);

COMMENT ON MATERIALIZED VIEW core.hourly_performance_metrics IS 'Hourly performance metrics with percentiles';

/**
 * User activity summary
 */
CREATE MATERIALIZED VIEW IF NOT EXISTS core.user_activity_summary AS
SELECT
  user_id,
  DATE(created_at) as activity_date,
  COUNT(*) as total_events,
  COUNT(DISTINCT session_id) as session_count,
  COUNT(DISTINCT app_id) as app_count,

  -- Event category breakdown
  COUNT(*) FILTER (WHERE event_category = 'messaging') as messaging_events,
  COUNT(*) FILTER (WHERE event_category = 'files') as file_events,
  COUNT(*) FILTER (WHERE event_category = 'deployments') as deployment_events,

  MIN(created_at) as first_event_at,
  MAX(created_at) as last_event_at
FROM core.events
GROUP BY user_id, DATE(created_at);

CREATE UNIQUE INDEX IF NOT EXISTS idx_user_activity_unique
  ON core.user_activity_summary(user_id, activity_date);

CREATE INDEX IF NOT EXISTS idx_user_activity_date ON core.user_activity_summary(activity_date DESC);

COMMENT ON MATERIALIZED VIEW core.user_activity_summary IS 'Daily user activity metrics';

-- ============================================================================
-- REFRESH FUNCTIONS FOR MATERIALIZED VIEWS
-- ============================================================================

/**
 * Refresh all analytics views (run daily via cron)
 */
CREATE OR REPLACE FUNCTION refresh_analytics_views()
RETURNS VOID AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY core.daily_event_summary;
  REFRESH MATERIALIZED VIEW CONCURRENTLY core.hourly_performance_metrics;
  REFRESH MATERIALIZED VIEW CONCURRENTLY core.user_activity_summary;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- CLEANUP FUNCTIONS
-- ============================================================================

/**
 * Archive old events (move to archive table or delete after N days)
 */
CREATE OR REPLACE FUNCTION archive_old_events(days_to_keep INT DEFAULT 90)
RETURNS INT AS $$
DECLARE
  archived_count INT;
BEGIN
  DELETE FROM core.events
  WHERE created_at < now() - (days_to_keep || ' days')::interval;

  GET DIAGNOSTICS archived_count = ROW_COUNT;

  RETURN archived_count;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION archive_old_events IS 'Delete events older than N days (default: 90)';

-- ============================================================================
-- EXAMPLE USAGE
-- ============================================================================

COMMENT ON FUNCTION log_telemetry_event IS 'Log generic telemetry event with typed metrics';
COMMENT ON FUNCTION log_message_event IS 'Log message event with token count and duration';
COMMENT ON FUNCTION log_file_event IS 'Log file operation event with size and path';
COMMENT ON FUNCTION log_deployment_event IS 'Log deployment event with status and duration';
COMMENT ON FUNCTION get_event_counts_by_category IS 'Get event counts grouped by category for a time range';
COMMENT ON FUNCTION get_metric_aggregates IS 'Get statistical aggregates for a metric';
COMMENT ON FUNCTION get_metric_timeseries IS 'Get time-series data for a metric';
</file>

<file path="packages/database/src/migrations/create.ts">
#!/usr/bin/env node
import { writeFile, readdir } from 'fs/promises';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

async function createMigration(name: string): Promise<void> {
  const migrationsDir = __dirname;
  const files = await readdir(migrationsDir);

  const sqlFiles = files.filter((f) => f.endsWith('.sql'));
  const maxId = sqlFiles.reduce((max, file) => {
    const match = file.match(/^(\d+)_/);
    if (match) {
      const id = parseInt(match[1], 10);
      return Math.max(max, id);
    }
    return max;
  }, 0);

  const nextId = maxId + 1;
  const paddedId = String(nextId).padStart(3, '0');
  const filename = `${paddedId}_${name}.sql`;
  const filepath = join(migrationsDir, filename);

  const template = `-- Migration ${paddedId}: ${name}

-- Add your SQL here

`;

  await writeFile(filepath, template);

  console.log(`Created migration: ${filename}`);
}

const migrationName = process.argv[2];

if (!migrationName) {
  console.error('Usage: npm run migrate:create <migration-name>');
  process.exit(1);
}

createMigration(migrationName);
</file>

<file path="packages/database/src/repositories/apps.ts">
import { DatabaseClient } from '../client.js';
import type { App } from '../types.js';

export class AppsRepository {
  constructor(private db: DatabaseClient) {}

  async create(ownerId: string, name: string, visibility: 'private' | 'team' | 'public' = 'private'): Promise<App> {
    const result = await this.db.query<App>(
      `INSERT INTO core.apps (owner_id, name, visibility)
       VALUES ($1, $2, $3)
       RETURNING *`,
      [ownerId, name, visibility],
    );
    return result.rows[0];
  }

  async findById(id: string): Promise<App | null> {
    const result = await this.db.query<App>(`SELECT * FROM core.apps WHERE id = $1`, [id]);
    return result.rows[0] ?? null;
  }

  async findByOwner(ownerId: string, limit = 50, offset = 0): Promise<App[]> {
    const result = await this.db.query<App>(
      `SELECT * FROM core.apps
       WHERE owner_id = $1
       ORDER BY created_at DESC
       LIMIT $2 OFFSET $3`,
      [ownerId, limit, offset],
    );
    return result.rows;
  }

  async update(
    id: string,
    data: {
      name?: string;
      visibility?: 'private' | 'team' | 'public';
      default_session_id?: string | null;
    },
  ): Promise<App> {
    const result = await this.db.query<App>(
      `UPDATE core.apps
       SET name = COALESCE($2, name),
           visibility = COALESCE($3, visibility),
           default_session_id = COALESCE($4, default_session_id)
       WHERE id = $1
       RETURNING *`,
      [id, data.name ?? null, data.visibility ?? null, data.default_session_id ?? null],
    );
    return result.rows[0];
  }

  async delete(id: string): Promise<void> {
    await this.db.query(`DELETE FROM core.apps WHERE id = $1`, [id]);
  }
}
</file>

<file path="packages/database/src/repositories/embeddings.ts">
import { DatabaseClient } from '../client.js';
import type { DocEmbedding, EmbeddingScope } from '../types.js';

export class EmbeddingsRepository {
  constructor(private db: DatabaseClient) {}

  async create(
    appId: string,
    scope: EmbeddingScope,
    vector: number[],
    options: {
      refId?: string;
      chunkIdx?: number;
      contentPreview?: string;
      metadata?: any;
    } = {},
  ): Promise<DocEmbedding> {
    const result = await this.db.query<DocEmbedding>(
      `INSERT INTO core.doc_embeddings
       (app_id, scope, ref_id, chunk_idx, vector, content_preview, metadata)
       VALUES ($1, $2, $3, $4, $5, $6, $7)
       RETURNING *`,
      [
        appId,
        scope,
        options.refId ?? null,
        options.chunkIdx ?? null,
        JSON.stringify(vector),
        options.contentPreview ?? null,
        options.metadata ? JSON.stringify(options.metadata) : null,
      ],
    );
    return result.rows[0];
  }

  async findByRef(refId: string, scope?: EmbeddingScope): Promise<DocEmbedding[]> {
    const query = scope
      ? `SELECT * FROM core.doc_embeddings WHERE ref_id = $1 AND scope = $2 ORDER BY chunk_idx ASC`
      : `SELECT * FROM core.doc_embeddings WHERE ref_id = $1 ORDER BY chunk_idx ASC`;

    const params = scope ? [refId, scope] : [refId];
    const result = await this.db.query<DocEmbedding>(query, params);
    return result.rows;
  }

  async semanticSearch(
    appId: string,
    queryVector: number[],
    options: {
      scope?: EmbeddingScope;
      limit?: number;
      minSimilarity?: number;
    } = {},
  ): Promise<Array<DocEmbedding & { similarity: number }>> {
    const limit = options.limit ?? 10;
    const minSimilarity = options.minSimilarity ?? 0.7;

    let query = `
      SELECT *,
        1 - (vector <=> $2::vector) AS similarity
      FROM core.doc_embeddings
      WHERE app_id = $1
    `;

    const params: any[] = [appId, JSON.stringify(queryVector)];

    if (options.scope) {
      query += ` AND scope = $${params.length + 1}`;
      params.push(options.scope);
    }

    query += `
      AND 1 - (vector <=> $2::vector) >= $${params.length + 1}
      ORDER BY vector <=> $2::vector
      LIMIT $${params.length + 2}
    `;

    params.push(minSimilarity, limit);

    const result = await this.db.query<DocEmbedding & { similarity: number }>(query, params);
    return result.rows;
  }

  async deleteByRef(refId: string, scope?: EmbeddingScope): Promise<void> {
    if (scope) {
      await this.db.query(`DELETE FROM core.doc_embeddings WHERE ref_id = $1 AND scope = $2`, [refId, scope]);
    } else {
      await this.db.query(`DELETE FROM core.doc_embeddings WHERE ref_id = $1`, [refId]);
    }
  }

  async upsertFileEmbeddings(
    appId: string,
    fileId: string,
    embeddings: Array<{
      vector: number[];
      chunkIdx: number;
      contentPreview: string;
      metadata?: any;
    }>,
  ): Promise<DocEmbedding[]> {
    return this.db.transaction(async (client) => {
      await client.query(`DELETE FROM core.doc_embeddings WHERE app_id = $1 AND ref_id = $2 AND scope = 'file'`, [
        appId,
        fileId,
      ]);

      const created: DocEmbedding[] = [];
      for (const emb of embeddings) {
        const result = await client.query<DocEmbedding>(
          `INSERT INTO core.doc_embeddings
           (app_id, scope, ref_id, chunk_idx, vector, content_preview, metadata)
           VALUES ($1, 'file', $2, $3, $4, $5, $6)
           RETURNING *`,
          [
            appId,
            fileId,
            emb.chunkIdx,
            JSON.stringify(emb.vector),
            emb.contentPreview,
            emb.metadata ? JSON.stringify(emb.metadata) : null,
          ],
        );
        created.push(result.rows[0]);
      }

      return created;
    });
  }

  async countByApp(appId: string): Promise<number> {
    const result = await this.db.query<{ count: string }>(
      `SELECT COUNT(*) as count FROM core.doc_embeddings WHERE app_id = $1`,
      [appId],
    );
    return parseInt(result.rows[0].count, 10);
  }
}
</file>

<file path="packages/database/src/repositories/events.ts">
import { DatabaseClient } from '../client.js';
import type { Event } from '../types.js';

export class EventsRepository {
  constructor(private db: DatabaseClient) {}

  async log(
    kind: string,
    payload: any,
    options: {
      sessionId?: string;
      appId?: string;
      actor?: string;
    } = {},
  ): Promise<Event> {
    const result = await this.db.query<Event>(
      `INSERT INTO core.events (session_id, app_id, actor, kind, payload)
       VALUES ($1, $2, $3, $4, $5)
       RETURNING *`,
      [options.sessionId ?? null, options.appId ?? null, options.actor ?? null, kind, JSON.stringify(payload)],
    );
    return result.rows[0];
  }

  async findBySession(sessionId: string, limit = 100, offset = 0): Promise<Event[]> {
    const result = await this.db.query<Event>(
      `SELECT * FROM core.events
       WHERE session_id = $1
       ORDER BY id DESC
       LIMIT $2 OFFSET $3`,
      [sessionId, limit, offset],
    );
    return result.rows;
  }

  async findByApp(appId: string, limit = 100, offset = 0): Promise<Event[]> {
    const result = await this.db.query<Event>(
      `SELECT * FROM core.events
       WHERE app_id = $1
       ORDER BY id DESC
       LIMIT $2 OFFSET $3`,
      [appId, limit, offset],
    );
    return result.rows;
  }

  async findByKind(kind: string, limit = 100, offset = 0): Promise<Event[]> {
    const result = await this.db.query<Event>(
      `SELECT * FROM core.events
       WHERE kind = $1
       ORDER BY created_at DESC
       LIMIT $2 OFFSET $3`,
      [kind, limit, offset],
    );
    return result.rows;
  }

  async findRecent(limit = 50): Promise<Event[]> {
    const result = await this.db.query<Event>(
      `SELECT * FROM core.events
       ORDER BY id DESC
       LIMIT $1`,
      [limit],
    );
    return result.rows;
  }

  async deleteBySession(sessionId: string): Promise<void> {
    await this.db.query(`DELETE FROM core.events WHERE session_id = $1`, [sessionId]);
  }

  async deleteOlderThan(daysAgo: number): Promise<number> {
    const result = await this.db.query<{ count: string }>(
      `WITH deleted AS (
         DELETE FROM core.events
         WHERE created_at < now() - interval '1 day' * $1
         RETURNING id
       )
       SELECT COUNT(*) as count FROM deleted`,
      [daysAgo],
    );
    return parseInt(result.rows[0].count, 10);
  }
}
</file>

<file path="packages/database/src/repositories/files.ts">
import { DatabaseClient } from '../client.js';
import type { File, FileVersion, FileReference, ReferenceType } from '../types.js';
import { createHash } from 'crypto';

export class FilesRepository {
  constructor(private db: DatabaseClient) {}

  async upsertFile(
    appId: string,
    path: string,
    content: string | Buffer,
    userId?: string,
    mimeType?: string,
  ): Promise<File> {
    return this.db.transaction(async (client) => {
      const isBuffer = Buffer.isBuffer(content);
      // Ensure isBinary is always a boolean, never null/undefined
      const isBinary = !!(
        isBuffer ||
        (mimeType?.startsWith('image/') ?? false) ||
        (mimeType?.startsWith('application/') ?? false)
      );
      const bytes = isBuffer ? content : Buffer.from(content as string, 'utf-8');
      const sha256 = createHash('sha256').update(bytes).digest();
      const sizeBytes = bytes.length;

      const fileResult = await client.query<File>(
        `INSERT INTO core.files (app_id, path, is_binary, mime_type, size_bytes, sha256)
         VALUES ($1, $2, $3, $4, $5, $6)
         ON CONFLICT (app_id, path)
         DO UPDATE SET
           is_binary = EXCLUDED.is_binary,
           mime_type = EXCLUDED.mime_type,
           size_bytes = EXCLUDED.size_bytes,
           sha256 = EXCLUDED.sha256,
           updated_at = now()
         RETURNING *`,
        [appId, path, isBinary, mimeType ?? null, sizeBytes, sha256],
      );
      const file = fileResult.rows[0];

      const versionCountResult = await client.query<{ count: string }>(
        `SELECT COUNT(*) as count FROM core.file_versions WHERE file_id = $1`,
        [file.id],
      );
      const nextVersion = parseInt(versionCountResult.rows[0].count, 10) + 1;

      const contentText = isBinary ? null : Buffer.isBuffer(content) ? content.toString('utf-8') : content;
      const contentBytes = isBinary ? bytes : null;

      const versionResult = await client.query<FileVersion>(
        `INSERT INTO core.file_versions
         (file_id, version, parent_version_id, content_text, content_bytes, created_by)
         VALUES ($1, $2, $3, $4, $5, $6)
         RETURNING *`,
        [file.id, nextVersion, file.head_version_id, contentText, contentBytes, userId ?? null],
      );
      const version = versionResult.rows[0];

      await client.query(`UPDATE core.files SET head_version_id = $1 WHERE id = $2`, [version.id, file.id]);

      return { ...file, head_version_id: version.id };
    });
  }

  async findById(id: string): Promise<File | null> {
    const result = await this.db.query<File>(`SELECT * FROM core.files WHERE id = $1`, [id]);
    return result.rows[0] ?? null;
  }

  async findByAppAndPath(appId: string, path: string): Promise<File | null> {
    const result = await this.db.query<File>(`SELECT * FROM core.files WHERE app_id = $1 AND path = $2`, [appId, path]);
    return result.rows[0] ?? null;
  }

  async findByApp(appId: string, limit = 1000): Promise<File[]> {
    const result = await this.db.query<File>(
      `SELECT * FROM core.files
       WHERE app_id = $1
       ORDER BY path ASC
       LIMIT $2`,
      [appId, limit],
    );
    return result.rows;
  }

  async searchByPath(appId: string, pathPattern: string, limit = 100): Promise<File[]> {
    const result = await this.db.query<File>(
      `SELECT * FROM core.files
       WHERE app_id = $1 AND path ILIKE $2
       ORDER BY path ASC
       LIMIT $3`,
      [appId, `%${pathPattern}%`, limit],
    );
    return result.rows;
  }

  async delete(id: string): Promise<void> {
    await this.db.query(`DELETE FROM core.files WHERE id = $1`, [id]);
  }

  async getHeadVersion(fileId: string): Promise<FileVersion | null> {
    const result = await this.db.query<FileVersion>(
      `SELECT fv.*
       FROM core.file_versions fv
       JOIN core.files f ON f.head_version_id = fv.id
       WHERE f.id = $1`,
      [fileId],
    );
    return result.rows[0] ?? null;
  }

  async getVersionHistory(fileId: string, limit = 50): Promise<FileVersion[]> {
    const result = await this.db.query<FileVersion>(
      `SELECT * FROM core.file_versions
       WHERE file_id = $1
       ORDER BY version DESC
       LIMIT $2`,
      [fileId, limit],
    );
    return result.rows;
  }

  async getVersion(fileId: string, version: number): Promise<FileVersion | null> {
    const result = await this.db.query<FileVersion>(
      `SELECT * FROM core.file_versions
       WHERE file_id = $1 AND version = $2`,
      [fileId, version],
    );
    return result.rows[0] ?? null;
  }
}

export class FileReferencesRepository {
  constructor(private db: DatabaseClient) {}

  async create(
    appId: string,
    srcFileId: string,
    refType: ReferenceType,
    options: {
      destFileId?: string;
      rawTarget?: string;
      symbol?: string;
    } = {},
  ): Promise<FileReference> {
    const result = await this.db.query<FileReference>(
      `INSERT INTO core.file_references
       (app_id, src_file_id, dest_file_id, raw_target, symbol, ref_type)
       VALUES ($1, $2, $3, $4, $5, $6)
       RETURNING *`,
      [appId, srcFileId, options.destFileId ?? null, options.rawTarget ?? null, options.symbol ?? null, refType],
    );
    return result.rows[0];
  }

  async findBySourceFile(srcFileId: string): Promise<FileReference[]> {
    const result = await this.db.query<FileReference>(
      `SELECT * FROM core.file_references
       WHERE src_file_id = $1
       ORDER BY created_at ASC`,
      [srcFileId],
    );
    return result.rows;
  }

  async findByDestFile(destFileId: string): Promise<FileReference[]> {
    const result = await this.db.query<FileReference>(
      `SELECT * FROM core.file_references
       WHERE dest_file_id = $1
       ORDER BY created_at ASC`,
      [destFileId],
    );
    return result.rows;
  }

  async findByApp(appId: string, limit = 10000): Promise<FileReference[]> {
    const result = await this.db.query<FileReference>(
      `SELECT * FROM core.file_references
       WHERE app_id = $1
       LIMIT $2`,
      [appId, limit],
    );
    return result.rows;
  }

  async deleteBySourceFile(srcFileId: string): Promise<void> {
    await this.db.query(`DELETE FROM core.file_references WHERE src_file_id = $1`, [srcFileId]);
  }

  async rebuildReferencesForFile(
    appId: string,
    srcFileId: string,
    references: Array<{
      refType: ReferenceType;
      destFileId?: string;
      rawTarget?: string;
      symbol?: string;
    }>,
  ): Promise<FileReference[]> {
    return this.db.transaction(async (client) => {
      await client.query(`DELETE FROM core.file_references WHERE src_file_id = $1`, [srcFileId]);

      const created: FileReference[] = [];
      for (const ref of references) {
        const result = await client.query<FileReference>(
          `INSERT INTO core.file_references
           (app_id, src_file_id, dest_file_id, raw_target, symbol, ref_type)
           VALUES ($1, $2, $3, $4, $5, $6)
           RETURNING *`,
          [appId, srcFileId, ref.destFileId ?? null, ref.rawTarget ?? null, ref.symbol ?? null, ref.refType],
        );
        created.push(result.rows[0]);
      }

      return created;
    });
  }
}
</file>

<file path="packages/database/src/repositories/images.ts">
import { DatabaseClient } from '../client.js';
import type { ImageJob, ImageAsset, ImageJobState } from '../types.js';

export class ImageJobsRepository {
  constructor(private db: DatabaseClient) {}

  async create(
    prompt: string,
    model: string,
    options: {
      sessionId?: string;
      appId?: string;
      size?: string;
      n?: number;
    } = {},
  ): Promise<ImageJob> {
    const result = await this.db.query<ImageJob>(
      `INSERT INTO core.image_jobs
       (session_id, app_id, prompt, model, size, n, state)
       VALUES ($1, $2, $3, $4, $5, $6, 'queued')
       RETURNING *`,
      [options.sessionId ?? null, options.appId ?? null, prompt, model, options.size ?? null, options.n ?? 1],
    );
    return result.rows[0];
  }

  async findById(id: string): Promise<ImageJob | null> {
    const result = await this.db.query<ImageJob>(`SELECT * FROM core.image_jobs WHERE id = $1`, [id]);
    return result.rows[0] ?? null;
  }

  async findBySession(sessionId: string, limit = 50): Promise<ImageJob[]> {
    const result = await this.db.query<ImageJob>(
      `SELECT * FROM core.image_jobs
       WHERE session_id = $1
       ORDER BY requested_at DESC
       LIMIT $2`,
      [sessionId, limit],
    );
    return result.rows;
  }

  async findByState(state: ImageJobState, limit = 100): Promise<ImageJob[]> {
    const result = await this.db.query<ImageJob>(
      `SELECT * FROM core.image_jobs
       WHERE state = $1
       ORDER BY requested_at ASC
       LIMIT $2`,
      [state, limit],
    );
    return result.rows;
  }

  async updateState(id: string, state: ImageJobState, error?: any): Promise<ImageJob> {
    const now = new Date();
    const startedAt = state === 'generating' ? now : undefined;
    const finishedAt = ['succeeded', 'failed', 'canceled'].includes(state) ? now : undefined;

    const result = await this.db.query<ImageJob>(
      `UPDATE core.image_jobs
       SET state = $2,
           started_at = COALESCE($3, started_at),
           finished_at = COALESCE($4, finished_at),
           error = COALESCE($5, error)
       WHERE id = $1
       RETURNING *`,
      [id, state, startedAt ?? null, finishedAt ?? null, error ? JSON.stringify(error) : null],
    );
    return result.rows[0];
  }

  async markStarted(id: string): Promise<ImageJob> {
    return this.updateState(id, 'generating');
  }

  async markSucceeded(id: string): Promise<ImageJob> {
    return this.updateState(id, 'succeeded');
  }

  async markFailed(id: string, error: any): Promise<ImageJob> {
    return this.updateState(id, 'failed', error);
  }

  async delete(id: string): Promise<void> {
    await this.db.query(`DELETE FROM core.image_jobs WHERE id = $1`, [id]);
  }
}

export class ImageAssetsRepository {
  constructor(private db: DatabaseClient) {}

  async create(
    jobId: string,
    position: number,
    mimeType: string,
    bytes: Buffer,
    options: {
      storageUrl?: string;
      checksum?: Buffer;
      width?: number;
      height?: number;
    } = {},
  ): Promise<ImageAsset> {
    const result = await this.db.query<ImageAsset>(
      `INSERT INTO core.image_assets
       (job_id, position, mime_type, bytes, storage_url, checksum, width, height)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
       RETURNING *`,
      [
        jobId,
        position,
        mimeType,
        bytes,
        options.storageUrl ?? null,
        options.checksum ?? null,
        options.width ?? null,
        options.height ?? null,
      ],
    );
    return result.rows[0];
  }

  async findById(id: string): Promise<ImageAsset | null> {
    const result = await this.db.query<ImageAsset>(`SELECT * FROM core.image_assets WHERE id = $1`, [id]);
    return result.rows[0] ?? null;
  }

  async findByJob(jobId: string): Promise<ImageAsset[]> {
    const result = await this.db.query<ImageAsset>(
      `SELECT * FROM core.image_assets
       WHERE job_id = $1
       ORDER BY position ASC`,
      [jobId],
    );
    return result.rows;
  }

  async findByJobWithoutBytes(jobId: string): Promise<Omit<ImageAsset, 'bytes'>[]> {
    const result = await this.db.query<Omit<ImageAsset, 'bytes'>>(
      `SELECT id, job_id, position, mime_type, storage_url, checksum, width, height, created_at
       FROM core.image_assets
       WHERE job_id = $1
       ORDER BY position ASC`,
      [jobId],
    );
    return result.rows;
  }

  async delete(id: string): Promise<void> {
    await this.db.query(`DELETE FROM core.image_assets WHERE id = $1`, [id]);
  }
}
</file>

<file path="packages/database/src/repositories/messages.ts">
import { DatabaseClient } from '../client.js';
import type { Message, MessageRole } from '../types.js';

export class MessagesRepository {
  constructor(private db: DatabaseClient) {}

  async create(
    sessionId: string,
    role: MessageRole,
    content: any,
    model?: string,
    tokenCount?: number,
  ): Promise<Message> {
    const result = await this.db.query<Message>(
      `INSERT INTO core.messages (session_id, role, content, model, token_count)
       VALUES ($1, $2, $3, $4, $5)
       RETURNING *`,
      [sessionId, role, JSON.stringify(content), model ?? null, tokenCount ?? null],
    );
    return result.rows[0];
  }

  async findById(id: string): Promise<Message | null> {
    const result = await this.db.query<Message>(`SELECT * FROM core.messages WHERE id = $1`, [id]);
    return result.rows[0] ?? null;
  }

  async findBySession(sessionId: string, limit = 100, offset = 0): Promise<Message[]> {
    const result = await this.db.query<Message>(
      `SELECT * FROM core.messages
       WHERE session_id = $1
       ORDER BY id ASC
       LIMIT $2 OFFSET $3`,
      [sessionId, limit, offset],
    );
    return result.rows;
  }

  async findRecentBySession(sessionId: string, limit = 10): Promise<Message[]> {
    const result = await this.db.query<Message>(
      `SELECT * FROM core.messages
       WHERE session_id = $1
       ORDER BY id DESC
       LIMIT $2`,
      [sessionId, limit],
    );
    return result.rows.reverse();
  }

  async countBySession(sessionId: string): Promise<number> {
    const result = await this.db.query<{ count: string }>(
      `SELECT COUNT(*) as count FROM core.messages WHERE session_id = $1`,
      [sessionId],
    );
    return parseInt(result.rows[0].count, 10);
  }

  async searchContent(sessionId: string, searchTerm: string, limit = 20): Promise<Message[]> {
    const result = await this.db.query<Message>(
      `SELECT * FROM core.messages
       WHERE session_id = $1
         AND content::text ILIKE $2
       ORDER BY id DESC
       LIMIT $3`,
      [sessionId, `%${searchTerm}%`, limit],
    );
    return result.rows;
  }

  async deleteBySession(sessionId: string): Promise<void> {
    await this.db.query(`DELETE FROM core.messages WHERE session_id = $1`, [sessionId]);
  }
}
</file>

<file path="packages/database/src/repositories/session-memory.ts">
import { DatabaseClient } from '../client.js';
import type { SessionMemory, WorkingSetItem } from '../types.js';

export class SessionMemoryRepository {
  constructor(private db: DatabaseClient) {}

  async upsert(
    sessionId: string,
    data: {
      rollingSummary?: string;
      facts?: any;
      lastCompactedMessageId?: string;
    },
  ): Promise<SessionMemory> {
    const result = await this.db.query<SessionMemory>(
      `INSERT INTO core.session_memory
       (session_id, rolling_summary, facts, last_compacted_message_id, updated_at)
       VALUES ($1, $2, $3, $4, now())
       ON CONFLICT (session_id)
       DO UPDATE SET
         rolling_summary = COALESCE($2, session_memory.rolling_summary),
         facts = COALESCE($3, session_memory.facts),
         last_compacted_message_id = COALESCE($4, session_memory.last_compacted_message_id),
         updated_at = now()
       RETURNING *`,
      [
        sessionId,
        data.rollingSummary ?? null,
        data.facts ? JSON.stringify(data.facts) : null,
        data.lastCompactedMessageId ?? null,
      ],
    );
    return result.rows[0];
  }

  async findBySession(sessionId: string): Promise<SessionMemory | null> {
    const result = await this.db.query<SessionMemory>(`SELECT * FROM core.session_memory WHERE session_id = $1`, [
      sessionId,
    ]);
    return result.rows[0] ?? null;
  }

  async updateSummary(sessionId: string, summary: string, lastMessageId: string): Promise<SessionMemory> {
    return this.upsert(sessionId, {
      rollingSummary: summary,
      lastCompactedMessageId: lastMessageId,
    });
  }

  async updateFacts(sessionId: string, facts: any): Promise<SessionMemory> {
    return this.upsert(sessionId, { facts });
  }

  async addFact(sessionId: string, key: string, value: any): Promise<SessionMemory> {
    const existing = await this.findBySession(sessionId);
    const currentFacts = existing?.facts || {};
    const updatedFacts = { ...currentFacts, [key]: value };
    return this.upsert(sessionId, { facts: updatedFacts });
  }

  async delete(sessionId: string): Promise<void> {
    await this.db.query(`DELETE FROM core.session_memory WHERE session_id = $1`, [sessionId]);
  }
}

export class WorkingSetRepository {
  constructor(private db: DatabaseClient) {}

  async add(
    sessionId: string,
    appId: string,
    fileId: string,
    reason?: string,
    pinnedBy: 'agent' | 'user' = 'agent',
  ): Promise<WorkingSetItem> {
    const result = await this.db.query<WorkingSetItem>(
      `INSERT INTO core.working_set
       (session_id, app_id, file_id, reason, pinned_by)
       VALUES ($1, $2, $3, $4, $5)
       ON CONFLICT (session_id, file_id) DO UPDATE
       SET reason = COALESCE($4, working_set.reason),
           pinned_by = $5
       RETURNING *`,
      [sessionId, appId, fileId, reason ?? null, pinnedBy],
    );
    return result.rows[0];
  }

  async findBySession(sessionId: string): Promise<WorkingSetItem[]> {
    const result = await this.db.query<WorkingSetItem>(
      `SELECT * FROM core.working_set
       WHERE session_id = $1
       ORDER BY created_at ASC`,
      [sessionId],
    );
    return result.rows;
  }

  async findBySessionWithFiles(sessionId: string): Promise<Array<WorkingSetItem & { file_path: string }>> {
    const result = await this.db.query<WorkingSetItem & { file_path: string }>(
      `SELECT ws.*, f.path as file_path
       FROM core.working_set ws
       JOIN core.files f ON ws.file_id = f.id
       WHERE ws.session_id = $1
       ORDER BY ws.created_at ASC`,
      [sessionId],
    );
    return result.rows;
  }

  async remove(sessionId: string, fileId: string): Promise<void> {
    await this.db.query(`DELETE FROM core.working_set WHERE session_id = $1 AND file_id = $2`, [sessionId, fileId]);
  }

  async clear(sessionId: string): Promise<void> {
    await this.db.query(`DELETE FROM core.working_set WHERE session_id = $1`, [sessionId]);
  }

  async countBySession(sessionId: string): Promise<number> {
    const result = await this.db.query<{ count: string }>(
      `SELECT COUNT(*) as count FROM core.working_set WHERE session_id = $1`,
      [sessionId],
    );
    return parseInt(result.rows[0].count, 10);
  }
}
</file>

<file path="packages/database/src/repositories/sessions.ts">
import { DatabaseClient } from '../client.js';
import type { Session } from '../types.js';

export class SessionsRepository {
  constructor(private db: DatabaseClient) {}

  async create(userId: string, title: string, appId?: string): Promise<Session> {
    const result = await this.db.query<Session>(
      `INSERT INTO core.sessions (user_id, title, app_id)
       VALUES ($1, $2, $3)
       RETURNING *`,
      [userId, title, appId ?? null],
    );
    return result.rows[0];
  }

  async findById(id: string): Promise<Session | null> {
    const result = await this.db.query<Session>(`SELECT * FROM core.sessions WHERE id = $1`, [id]);
    return result.rows[0] ?? null;
  }

  async findByUser(userId: string, limit = 50, offset = 0): Promise<Session[]> {
    const result = await this.db.query<Session>(
      `SELECT * FROM core.sessions
       WHERE user_id = $1
       ORDER BY updated_at DESC
       LIMIT $2 OFFSET $3`,
      [userId, limit, offset],
    );
    return result.rows;
  }

  async findByApp(appId: string, limit = 50, offset = 0): Promise<Session[]> {
    const result = await this.db.query<Session>(
      `SELECT * FROM core.sessions
       WHERE app_id = $1
       ORDER BY updated_at DESC
       LIMIT $2 OFFSET $3`,
      [appId, limit, offset],
    );
    return result.rows;
  }

  async update(
    id: string,
    data: {
      title?: string;
      status?: 'active' | 'archived';
      last_message_at?: Date;
    },
  ): Promise<Session> {
    const result = await this.db.query<Session>(
      `UPDATE core.sessions
       SET title = COALESCE($2, title),
           status = COALESCE($3, status),
           last_message_at = COALESCE($4, last_message_at)
       WHERE id = $1
       RETURNING *`,
      [id, data.title ?? null, data.status ?? null, data.last_message_at ?? null],
    );
    return result.rows[0];
  }

  async archive(id: string): Promise<Session> {
    return this.update(id, { status: 'archived' });
  }

  async delete(id: string): Promise<void> {
    await this.db.query(`DELETE FROM core.sessions WHERE id = $1`, [id]);
  }

  async touchLastMessage(id: string): Promise<void> {
    await this.db.query(`UPDATE core.sessions SET last_message_at = now() WHERE id = $1`, [id]);
  }
}
</file>

<file path="packages/database/src/repositories/users.ts">
import { DatabaseClient } from '../client.js';
import type { User } from '../types.js';

export class UsersRepository {
  constructor(private db: DatabaseClient) {}

  async create(email: string, displayName?: string): Promise<User> {
    const result = await this.db.query<User>(
      `INSERT INTO core.users (email, display_name)
       VALUES ($1, $2)
       RETURNING *`,
      [email, displayName ?? null],
    );
    return result.rows[0];
  }

  async findById(id: string): Promise<User | null> {
    const result = await this.db.query<User>(`SELECT * FROM core.users WHERE id = $1`, [id]);
    return result.rows[0] ?? null;
  }

  async findByEmail(email: string): Promise<User | null> {
    const result = await this.db.query<User>(`SELECT * FROM core.users WHERE email = $1`, [email]);
    return result.rows[0] ?? null;
  }

  async findOrCreate(email: string, displayName?: string): Promise<User> {
    const existing = await this.findByEmail(email);
    if (existing) return existing;
    return this.create(email, displayName);
  }

  async update(id: string, data: { displayName?: string }): Promise<User> {
    const result = await this.db.query<User>(
      `UPDATE core.users
       SET display_name = COALESCE($2, display_name)
       WHERE id = $1
       RETURNING *`,
      [id, data.displayName ?? null],
    );
    return result.rows[0];
  }

  async delete(id: string): Promise<void> {
    await this.db.query(`DELETE FROM core.users WHERE id = $1`, [id]);
  }
}
</file>

<file path="packages/database/src/services/atomic-file-writer.ts">
import { DatabaseClient } from '../client.js';
import type { File, FileVersion } from '../types.js';
import { createHash } from 'crypto';

export interface AtomicWriteResult {
  file: File;
  version: FileVersion;
  impactedFileIds: string[];
}

export class AtomicFileWriter {
  constructor(private db: DatabaseClient) {}

  async writeFile(
    appId: string,
    path: string,
    content: string | Buffer,
    userId?: string,
    mimeType?: string,
  ): Promise<AtomicWriteResult> {
    return this.db.transaction(async (client) => {
      const isBuffer = Buffer.isBuffer(content);
      const isBinary = isBuffer || mimeType?.startsWith('image/') || mimeType?.startsWith('application/');
      const bytes = isBuffer ? content : Buffer.from(content as string, 'utf-8');
      const sha256 = createHash('sha256').update(bytes).digest();
      const sizeBytes = bytes.length;

      const lockResult = await client.query<File>(
        `SELECT * FROM core.files
         WHERE app_id = $1 AND path = $2
         FOR UPDATE`,
        [appId, path],
      );

      const existingFile = lockResult.rows[0];

      let file: File;
      if (existingFile) {
        const updateResult = await client.query<File>(
          `UPDATE core.files
           SET is_binary = $3,
               mime_type = $4,
               size_bytes = $5,
               sha256 = $6,
               updated_at = now()
           WHERE id = $1 AND app_id = $2
           RETURNING *`,
          [existingFile.id, appId, isBinary, mimeType ?? null, sizeBytes, sha256],
        );
        file = updateResult.rows[0];
      } else {
        const insertResult = await client.query<File>(
          `INSERT INTO core.files (app_id, path, is_binary, mime_type, size_bytes, sha256)
           VALUES ($1, $2, $3, $4, $5, $6)
           RETURNING *`,
          [appId, path, isBinary, mimeType ?? null, sizeBytes, sha256],
        );
        file = insertResult.rows[0];
      }

      const versionCountResult = await client.query<{ count: string }>(
        `SELECT COUNT(*) as count FROM core.file_versions WHERE file_id = $1`,
        [file.id],
      );
      const nextVersion = parseInt(versionCountResult.rows[0].count, 10) + 1;

      const contentText = isBinary ? null : Buffer.isBuffer(content) ? content.toString('utf-8') : content;
      const contentBytes = isBinary ? bytes : null;

      const versionResult = await client.query<FileVersion>(
        `INSERT INTO core.file_versions
         (file_id, version, parent_version_id, content_text, content_bytes, created_by)
         VALUES ($1, $2, $3, $4, $5, $6)
         RETURNING *`,
        [file.id, nextVersion, file.head_version_id, contentText, contentBytes, userId ?? null],
      );
      const version = versionResult.rows[0];

      await client.query(`UPDATE core.files SET head_version_id = $1 WHERE id = $2`, [version.id, file.id]);

      const impactResult = await client.query<{ dest_file_id: string }>(
        `WITH RECURSIVE impact AS (
          SELECT f.dest_file_id
          FROM core.file_references f
          WHERE f.app_id = $1 AND f.src_file_id = $2

          UNION

          SELECT f.dest_file_id
          FROM impact i
          JOIN core.file_references f ON f.app_id = $1 AND f.src_file_id = i.dest_file_id
          WHERE (SELECT COUNT(*) FROM impact) < 100
        )
        SELECT DISTINCT dest_file_id FROM impact`,
        [appId, file.id],
      );

      const impactedFileIds = impactResult.rows.map((r) => r.dest_file_id);

      return {
        file: { ...file, head_version_id: version.id },
        version,
        impactedFileIds,
      };
    });
  }

  async batchWrite(
    appId: string,
    files: Array<{ path: string; content: string | Buffer; mimeType?: string }>,
    userId?: string,
  ): Promise<AtomicWriteResult[]> {
    const results: AtomicWriteResult[] = [];

    for (const f of files) {
      const result = await this.writeFile(appId, f.path, f.content, userId, f.mimeType);
      results.push(result);
    }

    return results;
  }
}
</file>

<file path="packages/database/src/services/image-generator.ts">
import OpenAI from 'openai';
import sharp from 'sharp';
import { createHash } from 'crypto';
import { DatabaseClient } from '../client.js';
import { ImageJobsRepository, ImageAssetsRepository } from '../repositories/images.js';

export interface ImageGenerationOptions {
  prompt: string;
  model?: 'dall-e-3' | 'dall-e-2';
  size?: '1024x1024' | '1792x1024' | '1024x1792' | '256x256' | '512x512';
  quality?: 'standard' | 'hd';
  n?: number;
  sessionId?: string;
  appId?: string;
}

export class ImageGenerationService {
  private openai: OpenAI;
  private jobsRepo: ImageJobsRepository;
  private assetsRepo: ImageAssetsRepository;

  constructor(db: DatabaseClient, openaiApiKey?: string) {
    this.openai = new OpenAI({
      apiKey: openaiApiKey || process.env.OPENAI_API_KEY,
    });
    this.jobsRepo = new ImageJobsRepository(db);
    this.assetsRepo = new ImageAssetsRepository(db);
  }

  async generateImage(options: ImageGenerationOptions): Promise<string> {
    const job = await this.jobsRepo.create(options.prompt, options.model || 'dall-e-3', {
      sessionId: options.sessionId,
      appId: options.appId,
      size: options.size || '1024x1024',
      n: options.n || 1,
    });

    this.processJobAsync(job.id, options).catch((error) => {
      console.error(`Background image generation failed for job ${job.id}:`, error);
    });

    return job.id;
  }

  private async processJobAsync(jobId: string, options: ImageGenerationOptions): Promise<void> {
    try {
      await this.jobsRepo.markStarted(jobId);

      const response = await this.openai.images.generate({
        model: options.model || 'dall-e-3',
        prompt: options.prompt,
        n: options.n || 1,
        size: options.size || '1024x1024',
        quality: options.quality || 'standard',
        response_format: 'b64_json',
      });

      if (!response.data || response.data.length === 0) {
        throw new Error('No image data returned from OpenAI');
      }

      const assets: Array<{ bytes: Buffer; mimeType: string; width: number; height: number }> = [];

      for (let i = 0; i < response.data.length; i++) {
        const imageData = response.data[i];

        if (!imageData.b64_json) {
          throw new Error(`No b64_json data for image ${i}`);
        }

        const bytes = Buffer.from(imageData.b64_json, 'base64');

        const { mimeType, isValid } = this.sniffImageMimeType(bytes);
        if (!isValid) {
          throw new Error(`Invalid image data for position ${i}: unrecognized format`);
        }

        let width: number;
        let height: number;
        try {
          const metadata = await sharp(bytes).metadata();
          if (!metadata.width || !metadata.height) {
            throw new Error('Failed to extract image dimensions');
          }
          width = metadata.width;
          height = metadata.height;

          await sharp(bytes).toBuffer();
        } catch (error: any) {
          throw new Error(`Image validation failed for position ${i}: ${error.message}`);
        }

        const checksum = createHash('sha256').update(bytes).digest();

        await this.assetsRepo.create(jobId, i, mimeType, bytes, {
          checksum,
          width,
          height,
        });

        assets.push({
          bytes,
          mimeType,
          width,
          height,
        });
      }

      await this.jobsRepo.markSucceeded(jobId);
    } catch (error: any) {
      console.error(`Image generation failed for job ${jobId}:`, error);
      await this.jobsRepo.markFailed(jobId, {
        message: error.message,
        stack: error.stack,
        code: error.code,
      });
      throw error;
    }
  }

  private sniffImageMimeType(bytes: Buffer): { mimeType: string; isValid: boolean } {
    if (bytes.length < 4) {
      return { mimeType: 'application/octet-stream', isValid: false };
    }

    const isPNG = bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4e && bytes[3] === 0x47;
    if (isPNG) {
      return { mimeType: 'image/png', isValid: true };
    }

    const isJPEG = bytes[0] === 0xff && bytes[1] === 0xd8;
    if (isJPEG) {
      const hasJPEGEnd = bytes.length >= 2 && bytes[bytes.length - 2] === 0xff && bytes[bytes.length - 1] === 0xd9;
      return { mimeType: 'image/jpeg', isValid: hasJPEGEnd };
    }

    const isWEBP = bytes[0] === 0x52 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x46;
    if (isWEBP) {
      return { mimeType: 'image/webp', isValid: true };
    }

    return { mimeType: 'application/octet-stream', isValid: false };
  }

  async getJobStatus(jobId: string): Promise<{
    job: any;
    assets: Array<Omit<any, 'bytes'>>;
  }> {
    const job = await this.jobsRepo.findById(jobId);
    if (!job) {
      throw new Error(`Image job ${jobId} not found`);
    }

    const assets = await this.assetsRepo.findByJobWithoutBytes(jobId);

    return { job, assets };
  }

  async getAsset(assetId: string): Promise<{ bytes: Buffer; mimeType: string } | null> {
    const asset = await this.assetsRepo.findById(assetId);
    if (!asset || !asset.bytes) {
      return null;
    }

    return {
      bytes: asset.bytes,
      mimeType: asset.mime_type,
    };
  }

  async pollJobUntilComplete(
    jobId: string,
    timeoutMs = 60000,
    pollIntervalMs = 1000,
  ): Promise<{ job: any; assets: Array<Omit<any, 'bytes'>> }> {
    const startTime = Date.now();

    while (Date.now() - startTime < timeoutMs) {
      const status = await this.getJobStatus(jobId);

      if (status.job.state === 'succeeded' || status.job.state === 'failed') {
        return status;
      }

      await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));
    }

    throw new Error(`Image generation timed out after ${timeoutMs}ms`);
  }
}
</file>

<file path="packages/database/src/services/impacted-analyzer.ts">
import { DatabaseClient } from '../client.js';
import type { File } from '../types.js';

export interface ImpactAnalysisResult {
  sourceFile: File;
  impactedFiles: File[];
  impactPaths: Array<{
    from: string;
    to: string;
    refType: string;
  }>;
  depth: number;
}

export class ImpactedFilesAnalyzer {
  constructor(private db: DatabaseClient) {}

  async analyzeImpact(appId: string, fileId: string, maxDepth = 10): Promise<ImpactAnalysisResult> {
    const sourceFile = await this.getFile(fileId);

    const result = await this.db.query<{
      src_file_id: string;
      src_path: string;
      ref_type: string;
      depth: number;
    }>(
      `WITH RECURSIVE impact AS (
        SELECT
          f.src_file_id,
          files.path as src_path,
          f.ref_type::text,
          1 as depth
        FROM core.file_references f
        JOIN core.files files ON f.src_file_id = files.id
        WHERE f.app_id = $1 AND f.dest_file_id = $2

        UNION

        SELECT
          f.src_file_id,
          files.path as src_path,
          f.ref_type::text,
          i.depth + 1
        FROM impact i
        JOIN core.file_references f ON f.app_id = $1 AND f.dest_file_id = i.src_file_id
        JOIN core.files files ON f.src_file_id = files.id
        WHERE i.depth < $3
      )
      SELECT DISTINCT
        src_file_id,
        src_path,
        ref_type,
        MIN(depth) as depth
      FROM impact
      GROUP BY src_file_id, src_path, ref_type
      ORDER BY depth, src_path`,
      [appId, fileId, maxDepth],
    );

    const impactedFileIds = [...new Set(result.rows.map((r) => r.src_file_id))];
    const impactedFiles = await this.getFiles(impactedFileIds);

    const impactPaths = result.rows.map((row) => ({
      from: row.src_path,
      to: sourceFile.path,
      refType: row.ref_type,
    }));

    return {
      sourceFile,
      impactedFiles,
      impactPaths,
      depth: Math.max(...result.rows.map((r) => r.depth), 0),
    };
  }

  async findDependencies(appId: string, fileId: string, maxDepth = 10): Promise<File[]> {
    const result = await this.db.query<{ src_file_id: string }>(
      `WITH RECURSIVE deps AS (
        SELECT f.src_file_id
        FROM core.file_references f
        WHERE f.app_id = $1 AND f.dest_file_id = $2

        UNION

        SELECT f.src_file_id
        FROM deps d
        JOIN core.file_references f ON f.app_id = $1 AND f.dest_file_id = d.src_file_id
        WHERE (SELECT COUNT(*) FROM deps) < $3
      )
      SELECT DISTINCT src_file_id FROM deps`,
      [appId, fileId, maxDepth * 100],
    );

    const fileIds = result.rows.map((r) => r.src_file_id);
    return this.getFiles(fileIds);
  }

  async getImpactSummary(
    appId: string,
    fileId: string,
  ): Promise<{
    directImpacts: number;
    totalImpacts: number;
    affectedTypes: Record<string, number>;
  }> {
    const result = await this.db.query<{
      depth: number;
      ref_type: string;
      count: string;
    }>(
      `WITH RECURSIVE impact AS (
        SELECT f.src_file_id, f.ref_type::text, 1 as depth
        FROM core.file_references f
        WHERE f.app_id = $1 AND f.dest_file_id = $2

        UNION

        SELECT f.src_file_id, f.ref_type::text, i.depth + 1
        FROM impact i
        JOIN core.file_references f ON f.app_id = $1 AND f.dest_file_id = i.src_file_id
        WHERE i.depth < 10
      )
      SELECT depth, ref_type, COUNT(DISTINCT src_file_id)::text as count
      FROM impact
      GROUP BY depth, ref_type`,
      [appId, fileId],
    );

    const directImpacts = result.rows.filter((r) => r.depth === 1).reduce((sum, r) => sum + parseInt(r.count, 10), 0);

    const totalImpacts = result.rows.reduce((sum, r) => sum + parseInt(r.count, 10), 0);

    const affectedTypes: Record<string, number> = {};
    result.rows.forEach((r) => {
      affectedTypes[r.ref_type] = (affectedTypes[r.ref_type] || 0) + parseInt(r.count, 10);
    });

    return { directImpacts, totalImpacts, affectedTypes };
  }

  private async getFile(fileId: string): Promise<File> {
    const result = await this.db.query<File>(`SELECT * FROM core.files WHERE id = $1`, [fileId]);
    if (!result.rows[0]) {
      throw new Error(`File ${fileId} not found`);
    }
    return result.rows[0];
  }

  private async getFiles(fileIds: string[]): Promise<File[]> {
    if (fileIds.length === 0) return [];

    const result = await this.db.query<File>(`SELECT * FROM core.files WHERE id = ANY($1::uuid[]) ORDER BY path`, [
      fileIds,
    ]);
    return result.rows;
  }
}
</file>

<file path="packages/database/src/services/integrity-checker.ts">
import { DatabaseClient } from '../client.js';
import sharp from 'sharp';
import { createHash } from 'crypto';

export interface FileIntegrityResult {
  fileId: string;
  path: string;
  storedChecksum: string;
  computedChecksum: string;
  matches: boolean;
  error?: string;
}

export interface ImageIntegrityResult {
  assetId: string;
  jobId: string;
  mimeType: string;
  hasValidMagicBytes: boolean;
  hasValidEOF: boolean;
  checksumValid: boolean;
  dimensionsValid: boolean;
  error?: string;
}

export class IntegrityChecker {
  constructor(private db: DatabaseClient) {}

  async verifyFileChecksums(appId?: string): Promise<FileIntegrityResult[]> {
    const result = await this.db.query<{
      file_id: string;
      path: string;
      stored_checksum: Buffer;
      computed_checksum: Buffer;
      matches: boolean;
    }>(`SELECT * FROM core.verify_file_checksums($1)`, [appId ?? null]);

    return result.rows.map((row) => ({
      fileId: row.file_id,
      path: row.path,
      storedChecksum: row.stored_checksum.toString('hex'),
      computedChecksum: row.computed_checksum.toString('hex'),
      matches: row.matches,
    }));
  }

  async verifyImageIntegrity(jobId?: string): Promise<ImageIntegrityResult[]> {
    const result = await this.db.query<{
      asset_id: string;
      job_id: string;
      mime_type: string;
      has_valid_magic_bytes: boolean;
      has_valid_eof: boolean;
      checksum_valid: boolean;
    }>(`SELECT * FROM core.verify_image_integrity($1)`, [jobId ?? null]);

    const results: ImageIntegrityResult[] = [];

    for (const row of result.rows) {
      try {
        const assetResult = await this.db.query<{ bytes: Buffer; width: number; height: number }>(
          `SELECT bytes, width, height FROM core.image_assets WHERE id = $1`,
          [row.asset_id],
        );

        const asset = assetResult.rows[0];
        let dimensionsValid = false;

        if (asset && asset.bytes) {
          try {
            const metadata = await sharp(asset.bytes).metadata();
            dimensionsValid = metadata.width === asset.width && metadata.height === asset.height;
          } catch {
            dimensionsValid = false;
          }
        }

        results.push({
          assetId: row.asset_id,
          jobId: row.job_id,
          mimeType: row.mime_type,
          hasValidMagicBytes: row.has_valid_magic_bytes,
          hasValidEOF: row.has_valid_eof,
          checksumValid: row.checksum_valid,
          dimensionsValid,
        });
      } catch (error: any) {
        results.push({
          assetId: row.asset_id,
          jobId: row.job_id,
          mimeType: row.mime_type,
          hasValidMagicBytes: row.has_valid_magic_bytes,
          hasValidEOF: row.has_valid_eof,
          checksumValid: row.checksum_valid,
          dimensionsValid: false,
          error: error.message,
        });
      }
    }

    return results;
  }

  async runFullIntegrityCheck(appId?: string): Promise<{
    files: FileIntegrityResult[];
    images: ImageIntegrityResult[];
    summary: {
      totalFiles: number;
      validFiles: number;
      totalImages: number;
      validImages: number;
    };
  }> {
    const files = await this.verifyFileChecksums(appId);
    const images = await this.verifyImageIntegrity();

    const validFiles = files.filter((f) => f.matches).length;
    const validImages = images.filter(
      (i) => i.hasValidMagicBytes && i.hasValidEOF && i.checksumValid && i.dimensionsValid,
    ).length;

    return {
      files,
      images,
      summary: {
        totalFiles: files.length,
        validFiles,
        totalImages: images.length,
        validImages,
      },
    };
  }

  async repairFileChecksum(fileId: string): Promise<boolean> {
    const result = await this.db.query<{ content_text: string; content_bytes: Buffer }>(
      `SELECT fv.content_text, fv.content_bytes
       FROM core.files f
       JOIN core.file_versions fv ON f.head_version_id = fv.id
       WHERE f.id = $1`,
      [fileId],
    );

    const version = result.rows[0];
    if (!version) return false;

    const content = version.content_text ? Buffer.from(version.content_text, 'utf-8') : version.content_bytes;

    if (!content) return false;

    const correctChecksum = createHash('sha256').update(content).digest();

    await this.db.query(`UPDATE core.files SET sha256 = $2 WHERE id = $1`, [fileId, correctChecksum]);

    return true;
  }
}
</file>

<file path="packages/database/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "composite": true,
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="packages/evaluations/src/calculator-eval.ts">
/**
 * Acceptance test for "Build me a calculator" request
 * Tests Stages 1-2: Analyze and Plan
 */

import { Agent } from '@eitherway/runtime';
import { ConfigLoader } from '@eitherway/runtime';
import { getAllExecutors } from '@eitherway/tools-impl';

interface EvalResult {
  passed: boolean;
  checks: Array<{
    name: string;
    passed: boolean;
    details?: string;
  }>;
  transcript?: any;
}

/**
 * Run calculator evaluation
 */
export async function runCalculatorEval(dryRun: boolean = true): Promise<EvalResult> {
  const request = 'Build me a calculator';

  try {
    // Load config
    const loader = new ConfigLoader('./configs');
    const { claudeConfig, agentConfig } = await loader.loadAll();

    // Create agent in dry-run mode
    const agent = new Agent({
      workingDir: process.cwd(),
      claudeConfig,
      agentConfig,
      executors: getAllExecutors(),
      dryRun,
    });

    // Process request
    const response = await agent.processRequest(request);
    // const transcript = agent.getCurrentTranscript(); // TODO: Implement transcript getter

    // Evaluation checks
    const checks = [];

    // Check 1: Agent produces a response
    checks.push({
      name: 'Agent produces response',
      passed: response.length > 0,
      details: `Response length: ${response.length} characters`,
    });

    // Check 2: Response contains analysis (Stage 1)
    const hasAnalysis =
      response.toLowerCase().includes('calculator') &&
      (response.toLowerCase().includes('intent') ||
        response.toLowerCase().includes('scope') ||
        response.toLowerCase().includes('requirement'));

    checks.push({
      name: 'Stage 1: Contains analysis of request',
      passed: hasAnalysis,
      details: hasAnalysis ? 'Found analysis keywords' : 'Missing analysis indicators',
    });

    // Check 3: Response contains architecture plan (Stage 2)
    const hasPlan =
      (response.toLowerCase().includes('component') ||
        response.toLowerCase().includes('file') ||
        response.toLowerCase().includes('design')) &&
      (response.toLowerCase().includes('structure') || response.toLowerCase().includes('architecture'));

    checks.push({
      name: 'Stage 2: Contains architecture plan',
      passed: hasPlan,
      details: hasPlan ? 'Found architecture planning' : 'Missing architecture plan',
    });

    // Check 4: Response mentions expected features
    const mentionsUI =
      response.toLowerCase().includes('ui') ||
      response.toLowerCase().includes('interface') ||
      response.toLowerCase().includes('button');

    checks.push({
      name: 'Identifies UI requirements',
      passed: mentionsUI,
      details: mentionsUI ? 'UI mentioned' : 'UI not explicitly mentioned',
    });

    // Check 5: Response mentions operations/logic
    const mentionsLogic =
      response.toLowerCase().includes('operation') ||
      response.toLowerCase().includes('calculation') ||
      response.toLowerCase().includes('arithmetic');

    checks.push({
      name: 'Identifies calculator operations',
      passed: mentionsLogic,
      details: mentionsLogic ? 'Operations mentioned' : 'Operations not mentioned',
    });

    // Check 6: In dry-run mode, no files should be created
    if (dryRun) {
      const noToolExecution = !response.includes('Successfully wrote') && !response.includes('Successfully replaced');
      checks.push({
        name: 'Dry run: No file modifications',
        passed: noToolExecution,
        details: noToolExecution ? 'No files modified' : 'Files were modified in dry-run mode',
      });
    }

    const allPassed = checks.every((c) => c.passed);

    return {
      passed: allPassed,
      checks,
    };
  } catch (error: any) {
    return {
      passed: false,
      checks: [
        {
          name: 'Execution',
          passed: false,
          details: `Error: ${error.message}`,
        },
      ],
    };
  }
}
</file>

<file path="packages/evaluations/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "references": [{ "path": "../runtime" }]
}
</file>

<file path="packages/runtime/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "composite": true,
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "references": [{ "path": "../tools-core" }, { "path": "../tools-impl" }]
}
</file>

<file path="packages/tools-core/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "composite": true,
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"]
}
</file>

<file path="packages/ui/package.json">
{
  "name": "@eitherway/ui",
  "version": "0.1.0",
  "description": "Minimal CLI and dev panel",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch"
  },
  "dependencies": {
    "@eitherway/runtime": "workspace:*"
  },
  "devDependencies": {
    "typescript": "^5.3.3"
  }
}
</file>

<file path="packages/ui/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "references": [{ "path": "../runtime" }]
}
</file>

<file path="packages/ui-frontend/app/components/chat/Artifact.tsx">
import { useStore } from '@nanostores/react';
import { AnimatePresence, motion } from 'framer-motion';
import { computed } from 'nanostores';
import { memo, useEffect, useRef, useState } from 'react';
import { createHighlighter, type BundledLanguage, type BundledTheme, type HighlighterGeneric } from 'shiki';
import type { ActionState } from '~/lib/runtime/action-runner';
import { workbenchStore } from '~/lib/stores/workbench';
import { classNames } from '~/utils/classNames';
import { cubicEasingFn } from '~/utils/easings';

const highlighterOptions = {
  langs: ['shell'],
  themes: ['light-plus', 'dark-plus'],
};

const shellHighlighter: HighlighterGeneric<BundledLanguage, BundledTheme> =
  import.meta.hot?.data.shellHighlighter ?? (await createHighlighter(highlighterOptions));

if (import.meta.hot) {
  import.meta.hot.data.shellHighlighter = shellHighlighter;
}

interface ArtifactProps {
  artifactId: string;
}

export const Artifact = memo(({ artifactId }: ArtifactProps) => {
  const userToggledActions = useRef(false);
  const [showActions, setShowActions] = useState(false);

  const artifacts = useStore(workbenchStore.artifacts);
  const artifact = artifacts[artifactId];

  const actions = useStore(
    computed(artifact.runner.actions, (actions) => {
      return Object.values(actions);
    }),
  );

  //   const isAnyActionRunning = useStore(
  //   computed(artifact.runner.actions, (actions) => {
  //       (action) => action.status === 'running' || action.status === 'pending'
  //     );
  //   })
  // );

  const toggleActions = () => {
    userToggledActions.current = true;
    setShowActions(!showActions);
  };

  useEffect(() => {
    if (actions.length && !showActions && !userToggledActions.current) {
      setShowActions(true);
    }
  }, [actions]);

  return (
    <div className="artifact border border-eitherway-elements-borderColor flex flex-col overflow-hidden rounded-lg w-full transition-border duration-150">
      <div className="flex">
        <button
          className="flex items-stretch bg-eitherway-elements-artifacts-background hover:bg-eitherway-elements-artifacts-backgroundHover w-full overflow-hidden"
          onClick={() => {
            const showWorkbench = workbenchStore.showWorkbench.get();
            workbenchStore.showWorkbench.set(!showWorkbench);
          }}
        >
          <div className="px-5 p-3.5 w-full text-left">
            <div className="w-full font-italic text-eitherway-elements-textPrimary font-bold text-[20px] leading-[150%]">
              {artifact?.title}
            </div>
            <div className="w-full w-full text-eitherway-elements-textSecondary text-xs mt-0.5">
              Click to open Workbench
            </div>
          </div>
        </button>
        <div className="bg-eitherway-elements-artifacts-borderColor w-[1px]" />
        <AnimatePresence>
          {actions.length && (
            <motion.button
              initial={{ width: 0 }}
              animate={{ width: 'auto' }}
              exit={{ width: 0 }}
              transition={{ duration: 0.15, ease: cubicEasingFn }}
              className="bg-eitherway-elements-artifacts-background hover:bg-eitherway-elements-artifacts-backgroundHover"
              onClick={toggleActions}
            >
              <div className="p-4">
                <div className={showActions ? 'i-ph:caret-up-bold' : 'i-ph:caret-down-bold'}></div>
              </div>
            </motion.button>
          )}
        </AnimatePresence>
      </div>
      <AnimatePresence>
        {showActions && actions.length > 0 && (
          <motion.div
            className="actions"
            initial={{ height: 0 }}
            animate={{ height: 'auto' }}
            exit={{ height: '0px' }}
            transition={{ duration: 0.15 }}
          >
            <div className="bg-eitherway-elements-artifacts-borderColor h-[1px]" />
            <div className="p-5 text-left bg-eitherway-elements-actions-background">
              <ActionList actions={actions} />
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
});

interface ShellCodeBlockProps {
  classsName?: string;
  code: string;
}

function ShellCodeBlock({ classsName, code }: ShellCodeBlockProps) {
  return (
    <div
      className={classNames('text-xs', classsName)}
      dangerouslySetInnerHTML={{
        __html: shellHighlighter.codeToHtml(code, {
          lang: 'shell',
          theme: 'dark-plus',
        }),
      }}
    ></div>
  );
}

interface ActionListProps {
  actions: ActionState[];
}

const actionVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0 },
};

const ActionList = memo(({ actions }: ActionListProps) => {
  return (
    <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} transition={{ duration: 0.15 }}>
      <ul className="list-none space-y-2.5">
        {actions.map((action, index) => {
          const { status, type, content } = action;
          const isLast = index === actions.length - 1;

          return (
            <motion.li
              key={index}
              variants={actionVariants}
              initial="hidden"
              animate="visible"
              transition={{
                duration: 0.2,
                ease: cubicEasingFn,
              }}
            >
              <div className="flex items-center gap-1.5 text-sm">
                <div className={classNames('text-lg', getIconColor(action.status))}>
                  {status === 'running' ? (
                    <img src="/icons/chat/loader.svg" alt="Loading" className="w-4.5 h-4.5 animate-spin" />
                  ) : status === 'pending' ? (
                    <div className="i-ph:circle"></div>
                  ) : status === 'complete' ? (
                    <div className="i-ph:check"></div>
                  ) : status === 'failed' || status === 'aborted' ? (
                    <div className="i-ph:x"></div>
                  ) : null}
                </div>
                {type === 'file' ? (
                  <div>
                    Create{' '}
                    <code className="bg-eitherway-elements-artifacts-inlineCode-background text-eitherway-elements-artifacts-inlineCode-text px-1.5 py-1 rounded-md">
                      {action.filePath}
                    </code>
                  </div>
                ) : type === 'shell' ? (
                  <div className="flex ml-1 items-center w-full min-h-[28px]">
                    <span className="flex-1">Run command</span>
                  </div>
                ) : null}
              </div>
              {type === 'shell' && (
                <ShellCodeBlock
                  classsName={classNames('border border-eitherway-elements-borderColor rounded-md mt-4', {
                    'mb-3.5': !isLast,
                  })}
                  code={content}
                />
              )}
            </motion.li>
          );
        })}
      </ul>
    </motion.div>
  );
});

function getIconColor(status: ActionState['status']) {
  switch (status) {
    case 'pending': {
      return 'text-eitherway-elements-textTertiary';
    }
    case 'running': {
      return 'text-eitherway-elements-loader-progress';
    }
    case 'complete': {
      return 'text-eitherway-elements-icon-success';
    }
    case 'aborted': {
      return 'text-eitherway-elements-textSecondary';
    }
    case 'failed': {
      return 'text-eitherway-elements-icon-error';
    }
    default: {
      return undefined;
    }
  }
}
</file>

<file path="packages/ui-frontend/app/components/chat/FileOperationProgress.tsx">
import { memo } from 'react';

interface FileOperationProgressProps {
  operations: Array<{ operation: string; filePath: string }>;
}

const operationConfig = {
  creating: {
    label: 'Creating',
    icon: 'i-ph:file-plus',
    color: 'text-blue-400',
    inProgress: true,
  },
  created: {
    label: 'Created',
    icon: 'i-ph:check',
    color: 'text-green-400',
    inProgress: false,
  },
  editing: {
    label: 'Editing',
    icon: 'i-ph:pencil-simple',
    color: 'text-yellow-400',
    inProgress: true,
  },
  edited: {
    label: 'Edited',
    icon: 'i-ph:check',
    color: 'text-green-400',
    inProgress: false,
  },
};

export const FileOperationProgress = memo(({ operations }: FileOperationProgressProps) => {
  if (operations.length === 0) return null;

  // Group operations by file path and keep only the latest operation per file
  const latestOperations = operations.reduce(
    (acc, op) => {
      acc[op.filePath] = op;
      return acc;
    },
    {} as Record<string, { operation: string; filePath: string }>,
  );

  const displayOperations = Object.values(latestOperations).slice(-5); // Show last 5 files

  return (
    <div className="flex flex-col gap-1.5 px-3 py-2 bg-black/30 border border-white/10 rounded-lg text-sm max-w-md">
      <div className="text-white/70 text-xs font-medium mb-1">File Operations</div>
      {displayOperations.map((op, index) => {
        const config = operationConfig[op.operation as keyof typeof operationConfig] || {
          label: op.operation,
          icon: 'i-ph:file',
          color: 'text-white',
          inProgress: false,
        };

        return (
          <div key={`${op.filePath}-${index}`} className="flex items-center gap-2">
            <div className={`${config.icon} ${config.color} text-base ${config.inProgress ? 'animate-pulse' : ''}`} />
            <span className="text-white/60 text-xs truncate flex-1" title={op.filePath}>
              {op.filePath}
            </span>
            <span className={`${config.color} text-xs font-medium`}>{config.label}</span>
          </div>
        );
      })}
    </div>
  );
});
</file>

<file path="packages/ui-frontend/app/components/chat/PhaseIndicator.tsx">
import { memo } from 'react';

interface PhaseIndicatorProps {
  phase: 'pending' | 'thinking' | 'reasoning' | 'code-writing' | 'building' | 'completed' | null;
  thinkingDuration?: number | null;
}

const phaseConfig = {
  pending: {
    label: 'Preparing',
    icon: 'i-ph:circle-dashed',
    color: 'text-gray-400',
  },
  thinking: {
    label: 'Thinking',
    icon: 'i-ph:brain',
    color: 'text-blue-400',
  },
  reasoning: {
    label: 'Planning',
    icon: 'i-ph:lightbulb',
    color: 'text-yellow-400',
  },
  'code-writing': {
    label: 'Writing Code',
    icon: 'i-ph:code',
    color: 'text-green-400',
  },
  building: {
    label: 'Building',
    icon: 'i-ph:hammer',
    color: 'text-orange-400',
  },
  completed: {
    label: 'Completed',
    icon: 'i-ph:check-circle',
    color: 'text-green-500',
  },
};

export const PhaseIndicator = memo(({ phase, thinkingDuration }: PhaseIndicatorProps) => {
  if (!phase) return null;

  const config = phaseConfig[phase];

  return (
    <div className="flex items-center gap-2 px-3 py-2 bg-black/30 border border-white/10 rounded-lg text-sm">
      <div className={`${config.icon} ${config.color} text-lg ${phase !== 'completed' ? 'animate-pulse' : ''}`} />
      <span className="text-white/90 font-medium">{config.label}</span>
      {phase === 'completed' && thinkingDuration !== null && thinkingDuration !== undefined && (
        <span className="text-white/50 text-xs ml-1">({thinkingDuration.toFixed(1)}s)</span>
      )}
    </div>
  );
});
</file>

<file path="packages/ui-frontend/app/components/chat/ReasoningPanel.tsx">
import { memo } from 'react';

interface ReasoningPanelProps {
  text: string;
  isActive: boolean;
}

export const ReasoningPanel = memo(({ text, isActive }: ReasoningPanelProps) => {
  if (!text) return null;

  return (
    <div className="flex flex-col gap-2 px-4 py-3 bg-black/40 border border-yellow-500/30 rounded-lg text-sm">
      <div className="flex items-center gap-2">
        <div className={`i-ph:lightbulb text-yellow-400 text-lg ${isActive ? 'animate-pulse' : ''}`} />
        <span className="text-yellow-400 font-medium">Reasoning</span>
      </div>
      <div className="text-white/80 text-xs whitespace-pre-wrap leading-relaxed">{text}</div>
    </div>
  );
});
</file>

<file path="packages/ui-frontend/app/components/editor/codemirror/CodeMirrorEditor.tsx">
import { acceptCompletion, autocompletion, closeBrackets } from '@codemirror/autocomplete';
import { defaultKeymap, history, historyKeymap } from '@codemirror/commands';
import { bracketMatching, foldGutter, indentOnInput, indentUnit } from '@codemirror/language';
import { searchKeymap } from '@codemirror/search';
import { Compartment, EditorSelection, EditorState, StateEffect, StateField, type Extension } from '@codemirror/state';
import {
  drawSelection,
  dropCursor,
  EditorView,
  highlightActiveLine,
  highlightActiveLineGutter,
  keymap,
  lineNumbers,
  scrollPastEnd,
  showTooltip,
  tooltips,
  type Tooltip,
} from '@codemirror/view';
import { memo, useEffect, useRef, useState, type MutableRefObject } from 'react';
import type { Theme } from '~/types/theme';
import { classNames } from '~/utils/classNames';
import { debounce } from '~/utils/debounce';
import { createScopedLogger } from '~/utils/logger';
import { BinaryContent } from './BinaryContent';
import { getTheme, reconfigureTheme } from './cm-theme';
import { indentKeyBinding } from './indent';
import { getLanguage } from './languages';

const logger = createScopedLogger('CodeMirrorEditor');

export interface EditorDocument {
  value: string;
  isBinary: boolean;
  filePath: string;
  scroll?: ScrollPosition;
}

export interface EditorSettings {
  fontSize?: string;
  gutterFontSize?: string;
  tabSize?: number;
}

type TextEditorDocument = EditorDocument & {
  value: string;
};

export interface ScrollPosition {
  top: number;
  left: number;
}

export interface EditorUpdate {
  selection: EditorSelection;
  content: string;
}

export type OnChangeCallback = (update: EditorUpdate) => void;
export type OnScrollCallback = (position: ScrollPosition) => void;
export type OnSaveCallback = () => void;

interface Props {
  theme: Theme;
  id?: unknown;
  doc?: EditorDocument;
  editable?: boolean;
  debounceChange?: number;
  debounceScroll?: number;
  autoFocusOnDocumentChange?: boolean;
  onChange?: OnChangeCallback;
  onScroll?: OnScrollCallback;
  onSave?: OnSaveCallback;
  className?: string;
  settings?: EditorSettings;
}

type EditorStates = Map<string, EditorState>;

const readOnlyTooltipStateEffect = StateEffect.define<boolean>();

const editableTooltipField = StateField.define<readonly Tooltip[]>({
  create: () => [],
  update(_tooltips, transaction) {
    if (!transaction.state.readOnly) {
      return [];
    }

    for (const effect of transaction.effects) {
      if (effect.is(readOnlyTooltipStateEffect) && effect.value) {
        return getReadOnlyTooltip(transaction.state);
      }
    }

    return [];
  },
  provide: (field) => {
    return showTooltip.computeN([field], (state) => state.field(field));
  },
});

const editableStateEffect = StateEffect.define<boolean>();

const editableStateField = StateField.define<boolean>({
  create() {
    return true;
  },
  update(value, transaction) {
    for (const effect of transaction.effects) {
      if (effect.is(editableStateEffect)) {
        return effect.value;
      }
    }

    return value;
  },
});

export const CodeMirrorEditor = memo(
  ({
    id,
    doc,
    debounceScroll = 100,
    debounceChange = 150,
    autoFocusOnDocumentChange = false,
    editable = true,
    onScroll,
    onChange,
    onSave,
    theme,
    settings,
    className = '',
  }: Props) => {
    const [languageCompartment] = useState(new Compartment());

    const containerRef = useRef<HTMLDivElement | null>(null);
    const viewRef = useRef<EditorView>();
    const themeRef = useRef<Theme>();
    const docRef = useRef<EditorDocument>();
    const editorStatesRef = useRef<EditorStates>();
    const onScrollRef = useRef(onScroll);
    const onChangeRef = useRef(onChange);
    const onSaveRef = useRef(onSave);

    /**
     * This effect is used to avoid side effects directly in the render function
     * and instead the refs are updated after each render.
     */
    useEffect(() => {
      onScrollRef.current = onScroll;
      onChangeRef.current = onChange;
      onSaveRef.current = onSave;
      docRef.current = doc;
      themeRef.current = theme;
    });

    useEffect(() => {
      const onUpdate = debounce((update: EditorUpdate) => {
        onChangeRef.current?.(update);
      }, debounceChange);

      const view = new EditorView({
        parent: containerRef.current!,
        dispatchTransactions(transactions) {
          const previousSelection = view.state.selection;

          view.update(transactions);

          const newSelection = view.state.selection;

          const selectionChanged =
            newSelection !== previousSelection &&
            (newSelection === undefined || previousSelection === undefined || !newSelection.eq(previousSelection));

          if (docRef.current && (transactions.some((transaction) => transaction.docChanged) || selectionChanged)) {
            onUpdate({
              selection: view.state.selection,
              content: view.state.doc.toString(),
            });

            editorStatesRef.current!.set(docRef.current.filePath, view.state);
          }
        },
      });

      viewRef.current = view;

      return () => {
        viewRef.current?.destroy();
        viewRef.current = undefined;
      };
    }, []);

    useEffect(() => {
      if (!viewRef.current) {
        return;
      }

      viewRef.current.dispatch({
        effects: [reconfigureTheme(theme)],
      });
    }, [theme]);

    useEffect(() => {
      editorStatesRef.current = new Map<string, EditorState>();
    }, [id]);

    useEffect(() => {
      const editorStates = editorStatesRef.current!;
      const view = viewRef.current!;
      const theme = themeRef.current!;

      if (!doc) {
        const state = newEditorState('', theme, settings, onScrollRef, debounceScroll, onSaveRef, [
          languageCompartment.of([]),
        ]);

        view.setState(state);

        setNoDocument(view);

        return;
      }

      if (doc.isBinary) {
        return;
      }

      if (doc.filePath === '') {
        logger.warn('File path should not be empty');
      }

      let state = editorStates.get(doc.filePath);

      if (!state) {
        state = newEditorState(doc.value, theme, settings, onScrollRef, debounceScroll, onSaveRef, [
          languageCompartment.of([]),
        ]);

        editorStates.set(doc.filePath, state);
      }

      view.setState(state);

      setEditorDocument(
        view,
        theme,
        editable,
        languageCompartment,
        autoFocusOnDocumentChange,
        doc as TextEditorDocument,
      );
    }, [doc?.value, editable, doc?.filePath, autoFocusOnDocumentChange]);

    return (
      <div className={classNames('relative h-full', className)}>
        {doc?.isBinary && <BinaryContent />}
        <div className="h-full overflow-hidden" ref={containerRef} />
      </div>
    );
  },
);

export default CodeMirrorEditor;

CodeMirrorEditor.displayName = 'CodeMirrorEditor';

function newEditorState(
  content: string,
  theme: Theme,
  settings: EditorSettings | undefined,
  onScrollRef: MutableRefObject<OnScrollCallback | undefined>,
  debounceScroll: number,
  onFileSaveRef: MutableRefObject<OnSaveCallback | undefined>,
  extensions: Extension[],
) {
  return EditorState.create({
    doc: content,
    extensions: [
      EditorView.domEventHandlers({
        scroll: debounce((event, view) => {
          if (event.target !== view.scrollDOM) {
            return;
          }

          onScrollRef.current?.({ left: view.scrollDOM.scrollLeft, top: view.scrollDOM.scrollTop });
        }, debounceScroll),
        keydown: (event, view) => {
          if (view.state.readOnly) {
            view.dispatch({
              effects: [readOnlyTooltipStateEffect.of(event.key !== 'Escape')],
            });

            return true;
          }

          return false;
        },
      }),
      getTheme(theme, settings),
      history(),
      keymap.of([
        ...defaultKeymap,
        ...historyKeymap,
        ...searchKeymap,
        { key: 'Tab', run: acceptCompletion },
        {
          key: 'Mod-s',
          preventDefault: true,
          run: () => {
            onFileSaveRef.current?.();
            return true;
          },
        },
        indentKeyBinding,
      ]),
      indentUnit.of('\t'),
      autocompletion({
        closeOnBlur: false,
      }),
      tooltips({
        position: 'absolute',
        parent: document.body,
        tooltipSpace: (view) => {
          const rect = view.dom.getBoundingClientRect();

          return {
            top: rect.top - 50,
            left: rect.left,
            bottom: rect.bottom,
            right: rect.right + 10,
          };
        },
      }),
      closeBrackets(),
      lineNumbers(),
      scrollPastEnd(),
      dropCursor(),
      drawSelection(),
      bracketMatching(),
      EditorState.tabSize.of(settings?.tabSize ?? 2),
      indentOnInput(),
      editableTooltipField,
      editableStateField,
      EditorState.readOnly.from(editableStateField, (editable) => !editable),
      highlightActiveLineGutter(),
      highlightActiveLine(),
      foldGutter({
        markerDOM: (open) => {
          const icon = document.createElement('div');

          icon.className = `fold-icon ${open ? 'i-ph-caret-down-bold' : 'i-ph-caret-right-bold'}`;

          return icon;
        },
      }),
      ...extensions,
    ],
  });
}

function setNoDocument(view: EditorView) {
  view.dispatch({
    selection: { anchor: 0 },
    changes: {
      from: 0,
      to: view.state.doc.length,
      insert: '',
    },
  });

  view.scrollDOM.scrollTo(0, 0);
}

function setEditorDocument(
  view: EditorView,
  theme: Theme,
  editable: boolean,
  languageCompartment: Compartment,
  autoFocus: boolean,
  doc: TextEditorDocument,
) {
  if (doc.value !== view.state.doc.toString()) {
    view.dispatch({
      selection: { anchor: 0 },
      changes: {
        from: 0,
        to: view.state.doc.length,
        insert: doc.value,
      },
    });
  }

  view.dispatch({
    effects: [editableStateEffect.of(editable && !doc.isBinary)],
  });

  getLanguage(doc.filePath).then((languageSupport) => {
    if (!languageSupport) {
      return;
    }

    view.dispatch({
      effects: [languageCompartment.reconfigure([languageSupport]), reconfigureTheme(theme)],
    });

    requestAnimationFrame(() => {
      const currentLeft = view.scrollDOM.scrollLeft;
      const currentTop = view.scrollDOM.scrollTop;
      const newLeft = doc.scroll?.left ?? 0;
      const newTop = doc.scroll?.top ?? 0;

      const needsScrolling = currentLeft !== newLeft || currentTop !== newTop;

      if (autoFocus && editable) {
        if (needsScrolling) {
          // we have to wait until the scroll position was changed before we can set the focus
          view.scrollDOM.addEventListener(
            'scroll',
            () => {
              view.focus();
            },
            { once: true },
          );
        } else {
          // if the scroll position is still the same we can focus immediately
          view.focus();
        }
      }

      view.scrollDOM.scrollTo(newLeft, newTop);
    });
  });
}

function getReadOnlyTooltip(state: EditorState) {
  if (!state.readOnly) {
    return [];
  }

  return state.selection.ranges
    .filter((range) => {
      return range.empty;
    })
    .map((range) => {
      return {
        pos: range.head,
        above: true,
        strictSide: true,
        arrow: true,
        create: () => {
          const divElement = document.createElement('div');
          divElement.className = 'cm-readonly-tooltip';
          divElement.textContent = 'Cannot edit file while AI response is being generated';

          return { dom: divElement };
        },
      };
    });
}
</file>

<file path="packages/ui-frontend/app/components/landing/ContentBlock1.tsx">
import React from 'react';

export function ContentBlock1() {
  return (
    <div className="w-full max-w-[1280px] mx-auto px-6 py-20 bg-black">
      <div className="space-y-16">
        {/* Ready in Minutes */}
        <div className="flex items-center justify-between gap-6 max-[768px]:flex-col max-[768px]:gap-8 box-border py-24 px-12 w-full  h-[336px] max-[768px]:h-auto max-[768px]:py-12 bg-white/5 border border-white/15 rounded-2xl mx-auto">
          <div className="flex flex-col items-start gap-6 flex-1 max-[768px]:order-2">
            <h2 className="text-white font-syne font-medium text-4xl leading-tight tracking-[-0.05em]">
              Ready in Minutes
            </h2>
            <p className="text-white font-montserrat font-medium text-base leading-[150%]">
              Why wait weeks for developers? With Eitherway, your app is generated in just minutes  complete with
              backend, flows, and polished UI.
            </p>
          </div>
          <div className="flex justify-center w-80 h-80 flex-shrink-0 max-[768px]:order-1 max-[768px]:w-64 max-[768px]:h-64">
            <img src="/icons/block1/readyInMinutes.svg" alt="Ready in Minutes" className="w-full h-full" />
          </div>
        </div>

        <div className="flex items-center justify-between gap-6 max-[768px]:flex-col max-[768px]:gap-8 box-border py-24 px-12 w-full h-[336px] max-[768px]:h-auto max-[768px]:py-12 bg-white/5 border border-white/15 rounded-2xl mx-auto">
          <div className="flex justify-center w-80 h-80 flex-shrink-0 max-[768px]:order-1 max-[768px]:w-64 max-[768px]:h-64">
            <img src="/icons/block1/noCodeJustAi.svg" alt="No Code, Just AI" className="w-full h-full" />
          </div>
          <div className="flex flex-col items-start gap-6 flex-1 max-[768px]:order-2">
            <h2 className="text-white font-syne font-medium text-4xl leading-tight tracking-[-0.05em]">
              No Code, Just AI
            </h2>
            <p className="text-white font-montserrat font-medium text-base leading-[150%]">
              Type your idea, and watch our AI write production-grade code live. No coding background required  you
              focus on vision, we handle execution.
            </p>
          </div>
        </div>

        {/* Built for Web3 & Beyond */}
        <div className="flex items-center justify-between gap-6 max-[768px]:flex-col max-[768px]:gap-8 box-border py-24 px-12 w-full h-[336px] max-[768px]:h-auto max-[768px]:py-12 bg-white/5 border border-white/15 rounded-2xl mx-auto">
          <div className="flex flex-col items-start gap-6 flex-1 max-[768px]:order-2">
            <h2 className="text-white font-syne font-medium text-4xl leading-tight tracking-[-0.05em]">
              Built for Web3 & Beyond
            </h2>
            <p className="text-white font-montserrat font-medium text-base leading-[150%]">
              From Web2 apps to complex dApps, Eitherway can generate smart contracts, wallets, and tokenized features 
              making your apps Web3-ready by default.
            </p>
          </div>
          <div className="flex justify-center w-80 h-80 flex-shrink-0 max-[768px]:order-1 max-[768px]:w-64 max-[768px]:h-64">
            <img src="/icons/block1/builtForWeb3&Beyond.svg" alt="Built for Web3 & Beyond" className="w-full h-full" />
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/plan/PlanProgress.tsx">
/**
 * Plan Progress Component
 *
 * Displays real-time progress of plan execution with:
 * - Overall status (running, completed, failed, partial)
 * - Progress bar and statistics
 * - Individual operation statuses
 * - Error details for failed operations
 * - Automatic polling for live updates
 */

import { useState, useEffect } from 'react';
import { classNames } from '~/utils/classNames';

interface PlanProgressProps {
  planId: string;
  sessionId: string;
  onComplete?: (result: PlanExecutionResult) => void;
  autoClose?: boolean; // Auto-close when completed successfully
}

interface PlanExecutionResult {
  execution: {
    planId: string;
    sessionId: string;
    appId: string;
    status: 'pending' | 'running' | 'completed' | 'failed' | 'partial';
    totalOps: number;
    succeededOps: number;
    failedOps: number;
    skippedOps: number;
    startedAt: string;
    completedAt?: string;
    durationMs?: number;
  };
  operations: Array<{
    index: number;
    type: string;
    status: 'pending' | 'running' | 'success' | 'failed' | 'skipped';
    result?: any;
    error?: string;
    startedAt?: string;
    completedAt?: string;
    durationMs?: number;
  }>;
}

export function PlanProgress({ planId, sessionId, onComplete, autoClose = false }: PlanProgressProps) {
  const [executionResult, setExecutionResult] = useState<PlanExecutionResult | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let interval: NodeJS.Timeout | null = null;

    const fetchProgress = async () => {
      try {
        const response = await fetch(`/api/projects/plans/${planId}`);

        if (!response.ok) {
          throw new Error(`Failed to fetch plan status: ${response.statusText}`);
        }

        const data: PlanExecutionResult = await response.json();
        setExecutionResult(data);
        setLoading(false);

        // Stop polling if execution is complete
        if (data.execution.status !== 'running' && data.execution.status !== 'pending') {
          if (interval) {
            clearInterval(interval);
            interval = null;
          }

          // Notify parent component
          if (onComplete) {
            onComplete(data);
          }
        }
      } catch (err: any) {
        console.error('[PlanProgress] Error fetching status:', err);
        setError(err.message);
        setLoading(false);

        if (interval) {
          clearInterval(interval);
          interval = null;
        }
      }
    };

    // Initial fetch
    fetchProgress();

    // Poll every second while running
    interval = setInterval(fetchProgress, 1000);

    return () => {
      if (interval) {
        clearInterval(interval);
      }
    };
  }, [planId, onComplete]);

  if (loading && !executionResult) {
    return (
      <div className="plan-progress p-4 bg-black/50 border border-eitherway-elements-borderColor rounded-lg">
        <div className="flex items-center gap-2">
          <div className="i-ph:spinner animate-spin text-blue-400" />
          <span className="text-sm text-eitherway-elements-textSecondary">Loading plan execution status...</span>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="plan-progress p-4 bg-red-500/10 border border-red-500/30 rounded-lg">
        <div className="flex items-center gap-2">
          <div className="i-ph:warning-circle text-red-400 text-xl" />
          <div>
            <div className="text-sm font-medium text-red-400">Error Loading Plan Status</div>
            <div className="text-xs text-red-300/80 mt-1">{error}</div>
          </div>
        </div>
      </div>
    );
  }

  if (!executionResult) {
    return null;
  }

  const { execution, operations } = executionResult;
  const progressPercent =
    execution.totalOps > 0
      ? Math.round(((execution.succeededOps + execution.failedOps) / execution.totalOps) * 100)
      : 0;

  const statusColors = {
    pending: 'text-gray-400',
    running: 'text-blue-400',
    completed: 'text-green-400',
    failed: 'text-red-400',
    partial: 'text-yellow-400',
  };

  const statusIcons = {
    pending: 'i-ph:clock',
    running: 'i-ph:spinner animate-spin',
    completed: 'i-ph:check-circle',
    failed: 'i-ph:x-circle',
    partial: 'i-ph:warning-circle',
  };

  return (
    <div className="plan-progress flex flex-col gap-3 p-4 bg-black/50 border border-eitherway-elements-borderColor rounded-lg">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <div className={classNames(statusIcons[execution.status], statusColors[execution.status], 'text-xl')} />
          <span className={classNames('text-sm font-medium', statusColors[execution.status])}>
            Plan Execution: {execution.status.toUpperCase()}
          </span>
        </div>

        {execution.durationMs !== undefined && (
          <span className="text-xs text-eitherway-elements-textTertiary">
            {execution.durationMs < 1000 ? `${execution.durationMs}ms` : `${(execution.durationMs / 1000).toFixed(1)}s`}
          </span>
        )}
      </div>

      {/* Progress Bar */}
      <div className="flex flex-col gap-1">
        <div className="h-2 bg-black/50 rounded-full overflow-hidden">
          <div
            className={classNames(
              'h-full transition-all duration-300',
              execution.status === 'completed'
                ? 'bg-green-500'
                : execution.status === 'failed'
                  ? 'bg-red-500'
                  : execution.status === 'partial'
                    ? 'bg-yellow-500'
                    : 'bg-blue-500',
            )}
            style={{ width: `${progressPercent}%` }}
          />
        </div>

        <div className="flex justify-between text-xs text-eitherway-elements-textTertiary">
          <span>
            {execution.succeededOps + execution.failedOps} / {execution.totalOps} operations
          </span>
          <span>{progressPercent}%</span>
        </div>
      </div>

      {/* Statistics */}
      <div className="flex gap-4 text-xs">
        <div className="flex items-center gap-1">
          <div className="i-ph:check-circle text-green-400" />
          <span className="text-eitherway-elements-textSecondary">{execution.succeededOps} succeeded</span>
        </div>

        {execution.failedOps > 0 && (
          <div className="flex items-center gap-1">
            <div className="i-ph:x-circle text-red-400" />
            <span className="text-eitherway-elements-textSecondary">{execution.failedOps} failed</span>
          </div>
        )}

        {execution.skippedOps > 0 && (
          <div className="flex items-center gap-1">
            <div className="i-ph:arrow-circle-right text-gray-400" />
            <span className="text-eitherway-elements-textSecondary">{execution.skippedOps} skipped</span>
          </div>
        )}
      </div>

      {/* Operations List */}
      <div className="flex flex-col gap-1 max-h-64 overflow-y-auto">
        {operations.map((op) => (
          <div
            key={op.index}
            className={classNames(
              'flex items-center justify-between px-3 py-2 rounded border text-xs',
              op.status === 'success'
                ? 'bg-green-500/10 border-green-500/30'
                : op.status === 'failed'
                  ? 'bg-red-500/10 border-red-500/30'
                  : op.status === 'running'
                    ? 'bg-blue-500/10 border-blue-500/30'
                    : op.status === 'skipped'
                      ? 'bg-gray-500/10 border-gray-500/30'
                      : 'bg-gray-500/5 border-gray-500/20',
            )}
          >
            <div className="flex items-center gap-2 flex-1 min-w-0">
              <span className="text-eitherway-elements-textTertiary">#{op.index}</span>
              <span className="font-mono text-eitherway-elements-textPrimary truncate">{op.type}</span>

              {/* Operation Status Icon */}
              {op.status === 'success' && <div className="i-ph:check text-green-400" />}
              {op.status === 'failed' && <div className="i-ph:x text-red-400" />}
              {op.status === 'running' && <div className="i-ph:spinner animate-spin text-blue-400" />}
              {op.status === 'skipped' && <div className="i-ph:minus text-gray-400" />}
            </div>

            {/* Duration */}
            {op.durationMs !== undefined && (
              <span className="text-eitherway-elements-textTertiary ml-2">{op.durationMs}ms</span>
            )}
          </div>
        ))}
      </div>

      {/* Error Details (if any operation failed) */}
      {operations.some((op) => op.error) && (
        <div className="mt-2 p-3 bg-red-500/10 border border-red-500/30 rounded text-xs">
          <div className="font-medium text-red-400 mb-1">Error Details:</div>
          {operations
            .filter((op) => op.error)
            .map((op) => (
              <div key={op.index} className="text-red-300/80 mt-1">
                <span className="font-mono">
                  Op {op.index} ({op.type}):
                </span>{' '}
                {op.error}
              </div>
            ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/ui/ThemeSwitch.tsx">
import { useStore } from '@nanostores/react';
import { memo, useEffect, useState } from 'react';
import { themeStore, toggleTheme } from '~/lib/stores/theme';
import { IconButton } from './IconButton';

interface ThemeSwitchProps {
  className?: string;
}

export const ThemeSwitch = memo(({ className }: ThemeSwitchProps) => {
  const theme = useStore(themeStore);
  const [domLoaded, setDomLoaded] = useState(false);

  useEffect(() => {
    setDomLoaded(true);
  }, []);

  return (
    domLoaded && (
      <IconButton
        className={`${className} [&>*]:!text-4xl [&>*]:!w-8 [&>*]:!h-8`}
        icon="i-ph-bug-duotone"
        size="xl"
        title="Report a Problem"
        onClick={() => window.open('https://t.me/Eitherway_support', '_blank')}
      />
    )
  );
});
</file>

<file path="packages/ui-frontend/app/components/workbench/EditorPanel.tsx">
import { useStore } from '@nanostores/react';
import { memo, useEffect, useMemo, useRef, useState } from 'react';
import { Panel, PanelGroup, PanelResizeHandle, type ImperativePanelHandle } from 'react-resizable-panels';
import {
  CodeMirrorEditor,
  type EditorDocument,
  type EditorSettings,
  type OnChangeCallback as OnEditorChange,
  type OnSaveCallback as OnEditorSave,
  type OnScrollCallback as OnEditorScroll,
} from '~/components/editor/codemirror/CodeMirrorEditor';
import { IconButton } from '~/components/ui/IconButton';
import { PanelHeader } from '~/components/ui/PanelHeader';
import { PanelHeaderButton } from '~/components/ui/PanelHeaderButton';
import { shortcutEventEmitter } from '~/lib/hooks';
import type { FileMap } from '~/lib/stores/files';
import { themeStore } from '~/lib/stores/theme';
import { workbenchStore } from '~/lib/stores/workbench';
import { classNames } from '~/utils/classNames';
import { WORK_DIR } from '~/utils/constants';
import { isMobile } from '~/utils/mobile';
import { FileBreadcrumb } from './FileBreadcrumb';
import { FileTree } from './FileTree';
import { Terminal, type TerminalRef } from './terminal/Terminal';

interface EditorPanelProps {
  files?: FileMap;
  unsavedFiles?: Set<string>;
  editorDocument?: EditorDocument;
  selectedFile?: string | undefined;
  isStreaming?: boolean;
  onEditorChange?: OnEditorChange;
  onEditorScroll?: OnEditorScroll;
  onFileSelect?: (value?: string) => void;
  onFileSave?: OnEditorSave;
  onFileReset?: () => void;
}

const MAX_TERMINALS = 3;
const DEFAULT_TERMINAL_SIZE = 25;
const DEFAULT_EDITOR_SIZE = 100 - DEFAULT_TERMINAL_SIZE;

const editorSettings: EditorSettings = { tabSize: 2 };

export const EditorPanel = memo(
  ({
    files,
    unsavedFiles,
    editorDocument,
    selectedFile,
    isStreaming,
    onFileSelect,
    onEditorChange,
    onEditorScroll,
    onFileSave,
    onFileReset,
  }: EditorPanelProps) => {
    const theme = useStore(themeStore);
    const showTerminal = useStore(workbenchStore.showTerminal);

    const terminalRefs = useRef<Array<TerminalRef | null>>([]);
    const terminalPanelRef = useRef<ImperativePanelHandle>(null);
    const terminalToggledByShortcut = useRef(false);

    const [activeTerminal, setActiveTerminal] = useState(0);
    const [terminalCount, setTerminalCount] = useState(1);

    const activeFileSegments = useMemo(() => {
      if (!editorDocument) {
        return undefined;
      }

      return editorDocument.filePath.split('/');
    }, [editorDocument]);

    const activeFileUnsaved = useMemo(() => {
      return editorDocument !== undefined && unsavedFiles?.has(editorDocument.filePath);
    }, [editorDocument, unsavedFiles]);

    useEffect(() => {
      const unsubscribeFromEventEmitter = shortcutEventEmitter.on('toggleTerminal', () => {
        terminalToggledByShortcut.current = true;
      });

      const unsubscribeFromThemeStore = themeStore.subscribe(() => {
        for (const ref of Object.values(terminalRefs.current)) {
          ref?.reloadStyles();
        }
      });

      return () => {
        unsubscribeFromEventEmitter();
        unsubscribeFromThemeStore();
      };
    }, []);

    useEffect(() => {
      const { current: terminal } = terminalPanelRef;

      if (!terminal) {
        return;
      }

      const isCollapsed = terminal.isCollapsed();

      if (!showTerminal && !isCollapsed) {
        terminal.collapse();
      } else if (showTerminal && isCollapsed) {
        terminal.resize(DEFAULT_TERMINAL_SIZE);
      }

      terminalToggledByShortcut.current = false;
    }, [showTerminal]);

    const addTerminal = () => {
      if (terminalCount < MAX_TERMINALS) {
        setTerminalCount(terminalCount + 1);
        setActiveTerminal(terminalCount);
      }
    };

    return (
      <PanelGroup direction="vertical">
        <Panel defaultSize={showTerminal ? DEFAULT_EDITOR_SIZE : 100} minSize={20}>
          <PanelGroup direction="horizontal">
            <Panel defaultSize={20} minSize={10} collapsible>
              <div className="flex flex-col border-r border-eitherway-elements-borderColor h-full">
                <PanelHeader>
                  <div className="i-ph:tree-structure-duotone shrink-0" />
                  Files
                </PanelHeader>
                <FileTree
                  className="h-full"
                  files={files}
                  hideRoot
                  unsavedFiles={unsavedFiles}
                  rootFolder={WORK_DIR}
                  selectedFile={selectedFile}
                  onFileSelect={onFileSelect}
                />
              </div>
            </Panel>
            <PanelResizeHandle />
            <Panel className="flex flex-col" defaultSize={80} minSize={20}>
              <PanelHeader className="overflow-x-auto">
                {activeFileSegments?.length && (
                  <div className="flex items-center flex-1 text-sm">
                    <FileBreadcrumb pathSegments={activeFileSegments} files={files} onFileSelect={onFileSelect} />
                    {activeFileUnsaved && (
                      <div className="flex gap-1 ml-auto -mr-1.5">
                        <PanelHeaderButton onClick={onFileSave}>
                          <div className="i-ph:floppy-disk-duotone" />
                          Save
                        </PanelHeaderButton>
                        <PanelHeaderButton onClick={onFileReset}>
                          <div className="i-ph:clock-counter-clockwise-duotone" />
                          Reset
                        </PanelHeaderButton>
                      </div>
                    )}
                  </div>
                )}
              </PanelHeader>
              <div className="h-full flex-1 overflow-hidden">
                <CodeMirrorEditor
                  theme={theme}
                  editable={!isStreaming && editorDocument !== undefined}
                  settings={editorSettings}
                  doc={editorDocument}
                  autoFocusOnDocumentChange={!isMobile()}
                  onScroll={onEditorScroll}
                  onChange={onEditorChange}
                  onSave={onFileSave}
                />
              </div>
            </Panel>
          </PanelGroup>
        </Panel>
        <PanelResizeHandle />
        <Panel
          ref={terminalPanelRef}
          defaultSize={showTerminal ? DEFAULT_TERMINAL_SIZE : 0}
          minSize={10}
          collapsible
          onExpand={() => {
            if (!terminalToggledByShortcut.current) {
              workbenchStore.toggleTerminal(true);
            }
          }}
          onCollapse={() => {
            if (!terminalToggledByShortcut.current) {
              workbenchStore.toggleTerminal(false);
            }
          }}
        >
          <div className="h-full">
            <div className="bg-eitherway-elements-terminals-background h-full flex flex-col">
              <div className="flex items-center bg-eitherway-elements-background-depth-2 border-y border-eitherway-elements-borderColor gap-1.5 min-h-[34px] p-2">
                {Array.from({ length: terminalCount }, (_, index) => {
                  const isActive = activeTerminal === index;

                  return (
                    <button
                      key={index}
                      className={classNames(
                        'flex items-center text-sm cursor-pointer gap-1.5 px-3 py-2 h-full whitespace-nowrap rounded-full',
                        {
                          'bg-gray-200 text-eitherway-elements-textPrimary': isActive,
                          'bg-eitherway-elements-background-depth-2 text-eitherway-elements-textSecondary hover:bg-eitherway-elements-terminals-buttonBackground':
                            !isActive,
                        },
                      )}
                      onClick={() => setActiveTerminal(index)}
                    >
                      <div className="i-ph:terminal-window-duotone text-lg" />
                      Terminal {terminalCount > 1 && index + 1}
                    </button>
                  );
                })}
                {terminalCount < MAX_TERMINALS && <IconButton icon="i-ph:plus" size="md" onClick={addTerminal} />}
                <IconButton
                  className="ml-auto"
                  icon="i-ph:caret-down"
                  title="Close"
                  size="md"
                  onClick={() => workbenchStore.toggleTerminal(false)}
                />
              </div>
              {Array.from({ length: terminalCount }, (_, index) => {
                const isActive = activeTerminal === index;

                return (
                  <Terminal
                    key={index}
                    className={classNames('h-full overflow-hidden', {
                      hidden: !isActive,
                    })}
                    ref={(ref) => {
                      terminalRefs.current.push(ref);
                    }}
                    onTerminalReady={(terminal) => workbenchStore.attachTerminal(terminal)}
                    onTerminalResize={(cols, rows) => workbenchStore.onTerminalResize(cols, rows)}
                    theme={theme}
                  />
                );
              })}
            </div>
          </div>
        </Panel>
      </PanelGroup>
    );
  },
);
</file>

<file path="packages/ui-frontend/app/components/workbench/FileBreadcrumb.tsx">
import * as DropdownMenu from '@radix-ui/react-dropdown-menu';
import { AnimatePresence, motion, type Variants } from 'framer-motion';
import { memo, useEffect, useRef, useState } from 'react';
import type { FileMap } from '~/lib/stores/files';
import { classNames } from '~/utils/classNames';
import { WORK_DIR } from '~/utils/constants';
import { cubicEasingFn } from '~/utils/easings';
import FileTree from './FileTree';

const WORK_DIR_REGEX = new RegExp(`^${WORK_DIR.split('/').slice(0, -1).join('/').replaceAll('/', '\\/')}/`);

interface FileBreadcrumbProps {
  files?: FileMap;
  pathSegments?: string[];
  onFileSelect?: (filePath: string) => void;
}

const contextMenuVariants = {
  open: {
    y: 0,
    opacity: 1,
    transition: {
      duration: 0.15,
      ease: cubicEasingFn,
    },
  },
  close: {
    y: 6,
    opacity: 0,
    transition: {
      duration: 0.15,
      ease: cubicEasingFn,
    },
  },
} satisfies Variants;

export const FileBreadcrumb = memo<FileBreadcrumbProps>(({ files, pathSegments = [], onFileSelect }) => {
  const [activeIndex, setActiveIndex] = useState<number | null>(null);

  const contextMenuRef = useRef<HTMLDivElement | null>(null);
  const segmentRefs = useRef<(HTMLSpanElement | null)[]>([]);

  const handleSegmentClick = (index: number) => {
    setActiveIndex((prevIndex) => (prevIndex === index ? null : index));
  };

  useEffect(() => {
    const handleOutsideClick = (event: MouseEvent) => {
      if (
        activeIndex !== null &&
        !contextMenuRef.current?.contains(event.target as Node) &&
        !segmentRefs.current.some((ref) => ref?.contains(event.target as Node))
      ) {
        setActiveIndex(null);
      }
    };

    document.addEventListener('mousedown', handleOutsideClick);

    return () => {
      document.removeEventListener('mousedown', handleOutsideClick);
    };
  }, [activeIndex]);

  if (files === undefined || pathSegments.length === 0) {
    return null;
  }

  return (
    <div className="flex">
      {pathSegments.map((segment, index) => {
        const isLast = index === pathSegments.length - 1;

        const path = pathSegments.slice(0, index).join('/');

        if (!WORK_DIR_REGEX.test(path)) {
          return null;
        }

        const isActive = activeIndex === index;

        return (
          <div key={index} className="relative flex items-center">
            <DropdownMenu.Root open={isActive} modal={false}>
              <DropdownMenu.Trigger asChild>
                <span
                  ref={(ref) => (segmentRefs.current[index] = ref)}
                  className={classNames('flex items-center gap-1.5 cursor-pointer shrink-0', {
                    'text-eitherway-elements-textTertiary hover:text-eitherway-elements-textPrimary': !isActive,
                    'text-eitherway-elements-textPrimary underline': isActive,
                    'pr-4': isLast,
                  })}
                  onClick={() => handleSegmentClick(index)}
                >
                  {isLast && <div className="i-ph:file-duotone" />}
                  {segment}
                </span>
              </DropdownMenu.Trigger>
              {index > 0 && !isLast && <span className="i-ph:caret-right inline-block mx-1" />}
              <AnimatePresence>
                {isActive && (
                  <DropdownMenu.Portal>
                    <DropdownMenu.Content
                      className="z-file-tree-breadcrumb"
                      asChild
                      align="start"
                      side="bottom"
                      avoidCollisions={false}
                    >
                      <motion.div
                        ref={contextMenuRef}
                        initial="close"
                        animate="open"
                        exit="close"
                        variants={contextMenuVariants}
                      >
                        <div className="rounded-lg overflow-hidden">
                          <div className="max-h-[50vh] min-w-[300px] overflow-scroll bg-eitherway-elements-background-depth-1 border border-eitherway-elements-borderColor shadow-sm rounded-lg">
                            <FileTree
                              files={files}
                              hideRoot
                              rootFolder={path}
                              collapsed
                              allowFolderSelection
                              selectedFile={`${path}/${segment}`}
                              onFileSelect={(filePath) => {
                                setActiveIndex(null);
                                onFileSelect?.(filePath);
                              }}
                            />
                          </div>
                        </div>
                        <DropdownMenu.Arrow className="fill-eitherway-elements-borderColor" />
                      </motion.div>
                    </DropdownMenu.Content>
                  </DropdownMenu.Portal>
                )}
              </AnimatePresence>
            </DropdownMenu.Root>
          </div>
        );
      })}
    </div>
  );
});
</file>

<file path="packages/ui-frontend/app/components/workbench/FileTree.tsx">
import { memo, useEffect, useMemo, useState, type ReactNode } from 'react';
import type { FileMap } from '~/lib/stores/files';
import { classNames } from '~/utils/classNames';
import { createScopedLogger } from '~/utils/logger';

const logger = createScopedLogger('FileTree');

const NODE_PADDING_LEFT = 8;
const DEFAULT_HIDDEN_FILES = [/\/node_modules\//, /\/\.next/, /\/\.astro/];

interface Props {
  files?: FileMap;
  selectedFile?: string;
  onFileSelect?: (filePath: string) => void;
  rootFolder?: string;
  hideRoot?: boolean;
  collapsed?: boolean;
  allowFolderSelection?: boolean;
  hiddenFiles?: Array<string | RegExp>;
  unsavedFiles?: Set<string>;
  className?: string;
}

export const FileTree = memo(
  ({
    files = {},
    onFileSelect,
    selectedFile,
    rootFolder,
    hideRoot = false,
    collapsed = false,
    allowFolderSelection = false,
    hiddenFiles,
    className,
    unsavedFiles,
  }: Props) => {
    const computedHiddenFiles = useMemo(() => [...DEFAULT_HIDDEN_FILES, ...(hiddenFiles ?? [])], [hiddenFiles]);

    const fileList = useMemo(() => {
      return buildFileList(files, rootFolder, hideRoot, computedHiddenFiles);
    }, [files, rootFolder, hideRoot, computedHiddenFiles]);

    const [collapsedFolders, setCollapsedFolders] = useState(() => {
      return collapsed
        ? new Set(fileList.filter((item) => item.kind === 'folder').map((item) => item.fullPath))
        : new Set<string>();
    });

    useEffect(() => {
      if (collapsed) {
        setCollapsedFolders(new Set(fileList.filter((item) => item.kind === 'folder').map((item) => item.fullPath)));
        return;
      }

      setCollapsedFolders((prevCollapsed) => {
        const newCollapsed = new Set<string>();

        for (const folder of fileList) {
          if (folder.kind === 'folder' && prevCollapsed.has(folder.fullPath)) {
            newCollapsed.add(folder.fullPath);
          }
        }

        return newCollapsed;
      });
    }, [fileList, collapsed]);

    const filteredFileList = useMemo(() => {
      const list = [];

      let lastDepth = Number.MAX_SAFE_INTEGER;

      for (const fileOrFolder of fileList) {
        const depth = fileOrFolder.depth;

        // if the depth is equal we reached the end of the collaped group
        if (lastDepth === depth) {
          lastDepth = Number.MAX_SAFE_INTEGER;
        }

        // ignore collapsed folders
        if (collapsedFolders.has(fileOrFolder.fullPath)) {
          lastDepth = Math.min(lastDepth, depth);
        }

        // ignore files and folders below the last collapsed folder
        if (lastDepth < depth) {
          continue;
        }

        list.push(fileOrFolder);
      }

      return list;
    }, [fileList, collapsedFolders]);

    const toggleCollapseState = (fullPath: string) => {
      setCollapsedFolders((prevSet) => {
        const newSet = new Set(prevSet);

        if (newSet.has(fullPath)) {
          newSet.delete(fullPath);
        } else {
          newSet.add(fullPath);
        }

        return newSet;
      });
    };

    return (
      <div className={classNames('text-sm', className)}>
        {filteredFileList.map((fileOrFolder) => {
          switch (fileOrFolder.kind) {
            case 'file': {
              return (
                <File
                  key={fileOrFolder.id}
                  selected={selectedFile === fileOrFolder.fullPath}
                  file={fileOrFolder}
                  unsavedChanges={unsavedFiles?.has(fileOrFolder.fullPath)}
                  onClick={() => {
                    onFileSelect?.(fileOrFolder.fullPath);
                  }}
                />
              );
            }
            case 'folder': {
              return (
                <Folder
                  key={fileOrFolder.id}
                  folder={fileOrFolder}
                  selected={allowFolderSelection && selectedFile === fileOrFolder.fullPath}
                  collapsed={collapsedFolders.has(fileOrFolder.fullPath)}
                  onClick={() => {
                    toggleCollapseState(fileOrFolder.fullPath);
                  }}
                />
              );
            }
            default: {
              return undefined;
            }
          }
        })}
      </div>
    );
  },
);

export default FileTree;

interface FolderProps {
  folder: FolderNode;
  collapsed: boolean;
  selected?: boolean;
  onClick: () => void;
}

function Folder({ folder: { depth, name }, collapsed, selected = false, onClick }: FolderProps) {
  return (
    <NodeButton
      className={classNames('group', {
        'bg-transparent text-eitherway-elements-item-contentDefault hover:text-eitherway-elements-item-contentActive hover:bg-eitherway-elements-item-backgroundActive':
          !selected,
        'bg-eitherway-elements-item-backgroundAccent text-eitherway-elements-item-contentAccent': selected,
      })}
      depth={depth}
      iconClasses={classNames({
        'i-ph:caret-right scale-98': collapsed,
        'i-ph:caret-down scale-98': !collapsed,
      })}
      onClick={onClick}
    >
      {name}
    </NodeButton>
  );
}

interface FileProps {
  file: FileNode;
  selected: boolean;
  unsavedChanges?: boolean;
  onClick: () => void;
}

function File({ file: { depth, name }, onClick, selected, unsavedChanges = false }: FileProps) {
  return (
    <NodeButton
      className={classNames('group', {
        'bg-transparent hover:bg-eitherway-elements-item-backgroundActive text-eitherway-elements-item-contentDefault':
          !selected,
        'bg-eitherway-elements-item-backgroundAccent text-eitherway-elements-item-contentAccent': selected,
      })}
      depth={depth}
      iconClasses={classNames('i-ph:file-duotone scale-98', {
        'group-hover:text-eitherway-elements-item-contentActive': !selected,
      })}
      onClick={onClick}
    >
      <div
        className={classNames('flex items-center', {
          'group-hover:text-eitherway-elements-item-contentActive': !selected,
        })}
      >
        <div className="flex-1 truncate pr-2">{name}</div>
        {unsavedChanges && <span className="i-ph:circle-fill scale-68 shrink-0 text-orange-500" />}
      </div>
    </NodeButton>
  );
}

interface ButtonProps {
  depth: number;
  iconClasses: string;
  children: ReactNode;
  className?: string;
  onClick?: () => void;
}

function NodeButton({ depth, iconClasses, onClick, className, children }: ButtonProps) {
  return (
    <button
      className={classNames(
        'flex items-center gap-1.5 w-full pr-2 border-2 border-transparent text-faded py-0.5',
        className,
      )}
      style={{ paddingLeft: `${6 + depth * NODE_PADDING_LEFT}px` }}
      onClick={() => onClick?.()}
    >
      <div className={classNames('scale-120 shrink-0', iconClasses)}></div>
      <div className="truncate w-full text-left">{children}</div>
    </button>
  );
}

type Node = FileNode | FolderNode;

interface BaseNode {
  id: number;
  depth: number;
  name: string;
  fullPath: string;
}

interface FileNode extends BaseNode {
  kind: 'file';
}

interface FolderNode extends BaseNode {
  kind: 'folder';
}

function buildFileList(
  files: FileMap,
  rootFolder = '/',
  hideRoot: boolean,
  hiddenFiles: Array<string | RegExp>,
): Node[] {
  const folderPaths = new Set<string>();
  const fileList: Node[] = [];

  let defaultDepth = 0;

  if (rootFolder === '/' && !hideRoot) {
    defaultDepth = 1;
    fileList.push({ kind: 'folder', name: '/', depth: 0, id: 0, fullPath: '/' });
  }

  for (const [filePath, dirent] of Object.entries(files)) {
    const segments = filePath.split('/').filter((segment) => segment);
    const fileName = segments.at(-1);

    if (!fileName || isHiddenFile(filePath, fileName, hiddenFiles)) {
      continue;
    }

    let currentPath = '';

    let i = 0;
    let depth = 0;

    while (i < segments.length) {
      const name = segments[i];
      const fullPath = (currentPath += `/${name}`);

      if (!fullPath.startsWith(rootFolder) || (hideRoot && fullPath === rootFolder)) {
        i++;
        continue;
      }

      if (i === segments.length - 1 && dirent?.type === 'file') {
        fileList.push({
          kind: 'file',
          id: fileList.length,
          name,
          fullPath,
          depth: depth + defaultDepth,
        });
      } else if (!folderPaths.has(fullPath)) {
        folderPaths.add(fullPath);

        fileList.push({
          kind: 'folder',
          id: fileList.length,
          name,
          fullPath,
          depth: depth + defaultDepth,
        });
      }

      i++;
      depth++;
    }
  }

  return sortFileList(rootFolder, fileList, hideRoot);
}

function isHiddenFile(filePath: string, fileName: string, hiddenFiles: Array<string | RegExp>) {
  return hiddenFiles.some((pathOrRegex) => {
    if (typeof pathOrRegex === 'string') {
      return fileName === pathOrRegex;
    }

    return pathOrRegex.test(filePath);
  });
}

/**
 * Sorts the given list of nodes into a tree structure (still a flat list).
 *
 * This function organizes the nodes into a hierarchical structure based on their paths,
 * with folders appearing before files and all items sorted alphabetically within their level.
 *
 * @note This function mutates the given `nodeList` array for performance reasons.
 *
 * @param rootFolder - The path of the root folder to start the sorting from.
 * @param nodeList - The list of nodes to be sorted.
 *
 * @returns A new array of nodes sorted in depth-first order.
 */
function sortFileList(rootFolder: string, nodeList: Node[], hideRoot: boolean): Node[] {
  logger.trace('sortFileList');

  const nodeMap = new Map<string, Node>();
  const childrenMap = new Map<string, Node[]>();

  // pre-sort nodes by name and type
  nodeList.sort((a, b) => compareNodes(a, b));

  for (const node of nodeList) {
    nodeMap.set(node.fullPath, node);

    const parentPath = node.fullPath.slice(0, node.fullPath.lastIndexOf('/'));

    if (parentPath !== rootFolder.slice(0, rootFolder.lastIndexOf('/'))) {
      if (!childrenMap.has(parentPath)) {
        childrenMap.set(parentPath, []);
      }

      childrenMap.get(parentPath)?.push(node);
    }
  }

  const sortedList: Node[] = [];

  const depthFirstTraversal = (path: string): void => {
    const node = nodeMap.get(path);

    if (node) {
      sortedList.push(node);
    }

    const children = childrenMap.get(path);

    if (children) {
      for (const child of children) {
        if (child.kind === 'folder') {
          depthFirstTraversal(child.fullPath);
        } else {
          sortedList.push(child);
        }
      }
    }
  };

  if (hideRoot) {
    // if root is hidden, start traversal from its immediate children
    const rootChildren = childrenMap.get(rootFolder) || [];

    for (const child of rootChildren) {
      depthFirstTraversal(child.fullPath);
    }
  } else {
    depthFirstTraversal(rootFolder);
  }

  return sortedList;
}

function compareNodes(a: Node, b: Node): number {
  if (a.kind !== b.kind) {
    return a.kind === 'folder' ? -1 : 1;
  }

  return a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' });
}
</file>

<file path="packages/ui-frontend/app/config/api.ts">
/**
 * API Configuration
 * Determines the backend URL based on environment
 */

export function getBackendUrl(): string {
  if (typeof window === 'undefined') {
    // Server-side: use relative URLs
    return '';
  }

  // Client-side: check if we're on localhost development
  const isDevelopment = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';

  if (isDevelopment && window.location.port === '5173') {
    // Local development: frontend on 5173, backend on 3001
    return 'https://localhost:3001';
  }

  // Production or any other case: use relative URLs (nginx will proxy)
  return '';
}

export function getWebSocketUrl(): string {
  if (typeof window === 'undefined') {
    return 'wss://localhost:3001';
  }

  const isDevelopment = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';

  if (isDevelopment && window.location.port === '5173') {
    return 'wss://localhost:3001';
  }

  // Production: use current host with wss
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  return `${protocol}//${window.location.host}`;
}

export const BACKEND_URL = getBackendUrl();
export const WEBSOCKET_URL = getWebSocketUrl();
</file>

<file path="packages/ui-frontend/app/lib/client/preview-helpers.client.ts">
// Client-only helpers for the Preview host window
// Provides small utilities like window.applyColorChange to patch /styles.css

import { webcontainer } from '~/lib/webcontainer';

declare global {
  interface Window {
    applyColorChange?: (instruction: string) => Promise<void>;
  }
}

function extractHex(input: string): string | null {
  const m = input.match(/#([0-9a-fA-F]{3,8})/);
  return m ? `#${m[1]}` : null;
}

async function ensureStylesFile(): Promise<string> {
  const wc = await webcontainer;
  try {
    const content = await wc.fs.readFile('/styles.css', 'utf8');
    return content as unknown as string;
  } catch {
    const initial = ':root{\n  --color-primary: #10b981;\n  --accent: #10b981;\n}\n';
    await wc.fs.writeFile('/styles.css', initial);
    return initial;
  }
}

async function writeStyles(content: string) {
  const wc = await webcontainer;
  await wc.fs.writeFile('/styles.css', content);
}

async function applyColorChange(instruction: string) {
  const hex = extractHex(instruction);
  if (!hex) return;

  const current = await ensureStylesFile();
  const override = `\n:root{\n  --accent: ${hex};\n  --color-primary: ${hex};\n}\n`;
  const next = current.includes(override) ? current : current + override;
  await writeStyles(next);
}

// Register on window
if (typeof window !== 'undefined') {
  window.applyColorChange = applyColorChange;
}
</file>

<file path="packages/ui-frontend/app/lib/persistence/useChatHistory.ts">
import { useLoaderData, useNavigate } from '@remix-run/react';
import { useState, useEffect } from 'react';
import { atom } from 'nanostores';
import type { Message } from 'ai';
import { toast } from 'react-toastify';
import { workbenchStore } from '~/lib/stores/workbench';
import { getMessages, getNextId, getUrlId, openDatabase, setMessages } from './db';

export interface ChatHistoryItem {
  id: string;
  urlId?: string;
  description?: string;
  messages: Message[];
  timestamp: string;
}

const persistenceEnabled = !import.meta.env.VITE_DISABLE_PERSISTENCE;

let dbInstance: IDBDatabase | undefined;
const dbPromise = persistenceEnabled
  ? openDatabase().then((db) => {
      dbInstance = db;
      return db;
    })
  : Promise.resolve(undefined);

// Export for backward compatibility - will be undefined until promise resolves
export const db = dbInstance;
export const getDb = async () => {
  await dbPromise;
  return dbInstance;
};

export const chatId = atom<string | undefined>(undefined);
export const description = atom<string | undefined>(undefined);

export function useChatHistory() {
  const navigate = useNavigate();
  const { id: mixedId } = useLoaderData<{ id?: string }>();

  const [initialMessages, setInitialMessages] = useState<Message[]>([]);
  const [ready, setReady] = useState<boolean>(false);
  const [urlId, setUrlId] = useState<string | undefined>();

  useEffect(() => {
    dbPromise.then((db) => {
      if (!db) {
        setReady(true);

        if (persistenceEnabled) {
          // More helpful error message with actionable steps
          toast.info(
            'Chat history disabled. To enable:\n' +
              ' Exit private/incognito mode\n' +
              ' Allow site storage in browser settings\n' +
              ' Clear browser data if storage is full',
            {
              autoClose: 8000,
              closeOnClick: true,
            },
          );
        }

        return;
      }

      if (mixedId) {
        getMessages(db, mixedId)
          .then((storedMessages) => {
            if (storedMessages && storedMessages.messages.length > 0) {
              setInitialMessages(storedMessages.messages);
              setUrlId(storedMessages.urlId);
              description.set(storedMessages.description);
              chatId.set(storedMessages.id);
            } else {
              navigate(`/chat`, { replace: true });
            }

            setReady(true);
          })
          .catch((error) => {
            toast.error(error.message);
          });
      } else {
        setReady(true);
      }
    });
  }, []);

  return {
    ready: !mixedId || ready,
    initialMessages,
    storeMessageHistory: async (messages: Message[]) => {
      if (!dbInstance || messages.length === 0) {
        return;
      }

      const { firstArtifact } = workbenchStore;

      if (!urlId && firstArtifact?.id) {
        const urlId = await getUrlId(dbInstance, firstArtifact.id);

        navigateChat(urlId);
        setUrlId(urlId);
      }

      if (!description.get() && firstArtifact?.title) {
        description.set(firstArtifact?.title);
      }

      if (initialMessages.length === 0 && !chatId.get()) {
        const nextId = await getNextId(dbInstance);

        chatId.set(nextId);

        if (!urlId) {
          navigateChat(nextId);
        }
      }

      await setMessages(dbInstance, chatId.get() as string, messages, urlId, description.get());
    },
  };
}

function navigateChat(nextId: string) {
  /**
   * FIXME: Using the intended navigate function causes a rerender for <Chat /> that breaks the app.
   *
   * `navigate(`/chat/${nextId}`, { replace: true });`
   */
  const url = new URL(window.location.href);
  url.pathname = `/chat/${nextId}`;

  window.history.replaceState({}, '', url);
}
</file>

<file path="packages/ui-frontend/app/lib/runtime/style-preserver.ts">
type VarMap = Record<string, string>;

function extractRootVars(css: string): VarMap {
  const vars: VarMap = {};
  const match = css.match(/:root\s*{([\s\S]*?)}/);
  if (!match) return vars;
  const body = match[1];
  const rx = /--([a-zA-Z0-9_-]+)\s*:\s*([^;]+);/g;
  let m: RegExpExecArray | null;
  while ((m = rx.exec(body)) !== null) {
    vars[m[1]] = m[2].trim();
  }
  return vars;
}

function buildRoot(vars: VarMap): string {
  const lines = Object.entries(vars).map(([k, v]) => `  --${k}: ${v};`);
  return `:root {\n${lines.join('\n')}\n}\n`;
}

function replaceRoot(css: string, newRoot: string): string {
  if (/:root\s*{/.test(css)) {
    return css.replace(/:root\s*{[\s\S]*?}\s*/m, newRoot);
  }
  return `${newRoot}\n${css}`;
}

export function mergeStylesCss(
  incomingCss: string,
  existingCss: string,
  lockedColors: VarMap,
): { css: string; updatedLock?: VarMap; explicitStyleChange: boolean } {
  const inVars = extractRootVars(incomingCss);
  const inColorKeys = Object.keys(inVars).filter((k) => k.startsWith('color-'));
  const lockHas = Object.keys(lockedColors || {}).length > 0;

  let explicitStyleChange = false;
  let merged: VarMap = { ...inVars };

  if (!lockHas) {
    // First post-build modify: adopt incoming colors as the user's theme.
    const initialColors: VarMap = {};
    for (const k of inColorKeys) initialColors[k] = inVars[k];
    return {
      css: replaceRoot(incomingCss, buildRoot(merged)),
      updatedLock: initialColors,
      explicitStyleChange: true,
    };
  }

  // Heuristic: if most color vars changed from lock, treat as explicit theme change
  const total = inColorKeys.length || 1;
  const changed = inColorKeys.filter((k) => lockedColors[k] && lockedColors[k] !== inVars[k]).length;
  explicitStyleChange = changed / total >= 0.6;

  if (!explicitStyleChange) {
    // Preserve locked colors
    for (const k of Object.keys(lockedColors)) {
      if (k.startsWith('color-')) {
        merged[k] = lockedColors[k];
      }
    }
    // Ensure any locked color missing in incoming is re-introduced
    for (const k of Object.keys(lockedColors)) {
      if (k.startsWith('color-') && !(k in merged)) merged[k] = lockedColors[k];
    }
    return {
      css: replaceRoot(incomingCss, buildRoot(merged)),
      explicitStyleChange: false,
    };
  }

  // Explicit change: accept incoming colors and refresh lock
  const newLock: VarMap = {};
  for (const k of inColorKeys) newLock[k] = inVars[k];
  return {
    css: replaceRoot(incomingCss, buildRoot(merged)),
    updatedLock: newLock,
    explicitStyleChange: true,
  };
}
</file>

<file path="packages/ui-frontend/app/lib/services/portfolio-pipeline.ts">
import { createScopedLogger } from '~/utils/logger';

const logger = createScopedLogger('PortfolioPipeline');

export interface Holding {
  chainId: number;
  tokenAddress: `0x${string}` | 'native';
  symbol: string;
  decimals: number;
  balanceRaw: string;
  balance: number;
  priceUsd?: number;
  valueUsd: number;
  sources: string[];
  priceSource?: string;
  confidence: number;
  timestamp: number;
}

export interface PortfolioResult {
  totalUsd: number;
  holdings: Holding[];
  confidence: 'high' | 'medium' | 'low' | 'none';
  provenance: ProvenanceData;
  isDemo: boolean;
}

export interface ProvenanceData {
  sources: string[];
  timestamp: number;
  cacheSources: string[];
  fallbacks: string[];
  errors: string[];
  demo: boolean;
  confidenceReason: string;
}

export class PortfolioPipeline {
  private isDemoMode: boolean;
  private confidenceThreshold = 0.5;

  constructor() {
    this.isDemoMode = this.checkDemoMode();
  }

  private checkDemoMode(): boolean {
    const envDemoMode = process.env.DEMO_MODE === 'true';
    const hasRequiredKeys = Boolean(
      process.env.WALLETCONNECT_PROJECT_ID && process.env.WALLETCONNECT_PROJECT_ID !== 'your-project-id-here',
    );

    if (envDemoMode) {
      logger.info('Demo mode explicitly enabled via DEMO_MODE=true');
      return true;
    }

    if (!hasRequiredKeys && process.env.DEMO_MODE !== 'false') {
      logger.warn('No API keys configured and DEMO_MODE not explicitly false - demo disabled');
      return false;
    }

    return false;
  }

  async computePortfolio(addresses: string[]): Promise<PortfolioResult> {
    const provenance: ProvenanceData = {
      sources: [],
      timestamp: Date.now(),
      cacheSources: [],
      fallbacks: [],
      errors: [],
      demo: false,
      confidenceReason: '',
    };

    if (!addresses?.length || addresses.every((addr) => !addr)) {
      logger.info('No addresses provided, returning empty portfolio');
      return this.emptyPortfolio('no-addresses', provenance);
    }

    if (this.isDemoMode) {
      logger.info('Demo mode active, returning demo portfolio');
      provenance.demo = true;
      return this.getDemoPortfolio(provenance);
    }

    try {
      const rawHoldings = await this.collectHoldingsFromProviders(addresses, provenance);

      if (!rawHoldings.length) {
        logger.info('No holdings found for addresses, returning empty portfolio');
        return this.emptyPortfolio('no-holdings', provenance);
      }

      const pricedHoldings = await this.attachPrices(rawHoldings, provenance);

      const valuedHoldings = pricedHoldings.map((h) => ({
        ...h,
        valueUsd: h.confidence >= this.confidenceThreshold && h.priceUsd ? h.priceUsd * h.balance : 0,
      }));

      const totalUsd = valuedHoldings.reduce((sum, h) => {
        if (h.confidence >= this.confidenceThreshold && h.valueUsd > 0) {
          return sum + h.valueUsd;
        }
        return sum;
      }, 0);

      const overallConfidence = this.calculateOverallConfidence(valuedHoldings);
      provenance.confidenceReason = this.getConfidenceReason(overallConfidence, valuedHoldings);

      return {
        totalUsd,
        holdings: valuedHoldings,
        confidence: overallConfidence,
        provenance,
        isDemo: false,
      };
    } catch (error) {
      logger.error('Portfolio computation failed:', error);
      provenance.errors.push(error instanceof Error ? error.message : 'Unknown error');

      if (process.env.ALLOW_FALLBACK_ON_ERROR === 'true') {
        logger.warn('Falling back to demo due to error and ALLOW_FALLBACK_ON_ERROR=true');
        provenance.demo = true;
        return this.getDemoPortfolio(provenance);
      }

      return this.emptyPortfolio('error', provenance);
    }
  }

  private async collectHoldingsFromProviders(addresses: string[], provenance: ProvenanceData): Promise<Holding[]> {
    const holdings: Map<string, Holding> = new Map();
    const providers = this.getAvailableProviders();

    for (const provider of providers) {
      try {
        const providerHoldings = await this.fetchFromProvider(provider, addresses);
        provenance.sources.push(provider);

        for (const holding of providerHoldings) {
          const key = `${holding.chainId}:${holding.tokenAddress}`;
          const existing = holdings.get(key);

          if (!existing) {
            holdings.set(key, holding);
          } else {
            existing.sources = [...new Set([...existing.sources, ...holding.sources])];
            existing.confidence = Math.min(1, existing.confidence + 0.1);
          }
        }
      } catch (error) {
        logger.warn(`Provider ${provider} failed:`, error);
        provenance.errors.push(`${provider}: ${error instanceof Error ? error.message : 'failed'}`);
      }
    }

    return Array.from(holdings.values());
  }

  private async attachPrices(holdings: Holding[], provenance: ProvenanceData): Promise<Holding[]> {
    const priceService = await import('./price-pipeline').then((m) => new m.PricePipeline());

    return Promise.all(
      holdings.map(async (holding) => {
        const priceResult = await priceService.getPrice(
          holding.chainId,
          holding.tokenAddress === 'native' ? 'native' : holding.tokenAddress,
        );

        if (priceResult) {
          provenance.sources.push(`price:${priceResult.source}`);
          return {
            ...holding,
            priceUsd: priceResult.value,
            priceSource: priceResult.source,
            confidence: Math.min(1, holding.confidence + priceResult.confidence * 0.3),
          };
        }

        logger.debug(`No price found for ${holding.symbol} on chain ${holding.chainId}`);
        return {
          ...holding,
          priceUsd: undefined,
          confidence: Math.max(0, holding.confidence - 0.3),
        };
      }),
    );
  }

  private getAvailableProviders(): string[] {
    const providers: string[] = [];

    if (process.env.ALCHEMY_API_KEY) providers.push('alchemy');
    if (process.env.COVALENT_API_KEY) providers.push('covalent');
    if (process.env.MORALIS_API_KEY) providers.push('moralis');
    if (process.env.QUICKNODE_ENDPOINT) providers.push('quicknode');
    if (process.env.BITQUERY_API_KEY) providers.push('bitquery');

    if (!providers.length) {
      logger.warn('No portfolio providers configured');
    }

    return providers;
  }

  private async fetchFromProvider(provider: string, addresses: string[]): Promise<Holding[]> {
    switch (provider) {
      case 'alchemy':
        return this.fetchFromAlchemy(addresses);
      case 'covalent':
        return this.fetchFromCovalent(addresses);
      case 'moralis':
        return this.fetchFromMoralis(addresses);
      default:
        throw new Error(`Unknown provider: ${provider}`);
    }
  }

  private async fetchFromAlchemy(addresses: string[]): Promise<Holding[]> {
    const holdings: Holding[] = [];

    for (const address of addresses) {
      const mockBalance: Holding = {
        chainId: 1,
        tokenAddress: 'native',
        symbol: 'ETH',
        decimals: 18,
        balanceRaw: '0',
        balance: 0,
        valueUsd: 0,
        sources: ['alchemy'],
        confidence: 0.7,
        timestamp: Date.now(),
      };
      holdings.push(mockBalance);
    }

    return holdings;
  }

  private async fetchFromCovalent(addresses: string[]): Promise<Holding[]> {
    return [];
  }

  private async fetchFromMoralis(addresses: string[]): Promise<Holding[]> {
    return [];
  }

  private calculateOverallConfidence(holdings: Holding[]): 'high' | 'medium' | 'low' | 'none' {
    if (!holdings.length) return 'none';

    const avgConfidence = holdings.reduce((sum, h) => sum + h.confidence, 0) / holdings.length;

    if (avgConfidence >= 0.7) return 'high';
    if (avgConfidence >= 0.4) return 'medium';
    if (avgConfidence > 0) return 'low';
    return 'none';
  }

  private getConfidenceReason(confidence: 'high' | 'medium' | 'low' | 'none', holdings: Holding[]): string {
    switch (confidence) {
      case 'high':
        return `Multiple sources confirmed ${holdings.length} holdings`;
      case 'medium':
        return `Single source data for ${holdings.length} holdings`;
      case 'low':
        return 'Limited data available, some prices missing';
      case 'none':
        return 'No reliable data available';
    }
  }

  private emptyPortfolio(reason: string, provenance: ProvenanceData): PortfolioResult {
    provenance.confidenceReason = `Empty portfolio: ${reason}`;
    return {
      totalUsd: 0,
      holdings: [],
      confidence: 'none',
      provenance,
      isDemo: false,
    };
  }

  private getDemoPortfolio(provenance: ProvenanceData): PortfolioResult {
    provenance.demo = true;
    provenance.sources.push('demo-generator');
    provenance.confidenceReason = 'Demo data - not real values';

    const demoHoldings: Holding[] = [
      {
        chainId: 1,
        tokenAddress: 'native',
        symbol: 'ETH',
        decimals: 18,
        balanceRaw: '2500000000000000000',
        balance: 2.5,
        priceUsd: 1850.25,
        valueUsd: 4625.625,
        sources: ['demo'],
        priceSource: 'demo',
        confidence: 0.1,
        timestamp: Date.now(),
      },
      {
        chainId: 1,
        tokenAddress: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
        symbol: 'USDC',
        decimals: 6,
        balanceRaw: '1250000000',
        balance: 1250,
        priceUsd: 1.0,
        valueUsd: 1250,
        sources: ['demo'],
        priceSource: 'demo',
        confidence: 0.1,
        timestamp: Date.now(),
      },
    ];

    return {
      totalUsd: demoHoldings.reduce((sum, h) => sum + h.valueUsd, 0),
      holdings: demoHoldings,
      confidence: 'none',
      provenance,
      isDemo: true,
    };
  }
}
</file>

<file path="packages/ui-frontend/app/lib/stores/artifact-validator.ts">
import { createScopedLogger } from '~/utils/logger';
import type { FileMap } from './files';

const logger = createScopedLogger('ArtifactValidator');

export interface ValidationResult {
  success: boolean;
  errors: string[];
  warnings: string[];
}

export interface PageManifest {
  pages: Array<{ slug: string; title: string; route: string }>;
  router: 'mpa' | 'spa';
  features: string[];
}

export class ArtifactValidator {
  validateGeneratedArtifact(files: FileMap, manifest?: PageManifest): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!files['index.html'] && !files['/index.html']) {
      errors.push('Missing required index.html file');
    }

    const indexFile = files['index.html'] || files['/index.html'];
    if (indexFile?.type === 'file') {
      const content = indexFile.content;

      if (content.includes('<style>') && content.includes('</style>')) {
        errors.push('Found inline <style> tags in HTML - all styles must be in styles.css');
      }

      if (
        !content.includes('<link rel="stylesheet" href="/styles.css">') &&
        !content.includes('<link rel="stylesheet" href="styles.css">') &&
        !content.includes('<link rel="stylesheet" href="./styles.css">')
      ) {
        warnings.push('index.html does not link to styles.css');
      }
    }

    if (!files['styles.css'] && !files['/styles.css']) {
      errors.push('Missing required styles.css file');
    }

    const stylesFile = files['styles.css'] || files['/styles.css'];
    if (stylesFile?.type === 'file') {
      const content = stylesFile.content;
      if (!content.includes(':root')) {
        warnings.push('styles.css missing :root CSS variables');
      }
    }

    if (manifest) {
      this.validateManifest(files, manifest, errors, warnings);
    }

    const htmlFiles = Object.keys(files).filter((path) => path.endsWith('.html') && files[path]?.type === 'file');

    for (const htmlPath of htmlFiles) {
      const htmlFile = files[htmlPath];
      if (htmlFile?.type === 'file') {
        this.validateHtmlFile(htmlPath, htmlFile.content, errors, warnings);
      }
    }

    const success = errors.length === 0;

    if (errors.length > 0) {
      logger.error('Validation failed:', errors);
    }

    if (warnings.length > 0) {
      logger.warn('Validation warnings:', warnings);
    }

    return { success, errors, warnings };
  }

  private validateManifest(files: FileMap, manifest: PageManifest, errors: string[], warnings: string[]): void {
    if (manifest.router === 'mpa') {
      for (const page of manifest.pages) {
        if (page.slug === 'index') continue;

        const expectedPaths = [`/pages/${page.slug}.html`, `pages/${page.slug}.html`];

        const exists = expectedPaths.some((path) => files[path]?.type === 'file');
        if (!exists) {
          errors.push(`Missing page file for route: ${page.route} (expected /pages/${page.slug}.html)`);
        }
      }
    }

    if (!files['/scripts/nav.js'] && !files['scripts/nav.js'] && manifest.pages.length > 1) {
      warnings.push('Multi-page app missing navigation script (scripts/nav.js)');
    }
  }

  private validateHtmlFile(path: string, content: string, errors: string[], warnings: string[]): void {
    const hasStyleTags = /<style[^>]*>[\s\S]*?<\/style>/i.test(content);
    if (hasStyleTags) {
      errors.push(`${path}: Contains inline <style> tags - move to styles.css`);
    }

    const linkRegex = /<a\s+[^>]*href=["']([^"']+)["'][^>]*>/gi;
    let match;
    while ((match = linkRegex.exec(content)) !== null) {
      const href = match[1];
      if (href.startsWith('#') || href.startsWith('http') || href.startsWith('//')) {
        continue;
      }

      if (href.includes('{{') || href.includes('${')) {
        continue;
      }
    }

    const hasDataPattern = /data-pattern=["'][^"']+["']/i.test(content);
    if (path === 'index.html' || path === '/index.html') {
      if (!hasDataPattern) {
        warnings.push('index.html missing data-pattern attribute on <html> element');
      }
    }
  }

  validateWalletConnection(files: FileMap): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    const hasEnvExample = files['.env.example'] || files['/.env.example'];
    if (!hasEnvExample) {
      errors.push('Missing .env.example file for Web3 configuration');
    } else if (hasEnvExample.type === 'file') {
      const content = hasEnvExample.content;
      if (!content.includes('WALLETCONNECT_PROJECT_ID')) {
        errors.push('.env.example missing WALLETCONNECT_PROJECT_ID');
      }
      if (!content.includes('RPC_URL')) {
        warnings.push('.env.example missing RPC_URL configuration');
      }
    }

    const jsFiles = Object.keys(files).filter(
      (path) => (path.endsWith('.js') || path.endsWith('.ts')) && files[path]?.type === 'file',
    );

    let hasWalletConnect = false;
    for (const jsPath of jsFiles) {
      const jsFile = files[jsPath];
      if (jsFile?.type === 'file') {
        const content = jsFile.content;
        if (content.includes('createAppKit') || content.includes('wagmi') || content.includes('WalletConnect')) {
          hasWalletConnect = true;

          if (content.includes('Math.random()') && (content.includes('walletAddress') || content.includes('0x'))) {
            errors.push(`${jsPath}: Using Math.random() for wallet addresses - use real wallet connection`);
          }
        }
      }
    }

    const success = errors.length === 0;
    return { success, errors, warnings };
  }

  validateChangeSet(
    changeSet: { operations: Array<{ kind: string; path: string }> },
    intent: 'MODIFY' | 'CREATE' | 'REWRITE',
  ): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    const criticalFiles = new Set([
      'index.html',
      '/index.html',
      'main.js',
      '/main.js',
      'styles.css',
      '/styles.css',
      'base.css',
      '/base.css',
    ]);

    if (intent === 'MODIFY') {
      const recreatedFiles = changeSet.operations.filter((op) => op.kind === 'create' && criticalFiles.has(op.path));

      if (recreatedFiles.length > 0) {
        errors.push(
          `Refusing to recreate existing critical files during MODIFY: ${recreatedFiles.map((f) => f.path).join(', ')}`,
        );
      }
    }

    const touchedCss = changeSet.operations.some(
      (op) => op.path.endsWith('.css') && (op.kind === 'modify' || op.kind === 'create'),
    );

    if (touchedCss && !this.changedCssVariables(changeSet)) {
      warnings.push('CSS changed but no theme tokens updated - use :root CSS variables');
    }

    const success = errors.length === 0;
    return { success, errors, warnings };
  }

  private changedCssVariables(changeSet: any): boolean {
    return true;
  }

  validateDataCorrectness(portfolioData: any, isDemoMode: boolean): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!isDemoMode && portfolioData.totalUsd > 0 && !portfolioData.holdings?.length) {
      errors.push('Portfolio shows positive value but no holdings - data integrity issue');
    }

    if (!isDemoMode && portfolioData.isDemo) {
      errors.push('Demo data being used without DEMO_MODE=true flag');
    }

    if (portfolioData.holdings) {
      for (const holding of portfolioData.holdings) {
        if (!holding.priceUsd && holding.valueUsd > 0) {
          errors.push(`Holding ${holding.symbol} has value but no price - invalid calculation`);
        }

        if (holding.confidence < 0.5 && holding.valueUsd > 0) {
          warnings.push(`Low confidence data for ${holding.symbol} being included in total`);
        }

        if (!holding.sources || holding.sources.length === 0) {
          errors.push(`Holding ${holding.symbol} has no data sources - provenance missing`);
        }
      }
    }

    if (portfolioData.provenance?.demo && !isDemoMode) {
      errors.push('Provenance indicates demo data but demo mode not enabled');
    }

    const success = errors.length === 0;
    return { success, errors, warnings };
  }

  validateStyleChanges(originalCss: string, modifiedCss: string, changeRequest: string): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    const requestedColorChange = /change|set|update|color/i.test(changeRequest);

    if (requestedColorChange) {
      const originalVars = this.extractCssVariables(originalCss);
      const modifiedVars = this.extractCssVariables(modifiedCss);

      const changedVars = Object.keys(modifiedVars).filter((key) => originalVars[key] !== modifiedVars[key]);

      if (changedVars.length === 0) {
        errors.push('Color change requested but no CSS variables were modified');
      }

      const nonColorVarsChanged = changedVars.filter(
        (v) => !v.includes('color') && !v.includes('bg') && !v.includes('text') && !v.includes('accent'),
      );

      if (nonColorVarsChanged.length > 0) {
        warnings.push(`Non-color variables modified: ${nonColorVarsChanged.join(', ')}`);
      }
    }

    const success = errors.length === 0;
    return { success, errors, warnings };
  }

  private extractCssVariables(css: string): Record<string, string> {
    const vars: Record<string, string> = {};
    const rootMatch = css.match(/:root\s*{([^}]*)}/s);

    if (rootMatch) {
      const varRegex = /(--[a-zA-Z0-9-]+)\s*:\s*([^;]+);/g;
      let match;
      while ((match = varRegex.exec(rootMatch[1])) !== null) {
        vars[match[1]] = match[2].trim();
      }
    }

    return vars;
  }
}

export const artifactValidator = new ArtifactValidator();
</file>

<file path="packages/ui-frontend/app/lib/stores/chat.ts">
import { map } from 'nanostores';

export type StreamingPhase = 'pending' | 'thinking' | 'reasoning' | 'code-writing' | 'building' | 'completed' | null;

export const chatStore = map<{
  started: boolean;
  aborted: boolean;
  showChat: boolean;
  currentPhase: StreamingPhase;
  sessionId: string | null;
}>({
  started: false,
  aborted: false,
  showChat: true,
  currentPhase: null,
  sessionId: null,
});
</file>

<file path="packages/ui-frontend/app/lib/stores/previews.ts">
import type { WebContainer } from '@webcontainer/api';
import { atom } from 'nanostores';
import { createScopedLogger } from '~/utils/logger';

const logger = createScopedLogger('PreviewsStore');

export interface PreviewInfo {
  port: number;
  ready: boolean;
  baseUrl: string;
}

export class PreviewsStore {
  #availablePreviews = new Map<number, PreviewInfo>();
  #webcontainer: Promise<WebContainer>;

  previews = atom<PreviewInfo[]>([]);

  constructor(webcontainerPromise: Promise<WebContainer>) {
    this.#webcontainer = webcontainerPromise;

    this.#init();
  }

  async #init() {
    const webcontainer = await this.#webcontainer;

    webcontainer.on('port', (port, type, url) => {
      logger.info(`Port event received - Port: ${port}, Type: ${type}, URL: ${url}`);

      let previewInfo = this.#availablePreviews.get(port);

      if (type === 'close' && previewInfo) {
        this.#availablePreviews.delete(port);
        this.previews.set(this.previews.get().filter((preview) => preview.port !== port));
        logger.debug(`Port ${port} closed`);
        return;
      }

      const previews = this.previews.get();

      if (!previewInfo) {
        // Use the URL provided by WebContainer as-is
        // WebContainer provides the correct URL for the environment
        previewInfo = { port, ready: type === 'open', baseUrl: url };
        this.#availablePreviews.set(port, previewInfo);
        previews.push(previewInfo);
        logger.info(`Preview registered - Port: ${port}, URL: ${url}`);
      } else {
        previewInfo.ready = type === 'open';
        previewInfo.baseUrl = url;
      }

      if (type === 'open') {
        logger.info(` Dev server ready at: ${url}`);
      }

      this.previews.set([...previews]);
    });
  }

  /**
   * Manually register a preview (fallback for when port event doesn't fire)
   */
  registerPreview(port: number, url: string) {
    const previews = this.previews.get();
    let previewInfo = this.#availablePreviews.get(port);

    if (!previewInfo) {
      previewInfo = { port, ready: true, baseUrl: url };
      this.#availablePreviews.set(port, previewInfo);
      previews.push(previewInfo);
      this.previews.set([...previews]);
      logger.info(` Manually registered preview - Port: ${port}, URL: ${url}`);
    } else {
      logger.debug(`Preview already registered for port ${port}`);
    }
  }
}
</file>

<file path="packages/ui-frontend/app/lib/templates/button-utilities-enhanced.js">
/**
 * Enhanced Universal Button Utilities - Fixes dropdown positioning and footer button issues
 * Automatically included in all generated apps
 */

// Initialize on DOM load and setup mutation observer
if (typeof document !== 'undefined') {
  document.addEventListener('DOMContentLoaded', initializeButtonUtilities);
  // Also run after a short delay to catch any delayed renders
  setTimeout(initializeButtonUtilities, 1000);
}

function initializeButtonUtilities() {
  // Initialize all systems
  attachDefaultHandlers();
  createFeedbackContainer();
  setupNavigationHandling();
  fixDropdownPositioning();
  setupMutationObserver();
  createFeedbackStyles();
}

// ===========================================
// ENHANCED DROPDOWN POSITIONING FIX
// ===========================================
function fixDropdownPositioning() {
  // Fix all select elements and custom dropdowns
  const selects = document.querySelectorAll('select, .dropdown, .select-wrapper, [data-dropdown]');

  selects.forEach((element) => {
    const parent = element.parentElement;

    // Ensure parent has proper positioning context
    if (parent && getComputedStyle(parent).position === 'static') {
      parent.style.position = 'relative';
    }

    // Fix custom dropdown menus
    const dropdownMenu = element.querySelector('.dropdown-menu, .dropdown-content, .options, .select-options');
    if (dropdownMenu) {
      dropdownMenu.style.position = 'absolute';
      dropdownMenu.style.zIndex = '9999';
      dropdownMenu.style.top = '100%';
      dropdownMenu.style.left = '0';
      dropdownMenu.style.minWidth = '100%';

      // Ensure dropdown appears on top
      element.style.position = 'relative';
      element.style.zIndex = '100';
    }
  });

  // Add global click handler for custom dropdowns
  document.addEventListener('click', (e) => {
    const dropdown = e.target.closest('.dropdown, .select-wrapper, [data-dropdown]');

    if (dropdown) {
      e.stopPropagation();
      const menu = dropdown.querySelector('.dropdown-menu, .dropdown-content, .options, .select-options');

      if (menu) {
        const isOpen = menu.style.display === 'block';

        // Close all other dropdowns
        document.querySelectorAll('.dropdown-menu, .dropdown-content, .options, .select-options').forEach((m) => {
          if (m !== menu) m.style.display = 'none';
        });

        // Toggle current dropdown
        menu.style.display = isOpen ? 'none' : 'block';

        // Ensure dropdown is visible in viewport
        if (!isOpen) {
          const rect = menu.getBoundingClientRect();
          const viewportHeight = window.innerHeight;

          if (rect.bottom > viewportHeight) {
            menu.style.bottom = '100%';
            menu.style.top = 'auto';
          } else {
            menu.style.top = '100%';
            menu.style.bottom = 'auto';
          }
        }
      }
    } else {
      // Close all dropdowns when clicking outside
      document.querySelectorAll('.dropdown-menu, .dropdown-content, .options, .select-options').forEach((m) => {
        m.style.display = 'none';
      });
    }
  });
}

// ===========================================
// MUTATION OBSERVER FOR DYNAMIC ELEMENTS
// ===========================================
function setupMutationObserver() {
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.type === 'childList') {
        mutation.addedNodes.forEach((node) => {
          if (node.nodeType === 1) {
            // Element node
            // Re-run handlers for new elements
            setTimeout(() => {
              attachDefaultHandlers();
              fixDropdownPositioning();
            }, 100);
          }
        });
      }
    });
  });

  observer.observe(document.body, {
    childList: true,
    subtree: true,
  });
}

// ===========================================
// ENHANCED DEFAULT BUTTON HANDLERS
// ===========================================
function attachDefaultHandlers() {
  // Handle ALL buttons, including those with empty onclick
  const buttons = document.querySelectorAll(
    'button, a[href="#"], a[href=""], a:not([href]), [role="button"], .btn, .button',
  );

  buttons.forEach((element) => {
    // Skip if element already has a real handler
    if (element.onclick && element.onclick.toString().includes('function')) {
      return;
    }

    const text = element.textContent?.toLowerCase() || '';
    const href = element.getAttribute('href')?.toLowerCase() || '';
    const className = element.className?.toLowerCase() || '';
    const id = element.id?.toLowerCase() || '';

    // Footer & Social Media buttons
    if (text.includes('twitter') || className.includes('twitter') || href.includes('twitter')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Opening Twitter...', 'info');
        window.open('https://twitter.com', '_blank');
      };
    } else if (text.includes('facebook') || className.includes('facebook') || href.includes('facebook')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Opening Facebook...', 'info');
        window.open('https://facebook.com', '_blank');
      };
    } else if (text.includes('linkedin') || className.includes('linkedin') || href.includes('linkedin')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Opening LinkedIn...', 'info');
        window.open('https://linkedin.com', '_blank');
      };
    } else if (text.includes('instagram') || className.includes('instagram') || href.includes('instagram')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Opening Instagram...', 'info');
        window.open('https://instagram.com', '_blank');
      };
    } else if (text.includes('github') || className.includes('github') || href.includes('github')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Opening GitHub...', 'info');
        window.open('https://github.com', '_blank');
      };
    } else if (text.includes('youtube') || className.includes('youtube') || href.includes('youtube')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Opening YouTube...', 'info');
        window.open('https://youtube.com', '_blank');
      };
    }
    // Footer navigation links
    else if (text.includes('privacy') || text.includes('policy')) {
      element.onclick = (e) => {
        e.preventDefault();
        showModal({
          title: 'Privacy Policy',
          content:
            '<p>Your privacy is important to us. This application does not collect any personal data.</p><p>All data is stored locally in your browser.</p>',
        });
      };
    } else if (text.includes('terms') || text.includes('service')) {
      element.onclick = (e) => {
        e.preventDefault();
        showModal({
          title: 'Terms of Service',
          content:
            '<p>By using this application, you agree to use it responsibly.</p><p>This is a demo application for educational purposes.</p>',
        });
      };
    } else if (text.includes('contact')) {
      element.onclick = (e) => {
        e.preventDefault();
        showModal({
          title: 'Contact Us',
          content: `
            <form>
              <div class="form-group">
                <label>Email</label>
                <input type="email" class="input" placeholder="your@email.com" />
              </div>
              <div class="form-group">
                <label>Message</label>
                <textarea class="input" rows="4" placeholder="Your message..."></textarea>
              </div>
            </form>
          `,
          footer:
            "<button class=\"btn btn-primary\" onclick=\"showToast('Message sent!', 'success'); closeModal(this.closest('.modal-overlay').id)\">Send</button>",
        });
      };
    } else if (text.includes('about')) {
      element.onclick = (e) => {
        e.preventDefault();
        navigateTo('about');
      };
    }
    // Navigation buttons
    else if (text.includes('home')) {
      element.onclick = (e) => {
        e.preventDefault();
        navigateTo('home');
      };
    } else if (text.includes('profile')) {
      element.onclick = (e) => {
        e.preventDefault();
        navigateTo('profile');
      };
    } else if (text.includes('settings')) {
      element.onclick = (e) => {
        e.preventDefault();
        navigateTo('settings');
      };
    } else if (text.includes('dashboard')) {
      element.onclick = (e) => {
        e.preventDefault();
        navigateTo('dashboard');
      };
    }
    // Action buttons
    else if (text.includes('save')) {
      element.onclick = (e) => {
        e.preventDefault();
        handleSaveAction(element);
      };
    } else if (text.includes('delete')) {
      element.onclick = (e) => {
        e.preventDefault();
        handleDeleteAction(element);
      };
    } else if (text.includes('edit')) {
      element.onclick = (e) => {
        e.preventDefault();
        handleEditAction(element);
      };
    } else if (text.includes('create') || text.includes('add') || text.includes('new')) {
      element.onclick = (e) => {
        e.preventDefault();
        handleCreateAction(element);
      };
    } else if (text.includes('submit') || text.includes('send')) {
      element.onclick = (e) => {
        e.preventDefault();
        handleFormSubmit(element);
      };
    } else if (text.includes('cancel') || text.includes('close')) {
      element.onclick = (e) => {
        e.preventDefault();
        handleCancelAction(element);
      };
    } else if (text.includes('download')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Download starting...', 'info');
      };
    } else if (text.includes('upload')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Opening file selector...', 'info');
      };
    } else if (text.includes('share')) {
      element.onclick = (e) => {
        e.preventDefault();
        handleShareAction(element);
      };
    } else if (text.includes('like') || className.includes('like')) {
      element.onclick = (e) => {
        e.preventDefault();
        handleLikeAction(element);
      };
    } else if (text.includes('follow')) {
      element.onclick = (e) => {
        e.preventDefault();
        handleFollowAction(element);
      };
    } else if (text.includes('subscribe')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Subscribed successfully!', 'success');
        if (element.tagName === 'BUTTON') {
          element.textContent = 'Subscribed';
          element.disabled = true;
        }
      };
    }
    // Default handler for any other clickable element
    else if (!element.onclick) {
      element.onclick = (e) => {
        e.preventDefault();
        const displayText = element.textContent.trim() || 'Button';
        showToast(`"${displayText}" clicked`, 'info');
        // Add visual feedback
        element.style.transform = 'scale(0.95)';
        setTimeout(() => (element.style.transform = ''), 100);
      };
    }
  });

  // Also handle clickable divs and spans
  document.querySelectorAll('[onclick=""], .clickable, .card, .item').forEach((element) => {
    if (!element.onclick || element.onclick.toString() === 'function onclick(event) {\n\n}') {
      element.style.cursor = 'pointer';
      element.onclick = () => {
        showToast('Item clicked', 'info');
        element.style.transform = 'scale(0.98)';
        setTimeout(() => (element.style.transform = ''), 100);
      };
    }
  });
}

// ===========================================
// ENHANCED FEEDBACK STYLES
// ===========================================
function createFeedbackStyles() {
  if (document.getElementById('buttonUtilStyles')) return;

  const style = document.createElement('style');
  style.id = 'buttonUtilStyles';
  style.textContent = `
    /* Enhanced Dropdown Positioning Fixes */
    .dropdown, .select-wrapper, [data-dropdown] {
      position: relative !important;
    }

    .dropdown-menu, .dropdown-content, .options, .select-options {
      position: absolute !important;
      z-index: 9999 !important;
      background: var(--color-surface, #fff) !important;
      border: 1px solid var(--color-border, #ddd) !important;
      border-radius: 8px !important;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
      max-height: 300px !important;
      overflow-y: auto !important;
      display: none;
    }

    .dropdown-menu.show, .dropdown-content.show, .options.show, .select-options.show {
      display: block !important;
    }

    /* Ensure dropdowns appear above other content */
    .dropdown:focus-within {
      z-index: 1000 !important;
    }

    /* Fix select element styling */
    select {
      position: relative !important;
      z-index: 1 !important;
      background: var(--color-surface, #fff) !important;
      cursor: pointer !important;
    }

    /* Footer link styling */
    footer a, .footer a {
      cursor: pointer !important;
      transition: opacity 0.2s !important;
    }

    footer a:hover, .footer a:hover {
      opacity: 0.8 !important;
    }

    /* Clickable element feedback */
    [role="button"], .btn, .button, .clickable {
      cursor: pointer !important;
      transition: transform 0.1s ease !important;
    }

    [role="button"]:active, .btn:active, .button:active, .clickable:active {
      transform: scale(0.95) !important;
    }

    /* Toast Container */
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }

    .toast {
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.9), rgba(147, 51, 234, 0.9));
      color: white;
      padding: 16px 20px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 12px;
      min-width: 250px;
      max-width: 400px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      opacity: 0;
      transform: translateX(100%);
      transition: all 0.3s ease;
      pointer-events: all;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(0);
    }

    .toast.toast-success {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.9), rgba(16, 185, 129, 0.9));
    }

    .toast.toast-error {
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.9), rgba(220, 38, 38, 0.9));
    }

    .toast.toast-warning {
      background: linear-gradient(135deg, rgba(245, 158, 11, 0.9), rgba(217, 119, 6, 0.9));
    }

    .toast-close {
      margin-left: auto;
      background: none;
      border: none;
      color: white;
      font-size: 20px;
      cursor: pointer;
      opacity: 0.8;
      transition: opacity 0.2s;
    }

    .toast-close:hover {
      opacity: 1;
    }

    /* Modal Styles */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      animation: fadeIn 0.2s ease;
      padding: 20px;
    }

    .modal-content {
      background: var(--color-surface, #1a1a2e);
      color: var(--color-text, white);
      border-radius: 16px;
      width: 100%;
      max-width: 500px;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      animation: slideUp 0.3s ease;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }

    .modal-header {
      padding: 24px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .modal-title {
      margin: 0;
      font-size: 1.5rem;
      font-weight: 600;
    }

    .modal-close {
      background: none;
      border: none;
      color: var(--color-text, white);
      font-size: 28px;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s;
      line-height: 1;
      padding: 0;
      width: 32px;
      height: 32px;
    }

    .modal-close:hover {
      opacity: 1;
    }

    .modal-body {
      padding: 24px;
      overflow-y: auto;
      flex: 1;
    }

    .modal-footer {
      padding: 20px 24px;
      border-top: 1px solid rgba(255,255,255,0.1);
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    /* Loading Overlay */
    .loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10001;
      animation: fadeIn 0.2s ease;
    }

    .loading-content {
      text-align: center;
      color: white;
    }

    .spinner {
      width: 48px;
      height: 48px;
      border: 3px solid rgba(255,255,255,0.2);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin: 0 auto 16px;
    }

    .loading-message {
      font-size: 1.1rem;
      opacity: 0.9;
    }

    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Form Groups */
    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      opacity: 0.9;
    }

    .form-group input,
    .form-group textarea {
      width: 100%;
      padding: 10px 12px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 6px;
      color: inherit;
      font-size: 1rem;
    }

    .form-group input:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: var(--color-primary, #3b82f6);
      background: rgba(255,255,255,0.08);
    }
  `;

  document.head.appendChild(style);
}

// ===========================================
// CORE FUNCTIONALITY (kept from original)
// ===========================================

function showToast(message, type = 'info', duration = 3000) {
  const container = document.getElementById('toastContainer') || createToastContainer();
  const toast = document.createElement('div');
  toast.className = `toast toast-${type}`;
  toast.innerHTML = `
    <span class="toast-message">${message}</span>
    <button class="toast-close" onclick="this.parentElement.remove()"></button>
  `;
  container.appendChild(toast);

  requestAnimationFrame(() => {
    toast.classList.add('show');
  });

  if (duration > 0) {
    setTimeout(() => {
      toast.classList.remove('show');
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function createToastContainer() {
  const container = document.createElement('div');
  container.id = 'toastContainer';
  container.className = 'toast-container';
  document.body.appendChild(container);
  return container;
}

function createFeedbackContainer() {
  createFeedbackStyles();
  createToastContainer();
}

function showModal(options) {
  const modal = document.createElement('div');
  modal.className = 'modal-overlay';
  modal.id = options.id || `modal-${Date.now()}`;

  modal.innerHTML = `
    <div class="modal-content ${options.size || 'medium'}">
      <div class="modal-header">
        <h2 class="modal-title">${options.title || 'Notice'}</h2>
        <button class="modal-close" onclick="closeModal('${modal.id}')"></button>
      </div>
      <div class="modal-body">
        ${options.content || ''}
      </div>
      ${options.footer ? `<div class="modal-footer">${options.footer}</div>` : ''}
    </div>
  `;

  document.body.appendChild(modal);
  document.body.style.overflow = 'hidden';

  modal.addEventListener('click', (e) => {
    if (e.target === modal) closeModal(modal.id);
  });

  const escHandler = (e) => {
    if (e.key === 'Escape') {
      closeModal(modal.id);
      document.removeEventListener('keydown', escHandler);
    }
  };
  document.addEventListener('keydown', escHandler);

  return modal;
}

function closeModal(modalId) {
  const modal = document.getElementById(modalId);
  if (modal) {
    modal.classList.add('closing');
    setTimeout(() => {
      modal.remove();
      if (!document.querySelector('.modal-overlay')) {
        document.body.style.overflow = '';
      }
    }, 200);
  }
}

function showLoadingOverlay(message = 'Loading...') {
  hideLoadingOverlay();

  const overlay = document.createElement('div');
  overlay.id = 'loadingOverlay';
  overlay.className = 'loading-overlay';
  overlay.innerHTML = `
    <div class="loading-content">
      <div class="spinner"></div>
      <p class="loading-message">${message}</p>
    </div>
  `;
  document.body.appendChild(overlay);
  return overlay;
}

function hideLoadingOverlay() {
  const overlay = document.getElementById('loadingOverlay');
  if (overlay) {
    overlay.classList.add('fade-out');
    setTimeout(() => overlay.remove(), 200);
  }
}

function setButtonLoading(button, isLoading, loadingText) {
  if (!button) return;

  if (isLoading) {
    button.dataset.originalText = button.textContent;
    button.textContent = loadingText || 'Processing...';
    button.disabled = true;
    button.classList.add('loading');
  } else {
    button.textContent = button.dataset.originalText || button.textContent;
    button.disabled = false;
    button.classList.remove('loading');
    delete button.dataset.originalText;
  }
}

// Navigation Handler
function navigateTo(section) {
  const allSections = document.querySelectorAll('[data-section], .section, .view, .page');
  const targetSection = document.querySelector(`[data-section="${section}"], #${section}, .${section}-section`);

  if (targetSection) {
    allSections.forEach((s) => (s.style.display = 'none'));
    targetSection.style.display = 'block';
    window.location.hash = `#${section}`;
    showToast(`Navigated to ${section}`, 'success');
  } else {
    showToast(`${section} section coming soon!`, 'info');
  }
}

function setupNavigationHandling() {
  window.addEventListener('hashchange', () => {
    const hash = window.location.hash.slice(1);
    if (hash) {
      const section = document.querySelector(`[data-section="${hash}"], #${hash}`);
      if (section) {
        document.querySelectorAll('[data-section], .section, .view').forEach((s) => {
          s.style.display = 'none';
        });
        section.style.display = 'block';
      }
    }
  });

  if (window.location.hash) {
    window.dispatchEvent(new HashChangeEvent('hashchange'));
  }
}

// Action Handlers
function handleFormSubmit(button) {
  setButtonLoading(button, true, 'Submitting...');

  setTimeout(() => {
    const form = button.closest('form');
    if (form) {
      const formData = new FormData(form);
      const data = Object.fromEntries(formData);
      localStorage.setItem('formData', JSON.stringify(data));
      showToast('Form submitted successfully!', 'success');
      form.reset();
    } else {
      showToast('Submitted successfully!', 'success');
    }
    setButtonLoading(button, false);
  }, 1500);
}

function handleSaveAction(button) {
  setButtonLoading(button, true, 'Saving...');

  setTimeout(() => {
    const form = button.closest('form');
    if (form) {
      const formData = new FormData(form);
      const data = Object.fromEntries(formData);
      localStorage.setItem('savedData', JSON.stringify(data));
    }

    setButtonLoading(button, false);
    showToast('Changes saved successfully!', 'success');
  }, 1000);
}

function handleDeleteAction(button) {
  showModal({
    title: 'Confirm Deletion',
    content:
      '<p>Are you sure you want to delete this item?</p><p class="text-sm opacity-75">This action cannot be undone.</p>',
    footer: `
      <button class="btn btn-danger" onclick="confirmDelete(this)">Delete</button>
      <button class="btn btn-secondary" onclick="closeModal(this.closest('.modal-overlay').id)">Cancel</button>
    `,
  });
}

function confirmDelete(button) {
  setButtonLoading(button, true, 'Deleting...');

  setTimeout(() => {
    closeModal(button.closest('.modal-overlay').id);
    showToast('Item deleted successfully', 'success');
  }, 800);
}

function handleEditAction(button) {
  showModal({
    title: 'Edit Item',
    content: `
      <form>
        <div class="form-group">
          <label>Title</label>
          <input type="text" class="input" value="Current Title" required>
        </div>
        <div class="form-group">
          <label>Description</label>
          <textarea class="input" rows="4">Current description...</textarea>
        </div>
      </form>
    `,
    footer: `
      <button class="btn btn-primary" onclick="showToast('Changes saved!', 'success'); closeModal(this.closest('.modal-overlay').id)">Save</button>
      <button class="btn btn-secondary" onclick="closeModal(this.closest('.modal-overlay').id)">Cancel</button>
    `,
  });
}

function handleCreateAction(button) {
  showModal({
    title: 'Create New Item',
    content: `
      <form>
        <div class="form-group">
          <label>Title</label>
          <input type="text" class="input" placeholder="Enter title..." required>
        </div>
        <div class="form-group">
          <label>Description</label>
          <textarea class="input" rows="4" placeholder="Enter description..."></textarea>
        </div>
      </form>
    `,
    footer: `
      <button class="btn btn-primary" onclick="showToast('Item created!', 'success'); closeModal(this.closest('.modal-overlay').id)">Create</button>
      <button class="btn btn-secondary" onclick="closeModal(this.closest('.modal-overlay').id)">Cancel</button>
    `,
  });
}

function handleCancelAction(button) {
  const modal = button.closest('.modal-overlay');
  if (modal) {
    closeModal(modal.id);
  } else {
    showToast('Cancelled', 'info');
  }
}

function handleShareAction(button) {
  if (navigator.share) {
    navigator
      .share({
        title: 'Check this out!',
        text: 'I found something interesting',
        url: window.location.href,
      })
      .then(() => {
        showToast('Shared successfully!', 'success');
      })
      .catch(() => {
        showToast('Share cancelled', 'info');
      });
  } else {
    showToast('Link copied to clipboard!', 'success');
    navigator.clipboard.writeText(window.location.href);
  }
}

function handleLikeAction(button) {
  const isLiked = button.classList.contains('liked');

  if (isLiked) {
    button.classList.remove('liked');
    showToast('Like removed', 'info');
  } else {
    button.classList.add('liked');
    showToast('Liked!', 'success');

    // Animate heart
    const heart = document.createElement('span');
    heart.textContent = '';
    heart.style.cssText = `
      position: absolute;
      animation: float-up 1s ease-out forwards;
      pointer-events: none;
    `;
    button.appendChild(heart);
    setTimeout(() => heart.remove(), 1000);
  }
}

function handleFollowAction(button) {
  const isFollowing = button.textContent.toLowerCase().includes('following');

  if (isFollowing) {
    button.textContent = 'Follow';
    showToast('Unfollowed', 'info');
  } else {
    button.textContent = 'Following';
    showToast('Following!', 'success');
  }
}

// Export for use in other scripts
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    showToast,
    showModal,
    closeModal,
    showLoadingOverlay,
    hideLoadingOverlay,
    setButtonLoading,
    navigateTo,
    fixDropdownPositioning,
  };
}

// Make functions globally available
window.buttonUtils = {
  showToast,
  showModal,
  closeModal,
  showLoadingOverlay,
  hideLoadingOverlay,
  setButtonLoading,
  navigateTo,
  fixDropdownPositioning,
};
</file>

<file path="packages/ui-frontend/app/lib/templates/button-utilities.js">
/**
 * Button utilities for generated apps
 */

// Initialize on DOM load and setup mutation observer
if (typeof document !== 'undefined') {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeButtonUtilities);
  } else {
    initializeButtonUtilities();
  }

  // Global click handler to close dropdowns when clicking outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('[data-selector-initialized], .dropdown-menu, .dropdown-content, .options, .menu')) {
      document
        .querySelectorAll('.dropdown-menu, .dropdown-content, .options, .menu, ul[role="menu"]')
        .forEach((dropdown) => {
          dropdown.style.display = 'none';
          dropdown.classList.remove('show', 'open');
          dropdown.hidden = true;
        });
    }
  });
}

function initializeButtonUtilities() {
  attachDefaultHandlers();
  createFeedbackContainer();
  setupNavigationHandling();
  fixDropdownPositioning();
  setupMutationObserver();
  createFeedbackStyles();
}

// Dropdown positioning fix
function fixDropdownPositioning() {
  // Fix all select elements and custom dropdowns including token selectors
  const selects = document.querySelectorAll(
    'select, .dropdown, .select-wrapper, [data-dropdown], .token-select, .token-selector, button[class*="token"], button[class*="select"]',
  );

  selects.forEach((element) => {
    const parent = element.parentElement;

    if (parent && getComputedStyle(parent).position === 'static') {
      parent.style.position = 'relative';
    }

    // Fix custom dropdown menus
    const dropdownMenu = element.querySelector(
      '.dropdown-menu, .dropdown-content, .options, .select-options, .token-list, .token-options',
    );
    if (dropdownMenu) {
      dropdownMenu.style.position = 'absolute';
      dropdownMenu.style.zIndex = '9999';
      dropdownMenu.style.top = '100%';
      dropdownMenu.style.left = '0';
      dropdownMenu.style.minWidth = '100%';

      element.style.position = 'relative';
      element.style.zIndex = '100';
    }
  });

  // Handle token selector buttons specifically
  setupTokenSelectors();

  // Add global click handler for custom dropdowns
  document.addEventListener('click', (e) => {
    const dropdown = e.target.closest('.dropdown, .select-wrapper, [data-dropdown], .token-select, .token-selector');

    if (dropdown) {
      e.stopPropagation();
      const menu = dropdown.querySelector('.dropdown-menu, .dropdown-content, .options, .select-options');

      if (menu) {
        const isOpen = menu.style.display === 'block';

        // Close all other dropdowns
        document.querySelectorAll('.dropdown-menu, .dropdown-content, .options, .select-options').forEach((m) => {
          if (m !== menu) m.style.display = 'none';
        });

        // Toggle current dropdown
        menu.style.display = isOpen ? 'none' : 'block';

        if (!isOpen) {
          const rect = menu.getBoundingClientRect();
          const viewportHeight = window.innerHeight;

          if (rect.bottom > viewportHeight) {
            menu.style.bottom = '100%';
            menu.style.top = 'auto';
          } else {
            menu.style.top = '100%';
            menu.style.bottom = 'auto';
          }
        }
      }
    } else {
      // Close all dropdowns when clicking outside
      document.querySelectorAll('.dropdown-menu, .dropdown-content, .options, .select-options').forEach((m) => {
        m.style.display = 'none';
      });
    }
  });
}

// Token selector handler
function setupTokenSelectors() {
  // Find all potential token selector buttons
  const selectors = document.querySelectorAll(
    'button[class*="token"], button[class*="select"], ' +
      '.token-button, .token-select, .token-selector, ' +
      '.swap-token, .send-token, .currency-select, ' +
      'div[role="button"][class*="token"], ' +
      '[class*="select"][class*="token"], ' +
      '.dropdown-trigger, [data-dropdown-trigger], ' +
      'button', // Check all buttons
  );

  selectors.forEach((button) => {
    // Skip if already initialized
    if (button.hasAttribute('data-selector-initialized')) return;

    const text = button.textContent?.trim();
    const hasChevron = button.querySelector('svg, .chevron, .arrow, [class*="chevron"], [class*="arrow"]');
    const hasTokenText = /^[A-Z]{2,10}/.test(text) || text?.includes('Token') || text?.includes('Select');

    // Check if this looks like a selector button
    if (hasChevron || hasTokenText) {
      // Find associated dropdown - could be sibling, child, or nearby element
      let dropdown = findAssociatedDropdown(button);

      if (dropdown) {
        button.setAttribute('data-selector-initialized', 'true');
        button.style.cursor = 'pointer';

        // Remove any existing onclick to prevent conflicts
        button.onclick = null;

        // Add proper click handler
        button.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          toggleExistingDropdown(button, dropdown);
        });

        // Setup click handlers for dropdown options
        setupDropdownOptions(button, dropdown);
      }
    }
  });
}

// Find the dropdown associated with a button
function findAssociatedDropdown(button) {
  // Check common patterns for dropdown location

  // 1. Direct child
  let dropdown = button.querySelector('.dropdown-menu, .dropdown-content, .options, .menu, ul, [role="menu"]');
  if (dropdown) return dropdown;

  // 2. Next sibling
  dropdown = button.nextElementSibling;
  if (
    dropdown &&
    (dropdown.classList.contains('dropdown-menu') ||
      dropdown.classList.contains('dropdown-content') ||
      dropdown.classList.contains('options') ||
      dropdown.classList.contains('menu') ||
      dropdown.tagName === 'UL' ||
      dropdown.getAttribute('role') === 'menu')
  )
    return dropdown;

  // 3. Within parent container
  const parent = button.parentElement;
  if (parent) {
    dropdown = parent.querySelector('.dropdown-menu, .dropdown-content, .options, .menu, ul, [role="menu"]');
    if (dropdown && dropdown !== button) return dropdown;
  }

  // 4. Following siblings within parent
  let sibling = button.nextElementSibling;
  while (sibling) {
    if (
      sibling.classList.contains('dropdown-menu') ||
      sibling.classList.contains('dropdown-content') ||
      sibling.classList.contains('options') ||
      sibling.tagName === 'UL' ||
      sibling.getAttribute('role') === 'menu'
    ) {
      return sibling;
    }
    sibling = sibling.nextElementSibling;
  }

  return null;
}

// Toggle existing dropdown visibility
function toggleExistingDropdown(button, dropdown) {
  const isVisible =
    dropdown.style.display === 'block' ||
    dropdown.classList.contains('show') ||
    dropdown.classList.contains('open') ||
    !dropdown.hidden;

  // Close all other dropdowns first
  document.querySelectorAll('.dropdown-menu, .dropdown-content, .options, .menu, ul[role="menu"]').forEach((d) => {
    if (d !== dropdown) {
      d.style.display = 'none';
      d.classList.remove('show', 'open');
      d.hidden = true;
    }
  });

  // Toggle current dropdown
  if (isVisible) {
    dropdown.style.display = 'none';
    dropdown.classList.remove('show', 'open');
    dropdown.hidden = true;
  } else {
    dropdown.style.display = 'block';
    dropdown.classList.add('show', 'open');
    dropdown.hidden = false;

    ensureDropdownPosition(button, dropdown);
  }
}

function ensureDropdownPosition(button, dropdown) {
  const buttonRect = button.getBoundingClientRect();
  const dropdownRect = dropdown.getBoundingClientRect();
  const viewportHeight = window.innerHeight;

  // Make sure parent has position relative
  const parent = button.parentElement;
  if (parent && getComputedStyle(parent).position === 'static') {
    parent.style.position = 'relative';
  }

  // Set dropdown positioning
  dropdown.style.position = 'absolute';
  dropdown.style.zIndex = '9999';
  dropdown.style.minWidth = `${buttonRect.width}px`;

  // Check if dropdown would go off screen
  if (buttonRect.bottom + dropdownRect.height > viewportHeight) {
    // Position above button
    dropdown.style.bottom = '100%';
    dropdown.style.top = 'auto';
    dropdown.style.marginBottom = '4px';
  } else {
    // Position below button
    dropdown.style.top = '100%';
    dropdown.style.bottom = 'auto';
    dropdown.style.marginTop = '4px';
  }

  dropdown.style.left = '0';
}

// Setup click handlers for dropdown options
function setupDropdownOptions(button, dropdown) {
  const options = dropdown.querySelectorAll('li, .option, .item, [role="option"], button, a');

  options.forEach((option) => {
    // Skip if already has handler
    if (option.hasAttribute('data-option-initialized')) return;
    option.setAttribute('data-option-initialized', 'true');

    option.style.cursor = 'pointer';

    option.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();

      // Get the text content to update button
      const optionText = option.textContent?.trim();
      const value = option.getAttribute('data-value') || option.value || optionText;

      // Update button text
      if (value) {
        // Preserve any chevron/arrow icon if present
        const chevron = button.querySelector('svg, .chevron, .arrow');
        if (chevron) {
          button.textContent = value;
          button.appendChild(chevron);
        } else {
          button.textContent = value;
        }
      }

      // Close dropdown
      dropdown.style.display = 'none';
      dropdown.classList.remove('show', 'open');
      dropdown.hidden = true;

      showToast(`Selected: ${value}`, 'success');
    });
  });
}

// Mutation observer for dynamic elements
function setupMutationObserver() {
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.type === 'childList') {
        mutation.addedNodes.forEach((node) => {
          if (node.nodeType === 1) {
            // Element node
            // Re-run handlers for new elements
            setTimeout(() => {
              attachDefaultHandlers();
              fixDropdownPositioning();
            }, 100);
          }
        });
      }
    });
  });

  observer.observe(document.body, {
    childList: true,
    subtree: true,
  });
}

// Default button handlers - only for buttons with NO functionality
function attachDefaultHandlers() {
  // Only handle buttons that have absolutely no functionality
  const buttons = document.querySelectorAll(
    'button:not([onclick]), a[href="#"], a[href=""], a:not([href]), [role="button"]',
  );

  buttons.forEach((element) => {
    // Skip theme toggle button - it has its own handler
    if (element.id === 'theme-toggle' || element.classList.contains('theme-toggle')) {
      return;
    }

    // Skip if already processed
    if (element.dataset.handlerAttached === 'true') {
      return;
    }

    // Check if element has ANY handler (inline, property, or event listeners)
    const hasOnclick = element.hasAttribute('onclick') || element.onclick;
    const hasHref =
      element.hasAttribute('href') && element.getAttribute('href') !== '#' && element.getAttribute('href') !== '';
    const isFormElement = element.closest('form') && (element.type === 'submit' || element.type === 'button');
    const hasDataAction = element.hasAttribute('data-action') || element.hasAttribute('data-click');

    // Skip if element has any form of handler or is part of app functionality
    if (hasOnclick || hasHref || isFormElement || hasDataAction) {
      return;
    }

    // Skip if button is inside a component that likely has its own handlers
    if (element.closest('.modal, .dropdown, .popover, .tooltip, .carousel, .tabs')) {
      return;
    }

    const text = element.textContent?.toLowerCase() || '';
    const href = element.getAttribute('href')?.toLowerCase() || '';
    const className = element.className?.toLowerCase() || '';
    const id = element.id?.toLowerCase() || '';

    // Footer & Social Media buttons
    if (text.includes('twitter') || className.includes('twitter') || href.includes('twitter')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Opening Twitter...', 'info');
        window.open('https://twitter.com', '_blank');
      };
      element.dataset.handlerAttached = 'true';
    } else if (text.includes('facebook') || className.includes('facebook') || href.includes('facebook')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Opening Facebook...', 'info');
        window.open('https://facebook.com', '_blank');
      };
      element.dataset.handlerAttached = 'true';
    } else if (text.includes('linkedin') || className.includes('linkedin') || href.includes('linkedin')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Opening LinkedIn...', 'info');
        window.open('https://linkedin.com', '_blank');
      };
      element.dataset.handlerAttached = 'true';
    } else if (text.includes('instagram') || className.includes('instagram') || href.includes('instagram')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Opening Instagram...', 'info');
        window.open('https://instagram.com', '_blank');
      };
      element.dataset.handlerAttached = 'true';
    } else if (text.includes('github') || className.includes('github') || href.includes('github')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Opening GitHub...', 'info');
        window.open('https://github.com', '_blank');
      };
      element.dataset.handlerAttached = 'true';
    } else if (text.includes('youtube') || className.includes('youtube') || href.includes('youtube')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Opening YouTube...', 'info');
        window.open('https://youtube.com', '_blank');
      };
      element.dataset.handlerAttached = 'true';
    }
    // Footer navigation links
    else if (text.includes('privacy') || text.includes('policy')) {
      element.onclick = (e) => {
        e.preventDefault();
        showModal({
          title: 'Privacy Policy',
          content:
            '<p>Your privacy is important to us. This application does not collect any personal data.</p><p>All data is stored locally in your browser.</p>',
        });
      };
    } else if (text.includes('terms') || text.includes('service')) {
      element.onclick = (e) => {
        e.preventDefault();
        showModal({
          title: 'Terms of Service',
          content:
            '<p>By using this application, you agree to use it responsibly.</p><p>This is a demo application for educational purposes.</p>',
        });
      };
    } else if (text.includes('contact')) {
      element.onclick = (e) => {
        e.preventDefault();
        showModal({
          title: 'Contact Us',
          content: `
            <form>
              <div class="form-group">
                <label>Email</label>
                <input type="email" class="input" placeholder="your@email.com" />
              </div>
              <div class="form-group">
                <label>Message</label>
                <textarea class="input" rows="4" placeholder="Your message..."></textarea>
              </div>
            </form>
          `,
          footer:
            "<button class=\"btn btn-primary\" onclick=\"showToast('Message sent!', 'success'); closeModal(this.closest('.modal-overlay').id)\">Send</button>",
        });
      };
    } else if (text.includes('about')) {
      element.onclick = (e) => {
        e.preventDefault();
        navigateTo('about');
      };
    }
    // Navigation buttons
    else if (text.includes('home')) {
      element.onclick = (e) => {
        e.preventDefault();
        navigateTo('home');
      };
    } else if (text.includes('profile')) {
      element.onclick = (e) => {
        e.preventDefault();
        navigateTo('profile');
      };
    } else if (text.includes('settings')) {
      element.onclick = (e) => {
        e.preventDefault();
        navigateTo('settings');
      };
    } else if (text.includes('dashboard')) {
      element.onclick = (e) => {
        e.preventDefault();
        navigateTo('dashboard');
      };
    } else if (text.includes('swap') || text.includes('history') || text.includes('send') || text.includes('receive')) {
      // For Web3/financial buttons, try to find their actual functionality
      element.onclick = (e) => {
        e.preventDefault();
        const action = text.toLowerCase();

        // Try to find a matching function in window scope
        const possibleFunctions = [
          `open${action.charAt(0).toUpperCase() + action.slice(1)}Modal`,
          `show${action.charAt(0).toUpperCase() + action.slice(1)}`,
          action,
          `handle${action.charAt(0).toUpperCase() + action.slice(1)}`,
        ];

        for (const funcName of possibleFunctions) {
          if (typeof window[funcName] === 'function') {
            window[funcName]();
            return;
          }
        }

        // Try to find a matching element/section to show
        const possibleSelectors = [
          `#${action}-modal`,
          `.${action}-modal`,
          `#${action}`,
          `.${action}-section`,
          `[data-section="${action}"]`,
        ];

        for (const selector of possibleSelectors) {
          const element = document.querySelector(selector);
          if (element) {
            element.style.display = 'block';
            element.classList.add('show', 'open');
            return;
          }
        }

        // Minimal feedback as last resort
        showToast(`${action.charAt(0).toUpperCase() + action.slice(1)} clicked`, 'info');
      };
    }
    // Check if it looks like a navigation item (sidebar, nav, menu context)
    else if (
      element.closest('.sidebar, nav, .navigation, .menu, .nav-menu, aside') ||
      element.closest('[class*="sidebar"], [class*="navigation"], [class*="nav-"]')
    ) {
      // For navigation context, assume the button text is a section name
      element.onclick = (e) => {
        e.preventDefault();
        const sectionName = element.textContent
          .trim()
          .toLowerCase()
          .replace(/[^a-z0-9]/g, '');
        navigateTo(sectionName);
      };
    }
    // Action buttons
    else if (text.includes('save')) {
      element.onclick = (e) => {
        e.preventDefault();
        handleSaveAction(element);
      };
    } else if (text.includes('delete')) {
      element.onclick = (e) => {
        e.preventDefault();
        handleDeleteAction(element);
      };
    } else if (text.includes('edit')) {
      element.onclick = (e) => {
        e.preventDefault();
        handleEditAction(element);
      };
    } else if (text.includes('create') || text.includes('add') || text.includes('new')) {
      element.onclick = (e) => {
        e.preventDefault();
        handleCreateAction(element);
      };
    } else if (text.includes('cancel') || text.includes('close')) {
      element.onclick = (e) => {
        e.preventDefault();
        handleCancelAction(element);
      };
    } else if (text.includes('download')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Download starting...', 'info');
      };
    } else if (text.includes('upload')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Opening file selector...', 'info');
      };
    } else if (text.includes('share')) {
      element.onclick = (e) => {
        e.preventDefault();
        handleShareAction(element);
      };
    } else if (text.includes('like') || className.includes('like')) {
      element.onclick = (e) => {
        e.preventDefault();
        handleLikeAction(element);
      };
    } else if (text.includes('follow')) {
      element.onclick = (e) => {
        e.preventDefault();
        handleFollowAction(element);
      };
    } else if (text.includes('subscribe')) {
      element.onclick = (e) => {
        e.preventDefault();
        showToast('Subscribed successfully!', 'success');
        if (element.tagName === 'BUTTON') {
          element.textContent = 'Subscribed';
          element.disabled = true;
        }
      };
    }
    // Only add minimal feedback for completely orphaned buttons
    else if (!element.onclick && !element.hasAttribute('onclick')) {
      // Skip icon-only buttons
      const hasOnlyIcon =
        element.querySelector('svg, i, .icon') &&
        (!element.textContent.trim() || element.textContent.trim().length <= 1);
      if (hasOnlyIcon) return;

      // Only add visual feedback, no toast spam
      element.onclick = (e) => {
        e.preventDefault();
        element.style.transform = 'scale(0.95)';
        setTimeout(() => (element.style.transform = ''), 100);
      };
      element.dataset.handlerAttached = 'true';
    }
  });

  // Only handle explicitly clickable elements with no functionality
  document.querySelectorAll('[onclick=""], .clickable').forEach((element) => {
    if (!element.onclick || element.onclick.toString() === 'function onclick(event) {\n\n}') {
      element.style.cursor = 'pointer';
      element.onclick = () => {
        element.style.transform = 'scale(0.98)';
        setTimeout(() => (element.style.transform = ''), 100);
      };
    }
  });
}

// Feedback styles
function createFeedbackStyles() {
  if (document.getElementById('buttonUtilStyles')) return;

  const style = document.createElement('style');
  style.id = 'buttonUtilStyles';
  style.textContent = `
    /* Enhanced Dropdown Positioning Fixes */
    .dropdown, .select-wrapper, [data-dropdown] {
      position: relative !important;
    }

    .dropdown-menu, .dropdown-content, .options, .select-options {
      position: absolute !important;
      z-index: 9999 !important;
      background: var(--color-surface, #fff) !important;
      border: 1px solid var(--color-border, #ddd) !important;
      border-radius: 8px !important;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
      max-height: 300px !important;
      overflow-y: auto !important;
      display: none;
    }

    .dropdown-menu.show, .dropdown-content.show, .options.show, .select-options.show {
      display: block !important;
    }

    /* Ensure dropdowns appear above other content */
    .dropdown:focus-within {
      z-index: 1000 !important;
    }

    /* Fix select element styling */
    select {
      position: relative !important;
      z-index: 1 !important;
      background: var(--color-surface, #fff) !important;
      cursor: pointer !important;
    }

    /* Footer link styling */
    footer a, .footer a {
      cursor: pointer !important;
      transition: opacity 0.2s !important;
    }

    footer a:hover, .footer a:hover {
      opacity: 0.8 !important;
    }

    /* Clickable element feedback */
    [role="button"], .btn, .button, .clickable {
      cursor: pointer !important;
      transition: transform 0.1s ease !important;
    }

    [role="button"]:active, .btn:active, .button:active, .clickable:active {
      transform: scale(0.95) !important;
    }

    /* Toast Container */
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }

    .toast {
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.9), rgba(147, 51, 234, 0.9));
      color: white;
      padding: 16px 20px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 12px;
      min-width: 250px;
      max-width: 400px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      opacity: 0;
      transform: translateX(100%);
      transition: all 0.3s ease;
      pointer-events: all;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(0);
    }

    .toast.toast-success {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.9), rgba(16, 185, 129, 0.9));
    }

    .toast.toast-error {
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.9), rgba(220, 38, 38, 0.9));
    }

    .toast.toast-warning {
      background: linear-gradient(135deg, rgba(245, 158, 11, 0.9), rgba(217, 119, 6, 0.9));
    }

    .toast-close {
      margin-left: auto;
      background: none;
      border: none;
      color: white;
      font-size: 20px;
      cursor: pointer;
      opacity: 0.8;
      transition: opacity 0.2s;
    }

    .toast-close:hover {
      opacity: 1;
    }

    /* Modal Styles */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      animation: fadeIn 0.2s ease;
      padding: 20px;
    }

    .modal-content {
      background: var(--color-surface, #1a1a2e);
      color: var(--color-text, white);
      border-radius: 16px;
      width: 100%;
      max-width: 500px;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      animation: slideUp 0.3s ease;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }

    .modal-header {
      padding: 24px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .modal-title {
      margin: 0;
      font-size: 1.5rem;
      font-weight: 600;
    }

    .modal-close {
      background: none;
      border: none;
      color: var(--color-text, white);
      font-size: 28px;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s;
      line-height: 1;
      padding: 0;
      width: 32px;
      height: 32px;
    }

    .modal-close:hover {
      opacity: 1;
    }

    .modal-body {
      padding: 24px;
      overflow-y: auto;
      flex: 1;
    }

    .modal-footer {
      padding: 20px 24px;
      border-top: 1px solid rgba(255,255,255,0.1);
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    /* Loading Overlay */
    .loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10001;
      animation: fadeIn 0.2s ease;
    }

    .loading-content {
      text-align: center;
      color: white;
    }

    .spinner {
      width: 48px;
      height: 48px;
      border: 3px solid rgba(255,255,255,0.2);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin: 0 auto 16px;
    }

    .loading-message {
      font-size: 1.1rem;
      opacity: 0.9;
    }

    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Header and Navigation Icon Sizing */
    header svg, nav svg, .header svg, .navigation svg,
    .navbar svg, .nav-menu svg, .menu svg {
      width: 24px;
      height: 24px;
      max-width: 24px;
      max-height: 24px;
      flex-shrink: 0;
    }

    header button svg, nav button svg,
    .header button svg, .navigation button svg {
      width: 20px;
      height: 20px;
    }

    /* Form Groups */
    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      opacity: 0.9;
    }

    .form-group input,
    .form-group textarea {
      width: 100%;
      padding: 10px 12px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 6px;
      color: inherit;
      font-size: 1rem;
    }

    .form-group input:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: var(--color-primary, #3b82f6);
      background: rgba(255,255,255,0.08);
    }
  `;

  document.head.appendChild(style);
}

// Core functionality

function showToast(message, type = 'info', duration = 3000) {
  const container = document.getElementById('toastContainer') || createToastContainer();
  const toast = document.createElement('div');
  toast.className = `toast toast-${type}`;
  toast.innerHTML = `
    <span class="toast-message">${message}</span>
    <button class="toast-close" onclick="this.parentElement.remove()"></button>
  `;
  container.appendChild(toast);

  requestAnimationFrame(() => {
    toast.classList.add('show');
  });

  if (duration > 0) {
    setTimeout(() => {
      toast.classList.remove('show');
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function createToastContainer() {
  const container = document.createElement('div');
  container.id = 'toastContainer';
  container.className = 'toast-container';
  document.body.appendChild(container);
  return container;
}

function createFeedbackContainer() {
  createFeedbackStyles();
  createToastContainer();
}

function showModal(options) {
  const modal = document.createElement('div');
  modal.className = 'modal-overlay';
  modal.id = options.id || `modal-${Date.now()}`;

  modal.innerHTML = `
    <div class="modal-content ${options.size || 'medium'}">
      <div class="modal-header">
        <h2 class="modal-title">${options.title || 'Notice'}</h2>
        <button class="modal-close" onclick="closeModal('${modal.id}')"></button>
      </div>
      <div class="modal-body">
        ${options.content || ''}
      </div>
      ${options.footer ? `<div class="modal-footer">${options.footer}</div>` : ''}
    </div>
  `;

  document.body.appendChild(modal);
  document.body.style.overflow = 'hidden';

  modal.addEventListener('click', (e) => {
    if (e.target === modal) closeModal(modal.id);
  });

  const escHandler = (e) => {
    if (e.key === 'Escape') {
      closeModal(modal.id);
      document.removeEventListener('keydown', escHandler);
    }
  };
  document.addEventListener('keydown', escHandler);

  return modal;
}

function closeModal(modalId) {
  const modal = document.getElementById(modalId);
  if (modal) {
    modal.classList.add('closing');
    setTimeout(() => {
      modal.remove();
      if (!document.querySelector('.modal-overlay')) {
        document.body.style.overflow = '';
      }
    }, 200);
  }
}

// Make closeModal globally available
window.closeModal = closeModal;

// Also make other utilities globally available
window.showToast = showToast;
window.showModal = showModal;
window.showLoadingOverlay = showLoadingOverlay;

function showLoadingOverlay(message = 'Loading...') {
  hideLoadingOverlay();

  const overlay = document.createElement('div');
  overlay.id = 'loadingOverlay';
  overlay.className = 'loading-overlay';
  overlay.innerHTML = `
    <div class="loading-content">
      <div class="spinner"></div>
      <p class="loading-message">${message}</p>
    </div>
  `;
  document.body.appendChild(overlay);
  return overlay;
}

function hideLoadingOverlay() {
  const overlay = document.getElementById('loadingOverlay');
  if (overlay) {
    overlay.classList.add('fade-out');
    setTimeout(() => overlay.remove(), 200);
  }
}

window.hideLoadingOverlay = hideLoadingOverlay;

function setButtonLoading(button, isLoading, loadingText) {
  if (!button) return;

  if (isLoading) {
    button.dataset.originalText = button.textContent;
    button.textContent = loadingText || 'Processing...';
    button.disabled = true;
    button.classList.add('loading');
  } else {
    button.textContent = button.dataset.originalText || button.textContent;
    button.disabled = false;
    button.classList.remove('loading');
    delete button.dataset.originalText;
  }
}

// Navigation Handler
function navigateTo(section) {
  const allSections = document.querySelectorAll('[data-section], .section, .view, .page');
  const targetSection = document.querySelector(`[data-section="${section}"], #${section}, .${section}-section`);

  if (targetSection) {
    allSections.forEach((s) => (s.style.display = 'none'));
    targetSection.style.display = 'block';
    window.location.hash = `#${section}`;
    showToast(`Navigated to ${section}`, 'success');
  } else {
    showToast(`${section} section coming soon!`, 'info');
  }
}

function setupNavigationHandling() {
  window.addEventListener('hashchange', () => {
    const hash = window.location.hash.slice(1);
    if (hash) {
      const section = document.querySelector(`[data-section="${hash}"], #${hash}`);
      if (section) {
        document.querySelectorAll('[data-section], .section, .view').forEach((s) => {
          s.style.display = 'none';
        });
        section.style.display = 'block';
      }
    }
  });

  if (window.location.hash) {
    window.dispatchEvent(new HashChangeEvent('hashchange'));
  }
}

// Action Handlers
function handleFormSubmit(button) {
  setButtonLoading(button, true, 'Submitting...');

  setTimeout(() => {
    const form = button.closest('form');
    if (form) {
      const formData = new FormData(form);
      const data = Object.fromEntries(formData);
      localStorage.setItem('formData', JSON.stringify(data));
      showToast('Form submitted successfully!', 'success');
      form.reset();
    } else {
      showToast('Submitted successfully!', 'success');
    }
    setButtonLoading(button, false);
  }, 1500);
}

function handleSaveAction(button) {
  setButtonLoading(button, true, 'Saving...');

  setTimeout(() => {
    const form = button.closest('form');
    if (form) {
      const formData = new FormData(form);
      const data = Object.fromEntries(formData);
      localStorage.setItem('savedData', JSON.stringify(data));
    }

    setButtonLoading(button, false);
    showToast('Changes saved successfully!', 'success');
  }, 1000);
}

function handleDeleteAction(button) {
  showModal({
    title: 'Confirm Deletion',
    content:
      '<p>Are you sure you want to delete this item?</p><p class="text-sm opacity-75">This action cannot be undone.</p>',
    footer: `
      <button class="btn btn-danger" onclick="confirmDelete(this)">Delete</button>
      <button class="btn btn-secondary" onclick="closeModal(this.closest('.modal-overlay').id)">Cancel</button>
    `,
  });
}

function confirmDelete(button) {
  setButtonLoading(button, true, 'Deleting...');

  setTimeout(() => {
    closeModal(button.closest('.modal-overlay').id);
    showToast('Item deleted successfully', 'success');
  }, 800);
}

function handleEditAction(button) {
  showModal({
    title: 'Edit Item',
    content: `
      <form>
        <div class="form-group">
          <label>Title</label>
          <input type="text" class="input" value="Current Title" required>
        </div>
        <div class="form-group">
          <label>Description</label>
          <textarea class="input" rows="4">Current description...</textarea>
        </div>
      </form>
    `,
    footer: `
      <button class="btn btn-primary" onclick="showToast('Changes saved!', 'success'); closeModal(this.closest('.modal-overlay').id)">Save</button>
      <button class="btn btn-secondary" onclick="closeModal(this.closest('.modal-overlay').id)">Cancel</button>
    `,
  });
}

function handleCreateAction(button) {
  showModal({
    title: 'Create New Item',
    content: `
      <form>
        <div class="form-group">
          <label>Title</label>
          <input type="text" class="input" placeholder="Enter title..." required>
        </div>
        <div class="form-group">
          <label>Description</label>
          <textarea class="input" rows="4" placeholder="Enter description..."></textarea>
        </div>
      </form>
    `,
    footer: `
      <button class="btn btn-primary" onclick="showToast('Item created!', 'success'); closeModal(this.closest('.modal-overlay').id)">Create</button>
      <button class="btn btn-secondary" onclick="closeModal(this.closest('.modal-overlay').id)">Cancel</button>
    `,
  });
}

function handleCancelAction(button) {
  const modal = button.closest('.modal-overlay');
  if (modal) {
    closeModal(modal.id);
  } else {
    showToast('Cancelled', 'info');
  }
}

function handleShareAction(button) {
  if (navigator.share) {
    navigator
      .share({
        title: 'Check this out!',
        text: 'I found something interesting',
        url: window.location.href,
      })
      .then(() => {
        showToast('Shared successfully!', 'success');
      })
      .catch(() => {
        showToast('Share cancelled', 'info');
      });
  } else {
    showToast('Link copied to clipboard!', 'success');
    navigator.clipboard.writeText(window.location.href);
  }
}

function handleLikeAction(button) {
  const isLiked = button.classList.contains('liked');

  if (isLiked) {
    button.classList.remove('liked');
    showToast('Like removed', 'info');
  } else {
    button.classList.add('liked');
    showToast('Liked!', 'success');

    // Animate heart
    const heart = document.createElement('span');
    heart.textContent = '';
    heart.style.cssText = `
      position: absolute;
      animation: float-up 1s ease-out forwards;
      pointer-events: none;
    `;
    button.appendChild(heart);
    setTimeout(() => heart.remove(), 1000);
  }
}

function handleFollowAction(button) {
  const isFollowing = button.textContent.toLowerCase().includes('following');

  if (isFollowing) {
    button.textContent = 'Follow';
    showToast('Unfollowed', 'info');
  } else {
    button.textContent = 'Following';
    showToast('Following!', 'success');
  }
}

// Export for use in other scripts
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    showToast,
    showModal,
    closeModal,
    showLoadingOverlay,
    hideLoadingOverlay,
    setButtonLoading,
    navigateTo,
    fixDropdownPositioning,
  };
}

// Make functions globally available
window.buttonUtils = {
  showToast,
  showModal,
  closeModal,
  showLoadingOverlay,
  hideLoadingOverlay,
  setButtonLoading,
  navigateTo,
  fixDropdownPositioning,
};
</file>

<file path="packages/ui-frontend/app/lib/templates/dark-mode-fix.js">
// Dark mode implementation for generated apps
// This must execute immediately to set up dark mode functionality
(function () {
  'use strict';

  const THEME_ICONS = {
    light:
      '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 50 50" fill="white"><path d="M 24.90625 3.96875 C 24.863281 3.976563 24.820313 3.988281 24.78125 4 C 24.316406 4.105469 23.988281 4.523438 24 5 L 24 11 C 23.996094 11.359375 24.183594 11.695313 24.496094 11.878906 C 24.808594 12.058594 25.191406 12.058594 25.503906 11.878906 C 25.816406 11.695313 26.003906 11.359375 26 11 L 26 5 C 26.011719 4.710938 25.894531 4.433594 25.6875 4.238281 C 25.476563 4.039063 25.191406 3.941406 24.90625 3.96875 Z M 10.65625 9.84375 C 10.28125 9.910156 9.980469 10.183594 9.875 10.546875 C 9.769531 10.914063 9.878906 11.304688 10.15625 11.5625 L 14.40625 15.8125 C 14.648438 16.109375 15.035156 16.246094 15.410156 16.160156 C 15.78125 16.074219 16.074219 15.78125 16.160156 15.410156 C 16.246094 15.035156 16.109375 14.648438 15.8125 14.40625 L 11.5625 10.15625 C 11.355469 9.933594 11.054688 9.820313 10.75 9.84375 C 10.71875 9.84375 10.6875 9.84375 10.65625 9.84375 Z M 39.03125 9.84375 C 38.804688 9.875 38.59375 9.988281 38.4375 10.15625 L 34.1875 14.40625 C 33.890625 14.648438 33.753906 15.035156 33.839844 15.410156 C 33.925781 15.78125 34.21875 16.074219 34.589844 16.160156 C 34.964844 16.246094 35.351563 16.109375 35.59375 15.8125 L 39.84375 11.5625 C 40.15625 11.265625 40.246094 10.800781 40.0625 10.410156 C 39.875 10.015625 39.460938 9.789063 39.03125 9.84375 Z M 25 15 C 19.484375 15 15 19.484375 15 25 C 15 30.515625 19.484375 35 25 35 C 30.515625 35 35 30.515625 35 25 C 35 19.484375 30.515625 15 25 15 Z M 4.71875 24 C 4.167969 24.078125 3.78125 24.589844 3.859375 25.140625 C 3.9375 25.691406 4.449219 26.078125 5 26 L 11 26 C 11.359375 26.003906 11.695313 25.816406 11.878906 25.503906 C 12.058594 25.191406 12.058594 24.808594 11.878906 24.496094 C 11.695313 24.183594 11.359375 23.996094 11 24 L 5 24 C 4.96875 24 4.9375 24 4.90625 24 C 4.875 24 4.84375 24 4.8125 24 C 4.78125 24 4.75 24 4.71875 24 Z M 38.71875 24 C 38.167969 24.078125 37.78125 24.589844 37.859375 25.140625 C 37.9375 25.691406 38.449219 26.078125 39 26 L 45 26 C 45.359375 26.003906 45.695313 25.816406 45.878906 25.503906 C 46.058594 25.191406 46.058594 24.808594 45.878906 24.496094 C 45.695313 24.183594 45.359375 23.996094 45 24 L 39 24 C 38.96875 24 38.9375 24 38.90625 24 C 38.875 24 38.84375 24 38.8125 24 C 38.78125 24 38.75 24 38.71875 24 Z M 15 33.875 C 14.773438 33.90625 14.5625 34.019531 14.40625 34.1875 L 10.15625 38.4375 C 9.859375 38.679688 9.722656 39.066406 9.808594 39.441406 C 9.894531 39.8125 10.1875 40.105469 10.558594 40.191406 C 10.933594 40.277344 11.320313 40.140625 11.5625 39.84375 L 15.8125 35.59375 C 16.109375 35.308594 16.199219 34.867188 16.039063 34.488281 C 15.882813 34.109375 15.503906 33.867188 15.09375 33.875 C 15.0625 33.875 15.03125 33.875 15 33.875 Z M 34.6875 33.875 C 34.3125 33.941406 34.011719 34.214844 33.90625 34.578125 C 33.800781 34.945313 33.910156 35.335938 34.1875 35.59375 L 38.4375 39.84375 C 38.679688 40.140625 39.066406 40.277344 39.441406 40.191406 C 39.8125 40.105469 40.105469 39.8125 40.191406 39.441406 C 40.277344 39.066406 40.140625 38.679688 39.84375 38.4375 L 35.59375 34.1875 C 35.40625 33.988281 35.148438 33.878906 34.875 33.875 C 34.84375 33.875 34.8125 33.875 34.78125 33.875 C 34.75 33.875 34.71875 33.875 34.6875 33.875 Z M 24.90625 37.96875 C 24.863281 37.976563 24.820313 37.988281 24.78125 38 C 24.316406 38.105469 23.988281 38.523438 24 39 L 24 45 C 23.996094 45.359375 24.183594 45.695313 24.496094 45.878906 C 24.808594 46.058594 25.191406 46.058594 25.503906 45.878906 C 25.816406 45.695313 26.003906 45.359375 26 45 L 26 39 C 26.011719 38.710938 25.894531 38.433594 25.6875 38.238281 C 25.476563 38.039063 25.191406 37.941406 24.90625 37.96875 Z"></path></svg>',
    dark: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="none"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>',
  };

  function initTheme() {
    const saved = localStorage.getItem('theme') || 'dark';
    document.documentElement.setAttribute('data-theme', saved);
    document.body?.setAttribute('data-theme', saved);
    updateThemeToggle(saved);

    if (!document.documentElement.hasAttribute('data-theme')) {
      document.documentElement.setAttribute('data-theme', 'dark');
    }
  }

  function updateThemeToggle(theme) {
    const btn = document.getElementById('theme-toggle');
    if (btn) {
      btn.innerHTML = theme === 'dark' ? THEME_ICONS.light : THEME_ICONS.dark;
    }
  }

  function toggleTheme() {
    const current = document.documentElement.getAttribute('data-theme') || 'dark';
    const next = current === 'dark' ? 'light' : 'dark';

    document.documentElement.classList.add('theme-transitioning');

    document.documentElement.setAttribute('data-theme', next);
    document.body?.setAttribute('data-theme', next);
    localStorage.setItem('theme', next);
    updateThemeToggle(next);

    setTimeout(() => {
      document.documentElement.classList.remove('theme-transitioning');
    }, 300);
  }

  function createThemeToggle() {
    // Always remove existing theme toggle to ensure we have the right one
    const existingToggle = document.getElementById('theme-toggle');
    if (existingToggle) {
      existingToggle.remove();
    }

    // Also remove any other potential theme toggles
    document
      .querySelectorAll('[onclick*="toggleTheme"], [onclick*="theme"], .theme-toggle, .dark-mode-toggle')
      .forEach((el) => {
        if (el.id !== 'theme-toggle') {
          el.remove();
        }
      });

    const btn = document.createElement('button');
    btn.id = 'theme-toggle';
    btn.className = 'theme-toggle';
    btn.setAttribute('aria-label', 'Toggle theme');
    btn.setAttribute('data-handler-attached', 'true'); // Mark as having handler
    // Set onclick as a property to make it detectable by button utilities
    btn.onclick = function (e) {
      e.preventDefault();
      e.stopPropagation();
      toggleTheme();
    };
    // Also add as event listener for redundancy
    btn.addEventListener(
      'click',
      function (e) {
        e.preventDefault();
        e.stopPropagation();
        toggleTheme();
      },
      true,
    );
    btn.style.cssText = `
      position: fixed;
      top: 1rem;
      right: 1rem;
      z-index: 9999;
      padding: 0;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.3);
      background: rgba(0, 0, 0, 0.5);
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 48px;
      height: 48px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color: white;
    `;

    // Set initial icon based on current theme
    const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
    btn.innerHTML = currentTheme === 'dark' ? THEME_ICONS.light : THEME_ICONS.dark;

    btn.addEventListener('mouseenter', () => {
      btn.style.transform = 'scale(1.1)';
      btn.style.boxShadow = '0 6px 20px rgba(0,0,0,0.4)';
    });

    btn.addEventListener('mouseleave', () => {
      btn.style.transform = 'scale(1)';
      btn.style.boxShadow = '0 4px 15px rgba(0,0,0,0.3)';
    });

    btn.addEventListener('mousedown', () => {
      btn.style.transform = 'scale(0.95)';
    });

    btn.addEventListener('mouseup', () => {
      btn.style.transform = 'scale(1.1)';
    });

    document.body.appendChild(btn);
  }

  function injectStyles() {
    if (document.getElementById('dark-mode-fix-styles')) return;

    const style = document.createElement('style');
    style.id = 'dark-mode-fix-styles';
    style.textContent = `
      .theme-transitioning,
      .theme-transitioning * {
        transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease !important;
      }

      .theme-toggle {
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        background: rgba(0, 0, 0, 0.5) !important;
        border: 2px solid rgba(255, 255, 255, 0.2) !important;
      }

      .theme-toggle svg {
        width: 28px !important;
        height: 28px !important;
        min-width: 28px !important;
        min-height: 28px !important;
        display: block;
        color: white !important;
        fill: white !important;
      }

      :root,
      [data-theme="light"] {
        --bg-primary: #ffffff;
        --bg-secondary: #f3f4f6;
        --text-primary: #111827;
        --text-secondary: #6b7280;
        --border: #e5e7eb;
        --accent: #3b82f6;
        --color-bg: #ffffff;
        --color-surface: #f3f4f6;
        --color-text: #111827;
        --color-text-secondary: #6b7280;
      }

      [data-theme="dark"] {
        --bg-primary: #0B0E14;
        --bg-secondary: #151A24;
        --text-primary: #f1f5f9;
        --text-secondary: #94A3B8;
        --border: rgba(255, 255, 255, 0.1);
        --accent: #6366F1;
        --color-bg: #0B0E14;
        --color-surface: #151A24;
        --color-text: #f1f5f9;
        --color-text-secondary: #94A3B8;
      }

      body {
        background: var(--bg-primary) !important;
        color: var(--text-primary) !important;
      }

      body *:not(img) {
        color: inherit;
      }

      h1, h2, h3, h4, h5, h6 {
        color: var(--text-primary) !important;
      }

      p, span, div, section, article, main, aside, nav, header, footer {
        color: var(--text-primary);
      }

      a {
        color: var(--accent);
      }

      button, input, select, textarea {
        color: var(--text-primary);
        background-color: var(--bg-secondary);
      }

      .text, .content, .description, .title, .subtitle, .heading {
        color: var(--text-primary) !important;
      }

      .card, .panel, .modal, .dropdown {
        background: var(--bg-secondary);
        color: var(--text-primary);
      }

      *:not(svg):not(path):not(circle):not(rect)[style*="color: white"],
      *:not(svg):not(path):not(circle):not(rect)[style*="color:#fff"],
      *:not(svg):not(path):not(circle):not(rect)[style*="color: #ffffff"] {
        color: var(--text-primary) !important;
      }

      *:not(svg):not(path):not(circle):not(rect)[style*="color: black"],
      *:not(svg):not(path):not(circle):not(rect)[style*="color:#000"],
      *:not(svg):not(path):not(circle):not(rect)[style*="color: #000000"] {
        color: var(--text-primary) !important;
      }

      img {
        color: initial !important;
        max-width: 100%;
        height: auto;
      }

      /* Ensure SVG icons maintain proper size */
      svg {
        flex-shrink: 0;
      }

      header svg, nav svg, .header svg, .navigation svg {
        width: 24px;
        height: 24px;
        max-width: 24px;
        max-height: 24px;
      }
    `;

    document.head.appendChild(style);
  }

  function initialize() {
    injectStyles();
    initTheme();

    // Remove any existing theme toggles before creating ours
    document
      .querySelectorAll('#theme-toggle, .theme-toggle, [onclick*="toggleTheme"], [onclick*="theme"]')
      .forEach((el) => {
        el.remove();
      });

    createThemeToggle();
    const theme = localStorage.getItem('theme') || 'dark';
    updateThemeToggle(theme);

    document.documentElement.setAttribute('data-theme', theme);
    document.body?.setAttribute('data-theme', theme);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initialize);
  } else {
    initialize();
  }

  setTimeout(initialize, 100);
  setTimeout(initialize, 500);
  window.addEventListener('load', initialize);

  const observer = new MutationObserver(() => {
    const toggle = document.getElementById('theme-toggle');
    if (!toggle) {
      createThemeToggle();
    } else {
      // Ensure it has our icons
      const theme = localStorage.getItem('theme') || 'dark';
      const expectedIcon = theme === 'dark' ? THEME_ICONS.light : THEME_ICONS.dark;
      if (!toggle.innerHTML.includes('viewBox="0 0 50 50"') && !toggle.innerHTML.includes('M21 12.79A9')) {
        toggle.innerHTML = expectedIcon;
      }
    }
  });

  if (document.body) {
    observer.observe(document.body, {
      childList: true,
      subtree: false,
    });
  }

  window.themeSystem = {
    toggle: toggleTheme,
    init: initialize,
    setTheme: (theme) => {
      document.documentElement.setAttribute('data-theme', theme);
      localStorage.setItem('theme', theme);
      updateThemeToggle(theme);
    },
  };

  // Make toggle function globally available
  window.toggleTheme = toggleTheme;
})();
</file>

<file path="packages/ui-frontend/app/lib/templates/price-service.js">
// Price Service Template
// Fetches live cryptocurrency prices from multiple sources

export const priceServiceTemplate = `
// Price Service - Fetches live token prices
// /scripts/services/prices.js

class PriceService {
  constructor() {
    this.cache = new Map();
    this.cacheDuration = 30 * 1000; // 30 seconds
    this.websocket = null;
    this.priceSubscribers = new Set();
    this.supportedProviders = this.detectAvailableProviders();
  }

  detectAvailableProviders() {
    const providers = [];

    // Free tier providers (no API key needed)
    providers.push('coingecko-free');
    providers.push('coinpaprika');

    // API key based providers
    if (window.ENV?.COINGECKO_API_KEY) providers.push('coingecko-pro');
    if (window.ENV?.CRYPTOCOMPARE_API_KEY) providers.push('cryptocompare');
    if (window.ENV?.COINMARKETCAP_API_KEY) providers.push('coinmarketcap');
    if (window.ENV?.MESSARI_API_KEY) providers.push('messari');

    return providers;
  }

  async getPrices(symbols, vsCurrency = 'usd') {
    const prices = {};
    const toFetch = [];

    // Check cache first
    for (const symbol of symbols) {
      const cacheKey = \`\${symbol}-\${vsCurrency}\`;
      const cached = this.getFromCache(cacheKey);
      if (cached !== null) {
        prices[symbol] = cached;
      } else {
        toFetch.push(symbol);
      }
    }

    // Fetch missing prices
    if (toFetch.length > 0) {
      const fetched = await this.fetchPrices(toFetch, vsCurrency);
      Object.assign(prices, fetched);
    }

    return prices;
  }

  async fetchPrices(symbols, vsCurrency = 'usd') {
    // Try providers in order of preference
    for (const provider of this.supportedProviders) {
      try {
        switch (provider) {
          case 'coingecko-free':
            return await this.fetchFromCoinGecko(symbols, vsCurrency, false);
          case 'coingecko-pro':
            return await this.fetchFromCoinGecko(symbols, vsCurrency, true);
          case 'cryptocompare':
            return await this.fetchFromCryptoCompare(symbols, vsCurrency);
          case 'coinmarketcap':
            return await this.fetchFromCoinMarketCap(symbols, vsCurrency);
          case 'coinpaprika':
            return await this.fetchFromCoinpaprika(symbols, vsCurrency);
          case 'messari':
            return await this.fetchFromMessari(symbols, vsCurrency);
        }
      } catch (error) {
        console.warn(\`Price provider \${provider} failed, trying next...\`);
        continue;
      }
    }

    // If all fail, return demo prices
    return this.getDemoPrices(symbols);
  }

  async fetchFromCoinGecko(symbols, vsCurrency, usePro = false) {
    const ids = symbols.map(s => this.symbolToCoingeckoId(s)).join(',');
    const baseUrl = usePro
      ? 'https://pro-api.coingecko.com/api/v3'
      : 'https://api.coingecko.com/api/v3';

    let url = \`\${baseUrl}/simple/price?ids=\${ids}&vs_currencies=\${vsCurrency}&include_24hr_change=true&include_market_cap=true\`;

    const headers = {};
    if (usePro && window.ENV?.COINGECKO_API_KEY) {
      headers['x-cg-pro-api-key'] = window.ENV.COINGECKO_API_KEY;
    }

    const response = await fetch(url, { headers });
    if (!response.ok) throw new Error('CoinGecko API error');

    const data = await response.json();
    const prices = {};

    for (const symbol of symbols) {
      const id = this.symbolToCoingeckoId(symbol);
      if (data[id]) {
        const price = {
          price: data[id][vsCurrency],
          change24h: data[id][\`\${vsCurrency}_24h_change\`] || 0,
          marketCap: data[id][\`\${vsCurrency}_market_cap\`] || 0
        };
        prices[symbol] = price;
        this.setCache(\`\${symbol}-\${vsCurrency}\`, price);
      }
    }

    return prices;
  }

  async fetchFromCryptoCompare(symbols, vsCurrency) {
    const apiKey = window.ENV.CRYPTOCOMPARE_API_KEY;
    const fsyms = symbols.join(',');
    const tsyms = vsCurrency.toUpperCase();

    const url = \`https://min-api.cryptocompare.com/data/pricemultifull?fsyms=\${fsyms}&tsyms=\${tsyms}&api_key=\${apiKey}\`;

    const response = await fetch(url);
    if (!response.ok) throw new Error('CryptoCompare API error');

    const data = await response.json();
    const prices = {};

    if (data.RAW) {
      for (const symbol of symbols) {
        if (data.RAW[symbol] && data.RAW[symbol][tsyms]) {
          const raw = data.RAW[symbol][tsyms];
          const price = {
            price: raw.PRICE,
            change24h: raw.CHANGEPCT24HOUR || 0,
            marketCap: raw.MKTCAP || 0,
            volume24h: raw.VOLUME24HOUR || 0
          };
          prices[symbol] = price;
          this.setCache(\`\${symbol}-\${vsCurrency}\`, price);
        }
      }
    }

    return prices;
  }

  async fetchFromCoinMarketCap(symbols, vsCurrency) {
    const apiKey = window.ENV.COINMARKETCAP_API_KEY;
    const symbolString = symbols.join(',');

    const url = \`https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest?symbol=\${symbolString}&convert=\${vsCurrency.toUpperCase()}\`;

    const response = await fetch(url, {
      headers: {
        'X-CMC_PRO_API_KEY': apiKey,
        'Accept': 'application/json'
      }
    });

    if (!response.ok) throw new Error('CoinMarketCap API error');

    const data = await response.json();
    const prices = {};

    if (data.data) {
      for (const symbol of symbols) {
        if (data.data[symbol]) {
          const quote = data.data[symbol].quote[vsCurrency.toUpperCase()];
          const price = {
            price: quote.price,
            change24h: quote.percent_change_24h || 0,
            marketCap: quote.market_cap || 0,
            volume24h: quote.volume_24h || 0
          };
          prices[symbol] = price;
          this.setCache(\`\${symbol}-\${vsCurrency}\`, price);
        }
      }
    }

    return prices;
  }

  async fetchFromCoinpaprika(symbols, vsCurrency) {
    const prices = {};

    for (const symbol of symbols) {
      try {
        const id = this.symbolToCoinpaprikaId(symbol);
        const url = \`https://api.coinpaprika.com/v1/tickers/\${id}?quotes=\${vsCurrency.toUpperCase()}\`;

        const response = await fetch(url);
        if (!response.ok) continue;

        const data = await response.json();
        if (data.quotes && data.quotes[vsCurrency.toUpperCase()]) {
          const quote = data.quotes[vsCurrency.toUpperCase()];
          const price = {
            price: quote.price,
            change24h: quote.percent_change_24h || 0,
            marketCap: quote.market_cap || 0,
            volume24h: quote.volume_24h || 0
          };
          prices[symbol] = price;
          this.setCache(\`\${symbol}-\${vsCurrency}\`, price);
        }
      } catch (error) {
        console.warn(\`Failed to fetch \${symbol} from Coinpaprika\`);
      }
    }

    return prices;
  }

  async fetchFromMessari(symbols, vsCurrency) {
    const apiKey = window.ENV.MESSARI_API_KEY;
    const prices = {};

    for (const symbol of symbols) {
      try {
        const url = \`https://data.messari.io/api/v1/assets/\${symbol.toLowerCase()}/metrics/market-data\`;

        const response = await fetch(url, {
          headers: {
            'x-messari-api-key': apiKey
          }
        });

        if (!response.ok) continue;

        const data = await response.json();
        if (data.data && data.data.market_data) {
          const marketData = data.data.market_data;
          const price = {
            price: marketData.price_usd,
            change24h: marketData.percent_change_usd_last_24_hours || 0,
            marketCap: marketData.marketcap_current_usd || 0,
            volume24h: marketData.volume_last_24_hours || 0
          };
          prices[symbol] = price;
          this.setCache(\`\${symbol}-\${vsCurrency}\`, price);
        }
      } catch (error) {
        console.warn(\`Failed to fetch \${symbol} from Messari\`);
      }
    }

    return prices;
  }

  symbolToCoingeckoId(symbol) {
    const mapping = {
      'ETH': 'ethereum',
      'BTC': 'bitcoin',
      'USDC': 'usd-coin',
      'USDT': 'tether',
      'BNB': 'binancecoin',
      'SOL': 'solana',
      'MATIC': 'matic-network',
      'AVAX': 'avalanche-2',
      'LINK': 'chainlink',
      'UNI': 'uniswap',
      'AAVE': 'aave',
      'CRV': 'curve-dao-token'
    };
    return mapping[symbol.toUpperCase()] || symbol.toLowerCase();
  }

  symbolToCoinpaprikaId(symbol) {
    const mapping = {
      'ETH': 'eth-ethereum',
      'BTC': 'btc-bitcoin',
      'USDC': 'usdc-usd-coin',
      'USDT': 'usdt-tether',
      'BNB': 'bnb-binance-coin'
    };
    return mapping[symbol.toUpperCase()] || \`\${symbol.toLowerCase()}-\${symbol.toLowerCase()}\`;
  }

  getDemoPrices(symbols) {
    const basePrices = {
      'ETH': { price: 1850.25, change24h: 2.34, marketCap: 222000000000 },
      'BTC': { price: 35420.50, change24h: 3.12, marketCap: 690000000000 },
      'USDC': { price: 1.00, change24h: 0.01, marketCap: 24000000000 },
      'USDT': { price: 1.00, change24h: -0.02, marketCap: 91000000000 },
      'BNB': { price: 245.80, change24h: 1.56, marketCap: 37000000000 },
      'SOL': { price: 58.25, change24h: 5.43, marketCap: 24000000000 },
      'MATIC': { price: 0.85, change24h: -1.23, marketCap: 7900000000 }
    };

    const prices = {};
    for (const symbol of symbols) {
      if (basePrices[symbol.toUpperCase()]) {
        // Add some randomness to make it look live
        const base = basePrices[symbol.toUpperCase()];
        prices[symbol] = {
          price: base.price * (1 + (Math.random() - 0.5) * 0.02),
          change24h: base.change24h + (Math.random() - 0.5) * 0.5,
          marketCap: base.marketCap
        };
      } else {
        prices[symbol] = {
          price: Math.random() * 100,
          change24h: (Math.random() - 0.5) * 10,
          marketCap: Math.random() * 1000000000
        };
      }
    }

    return prices;
  }

  // Real-time price updates via WebSocket
  subscribeToRealtime(symbols, callback) {
    if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
      this.connectWebSocket();
    }

    // Store subscriber
    this.priceSubscribers.add({ symbols, callback });

    // Send subscription message
    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
      this.websocket.send(JSON.stringify({
        action: 'subscribe',
        symbols: symbols
      }));
    }
  }

  connectWebSocket() {
    // Use free WebSocket providers like Binance or Coinbase
    const wsUrl = 'wss://stream.binance.com:9443/ws';

    this.websocket = new WebSocket(wsUrl);

    this.websocket.onopen = () => {
      console.log('WebSocket connected for real-time prices');
      // Re-subscribe all existing subscriptions
      for (const subscriber of this.priceSubscribers) {
        this.websocket.send(JSON.stringify({
          method: 'SUBSCRIBE',
          params: subscriber.symbols.map(s => \`\${s.toLowerCase()}usdt@ticker\`),
          id: 1
        }));
      }
    };

    this.websocket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.e === '24hrTicker') {
        const symbol = data.s.replace('USDT', '');
        const price = {
          price: parseFloat(data.c),
          change24h: parseFloat(data.P),
          volume24h: parseFloat(data.v)
        };

        // Notify all subscribers
        for (const subscriber of this.priceSubscribers) {
          if (subscriber.symbols.includes(symbol)) {
            subscriber.callback({ [symbol]: price });
          }
        }
      }
    };

    this.websocket.onerror = (error) => {
      console.error('WebSocket error:', error);
    };

    this.websocket.onclose = () => {
      console.log('WebSocket disconnected');
      // Reconnect after 5 seconds
      setTimeout(() => this.connectWebSocket(), 5000);
    };
  }

  getFromCache(key) {
    const cached = this.cache.get(key);
    if (!cached) return null;

    if (Date.now() - cached.timestamp > this.cacheDuration) {
      this.cache.delete(key);
      return null;
    }

    return cached.data;
  }

  setCache(key, data) {
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  }

  clearCache() {
    this.cache.clear();
  }

  formatPrice(price, decimals = 2) {
    if (price >= 1000) {
      return price.toLocaleString('en-US', { maximumFractionDigits: decimals });
    } else if (price >= 1) {
      return price.toFixed(decimals);
    } else {
      return price.toFixed(Math.max(4, decimals));
    }
  }

  formatMarketCap(marketCap) {
    if (marketCap >= 1e12) {
      return '$' + (marketCap / 1e12).toFixed(2) + 'T';
    } else if (marketCap >= 1e9) {
      return '$' + (marketCap / 1e9).toFixed(2) + 'B';
    } else if (marketCap >= 1e6) {
      return '$' + (marketCap / 1e6).toFixed(2) + 'M';
    } else {
      return '$' + marketCap.toLocaleString();
    }
  }
}

// Export for use
const priceService = new PriceService();
window.priceService = priceService;
`;
</file>

<file path="packages/ui-frontend/app/lib/templates/testing-templates.js">
// Testing Templates for Quality Gates
// Provides unit tests, E2E tests, and CI/CD configurations

export const playwrightTestTemplate = `
// E2E Tests using Playwright
// /tests/e2e/app.spec.js

import { test, expect } from '@playwright/test';

test.describe('Web3 Application E2E Tests', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    await page.waitForLoadState('networkidle');
  });

  test('app loads successfully', async ({ page }) => {
    await expect(page).toHaveTitle(/Web3/);
    await expect(page.locator('body')).toBeVisible();
  });

  test('wallet connect button is visible and clickable', async ({ page }) => {
    const connectButton = page.locator('#connect-wallet, button:has-text("Connect Wallet")');
    await expect(connectButton).toBeVisible();
    await expect(connectButton).toBeEnabled();

    await connectButton.click();

    // Check if wallet modal opens (may vary based on implementation)
    const modal = page.locator('[role="dialog"], .wallet-modal, .w3m-modal');
    await expect(modal).toBeVisible({ timeout: 5000 });
  });

  test('navigation links work correctly', async ({ page }) => {
    const navLinks = [
      { text: 'Dashboard', url: '/' },
      { text: 'Wallets', url: '/wallets' },
      { text: 'Analytics', url: '/analytics' },
      { text: 'Settings', url: '/settings' }
    ];

    for (const link of navLinks) {
      const navLink = page.locator(\`a:has-text("\${link.text}")\`);
      if (await navLink.isVisible()) {
        await navLink.click();
        await page.waitForLoadState('networkidle');

        // Check URL or page content changed
        if (link.url !== '/') {
          const url = page.url();
          expect(url).toContain(link.url.replace('/', ''));
        }
      }
    }
  });

  test('no inline styles in HTML', async ({ page }) => {
    const html = await page.content();

    // Check for <style> tags in HTML
    expect(html).not.toMatch(/<style[^>]*>[\s\S]*?<\/style>/i);

    // Check that styles.css is linked
    const stylesLink = page.locator('link[href*="styles.css"]');
    await expect(stylesLink).toHaveCount(1);
  });

  test('theme toggle works', async ({ page }) => {
    const themeToggle = page.locator('#theme-toggle, button[aria-label*="theme"]');

    if (await themeToggle.isVisible()) {
      // Get initial theme
      const initialTheme = await page.evaluate(() =>
        document.documentElement.getAttribute('data-theme')
      );

      // Click toggle
      await themeToggle.click();

      // Check theme changed
      const newTheme = await page.evaluate(() =>
        document.documentElement.getAttribute('data-theme')
      );

      expect(newTheme).not.toBe(initialTheme);
    }
  });

  test('demo mode banner appears when no env configured', async ({ page }) => {
    // Check if demo banner is present
    const demoBanner = page.locator('.demo-banner, [class*="demo-mode"]');

    // This should be visible if no env vars are configured
    if (await demoBanner.isVisible()) {
      await expect(demoBanner).toContainText(/demo/i);
    }
  });

  test('all required files exist', async ({ page }) => {
    const requiredFiles = [
      '/index.html',
      '/styles.css',
      '/.env.example'
    ];

    for (const file of requiredFiles) {
      const response = await page.request.get(file);
      expect(response.status()).toBeLessThan(400);
    }
  });

  test('responsive design works', async ({ page }) => {
    // Test mobile viewport
    await page.setViewportSize({ width: 375, height: 667 });
    await page.reload();

    const mobileMenu = page.locator('.mobile-menu, [class*="burger"], [aria-label*="menu"]');
    if (await mobileMenu.isVisible()) {
      await expect(mobileMenu).toBeVisible();
    }

    // Test desktop viewport
    await page.setViewportSize({ width: 1920, height: 1080 });
    await page.reload();

    const desktopNav = page.locator('nav, .navbar');
    await expect(desktopNav).toBeVisible();
  });

  test('wallet address formatting works', async ({ page }) => {
    // Look for any wallet address displays
    const addressElements = page.locator('[class*="address"], [data-testid*="address"]');

    const count = await addressElements.count();
    for (let i = 0; i < count; i++) {
      const text = await addressElements.nth(i).textContent();

      // Check if it's a formatted address (0x1234...5678)
      if (text && text.includes('0x')) {
        expect(text).toMatch(/0x[a-fA-F0-9]{4}\.{2,3}[a-fA-F0-9]{4}/);
      }
    }
  });
});

test.describe('Performance Tests', () => {
  test('page loads within acceptable time', async ({ page }) => {
    const startTime = Date.now();

    await page.goto('/');
    await page.waitForLoadState('networkidle');

    const loadTime = Date.now() - startTime;
    expect(loadTime).toBeLessThan(3000); // 3 seconds max
  });

  test('no console errors', async ({ page }) => {
    const errors = [];

    page.on('console', msg => {
      if (msg.type() === 'error') {
        errors.push(msg.text());
      }
    });

    await page.goto('/');
    await page.waitForLoadState('networkidle');

    // Some errors might be acceptable (like failed external resources in demo mode)
    const criticalErrors = errors.filter(error =>
      !error.includes('Failed to load resource') &&
      !error.includes('404') &&
      !error.includes('demo')
    );

    expect(criticalErrors).toHaveLength(0);
  });
});
`;

export const unitTestTemplate = `
// Unit Tests for Services
// /tests/unit/services.test.js

import { describe, it, expect, beforeEach, vi } from 'vitest';

describe('PriceService', () => {
  let priceService;

  beforeEach(() => {
    // Reset service
    global.window = { ENV: {} };
    priceService = new PriceService();
  });

  it('should format prices correctly', () => {
    expect(priceService.formatPrice(1850.2534)).toBe('1850.25');
    expect(priceService.formatPrice(0.00045678)).toBe('0.0005');
    expect(priceService.formatPrice(35420)).toBe('35,420.00');
  });

  it('should format market cap correctly', () => {
    expect(priceService.formatMarketCap(1500000000)).toBe('$1.50B');
    expect(priceService.formatMarketCap(250000000000)).toBe('$250.00B');
    expect(priceService.formatMarketCap(1200000000000)).toBe('$1.20T');
  });

  it('should cache prices correctly', async () => {
    const mockPrice = { price: 1850, change24h: 2.5, marketCap: 200000000000 };

    priceService.setCache('ETH-usd', mockPrice);
    const cached = priceService.getFromCache('ETH-usd');

    expect(cached).toEqual(mockPrice);
  });

  it('should return demo prices when no API configured', async () => {
    const prices = await priceService.getPrices(['ETH', 'BTC']);

    expect(prices).toHaveProperty('ETH');
    expect(prices).toHaveProperty('BTC');
    expect(prices.ETH.price).toBeGreaterThan(0);
  });

  it('should handle API errors gracefully', async () => {
    global.fetch = vi.fn().mockRejectedValue(new Error('API Error'));

    const prices = await priceService.getPrices(['ETH']);

    // Should fall back to demo prices
    expect(prices).toHaveProperty('ETH');
    expect(prices.ETH.price).toBeGreaterThan(0);
  });
});

describe('PortfolioService', () => {
  let portfolioService;

  beforeEach(() => {
    global.window = { ENV: {} };
    portfolioService = new PortfolioService();
  });

  it('should detect available indexers', () => {
    global.window.ENV = {
      COVALENT_API_KEY: 'test-key',
      MORALIS_API_KEY: 'test-key'
    };

    portfolioService = new PortfolioService();
    expect(portfolioService.supportedIndexers).toContain('covalent');
    expect(portfolioService.supportedIndexers).toContain('moralis');
  });

  it('should format balances correctly', () => {
    const formatted = portfolioService.formatBalance('1000000000000000000', 18);
    expect(formatted).toBe('1.0000');
  });

  it('should return demo portfolio when no address provided', async () => {
    const portfolio = await portfolioService.getPortfolio(null);

    expect(Array.isArray(portfolio)).toBe(true);
    expect(portfolio.length).toBeGreaterThan(0);
    expect(portfolio[0]).toHaveProperty('symbol');
    expect(portfolio[0]).toHaveProperty('balance');
  });

  it('should cache portfolio data', async () => {
    const mockPortfolio = [
      { symbol: 'ETH', balance: '2.5', valueUSD: 4625 }
    ];

    portfolioService.setCache('portfolio-0x123-1', mockPortfolio);
    const cached = portfolioService.getFromCache('portfolio-0x123-1');

    expect(cached).toEqual(mockPortfolio);
  });
});

describe('Web3Service', () => {
  let web3Service;

  beforeEach(() => {
    global.window = { ENV: {}, localStorage: new Map() };
    global.document = {
      getElementById: vi.fn(),
      title: 'Test App',
      documentElement: { getAttribute: vi.fn() }
    };
  });

  it('should detect demo mode correctly', () => {
    web3Service = new Web3Service();
    expect(web3Service.isDemo).toBe(true);

    global.window.ENV.WALLETCONNECT_PROJECT_ID = 'real-project-id';
    web3Service = new Web3Service();
    expect(web3Service.isDemo).toBe(false);
  });

  it('should format addresses correctly', () => {
    web3Service = new Web3Service();

    expect(web3Service.formatAddress('0x1234567890123456789012345678901234567890'))
      .toBe('0x1234...7890');

    expect(web3Service.formatAddress(null)).toBe('');
  });

  it('should get chain name correctly', () => {
    web3Service = new Web3Service();

    expect(web3Service.getChainName(1)).toBe('Ethereum');
    expect(web3Service.getChainName(137)).toBe('Polygon');
    expect(web3Service.getChainName(999)).toBe('Unknown');
  });
});

describe('Validator', () => {
  let validator;

  beforeEach(() => {
    validator = new ArtifactValidator();
  });

  it('should detect inline styles', () => {
    const files = {
      'index.html': {
        type: 'file',
        content: '<html><head><style>body{}</style></head></html>'
      }
    };

    const result = validator.validateGeneratedArtifact(files);

    expect(result.success).toBe(false);
    expect(result.errors).toContain('Found inline <style> tags in HTML - all styles must be in styles.css');
  });

  it('should validate required files', () => {
    const files = {};

    const result = validator.validateGeneratedArtifact(files);

    expect(result.success).toBe(false);
    expect(result.errors).toContain('Missing required index.html file');
    expect(result.errors).toContain('Missing required styles.css file');
  });

  it('should validate page manifest', () => {
    const files = {
      'index.html': { type: 'file', content: '<html></html>' },
      'styles.css': { type: 'file', content: ':root{}' }
    };

    const manifest = {
      pages: [
        { slug: 'index', title: 'Home', route: '/' },
        { slug: 'wallets', title: 'Wallets', route: '/wallets' }
      ],
      router: 'mpa',
      features: []
    };

    const result = validator.validateGeneratedArtifact(files, manifest);

    expect(result.errors).toContain('Missing page file for route: /wallets (expected /pages/wallets.html)');
  });
});
`;

export const cicdTemplate = `
# GitHub Actions CI/CD Configuration
# /.github/workflows/ci.yml

name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  validate:
    name: Validate Generated App
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Check for inline styles
      run: |
        if grep -r '<style>' --include="*.html" .; then
          echo " Found inline styles in HTML files"
          exit 1
        fi
        echo " No inline styles found"

    - name: Verify required files
      run: |
        files=("index.html" "styles.css" ".env.example")
        for file in "\${files[@]}"; do
          if [ ! -f "$file" ]; then
            echo " Missing required file: $file"
            exit 1
          fi
        done
        echo " All required files present"

    - name: Validate CSS variables
      run: |
        if ! grep -q ':root' styles.css; then
          echo " Missing :root CSS variables in styles.css"
          exit 1
        fi
        echo " CSS variables found"

    - name: Check wallet configuration
      run: |
        if ! grep -q 'WALLETCONNECT_PROJECT_ID' .env.example; then
          echo " Missing WALLETCONNECT_PROJECT_ID in .env.example"
          exit 1
        fi
        echo " Environment configuration valid"

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: validate

    steps:
    - uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run unit tests
      run: npm run test:unit

    - name: Run linter
      run: npm run lint || true

    - name: Install Playwright
      run: npx playwright install --with-deps

    - name: Run E2E tests
      run: npm run test:e2e

    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: test-results
        path: test-results/

  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: test

    steps:
    - uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Build application
      run: npm run build
      env:
        NODE_ENV: production

    - name: Check build output
      run: |
        if [ ! -d "dist" ] && [ ! -d "build" ]; then
          echo " No build output found"
          exit 1
        fi
        echo " Build successful"

    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: build-output
        path: |
          dist/
          build/

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'

    steps:
    - uses: actions/checkout@v3

    - name: Download build artifacts
      uses: actions/download-artifact@v3
      with:
        name: build-output

    - name: Deploy to Vercel
      env:
        VERCEL_TOKEN: \${{ secrets.VERCEL_TOKEN }}
      run: |
        npx vercel --prod --token=$VERCEL_TOKEN

    # Alternative: Deploy to Netlify
    # - name: Deploy to Netlify
    #   uses: nwtgck/actions-netlify@v2.0
    #   with:
    #     publish-dir: './dist'
    #     production-deploy: true
    #   env:
    #     NETLIFY_AUTH_TOKEN: \${{ secrets.NETLIFY_AUTH_TOKEN }}
    #     NETLIFY_SITE_ID: \${{ secrets.NETLIFY_SITE_ID }}
`;

export const packageJsonTestScripts = `
{
  "scripts": {
    "test": "npm run test:unit && npm run test:e2e",
    "test:unit": "vitest run",
    "test:unit:watch": "vitest watch",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx",
    "lint:fix": "eslint . --ext .js,.jsx,.ts,.tsx --fix",
    "validate": "node scripts/validate-artifact.js",
    "ci": "npm run lint && npm run test && npm run build"
  },
  "devDependencies": {
    "@playwright/test": "^1.40.0",
    "vitest": "^1.0.0",
    "eslint": "^8.50.0",
    "@vitest/ui": "^1.0.0"
  }
}
`;
</file>

<file path="packages/ui-frontend/app/lib/templates/wallet-connection-fix.js">
/**
 * Enhanced Wallet Connection Manager
 * Fixes auto-connect issues and dark mode contrast problems
 */

// Global state to prevent duplicate connection requests
window.walletConnectionState = {
  isConnecting: false,
  isConnected: false,
  account: null,
  pendingRequest: null,
  connectionTimer: null,
};

/**
 * Safely connect wallet with duplicate request prevention
 */
async function connectWalletSafely(buttonElement = null) {
  const state = window.walletConnectionState;

  // Check if already connecting
  if (state.isConnecting) {
    console.warn('Wallet connection already in progress. Please wait...');
    showToast('Connection already in progress. Please wait...', 'warning');
    return null;
  }

  // Check if already connected
  if (state.isConnected && state.account) {
    console.log('Wallet already connected:', state.account);
    showToast(`Already connected: ${state.account.slice(0, 6)}...${state.account.slice(-4)}`, 'info');
    return state.account;
  }

  // Check if MetaMask is installed
  if (typeof window.ethereum === 'undefined') {
    showToast('Please install MetaMask to connect your wallet', 'error');
    window.open('https://metamask.io/download/', '_blank');
    return null;
  }

  try {
    // Set connecting state
    state.isConnecting = true;

    // Update button if provided
    if (buttonElement) {
      buttonElement.disabled = true;
      buttonElement.textContent = 'Connecting...';
      buttonElement.style.opacity = '0.7';
    }

    // Clear any existing pending requests
    if (state.pendingRequest) {
      try {
        state.pendingRequest.abort();
      } catch (e) {
        // Ignore abort errors
      }
      state.pendingRequest = null;
    }

    // Set a timeout for the connection
    const timeoutPromise = new Promise((_, reject) => {
      state.connectionTimer = setTimeout(() => {
        reject(new Error('Connection timeout'));
      }, 30000); // 30 second timeout
    });

    // Request accounts with timeout
    const accountsPromise = window.ethereum.request({
      method: 'eth_requestAccounts',
    });

    const accounts = await Promise.race([accountsPromise, timeoutPromise]);

    // Clear timeout
    if (state.connectionTimer) {
      clearTimeout(state.connectionTimer);
      state.connectionTimer = null;
    }

    if (accounts && accounts.length > 0) {
      const account = accounts[0];
      state.account = account;
      state.isConnected = true;

      showToast(`Connected: ${account.slice(0, 6)}...${account.slice(-4)}`, 'success');

      // Update button if provided
      if (buttonElement) {
        buttonElement.textContent = `${account.slice(0, 6)}...${account.slice(-4)}`;
        buttonElement.style.backgroundColor = 'var(--color-success, #10b981)';
      }

      // Listen for account changes
      window.ethereum.on('accountsChanged', handleAccountsChanged);
      window.ethereum.on('chainChanged', handleChainChanged);

      return account;
    } else {
      throw new Error('No accounts found');
    }
  } catch (error) {
    console.error('Wallet connection error:', error);

    // Clear timeout if still active
    if (state.connectionTimer) {
      clearTimeout(state.connectionTimer);
      state.connectionTimer = null;
    }

    // Handle specific errors
    if (error.code === -32002) {
      showToast('Please check MetaMask - a connection request is already pending', 'warning');
    } else if (error.message === 'Connection timeout') {
      showToast('Connection timeout. Please try again.', 'error');
    } else if (error.code === 4001) {
      showToast('Connection rejected. Please try again when ready.', 'info');
    } else {
      showToast(`Connection failed: ${error.message}`, 'error');
    }

    // Reset button if provided
    if (buttonElement) {
      buttonElement.textContent = 'Connect Wallet';
      buttonElement.style.backgroundColor = '';
    }

    return null;
  } finally {
    // Always reset connecting state
    state.isConnecting = false;

    // Re-enable button
    if (buttonElement) {
      buttonElement.disabled = false;
      buttonElement.style.opacity = '1';
    }
  }
}

/**
 * Disconnect wallet
 */
function disconnectWallet(buttonElement = null) {
  const state = window.walletConnectionState;

  state.isConnected = false;
  state.account = null;
  state.pendingRequest = null;

  // Remove listeners
  if (window.ethereum && window.ethereum.removeListener) {
    window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
    window.ethereum.removeListener('chainChanged', handleChainChanged);
  }

  // Update button if provided
  if (buttonElement) {
    buttonElement.textContent = 'Connect Wallet';
    buttonElement.style.backgroundColor = '';
  }

  showToast('Wallet disconnected', 'info');
}

/**
 * Handle account changes
 */
function handleAccountsChanged(accounts) {
  const state = window.walletConnectionState;

  if (accounts.length === 0) {
    // User disconnected wallet
    disconnectWallet();
  } else if (accounts[0] !== state.account) {
    // User switched accounts
    state.account = accounts[0];
    showToast(`Account changed: ${accounts[0].slice(0, 6)}...${accounts[0].slice(-4)}`, 'info');

    // Update any connect buttons
    document.querySelectorAll('.wallet-connect-btn').forEach((btn) => {
      if (btn.textContent.includes('0x')) {
        btn.textContent = `${accounts[0].slice(0, 6)}...${accounts[0].slice(-4)}`;
      }
    });
  }
}

/**
 * Handle chain changes
 */
function handleChainChanged(chainId) {
  // Reload the page as recommended by MetaMask
  window.location.reload();
}

/**
 * Check if wallet is already connected (for page refresh)
 */
async function checkExistingConnection() {
  if (typeof window.ethereum === 'undefined') {
    return null;
  }

  try {
    const accounts = await window.ethereum.request({
      method: 'eth_accounts',
    });

    if (accounts && accounts.length > 0) {
      const state = window.walletConnectionState;
      state.account = accounts[0];
      state.isConnected = true;

      // Update any connect buttons
      document.querySelectorAll('.wallet-connect-btn').forEach((btn) => {
        btn.textContent = `${accounts[0].slice(0, 6)}...${accounts[0].slice(-4)}`;
        btn.style.backgroundColor = 'var(--color-success, #10b981)';
      });

      // Listen for changes
      window.ethereum.on('accountsChanged', handleAccountsChanged);
      window.ethereum.on('chainChanged', handleChainChanged);

      return accounts[0];
    }
  } catch (error) {
    console.error('Error checking existing connection:', error);
  }

  return null;
}

/**
 * Fix wallet button contrast for dark mode
 */
function fixWalletButtonContrast() {
  // Add CSS to ensure wallet buttons are always visible
  if (!document.getElementById('wallet-contrast-fix')) {
    const style = document.createElement('style');
    style.id = 'wallet-contrast-fix';
    style.textContent = `
      /* Fix wallet button contrast in dark mode */
      .wallet-connect-btn,
      button[class*="connect"],
      button[class*="wallet"],
      [class*="connect-wallet"],
      [class*="wallet-connect"],
      [class*="connect-button"] {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
        color: white !important;
        border: none !important;
        padding: 12px 24px !important;
        border-radius: 8px !important;
        font-weight: 600 !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
        min-height: 44px !important;
      }

      .wallet-connect-btn:hover:not(:disabled),
      button[class*="connect"]:hover:not(:disabled),
      button[class*="wallet"]:hover:not(:disabled) {
        transform: translateY(-2px) !important;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4) !important;
      }

      .wallet-connect-btn:disabled,
      button[class*="connect"]:disabled,
      button[class*="wallet"]:disabled {
        cursor: not-allowed !important;
        opacity: 0.7 !important;
      }

      /* Ensure text is always white */
      .wallet-connect-btn *,
      button[class*="connect"] *,
      button[class*="wallet"] * {
        color: white !important;
      }

      /* Connected state */
      .wallet-connected,
      button[class*="connect"].connected {
        background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important;
      }

      /* Dark mode specific overrides */
      [data-theme="dark"] .wallet-connect-btn,
      .dark .wallet-connect-btn,
      html.dark button[class*="connect"],
      html.dark button[class*="wallet"] {
        background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%) !important;
        color: white !important;
        box-shadow: 0 2px 8px rgba(168, 85, 247, 0.3) !important;
      }
    `;
    document.head.appendChild(style);
  }
}

/**
 * Enhanced wallet button click handler
 */
function setupWalletButtons() {
  // Find all wallet connect buttons
  const walletButtons = document.querySelectorAll(
    'button[class*="connect"], button[class*="wallet"], .wallet-connect-btn, [onclick*="ethereum"], [onclick*="wallet"]',
  );

  walletButtons.forEach((button) => {
    // Add class for styling
    if (!button.classList.contains('wallet-connect-btn')) {
      button.classList.add('wallet-connect-btn');
    }

    // Remove any existing onclick to prevent auto-connect
    button.onclick = null;
    button.removeAttribute('onclick');

    // Add safe click handler
    button.addEventListener('click', async (e) => {
      e.preventDefault();
      e.stopPropagation();

      const state = window.walletConnectionState;

      if (state.isConnected) {
        // If connected, disconnect
        const confirmDisconnect = confirm('Disconnect wallet?');
        if (confirmDisconnect) {
          disconnectWallet(button);
        }
      } else {
        // Connect wallet
        await connectWalletSafely(button);
      }
    });
  });
}

/**
 * Initialize wallet connection manager
 */
function initializeWalletManager() {
  // Fix contrast first
  fixWalletButtonContrast();

  // Setup wallet buttons
  setupWalletButtons();

  // Check for existing connection (but don't auto-connect)
  checkExistingConnection();

  // Re-setup buttons when DOM changes
  const observer = new MutationObserver(() => {
    setupWalletButtons();
  });

  observer.observe(document.body, {
    childList: true,
    subtree: true,
  });
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeWalletManager);
} else {
  initializeWalletManager();
}

// Also initialize after a delay to catch any late-loading elements
setTimeout(initializeWalletManager, 1000);

// Export functions for global use
window.walletManager = {
  connect: connectWalletSafely,
  disconnect: disconnectWallet,
  checkConnection: checkExistingConnection,
  getAccount: () => window.walletConnectionState.account,
  isConnected: () => window.walletConnectionState.isConnected,
};

// Helper function for toast notifications (if not already defined)
if (typeof showToast === 'undefined') {
  window.showToast = function (message, type = 'info') {
    console.log(`[${type.toUpperCase()}] ${message}`);

    // Create simple toast if no toast system exists
    const toast = document.createElement('div');
    toast.style.cssText = `
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: ${type === 'error' ? '#ef4444' : type === 'success' ? '#10b981' : type === 'warning' ? '#f59e0b' : '#3b82f6'};
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      z-index: 10000;
      animation: slideIn 0.3s ease;
    `;
    toast.textContent = message;
    document.body.appendChild(toast);

    setTimeout(() => {
      toast.style.animation = 'slideOut 0.3s ease';
      setTimeout(() => toast.remove(), 300);
    }, 3000);
  };
}
</file>

<file path="packages/ui-frontend/app/lib/templates/web3-react.tsx">
// Web3 Service Template for React
// Using wagmi + viem + Reown AppKit

export const web3ReactTemplate = `
// Web3 Configuration for React
// /src/lib/web3.ts

import { createAppKit } from '@reown/appkit/react';
import { WagmiAdapter } from '@reown/appkit-adapter-wagmi';
import { mainnet, polygon, arbitrum, optimism, base } from 'viem/chains';
import { QueryClient } from '@tanstack/react-query';
import { http, createConfig } from 'wagmi';

const queryClient = new QueryClient();

const projectId = import.meta.env.VITE_WALLETCONNECT_PROJECT_ID || 'demo-project-id';

const metadata = {
  name: 'Web3 Application',
  description: 'Production-ready Web3 app with wallet connection',
  url: window.location.origin,
  icons: ['/logo.png']
};

const chains = [mainnet, polygon, arbitrum, optimism, base] as const;

const wagmiAdapter = new WagmiAdapter({
  chains,
  transports: {
    [mainnet.id]: http(import.meta.env.VITE_RPC_URL_MAINNET || 'https://eth.llamarpc.com'),
    [polygon.id]: http(import.meta.env.VITE_RPC_URL_POLYGON || 'https://polygon-rpc.com'),
    [arbitrum.id]: http(import.meta.env.VITE_RPC_URL_ARBITRUM || 'https://arb1.arbitrum.io/rpc'),
    [optimism.id]: http(import.meta.env.VITE_RPC_URL_OPTIMISM || 'https://mainnet.optimism.io'),
    [base.id]: http(import.meta.env.VITE_RPC_URL_BASE || 'https://mainnet.base.org')
  },
  projectId
});

createAppKit({
  adapters: [wagmiAdapter],
  projectId,
  chains,
  metadata,
  features: {
    analytics: true,
    email: false,
    socials: false
  },
  themeMode: 'light',
  themeVariables: {
    '--w3m-accent': '#6366F1',
    '--w3m-border-radius-master': '12px'
  }
});

export { wagmiAdapter, queryClient };

// /src/hooks/useWeb3.ts
import { useAccount, useBalance, useDisconnect, useChainId, useSwitchChain } from 'wagmi';
import { formatEther } from 'viem';
import { useState, useEffect } from 'react';

export interface Web3State {
  address?: string;
  chainId?: number;
  balance?: string;
  isConnected: boolean;
  isConnecting: boolean;
  isDemo: boolean;
}

export function useWeb3() {
  const { address, isConnected, isConnecting } = useAccount();
  const chainId = useChainId();
  const { disconnect } = useDisconnect();
  const { switchChain } = useSwitchChain();
  const { data: balanceData } = useBalance({ address });

  const [isDemo] = useState(!import.meta.env.VITE_WALLETCONNECT_PROJECT_ID);

  const balance = balanceData ? formatEther(balanceData.value) : undefined;

  const formatAddress = (addr?: string) => {
    if (!addr) return '';
    return addr.slice(0, 6) + '...' + addr.slice(-4);
  };

  const handleSwitchNetwork = async (newChainId: number) => {
    try {
      await switchChain({ chainId: newChainId });
    } catch (error) {
      console.error('Failed to switch network:', error);
    }
  };

  return {
    address,
    chainId,
    balance,
    isConnected,
    isConnecting,
    isDemo,
    disconnect,
    switchNetwork: handleSwitchNetwork,
    formatAddress
  };
}

// /src/components/ConnectButton.tsx
import React from 'react';
import { useAppKit } from '@reown/appkit/react';
import { useWeb3 } from '../hooks/useWeb3';

export function ConnectButton() {
  const { open } = useAppKit();
  const { address, isConnected, disconnect, formatAddress, isDemo } = useWeb3();

  const handleClick = () => {
    if (isConnected) {
      disconnect();
    } else {
      open();
    }
  };

  return (
    <>
      {isDemo && (
        <div className="demo-banner">
          Demo Mode - Configure VITE_WALLETCONNECT_PROJECT_ID for live connections
        </div>
      )}
      <button
        onClick={handleClick}
        className="btn btn-primary connect-wallet"
      >
        {isConnected && address ? formatAddress(address) : 'Connect Wallet'}
      </button>
    </>
  );
}

// /src/components/NetworkSelector.tsx
import React from 'react';
import { useWeb3 } from '../hooks/useWeb3';

const networks = [
  { id: 1, name: 'Ethereum', icon: '' },
  { id: 137, name: 'Polygon', icon: '' },
  { id: 42161, name: 'Arbitrum', icon: '' },
  { id: 10, name: 'Optimism', icon: '' },
  { id: 8453, name: 'Base', icon: '' }
];

export function NetworkSelector() {
  const { chainId, switchNetwork, isConnected } = useWeb3();

  if (!isConnected) return null;

  return (
    <select
      value={chainId}
      onChange={(e) => switchNetwork(Number(e.target.value))}
      className="network-selector"
    >
      {networks.map((network) => (
        <option key={network.id} value={network.id}>
          {network.name}
        </option>
      ))}
    </select>
  );
}

// /src/services/portfolio.ts
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';

export interface TokenBalance {
  symbol: string;
  name: string;
  balance: string;
  valueUSD: number;
  price: number;
}

export class PortfolioService {
  private client;
  private cache = new Map<string, { data: any; timestamp: number }>();
  private cacheDuration = 60 * 1000; // 1 minute

  constructor() {
    this.client = createPublicClient({
      chain: mainnet,
      transport: http(import.meta.env.VITE_RPC_URL_MAINNET)
    });
  }

  async getTokenBalances(address: string): Promise<TokenBalance[]> {
    const cacheKey = \`balances-\${address}\`;
    const cached = this.getFromCache(cacheKey);
    if (cached) return cached;

    try {
      // Use a token indexer API like Covalent, Alchemy, or Moralis
      const response = await this.fetchFromIndexer(address);
      const balances = this.parseTokenBalances(response);

      this.setCache(cacheKey, balances);
      return balances;
    } catch (error) {
      console.error('Failed to fetch token balances:', error);
      return this.getDemoBalances();
    }
  }

  private async fetchFromIndexer(address: string) {
    const apiKey = import.meta.env.VITE_COVALENT_API_KEY;
    if (!apiKey) return this.getDemoBalances();

    const url = \`https://api.covalenthq.com/v1/1/address/\${address}/balances_v2/?key=\${apiKey}\`;
    const response = await fetch(url);
    return response.json();
  }

  private parseTokenBalances(data: any): TokenBalance[] {
    if (!data?.data?.items) return [];

    return data.data.items
      .filter((item: any) => item.balance > 0)
      .map((item: any) => ({
        symbol: item.contract_ticker_symbol,
        name: item.contract_name,
        balance: (Number(item.balance) / Math.pow(10, item.contract_decimals)).toFixed(4),
        valueUSD: item.quote || 0,
        price: item.quote_rate || 0
      }));
  }

  private getDemoBalances(): TokenBalance[] {
    return [
      { symbol: 'ETH', name: 'Ethereum', balance: '2.4567', valueUSD: 4500, price: 1832.45 },
      { symbol: 'USDC', name: 'USD Coin', balance: '1250.00', valueUSD: 1250, price: 1.00 },
      { symbol: 'WBTC', name: 'Wrapped Bitcoin', balance: '0.0543', valueUSD: 2150, price: 39592.12 }
    ];
  }

  private getFromCache(key: string) {
    const cached = this.cache.get(key);
    if (!cached) return null;

    if (Date.now() - cached.timestamp > this.cacheDuration) {
      this.cache.delete(key);
      return null;
    }

    return cached.data;
  }

  private setCache(key: string, data: any) {
    this.cache.set(key, { data, timestamp: Date.now() });
  }
}

// /src/services/prices.ts
export class PriceService {
  private cache = new Map<string, { price: number; timestamp: number }>();
  private cacheDuration = 30 * 1000; // 30 seconds

  async getTokenPrices(symbols: string[]): Promise<Record<string, number>> {
    const prices: Record<string, number> = {};
    const toFetch: string[] = [];

    for (const symbol of symbols) {
      const cached = this.getFromCache(symbol);
      if (cached) {
        prices[symbol] = cached;
      } else {
        toFetch.push(symbol);
      }
    }

    if (toFetch.length > 0) {
      const fetched = await this.fetchPrices(toFetch);
      Object.assign(prices, fetched);
    }

    return prices;
  }

  private async fetchPrices(symbols: string[]): Promise<Record<string, number>> {
    try {
      const ids = symbols.map(s => this.symbolToCoingeckoId(s)).join(',');
      const url = \`https://api.coingecko.com/api/v3/simple/price?ids=\${ids}&vs_currencies=usd\`;

      const response = await fetch(url);
      const data = await response.json();

      const prices: Record<string, number> = {};
      for (const symbol of symbols) {
        const id = this.symbolToCoingeckoId(symbol);
        if (data[id]) {
          prices[symbol] = data[id].usd;
          this.setCache(symbol, data[id].usd);
        }
      }

      return prices;
    } catch (error) {
      console.error('Failed to fetch prices:', error);
      return this.getDemoPrices(symbols);
    }
  }

  private symbolToCoingeckoId(symbol: string): string {
    const mapping: Record<string, string> = {
      'ETH': 'ethereum',
      'BTC': 'bitcoin',
      'USDC': 'usd-coin',
      'USDT': 'tether',
      'MATIC': 'matic-network'
    };
    return mapping[symbol.toUpperCase()] || symbol.toLowerCase();
  }

  private getDemoPrices(symbols: string[]): Record<string, number> {
    const basePrices: Record<string, number> = {
      'ETH': 1850 + Math.random() * 100,
      'BTC': 35000 + Math.random() * 1000,
      'USDC': 1.00,
      'USDT': 1.00
    };

    const prices: Record<string, number> = {};
    for (const symbol of symbols) {
      prices[symbol] = basePrices[symbol] || Math.random() * 100;
    }
    return prices;
  }

  private getFromCache(symbol: string): number | null {
    const cached = this.cache.get(symbol);
    if (!cached) return null;

    if (Date.now() - cached.timestamp > this.cacheDuration) {
      this.cache.delete(symbol);
      return null;
    }

    return cached.price;
  }

  private setCache(symbol: string, price: number) {
    this.cache.set(symbol, { price, timestamp: Date.now() });
  }
}
`;
</file>

<file path="packages/ui-frontend/app/lib/webcontainer/ensure-dev-headers.ts">
import type { WebContainer } from '@webcontainer/api';

async function readText(webcontainer: WebContainer, path: string) {
  try {
    return await webcontainer.fs.readFile(path, 'utf-8');
  } catch {
    return undefined;
  }
}

async function fileExists(webcontainer: WebContainer, path: string) {
  try {
    await webcontainer.fs.readFile(path);
    return true;
  } catch {
    return false;
  }
}

export async function ensureDevHeaders(webcontainer: WebContainer) {
  const candidates = ['vite.config.ts', 'vite.config.js', 'vite.config.mjs', 'vite.config.cjs'];

  let configPath: string | undefined;

  for (const path of candidates) {
    if (await fileExists(webcontainer, path)) {
      configPath = path;
      break;
    }
  }

  // WebContainer preview must use COEP: credentialless to allow opaque cross-origin fetches
  const headerLines = `server: { cors: true, headers: {
    'Cross-Origin-Opener-Policy': 'same-origin',
    'Cross-Origin-Embedder-Policy': 'credentialless',
    'Cross-Origin-Resource-Policy': 'cross-origin',
    'Access-Control-Allow-Origin': '*'
  } },`;

  if (!configPath) {
    const content = `import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react-swc'
export default defineConfig({ ${headerLines} plugins:[react()] })
`;
    await webcontainer.fs.writeFile('vite.config.ts', content);

    return;
  }

  const original = await readText(webcontainer, configPath);

  if (!original) {
    return;
  }

  if (original.includes('Cross-Origin-Embedder-Policy')) {
    return;
  }

  const idx = original.indexOf('defineConfig(');

  if (idx === -1) {
    return;
  }

  const braceIdx = original.indexOf('{', idx);

  if (braceIdx === -1) {
    return;
  }

  const updated = `${original.slice(0, braceIdx + 1)} ${headerLines} ${original.slice(braceIdx + 1)}`;
  await webcontainer.fs.writeFile(configPath, updated);
}
</file>

<file path="packages/ui-frontend/app/lib/webcontainer/index.ts">
import { WebContainer } from '@webcontainer/api';
import { WORK_DIR_NAME } from '~/utils/constants';
import { createScopedLogger } from '~/utils/logger';

const logger = createScopedLogger('WebContainer');

interface WebContainerContext {
  loaded: boolean;
}

export const webcontainerContext: WebContainerContext = import.meta.hot?.data.webcontainerContext ?? {
  loaded: false,
};

if (import.meta.hot) {
  import.meta.hot.data.webcontainerContext = webcontainerContext;
}

export let webcontainer: Promise<WebContainer> = new Promise(() => {
  // noop for ssr
});

let webcontainerInstance: WebContainer | null = null;

if (!import.meta.env.SSR) {
  webcontainer =
    import.meta.hot?.data.webcontainer ??
    Promise.resolve()
      .then(() => {
        return WebContainer.boot({ workdirName: WORK_DIR_NAME });
      })
      .then((wc) => {
        webcontainerContext.loaded = true;
        webcontainerInstance = wc;

        logger.info(' WebContainer booted successfully');

        return wc;
      });

  if (import.meta.hot) {
    import.meta.hot.data.webcontainer = webcontainer;
  }
}

/**
 * Tear down WebContainer completely and reset state
 * Call this when starting a new conversation to ensure clean state
 */
export async function tearDownWebContainer(): Promise<void> {
  if (!webcontainerInstance) {
    logger.debug('No WebContainer instance to tear down');
    return;
  }

  try {
    logger.info(' Tearing down WebContainer...');
    await webcontainerInstance.teardown();
    webcontainerInstance = null;
    webcontainerContext.loaded = false;
    logger.info(' WebContainer torn down successfully');
  } catch (error) {
    logger.error('Error tearing down WebContainer:', error);
    // Force reset even if teardown fails
    webcontainerInstance = null;
    webcontainerContext.loaded = false;
  }
}

/**
 * Reboot WebContainer after teardown
 * Creates a fresh instance for new conversation
 */
export async function rebootWebContainer(): Promise<WebContainer> {
  if (!import.meta.env.SSR) {
    logger.info(' Rebooting WebContainer...');
    const wc = await WebContainer.boot({ workdirName: WORK_DIR_NAME });
    webcontainerInstance = wc;
    webcontainerContext.loaded = true;
    webcontainer = Promise.resolve(wc);
    logger.info(' WebContainer rebooted successfully');
    return wc;
  }
  throw new Error('Cannot reboot WebContainer in SSR mode');
}
</file>

<file path="packages/ui-frontend/app/lib/webcontainer/url-helper.ts">
import { createScopedLogger } from '~/utils/logger';

const logger = createScopedLogger('WebContainerURL');

/**
 * Determines if we're running in a real WebContainer environment (StackBlitz/eitherway)
 * or in local development
 */
export function isWebContainerEnvironment(): boolean {
  if (typeof window === 'undefined') {
    return false;
  }

  // WebContainer sets specific globals
  const hasWebContainerGlobal = 'WebContainer' in window;

  const isStackBlitz =
    window.location.hostname.includes('stackblitz') || window.location.hostname.includes('webcontainer');

  const isEmbedded = window.parent !== window;

  // In production Eitherway, we should be in WebContainer environment
  const isProduction = window.location.hostname.includes('eitherway');

  return hasWebContainerGlobal || isStackBlitz || isProduction;
}

/**
 * Transforms a URL based on the environment
 * In WebContainer: Uses the provided URL (should be https://[id].webcontainerapp.io)
 * In local dev: Transforms localhost to work properly
 */
export function transformPreviewUrl(url: string, port: number): string {
  if (!url) {
    logger.warn('No URL provided for transformation');
    return '';
  }

  // If we're in a real WebContainer environment, use the URL as-is
  if (isWebContainerEnvironment()) {
    logger.info(`WebContainer environment detected, using URL: ${url}`);
    return url;
  }

  // In local development, WebContainer might still provide localhost URLs
  // We need to ensure they work properly
  if (url.includes('localhost') || url.includes('127.0.0.1')) {
    // For local development, ensure the URL is accessible
    // WebContainer in local dev runs on the same machine
    const localUrl = `http://localhost:${port}`;
    logger.info(`Local development detected, using: ${localUrl}`);

    return localUrl;
  }

  // If it's already a WebContainer URL, use it as-is
  if (url.includes('webcontainerapp.io') || url.includes('webcontainer.io')) {
    logger.info(`WebContainer URL detected: ${url}`);
    return url;
  }

  // Default: use the URL as provided
  logger.info(`Using URL as provided: ${url}`);

  return url;
}

/**
 * Validates if a preview URL is ready and accessible
 */
export async function validatePreviewUrl(url: string): Promise<boolean> {
  if (!url) {
    return false;
  }

  try {
    // Try to fetch with a short timeout
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 3000);

    const response = await fetch(url, {
      method: 'HEAD',
      mode: 'no-cors',
      signal: controller.signal,
    });

    clearTimeout(timeout);

    // In no-cors mode, we can't read the response but if it doesn't throw, it's likely accessible
    logger.info(`Preview URL validated: ${url}`);

    return true;
  } catch (error) {
    logger.warn(`Preview URL not ready yet: ${url}`);
    return false;
  }
}

/**
 * Gets the appropriate preview URL for the current environment
 */
export function getPreviewUrl(baseUrl: string, port: number): string {
  const transformedUrl = transformPreviewUrl(baseUrl, port);

  if (baseUrl !== transformedUrl) {
    logger.info(`URL transformed: ${baseUrl} -> ${transformedUrl}`);
  }

  return transformedUrl;
}
</file>

<file path="packages/ui-frontend/app/utils/constants.ts">
export const WORK_DIR_NAME = 'project';
export const WORK_DIR = `/home/${WORK_DIR_NAME}`;
export const MODIFICATIONS_TAG_NAME = 'eitherway_file_modifications';

/**
 * WebContainer and Preview Configuration Constants
 */

/**
 * Timeout to wait for preview registration after server starts (milliseconds)
 * Allows time for WebContainer port events to fire before attempting manual registration
 */
export const PREVIEW_REGISTRATION_TIMEOUT_MS = 3000;

/**
 * Default port for WebContainer dev server and static server
 */
export const WEBCONTAINER_DEFAULT_PORT = 3000;
</file>

<file path="packages/ui-frontend/app/utils/logger.ts">
export type DebugLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error';

type LoggerFunction = (...messages: any[]) => void;

interface Logger {
  trace: LoggerFunction;
  debug: LoggerFunction;
  info: LoggerFunction;
  warn: LoggerFunction;
  error: LoggerFunction;
  setLevel: (level: DebugLevel) => void;
}

let currentLevel: DebugLevel = (import.meta.env.VITE_LOG_LEVEL ?? import.meta.env.DEV) ? 'debug' : 'info';

const isWorker = 'HTMLRewriter' in globalThis;
const supportsColor = !isWorker;

export const logger: Logger = {
  trace: (...messages: any[]) => log('trace', undefined, messages),
  debug: (...messages: any[]) => log('debug', undefined, messages),
  info: (...messages: any[]) => log('info', undefined, messages),
  warn: (...messages: any[]) => log('warn', undefined, messages),
  error: (...messages: any[]) => log('error', undefined, messages),
  setLevel,
};

export function createScopedLogger(scope: string): Logger {
  return {
    trace: (...messages: any[]) => log('trace', scope, messages),
    debug: (...messages: any[]) => log('debug', scope, messages),
    info: (...messages: any[]) => log('info', scope, messages),
    warn: (...messages: any[]) => log('warn', scope, messages),
    error: (...messages: any[]) => log('error', scope, messages),
    setLevel,
  };
}

function setLevel(level: DebugLevel) {
  if ((level === 'trace' || level === 'debug') && import.meta.env.PROD) {
    return;
  }

  currentLevel = level;
}

function log(level: DebugLevel, scope: string | undefined, messages: any[]) {
  const levelOrder: DebugLevel[] = ['trace', 'debug', 'info', 'warn', 'error'];

  if (levelOrder.indexOf(level) < levelOrder.indexOf(currentLevel)) {
    return;
  }

  const allMessages = messages.reduce((acc, current) => {
    if (acc.endsWith('\n')) {
      return acc + current;
    }

    if (!acc) {
      return current;
    }

    return `${acc} ${current}`;
  }, '');

  if (!supportsColor) {
    console.log(`[${level.toUpperCase()}]`, allMessages);

    return;
  }

  const labelBackgroundColor = getColorForLevel(level);
  const labelTextColor = level === 'warn' ? 'black' : 'white';

  const labelStyles = getLabelStyles(labelBackgroundColor, labelTextColor);
  const scopeStyles = getLabelStyles('#77828D', 'white');

  const styles = [labelStyles];

  if (typeof scope === 'string') {
    styles.push('', scopeStyles);
  }

  console.log(`%c${level.toUpperCase()}${scope ? `%c %c${scope}` : ''}`, ...styles, allMessages);
}

function getLabelStyles(color: string, textColor: string) {
  return `background-color: ${color}; color: white; border: 4px solid ${color}; color: ${textColor};`;
}

function getColorForLevel(level: DebugLevel): string {
  switch (level) {
    case 'trace':
    case 'debug': {
      return '#77828D';
    }
    case 'info': {
      return '#1389FD';
    }
    case 'warn': {
      return '#FFDB6C';
    }
    case 'error': {
      return '#EE4744';
    }
    default: {
      return 'black';
    }
  }
}

export const renderLogger = createScopedLogger('Render');
</file>

<file path="packages/ui-frontend/app/root.tsx">
import { useStore } from '@nanostores/react';
import type { LinksFunction } from '@remix-run/node';
import { Links, Meta, Outlet, Scripts, ScrollRestoration } from '@remix-run/react';
import tailwindReset from '@unocss/reset/tailwind-compat.css?url';
import { themeStore } from './lib/stores/theme';
import { stripIndents } from './utils/stripIndent';
import { createHead } from 'remix-island';
import { useEffect } from 'react';
import { Web3Provider } from './lib/web3/Web3Provider';

import reactToastifyStyles from 'react-toastify/dist/ReactToastify.css?url';
import globalStyles from './styles/index.scss?url';
import xtermStyles from '@xterm/xterm/css/xterm.css?url';

import 'virtual:uno.css';

export const links: LinksFunction = () => [
  {
    rel: 'icon',
    href: '/favicon.svg',
    type: 'image/svg+xml',
  },
  { rel: 'stylesheet', href: reactToastifyStyles },
  { rel: 'stylesheet', href: tailwindReset },
  { rel: 'stylesheet', href: globalStyles },
  { rel: 'stylesheet', href: xtermStyles },
  {
    rel: 'preconnect',
    href: 'https://fonts.googleapis.com',
  },
  {
    rel: 'preconnect',
    href: 'https://fonts.gstatic.com',
    crossOrigin: 'anonymous',
  },
  {
    rel: 'preload',
    href: 'https://fonts.googleapis.com/css2?family=Righteous&family=Azeret+Mono:wght@300;400;500;600;700&display=block',
    as: 'style',
    onLoad: "this.onload=null;this.rel='stylesheet'",
  },
  {
    rel: 'preload',
    href: 'https://fonts.googleapis.com/css2?family=Syne:wght@400;500;600;700&family=Montserrat:wght@400;500;600;700&display=block',
    as: 'style',
    onLoad: "this.onload=null;this.rel='stylesheet'",
  },
  {
    rel: 'stylesheet',
    href: 'https://fonts.googleapis.com/css2?family=Righteous&family=Azeret+Mono:wght@300;400;500;600;700&display=block',
  },
  {
    rel: 'stylesheet',
    href: 'https://fonts.googleapis.com/css2?family=Syne:wght@400;500;600;700&family=Montserrat:wght@400;500;600;700&display=block',
  },
];

const inlineThemeCode = stripIndents`
  setTutorialKitTheme();
  optimizeFontLoading();

  function setTutorialKitTheme() {
    let theme = localStorage.getItem('eitherway_theme');

    if (!theme) {
      theme = 'dark';
    }

    document.querySelector('html')?.setAttribute('data-theme', theme);
  }

  function optimizeFontLoading() {
    // Hide text until fonts are loaded
    document.documentElement.classList.add('fonts-loading');

    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(() => {
        document.documentElement.classList.remove('fonts-loading');
        document.documentElement.classList.add('fonts-loaded');
      });
    } else {
      // Fallback for browsers without Font Loading API
      setTimeout(() => {
        document.documentElement.classList.remove('fonts-loading');
        document.documentElement.classList.add('fonts-loaded');
      }, 1000);
    }
  }
`;

export const Head = createHead(() => (
  <>
    <meta charSet="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta httpEquiv="Cross-Origin-Opener-Policy" content="same-origin" />
    <meta httpEquiv="Cross-Origin-Embedder-Policy" content="require-corp" />

    <Meta />
    <Links />
    <script dangerouslySetInnerHTML={{ __html: inlineThemeCode }} />
  </>
));

export function Layout({ children }: { children: React.ReactNode }) {
  const theme = useStore(themeStore);

  useEffect(() => {
    document.querySelector('html')?.setAttribute('data-theme', theme);
  }, [theme]);

  useEffect(() => {
    import('~/lib/client/preview-helpers.client').catch(() => {});
  }, []);

  return (
    <>
      {children}
      {/* <ScrollRestoration /> */}
      <Scripts />
    </>
  );
}

export default function App() {
  return (
    <Web3Provider>
      <Outlet />
    </Web3Provider>
  );
}
</file>

<file path="packages/ui-frontend/backend/streaming.ts">
/**
 * Minimal streaming utilities
 * Stripped from robust backend - no AI, no DB, just pure streaming
 */

const LOREM_TEXT = `Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`;

export interface StreamOptions {
  chunkSize?: number;
  delayMs?: number;
  text?: string;
}

/**
 * Async generator for streaming text chunks
 * Mimics the RequirementsExtractor.streamSuggestions pattern from robust backend
 */
export async function* streamLoremChunks(options: StreamOptions = {}): AsyncGenerator<string, void, unknown> {
  const { chunkSize = 20, delayMs = 300, text = LOREM_TEXT } = options;

  // Split text into chunks
  for (let i = 0; i < text.length; i += chunkSize) {
    const chunk = text.slice(i, i + chunkSize);
    yield chunk;

    // Simulate processing delay
    if (i + chunkSize < text.length) {
      await new Promise((resolve) => setTimeout(resolve, delayMs));
    }
  }
}

/**
 * Agent simulation: Input  Output streaming
 * Replaces complex @openai/agents SDK with simple async generator
 */
export async function* streamAgentResponse(
  prompt: string,
  options: StreamOptions = {},
): AsyncGenerator<any, void, unknown> {
  // Phase 1: Yield initial acknowledgment
  yield {
    type: 'start',
    prompt,
    timestamp: new Date().toISOString(),
  };

  await new Promise((resolve) => setTimeout(resolve, 500));

  // Phase 2: Stream response chunks
  const responseText = `[Agent processing: "${prompt}"]\n\n${options.text || LOREM_TEXT}`;

  for await (const chunk of streamLoremChunks({ ...options, text: responseText })) {
    yield {
      type: 'chunk',
      data: chunk,
      timestamp: new Date().toISOString(),
    };
  }

  // Phase 3: Completion event
  yield {
    type: 'complete',
    prompt,
    timestamp: new Date().toISOString(),
  };
}

/**
 * SSE (Server-Sent Events) formatter
 * Converts data to SSE format: "data: {json}\n\n"
 */
export function formatSSE(data: any): string {
  return `data: ${JSON.stringify(data)}\n\n`;
}
</file>

<file path="packages/ui-frontend/patterns.json">
{
  "version": "2025.09",
  "confidence_threshold": 0.5,
  "detection": {
    "scoring": "sum(weights for matched keywords), choose highest score if >= confidence_threshold; else use 'default'",
    "patterns": {
      "web3": {
        "keywords": {
          "wallet": 2,
          "crypto": 2,
          "blockchain": 2,
          "defi": 2,
          "nft": 2,
          "token": 1.5,
          "eth": 1.5,
          "metamask": 1.5
        }
      },
      "ecommerce": {
        "keywords": {
          "shop": 2,
          "store": 2,
          "product": 2,
          "cart": 2,
          "buy": 1.5,
          "sell": 1.5,
          "checkout": 2,
          "payment": 2
        }
      },
      "dashboard": {
        "keywords": {
          "dashboard": 2,
          "analytics": 2,
          "admin": 1.5,
          "data": 1.5,
          "chart": 2,
          "metrics": 2,
          "reports": 1.5
        }
      },
      "saas": {
        "keywords": { "saas": 2, "pricing": 2, "landing": 2, "features": 1.5, "subscription": 1.5, "plans": 1.5 }
      },
      "portfolio": {
        "keywords": { "portfolio": 2, "personal": 1.5, "resume": 1.5, "showcase": 2, "projects": 2, "about": 1.5 }
      },
      "social": {
        "keywords": { "social": 2, "feed": 2, "post": 2, "profile": 1.5, "chat": 2, "message": 2, "community": 1.5 }
      },
      "gaming": {
        "keywords": { "game": 2, "play": 1.5, "score": 1.5, "level": 1.5, "achievement": 2, "leaderboard": 2 }
      },
      "educational": {
        "keywords": { "learn": 2, "course": 2, "education": 1.5, "quiz": 2, "lesson": 2, "study": 1.5 }
      },
      "healthcare": {
        "keywords": { "health": 2, "medical": 2, "doctor": 1.5, "appointment": 2, "patient": 2, "wellness": 1.5 }
      },
      "fintech": {
        "keywords": { "bank": 2, "finance": 2, "investment": 2, "transfer": 2, "account": 1.5, "budget": 1.5 }
      },
      "default": { "keywords": {} }
    }
  },

  "base": {
    "breakpoints": { "xs": 360, "sm": 640, "md": 768, "lg": 1024, "xl": 1280, "xxl": 1536 },
    "space": {
      "0": "0px",
      "1": "4px",
      "2": "8px",
      "3": "12px",
      "4": "16px",
      "5": "20px",
      "6": "24px",
      "8": "32px",
      "10": "40px",
      "12": "48px",
      "16": "64px",
      "20": "80px",
      "24": "96px"
    },
    "radius": { "sm": "8px", "md": "12px", "lg": "16px", "xl": "24px", "pill": "9999px" },
    "shadow": {
      "sm": "0 1px 2px rgba(0,0,0,0.06)",
      "md": "0 3px 10px rgba(0,0,0,0.08)",
      "lg": "0 8px 24px rgba(0,0,0,0.12)",
      "xl": "0 12px 40px rgba(0,0,0,0.16)",
      "inner": "inset 0 1px 0 rgba(255,255,255,0.06)"
    },
    "transition": {
      "fast": "120ms cubic-bezier(0.2, 0.8, 0.2, 1)",
      "base": "200ms cubic-bezier(0.2, 0.8, 0.2, 1)",
      "slow": "380ms cubic-bezier(0.2, 0.8, 0.2, 1)"
    },
    "typography": {
      "font_family_sans": "Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji",
      "font_family_mono": "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
      "sizes": {
        "xs": "12px",
        "sm": "14px",
        "md": "16px",
        "lg": "18px",
        "xl": "20px",
        "2xl": "24px",
        "3xl": "30px",
        "4xl": "36px",
        "5xl": "48px"
      },
      "line_heights": { "tight": 1.15, "snug": 1.25, "normal": 1.5, "relaxed": 1.65 }
    },
    "a11y": {
      "min_contrast": 4.5,
      "focus_ring": "0 0 0 3px var(--color-focus)",
      "target_min_size": "44px"
    },
    "components": {
      "button": {
        "padding_y": "12px",
        "padding_x": "16px",
        "gap": "8px",
        "radius_ref": "md",
        "font_weight": 600,
        "states": {
          "hover": { "elevate": "md", "translate_y": "-1px" },
          "active": { "elevate": "sm", "translate_y": "0px", "scale": 0.99 },
          "focus": { "ring": "var(--focus-ring)" }
        }
      },
      "card": {
        "padding": "16px",
        "radius_ref": "lg",
        "elevation_ref": "md",
        "border_width": "1px"
      },
      "input": {
        "padding_y": "12px",
        "padding_x": "14px",
        "radius_ref": "md",
        "border_width": "1px",
        "states": {
          "focus": { "ring": "var(--focus-ring)" },
          "invalid": { "border_color_ref": "error" }
        }
      },
      "navbar": {
        "height": "64px",
        "radius_ref": "sm"
      },
      "sidebar": {
        "width": "280px",
        "radius_ref": "sm"
      },
      "table": {
        "row_height": "48px",
        "header_height": "40px",
        "gridlines": "1px solid var(--color-border)"
      }
    }
  },

  "patterns": [
    {
      "id": "web3",
      "name": "Crypto/Blockchain",
      "theme_default": "dark",
      "palette": {
        "bg": "#0B0F1A",
        "surface": "rgba(15, 23, 42, 0.6)",
        "elevated": "rgba(2, 6, 23, 0.7)",
        "text": "#E5E7EB",
        "muted": "#94A3B8",
        "border": "rgba(255,255,255,0.10)",
        "primary": "#8B5CF6",
        "primary_fg": "#0B0F1A",
        "accent": "#22D3EE",
        "accent_fg": "#0B0F1A",
        "success": "#10B981",
        "warning": "#F59E0B",
        "error": "#EF4444",
        "focus": "#7DD3FC"
      },
      "gradients": {
        "primary": "linear-gradient(135deg, #8B5CF6 0%, #22D3EE 100%)",
        "accent": "linear-gradient(135deg, #22D3EE 0%, #14B8A6 100%)"
      },
      "effects": {
        "backdrop_blur": "16px",
        "glass_border": "1px solid rgba(255,255,255,0.10)",
        "glow": "0 0 24px rgba(34,211,238,0.25), 0 0 0 1px rgba(139,92,246,0.35)"
      },
      "layout": {
        "page_max_width": "1280px",
        "header": { "position": "sticky", "top": "0", "style": "blurred", "divider": "rgba(255,255,255,0.08)" },
        "nav": { "type": "sidebar-collapsible", "width": "84px", "collapsed_icons": true },
        "content_grid": "minmax(0,1fr)"
      },
      "components": {
        "button_primary": {
          "bg_ref": "gradients.primary",
          "text_ref": "palette.primary_fg",
          "radius": "9999px",
          "shadow": "0 10px 30px rgba(139,92,246,0.25)",
          "hover": { "shadow": "0 14px 40px rgba(34,211,238,0.30)", "translate_y": "-1px" }
        },
        "card": {
          "background": "rgba(15,23,42,0.55)",
          "border": "1px solid rgba(255,255,255,0.08)",
          "backdrop_filter": "blur(16px)",
          "shadow": "var(--shadow-md)"
        },
        "nft_card": {
          "media_ratio": "1:1",
          "border": "1px solid transparent",
          "border_image": "linear-gradient(120deg, #8B5CF6, #22D3EE) 1",
          "hover": { "scale": 1.02 }
        },
        "stat_pill": {
          "background": "rgba(34,211,238,0.10)",
          "text": "#67E8F9",
          "radius": "9999px",
          "border": "1px solid rgba(34,211,238,0.25)"
        }
      },
      "a11y": { "min_contrast": 4.5, "reduced_motion": "disable glow and scale effects" },
      "page_templates": ["Wallet", "Swap", "NFT-Grid", "Portfolio"]
    },

    {
      "id": "ecommerce",
      "name": "Shopping/Retail",
      "theme_default": "light",
      "palette": {
        "bg": "#FFFFFF",
        "surface": "#F8FAFC",
        "elevated": "#FFFFFF",
        "text": "#0F172A",
        "muted": "#475569",
        "border": "#E2E8F0",
        "primary": "#2563EB",
        "primary_fg": "#FFFFFF",
        "accent": "#F59E0B",
        "accent_fg": "#0F172A",
        "success": "#16A34A",
        "warning": "#F59E0B",
        "error": "#DC2626",
        "focus": "#2563EB"
      },
      "gradients": {
        "hero": "linear-gradient(180deg, #EFF6FF 0%, #FFFFFF 60%)"
      },
      "effects": {
        "backdrop_blur": "0px",
        "glow": "none"
      },
      "layout": {
        "page_max_width": "1280px",
        "header": { "position": "sticky", "top": "0", "style": "flat", "divider": "#E2E8F0" },
        "nav": { "type": "top", "search_in_nav": true },
        "content_grid": "repeat(12, minmax(0, 1fr))"
      },
      "components": {
        "button_primary": {
          "bg_ref": "palette.primary",
          "text_ref": "palette.primary_fg",
          "radius_ref": "md",
          "shadow": "0 10px 20px rgba(37,99,235,0.20)"
        },
        "card": {
          "background": "#FFFFFF",
          "border": "1px solid #E2E8F0",
          "shadow": "var(--shadow-sm)"
        },
        "product_card": {
          "media_ratio": "4:5",
          "image_radius": "12px",
          "price_color": "#0F172A",
          "badge": { "bg": "#F1F5F9", "text": "#0F172A" },
          "hover": { "shadow": "var(--shadow-md)", "translate_y": "-2px" }
        },
        "checkout_panel": {
          "background": "#F8FAFC",
          "border": "1px solid #E2E8F0",
          "radius": "16px",
          "sticky": "top:80px"
        }
      },
      "a11y": { "min_contrast": 7, "price_font_weight": 700 },
      "page_templates": ["Home-Grid", "Product-Detail", "Cart", "Checkout"]
    },

    {
      "id": "dashboard",
      "name": "Analytics/Admin",
      "theme_default": "light",
      "palette": {
        "bg": "#F8FAFC",
        "surface": "#FFFFFF",
        "elevated": "#FFFFFF",
        "text": "#0B1220",
        "muted": "#475569",
        "border": "#E5E7EB",
        "primary": "#6366F1",
        "primary_fg": "#FFFFFF",
        "accent": "#14B8A6",
        "accent_fg": "#06261F",
        "success": "#16A34A",
        "warning": "#F59E0B",
        "error": "#DC2626",
        "focus": "#6366F1"
      },
      "effects": { "backdrop_blur": "0px" },
      "layout": {
        "page_max_width": "1440px",
        "header": { "position": "sticky", "top": "0", "style": "flat", "divider": "#E5E7EB" },
        "nav": { "type": "sidebar", "width": "280px" },
        "content_grid": "repeat(12, minmax(0,1fr))"
      },
      "components": {
        "button_primary": { "bg_ref": "palette.primary", "text_ref": "palette.primary_fg" },
        "card": { "background": "#FFFFFF", "border": "1px solid #E5E7EB", "shadow": "var(--shadow-sm)" },
        "chart_card": {
          "title_size": "16px",
          "gridline_color": "#E2E8F0",
          "series": [
            "#6366F1",
            "#06B6D4",
            "#22C55E",
            "#F59E0B",
            "#EF4444",
            "#8B5CF6",
            "#14B8A6",
            "#F472B6",
            "#84CC16",
            "#0EA5E9",
            "#F97316",
            "#A78BFA"
          ],
          "legend_position": "bottom",
          "hover_crosshair": true
        },
        "table": {
          "row_zebra": ["#FFFFFF", "#F8FAFC"],
          "row_hover": "#F1F5F9",
          "header_bg": "#F1F5F9",
          "cell_padding": "12px 16px"
        },
        "filter_bar": {
          "background": "#FFFFFF",
          "border": "1px solid #E5E7EB",
          "radius": "12px",
          "gap": "8px"
        }
      },
      "a11y": { "min_contrast": 7 },
      "page_templates": ["Overview", "Reports", "Users", "Settings"]
    },

    {
      "id": "saas",
      "name": "Landing/Marketing",
      "theme_default": "light",
      "palette": {
        "bg": "#FFFFFF",
        "surface": "#FFFFFF",
        "elevated": "#FFFFFF",
        "text": "#0F172A",
        "muted": "#475569",
        "border": "#E5E7EB",
        "primary": "#7C3AED",
        "primary_fg": "#FFFFFF",
        "accent": "#22D3EE",
        "accent_fg": "#0B0F1A",
        "success": "#16A34A",
        "warning": "#F59E0B",
        "error": "#DC2626",
        "focus": "#7C3AED"
      },
      "gradients": {
        "hero": "radial-gradient(1200px 600px at 70% -20%, rgba(124,58,237,0.20), rgba(34,211,238,0.15) 40%, transparent 70%)"
      },
      "effects": { "backdrop_blur": "4px" },
      "layout": {
        "page_max_width": "1200px",
        "header": { "position": "sticky", "top": "0", "style": "glass", "divider": "rgba(0,0,0,0.06)" },
        "nav": { "type": "top", "cta_button": true },
        "content_grid": "minmax(0,1fr)"
      },
      "components": {
        "button_primary": {
          "bg_ref": "palette.primary",
          "text_ref": "palette.primary_fg",
          "radius_ref": "pill",
          "shadow": "0 12px 24px rgba(124,58,237,0.25)"
        },
        "card": {
          "background": "#FFFFFF",
          "border": "1px solid #E5E7EB",
          "shadow": "var(--shadow-md)"
        },
        "pricing_card": {
          "highlighted_border": "2px solid #7C3AED",
          "badge_bg": "#F1F0FF",
          "price_size": "36px",
          "feature_icon_color": "#7C3AED"
        },
        "hero": {
          "headline_size": "48px",
          "subhead_size": "20px",
          "illustration_style": "3D-soft"
        }
      },
      "a11y": { "min_contrast": 7 },
      "page_templates": ["Hero-Pricing", "Features", "Testimonials", "Contact"]
    },

    {
      "id": "portfolio",
      "name": "Personal/Creative",
      "theme_default": "dark",
      "palette": {
        "bg": "#0B0B0F",
        "surface": "#111217",
        "elevated": "#141621",
        "text": "#F3F4F6",
        "muted": "#9CA3AF",
        "border": "rgba(255,255,255,0.10)",
        "primary": "#E11D48",
        "primary_fg": "#0B0B0F",
        "accent": "#06B6D4",
        "accent_fg": "#0B0B0F",
        "success": "#22C55E",
        "warning": "#F59E0B",
        "error": "#F43F5E",
        "focus": "#93C5FD"
      },
      "effects": { "backdrop_blur": "8px", "glow": "0 10px 30px rgba(6,182,212,0.25)" },
      "layout": {
        "page_max_width": "1080px",
        "header": { "position": "static", "style": "minimal" },
        "nav": { "type": "top-minimal" },
        "content_grid": "minmax(0,1fr)"
      },
      "components": {
        "button_primary": { "bg_ref": "palette.primary", "text_ref": "palette.primary_fg", "radius_ref": "pill" },
        "card": { "background": "#111217", "border": "1px solid rgba(255,255,255,0.08)" },
        "project_tile": {
          "media_ratio": "16:9",
          "title_size": "24px",
          "hover": { "scale": 1.02, "shadow": "0 14px 40px rgba(6,182,212,0.25)" },
          "caption_style": "mono"
        },
        "about_block": { "two_column": true, "avatar_radius": "9999px" }
      },
      "a11y": { "min_contrast": 4.5 },
      "page_templates": ["Gallery", "Case-Study", "About", "Contact"]
    },

    {
      "id": "social",
      "name": "Social/Community",
      "theme_default": "light",
      "palette": {
        "bg": "#FFFFFF",
        "surface": "#FFFFFF",
        "elevated": "#FFFFFF",
        "text": "#111827",
        "muted": "#6B7280",
        "border": "#E5E7EB",
        "primary": "#3B82F6",
        "primary_fg": "#FFFFFF",
        "accent": "#F472B6",
        "accent_fg": "#111827",
        "success": "#22C55E",
        "warning": "#F59E0B",
        "error": "#EF4444",
        "focus": "#3B82F6"
      },
      "effects": { "backdrop_blur": "0px" },
      "layout": {
        "page_max_width": "1200px",
        "header": { "position": "sticky", "top": "0", "style": "flat", "divider": "#E5E7EB" },
        "nav": { "type": "top-with-tabs" },
        "content_grid": "minmax(0, 720px)"
      },
      "components": {
        "button_primary": { "bg_ref": "palette.primary", "text_ref": "palette.primary_fg", "radius_ref": "pill" },
        "card": { "background": "#FFFFFF", "border": "1px solid #E5E7EB", "radius": "16px" },
        "feed_item": {
          "avatar_size": "40px",
          "media_radius": "12px",
          "action_bar": { "like": true, "comment": true, "share": true },
          "hover": { "bg": "#F9FAFB" }
        },
        "message_bubble": {
          "radius": "18px",
          "me_bg": "#3B82F6",
          "me_text": "#FFFFFF",
          "other_bg": "#F3F4F6",
          "other_text": "#111827"
        }
      },
      "a11y": { "min_contrast": 7 },
      "page_templates": ["Home-Feed", "Profile", "Messages", "Create-Post"]
    },

    {
      "id": "gaming",
      "name": "Game UI",
      "theme_default": "dark",
      "palette": {
        "bg": "#070A0F",
        "surface": "#0C111B",
        "elevated": "#0E1422",
        "text": "#E2E8F0",
        "muted": "#94A3B8",
        "border": "rgba(255,255,255,0.08)",
        "primary": "#22D3EE",
        "primary_fg": "#0A0F1C",
        "accent": "#A78BFA",
        "accent_fg": "#0A0F1C",
        "success": "#22C55E",
        "warning": "#F59E0B",
        "error": "#F43F5E",
        "focus": "#22D3EE"
      },
      "effects": { "backdrop_blur": "6px", "scanline_overlay": 0.06 },
      "typography_overrides": {
        "display": "'Rajdhani', var(--font-sans)",
        "display_weight": 700,
        "letter_spacing": "0.02em"
      },
      "layout": {
        "page_max_width": "1400px",
        "header": { "position": "static", "style": "hud" },
        "nav": { "type": "sidebar-compact" },
        "content_grid": "repeat(12, minmax(0,1fr))"
      },
      "components": {
        "button_primary": {
          "bg_ref": "palette.primary",
          "text_ref": "palette.primary_fg",
          "radius": "10px",
          "shadow": "0 0 20px rgba(34,211,238,0.35)"
        },
        "card": { "background": "#0C111B", "border": "1px solid rgba(255,255,255,0.08)" },
        "leaderboard_row": {
          "height": "56px",
          "stripe": "rgba(255,255,255,0.03)",
          "rank_badge_bg": "#22D3EE",
          "rank_badge_text": "#0A0F1C"
        },
        "inventory_slot": {
          "size": "80px",
          "radius": "12px",
          "border": "1px solid rgba(167,139,250,0.3)",
          "hover": { "shadow": "0 0 16px rgba(167,139,250,0.35)" }
        }
      },
      "a11y": { "min_contrast": 4.5 },
      "page_templates": ["Dashboard-HUD", "Leaderboard", "Inventory", "Achievements"]
    },

    {
      "id": "educational",
      "name": "Learning",
      "theme_default": "light",
      "palette": {
        "bg": "#FFFFFF",
        "surface": "#F9FAFB",
        "elevated": "#FFFFFF",
        "text": "#0F172A",
        "muted": "#475569",
        "border": "#E5E7EB",
        "primary": "#0EA5E9",
        "primary_fg": "#FFFFFF",
        "accent": "#8B5CF6",
        "accent_fg": "#FFFFFF",
        "success": "#22C55E",
        "warning": "#F59E0B",
        "error": "#DC2626",
        "focus": "#0EA5E9"
      },
      "effects": { "backdrop_blur": "0px" },
      "layout": {
        "page_max_width": "1200px",
        "header": { "position": "sticky", "top": "0", "style": "flat" },
        "nav": { "type": "top-with-breadcrumbs" },
        "content_grid": "minmax(0, 900px)"
      },
      "components": {
        "button_primary": { "bg_ref": "palette.primary", "text_ref": "palette.primary_fg" },
        "card": { "background": "#FFFFFF", "border": "1px solid #E5E7EB" },
        "course_card": {
          "media_ratio": "16:9",
          "progress_bar": { "height": "6px", "bg": "#E5E7EB", "fill": "#0EA5E9", "radius": "9999px" },
          "meta": { "badge_bg": "#EEF2FF", "badge_text": "#3730A3" }
        },
        "quiz_block": {
          "option_radius": "12px",
          "option_hover_bg": "#F3F4F6",
          "correct_bg": "#ECFDF5",
          "incorrect_bg": "#FEF2F2"
        }
      },
      "a11y": { "min_contrast": 7 },
      "page_templates": ["Catalog", "Course-Detail", "Lesson", "Quiz"]
    },

    {
      "id": "healthcare",
      "name": "Medical/Health",
      "theme_default": "light",
      "palette": {
        "bg": "#FFFFFF",
        "surface": "#F8FAFC",
        "elevated": "#FFFFFF",
        "text": "#0F172A",
        "muted": "#475569",
        "border": "#E2E8F0",
        "primary": "#0284C7",
        "primary_fg": "#FFFFFF",
        "accent": "#22C55E",
        "accent_fg": "#06290F",
        "success": "#16A34A",
        "warning": "#F59E0B",
        "error": "#DC2626",
        "focus": "#0284C7"
      },
      "effects": { "backdrop_blur": "0px" },
      "layout": {
        "page_max_width": "1200px",
        "header": { "position": "sticky", "top": "0", "style": "flat" },
        "nav": { "type": "sidebar" },
        "content_grid": "repeat(12, minmax(0,1fr))"
      },
      "components": {
        "button_primary": { "bg_ref": "palette.primary", "text_ref": "palette.primary_fg", "radius_ref": "md" },
        "card": { "background": "#FFFFFF", "border": "1px solid #E2E8F0", "radius": "16px" },
        "appointment_card": {
          "slot_height": "68px",
          "doctor_avatar": "48px",
          "status_chip": { "scheduled": "#E0F2FE", "completed": "#ECFDF5", "cancelled": "#FEF2F2" }
        },
        "form": {
          "label_weight": 600,
          "helper_text_color": "#64748B",
          "error_text_color": "#B91C1C"
        }
      },
      "a11y": { "min_contrast": 7, "touch_target_min": "48px" },
      "page_templates": ["Appointments", "Records", "Messaging", "Billing"]
    },

    {
      "id": "fintech",
      "name": "Banking/Finance",
      "theme_default": "light",
      "palette": {
        "bg": "#FFFFFF",
        "surface": "#F8FAFC",
        "elevated": "#FFFFFF",
        "text": "#0B1220",
        "muted": "#475569",
        "border": "#E2E8F0",
        "primary": "#0EA5E9",
        "primary_fg": "#06202A",
        "accent": "#16A34A",
        "accent_fg": "#05210E",
        "success": "#16A34A",
        "warning": "#F59E0B",
        "error": "#DC2626",
        "focus": "#0EA5E9"
      },
      "effects": { "backdrop_blur": "0px" },
      "layout": {
        "page_max_width": "1320px",
        "header": { "position": "sticky", "top": "0", "style": "flat" },
        "nav": { "type": "sidebar" },
        "content_grid": "repeat(12, minmax(0,1fr))"
      },
      "components": {
        "button_primary": { "bg_ref": "palette.accent", "text_ref": "#FFFFFF", "radius_ref": "md" },
        "card": { "background": "#FFFFFF", "border": "1px solid #E2E8F0", "radius": "14px" },
        "transaction_row": {
          "height": "56px",
          "merchant_icon": "40px",
          "amount_font_weight": 600,
          "positive_color": "#16A34A",
          "negative_color": "#DC2626"
        },
        "chart_card": {
          "series": ["#0EA5E9", "#16A34A", "#F59E0B", "#EF4444", "#6366F1", "#22D3EE"],
          "gridline_color": "#E2E8F0",
          "sparkline_color": "#16A34A"
        },
        "budget_bar": {
          "height": "8px",
          "radius": "9999px",
          "bg": "#E2E8F0",
          "fill": "#16A34A"
        }
      },
      "a11y": { "min_contrast": 7 },
      "page_templates": ["Accounts", "Transactions", "Budgets", "Investments"]
    },

    {
      "id": "default",
      "name": "Generic Modern",
      "theme_default": "light",
      "palette": {
        "bg": "#FFFFFF",
        "surface": "#F7F7FB",
        "elevated": "#FFFFFF",
        "text": "#111827",
        "muted": "#6B7280",
        "border": "#E5E7EB",
        "primary": "#6366F1",
        "primary_fg": "#FFFFFF",
        "accent": "#06B6D4",
        "accent_fg": "#083344",
        "success": "#22C55E",
        "warning": "#F59E0B",
        "error": "#EF4444",
        "focus": "#6366F1"
      },
      "effects": { "backdrop_blur": "0px" },
      "layout": {
        "page_max_width": "1200px",
        "header": { "position": "sticky", "top": "0", "style": "flat" },
        "nav": { "type": "top" },
        "content_grid": "minmax(0,1fr)"
      },
      "components": {
        "button_primary": { "bg_ref": "palette.primary", "text_ref": "palette.primary_fg" },
        "card": { "background": "#FFFFFF", "border": "1px solid #E5E7EB", "radius": "12px" },
        "empty_state": {
          "icon_bg": "#EEF2FF",
          "title_color": "#111827",
          "desc_color": "#6B7280"
        }
      },
      "a11y": { "min_contrast": 7 },
      "page_templates": ["Home", "List-Detail", "Settings"]
    }
  ]
}
</file>

<file path="packages/ui-frontend/server.js">
import { createRequestHandler } from '@remix-run/express';
import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';

// FORCE PRODUCTION MODE
process.env.NODE_ENV = 'production';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();

//    SharedArrayBuffer   
app.use((req, res, next) => {
  res.setHeader('Cross-Origin-Opener-Policy', 'same-origin');
  res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp');
  next();
});

// PRODUCTION STATIC FILES
app.use(
  express.static('build/client', {
    maxAge: '1y',
    etag: true,
    lastModified: true,
    setHeaders: (res, filePath) => {
      if (filePath.endsWith('.wasm')) {
        res.setHeader('Content-Type', 'application/wasm');
      }

      //    SharedArrayBuffer
      res.setHeader('Cross-Origin-Opener-Policy', 'same-origin');
      res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp');
    },
  }),
);

// PRODUCTION BUILD - NOT DEV
const build = await import('./build/server/index.js');

// ALL ROUTES TO REMIX
app.all(
  '*',
  createRequestHandler({
    build,
    mode: 'production',
  }),
);

const port = process.env.PORT || 3000;
app.listen(port, () => {
  console.log(`PRODUCTION Express server on port ${port}`);
  console.log(`NODE_ENV: ${process.env.NODE_ENV}`);
  console.log(`Static files cached, pre-built pages served`);
});
</file>

<file path="packages/ui-frontend/vercel.json">
{
  "build": {
    "env": {
      "ENABLE_FILE_SYSTEM_API": "1"
    }
  }
}
</file>

<file path="packages/ui-server/src/routes/apps.ts">
import { FastifyInstance } from 'fastify';
import {
  AppsRepository,
  FilesRepository,
  FileReferencesRepository,
  EventsRepository,
  DatabaseClient,
} from '@eitherway/database';

export async function registerAppRoutes(fastify: FastifyInstance, db: DatabaseClient) {
  const appsRepo = new AppsRepository(db);
  const filesRepo = new FilesRepository(db);
  const referencesRepo = new FileReferencesRepository(db);
  const eventsRepo = new EventsRepository(db);

  fastify.post<{
    Body: { ownerId: string; name: string; visibility?: 'private' | 'team' | 'public' };
  }>('/api/apps', async (request, reply) => {
    const { ownerId, name, visibility } = request.body;

    const app = await appsRepo.create(ownerId, name, visibility);

    await eventsRepo.log(
      'app.created',
      { appId: app.id, name },
      {
        appId: app.id,
        actor: 'user',
      },
    );

    return app;
  });

  fastify.get<{
    Params: { id: string };
  }>('/api/apps/:id', async (request, reply) => {
    const app = await appsRepo.findById(request.params.id);

    if (!app) {
      return reply.code(404).send({ error: 'App not found' });
    }

    return app;
  });

  fastify.get<{
    Querystring: { ownerId: string; limit?: string; offset?: string };
  }>('/api/apps', async (request, reply) => {
    const { ownerId, limit = '50', offset = '0' } = request.query;

    if (!ownerId) {
      return reply.code(400).send({ error: 'ownerId is required' });
    }

    const apps = await appsRepo.findByOwner(ownerId, parseInt(limit, 10), parseInt(offset, 10));

    return { apps };
  });

  fastify.patch<{
    Params: { id: string };
    Body: { name?: string; visibility?: 'private' | 'team' | 'public'; default_session_id?: string | null };
  }>('/api/apps/:id', async (request, reply) => {
    const { id } = request.params;
    const data = request.body;

    const app = await appsRepo.update(id, data);

    return app;
  });

  fastify.delete<{
    Params: { id: string };
  }>('/api/apps/:id', async (request, reply) => {
    const { id } = request.params;

    await appsRepo.delete(id);

    return { success: true };
  });

  fastify.get<{
    Params: { appId: string };
    Querystring: { limit?: string };
  }>('/api/apps/:appId/files', async (request, reply) => {
    const { appId } = request.params;
    const { limit = '1000' } = request.query;

    const files = await filesRepo.findByApp(appId, parseInt(limit, 10));

    return { files };
  });

  fastify.post<{
    Params: { appId: string };
    Body: {
      path: string;
      content: string;
      userId?: string;
      mimeType?: string;
    };
  }>('/api/apps/:appId/files', async (request, reply) => {
    const { appId } = request.params;
    const { path, content, userId, mimeType } = request.body;

    const file = await filesRepo.upsertFile(appId, path, content, userId, mimeType);

    await eventsRepo.log(
      'file.upserted',
      { fileId: file.id, path },
      {
        appId,
        actor: userId ? 'user' : 'agent',
      },
    );

    return file;
  });

  fastify.get<{
    Params: { appId: string; fileId: string };
  }>('/api/apps/:appId/files/:fileId', async (request, reply) => {
    const { fileId } = request.params;

    const file = await filesRepo.findById(fileId);
    if (!file) {
      return reply.code(404).send({ error: 'File not found' });
    }

    const version = await filesRepo.getHeadVersion(fileId);

    return { file, version };
  });

  fastify.get<{
    Params: { appId: string; fileId: string };
    Querystring: { limit?: string };
  }>('/api/apps/:appId/files/:fileId/versions', async (request, reply) => {
    const { fileId } = request.params;
    const { limit = '50' } = request.query;

    const versions = await filesRepo.getVersionHistory(fileId, parseInt(limit, 10));

    return { versions };
  });

  fastify.delete<{
    Params: { appId: string; fileId: string };
  }>('/api/apps/:appId/files/:fileId', async (request, reply) => {
    const { fileId } = request.params;

    await filesRepo.delete(fileId);

    return { success: true };
  });

  fastify.get<{
    Params: { appId: string };
  }>('/api/apps/:appId/references', async (request, reply) => {
    const { appId } = request.params;

    const references = await referencesRepo.findByApp(appId);

    return { references };
  });
}
</file>

<file path="packages/ui-server/src/routes/images.ts">
import { FastifyInstance } from 'fastify';
import { ImageGenerationService, EventsRepository, DatabaseClient } from '@eitherway/database';

export async function registerImageRoutes(fastify: FastifyInstance, db: DatabaseClient) {
  const imageService = new ImageGenerationService(db);
  const eventsRepo = new EventsRepository(db);

  fastify.post<{
    Body: {
      prompt: string;
      model?: 'dall-e-3' | 'dall-e-2';
      size?: '1024x1024' | '1792x1024' | '1024x1792' | '256x256' | '512x512';
      quality?: 'standard' | 'hd';
      n?: number;
      sessionId?: string;
      appId?: string;
    };
  }>('/api/images/generate', async (request, reply) => {
    const options = request.body;

    const jobId = await imageService.generateImage(options);

    await eventsRepo.log(
      'image.job.created',
      { jobId, prompt: options.prompt },
      {
        sessionId: options.sessionId,
        appId: options.appId,
        actor: 'user',
      },
    );

    return { jobId };
  });

  fastify.get<{
    Params: { jobId: string };
  }>('/api/images/jobs/:jobId', async (request, reply) => {
    const { jobId } = request.params;

    try {
      const status = await imageService.getJobStatus(jobId);
      return status;
    } catch (error: any) {
      return reply.code(404).send({ error: error.message });
    }
  });

  fastify.get<{
    Params: { assetId: string };
  }>('/api/images/assets/:assetId', async (request, reply) => {
    const { assetId } = request.params;

    const asset = await imageService.getAsset(assetId);

    if (!asset) {
      return reply.code(404).send({ error: 'Asset not found' });
    }

    return reply
      .header('Content-Type', asset.mimeType)
      .header('Cache-Control', 'public, max-age=31536000')
      .send(asset.bytes);
  });

  fastify.post<{
    Body: { jobId: string; timeoutMs?: number };
  }>('/api/images/poll', async (request, reply) => {
    const { jobId, timeoutMs = 60000 } = request.body;

    try {
      const result = await imageService.pollJobUntilComplete(jobId, timeoutMs);
      return result;
    } catch (error: any) {
      return reply.code(408).send({ error: error.message });
    }
  });
}
</file>

<file path="packages/ui-server/workspace/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path=".gitignore">
# Dependencies
node_modules/
package-lock.json
yarn.lock
pnpm-lock.yaml

# Build outputs
dist/
*.tsbuildinfo

# Environment and secrets
.env
.env.local
configs/anthropic.json
*.key
*.pem
.certs/

# Logs
*.log
logs/
transcripts/

# OS files
.DS_Store
Thumbs.db

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# Testing
coverage/
.nyc_output/

# Temporary
tmp/
temp/
*.tmp
mkcert/
</file>

<file path="configs/agent.json">
{
  "policy": {
    "deterministic": true,
    "singleAgent": true,
    "parallelTools": true
  },
  "security": {
    "allowedWorkspaces": ["**", "workspace/**"],
    "deniedPaths": [".env", "*.key", "*.pem", "configs/anthropic.json", "node_modules/**"],
    "maxFileSize": 1048576,
    "secretPatterns": [
      "sk-ant-[a-zA-Z0-9-_]+",
      "AIza[0-9A-Za-z-_]{35}",
      "sk-[a-zA-Z0-9]{32,}",
      "-----BEGIN.*PRIVATE KEY-----"
    ],
    "redactSecrets": true
  },
  "limits": {
    "maxToolPayloadSize": 524288,
    "maxConcurrentTools": 10,
    "maxSearchResults": 1000,
    "chunkSize": 4096
  },
  "logging": {
    "level": "info",
    "captureTranscripts": true,
    "transcriptDir": "./transcripts",
    "logFile": "./logs/agent.log"
  },
  "tools": {
    "webSearch": {
      "enabled": true,
      "maxUses": 5,
      "allowedDomains": [],
      "blockedDomains": []
    },
    "imagegen": {
      "provider": "openai",
      "defaultSize": "1024x1024",
      "supportedProviders": ["openai", "stability", "fal", "replicate", "custom"]
    }
  }
}
</file>

<file path="packages/database/src/migrations/008_brand_kits.sql">
/**
 * Migration 008: Brand Kit System
 *
 * Purpose:
 * - Store user-uploaded brand assets (logos, images)
 * - Extract and store color palettes
 * - Link brand kits to user accounts
 * - Support versioning and metadata
 *
 * Tables:
 * - core.brand_kits: Main brand kit metadata
 * - core.brand_assets: Individual assets (logos, images)
 * - core.brand_colors: Extracted color palettes
 */

-- ============================================================================
-- BRAND KITS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.brand_kits (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id           UUID NOT NULL REFERENCES core.users(id) ON DELETE CASCADE,

  -- Metadata
  name              TEXT NOT NULL,
  description       TEXT,

  -- Status
  status            TEXT NOT NULL DEFAULT 'active'
                    CHECK (status IN ('active', 'archived', 'deleted')),

  -- Versioning
  version           INT NOT NULL DEFAULT 1,

  -- Timestamps
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at        TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- Indexes
  CONSTRAINT brand_kits_name_check CHECK (char_length(name) >= 1 AND char_length(name) <= 100)
);

CREATE INDEX idx_brand_kits_user_id ON core.brand_kits(user_id);
CREATE INDEX idx_brand_kits_status ON core.brand_kits(status);
CREATE INDEX idx_brand_kits_created_at ON core.brand_kits(created_at DESC);

-- ============================================================================
-- BRAND ASSETS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.brand_assets (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  brand_kit_id      UUID NOT NULL REFERENCES core.brand_kits(id) ON DELETE CASCADE,
  user_id           UUID NOT NULL REFERENCES core.users(id) ON DELETE CASCADE,

  -- Asset metadata
  asset_type        TEXT NOT NULL
                    CHECK (asset_type IN ('logo', 'image', 'icon', 'pattern')),
  file_name         TEXT NOT NULL,

  -- Storage
  storage_key       TEXT NOT NULL,  -- S3/GCS object key
  storage_provider  TEXT NOT NULL DEFAULT 'gcs'
                    CHECK (storage_provider IN ('s3', 'gcs', 'local')),

  -- File details
  mime_type         TEXT NOT NULL,
  file_size_bytes   BIGINT NOT NULL CHECK (file_size_bytes > 0),

  -- Image dimensions
  width_px          INT,
  height_px         INT,

  -- Processing status
  processing_status TEXT NOT NULL DEFAULT 'pending'
                    CHECK (processing_status IN ('pending', 'processing', 'completed', 'failed')),
  processing_error  TEXT,

  -- Metadata
  metadata          JSONB DEFAULT '{}',

  -- Timestamps
  uploaded_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
  processed_at      TIMESTAMPTZ,
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- Constraints
  CONSTRAINT brand_assets_file_size_check CHECK (file_size_bytes <= 10485760)  -- 10MB max
);

CREATE INDEX idx_brand_assets_brand_kit_id ON core.brand_assets(brand_kit_id);
CREATE INDEX idx_brand_assets_user_id ON core.brand_assets(user_id);
CREATE INDEX idx_brand_assets_asset_type ON core.brand_assets(asset_type);
CREATE INDEX idx_brand_assets_processing_status ON core.brand_assets(processing_status);

-- ============================================================================
-- BRAND COLORS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.brand_colors (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  brand_kit_id      UUID NOT NULL REFERENCES core.brand_kits(id) ON DELETE CASCADE,
  asset_id          UUID REFERENCES core.brand_assets(id) ON DELETE SET NULL,  -- Source asset (optional)

  -- Color information
  color_hex         TEXT NOT NULL CHECK (color_hex ~ '^#[0-9A-Fa-f]{6}$'),  -- e.g., #FF5733
  color_rgb         JSONB NOT NULL,  -- { "r": 255, "g": 87, "b": 51 }
  color_hsl         JSONB,           -- { "h": 12, "s": 100, "l": 60 }

  -- Color metadata
  color_name        TEXT,            -- Optional: "Primary Red", "Brand Blue", etc.
  color_role        TEXT CHECK (color_role IN ('primary', 'secondary', 'accent', 'neutral', 'extracted')),

  -- Prominence (for extracted colors)
  prominence_score  FLOAT CHECK (prominence_score >= 0 AND prominence_score <= 1),
  pixel_percentage  FLOAT CHECK (pixel_percentage >= 0 AND pixel_percentage <= 100),

  -- Ordering
  display_order     INT DEFAULT 0,

  -- Timestamps
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_brand_colors_brand_kit_id ON core.brand_colors(brand_kit_id);
CREATE INDEX idx_brand_colors_asset_id ON core.brand_colors(asset_id);
CREATE INDEX idx_brand_colors_color_role ON core.brand_colors(color_role);
CREATE INDEX idx_brand_colors_display_order ON core.brand_colors(brand_kit_id, display_order);

-- ============================================================================
-- UPDATE TRIGGERS
-- ============================================================================

-- Auto-update updated_at for brand_kits
CREATE OR REPLACE FUNCTION update_brand_kit_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER brand_kits_updated_at
  BEFORE UPDATE ON core.brand_kits
  FOR EACH ROW
  EXECUTE FUNCTION update_brand_kit_timestamp();

-- Auto-update updated_at for brand_colors
CREATE OR REPLACE FUNCTION update_brand_color_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER brand_colors_updated_at
  BEFORE UPDATE ON core.brand_colors
  FOR EACH ROW
  EXECUTE FUNCTION update_brand_color_timestamp();

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON TABLE core.brand_kits IS 'User-created brand kits containing assets and color palettes';
COMMENT ON TABLE core.brand_assets IS 'Individual assets (logos, images) uploaded to brand kits';
COMMENT ON TABLE core.brand_colors IS 'Color palettes extracted from brand assets or manually defined';

COMMENT ON COLUMN core.brand_assets.storage_key IS 'Cloud storage object key (e.g., brand-kits/user123/asset456.png)';
COMMENT ON COLUMN core.brand_assets.processing_status IS 'Status of image processing and palette extraction';
COMMENT ON COLUMN core.brand_colors.prominence_score IS 'AI-determined color importance (0-1, higher = more prominent)';
COMMENT ON COLUMN core.brand_colors.pixel_percentage IS 'Percentage of image pixels with this color';
</file>

<file path="packages/database/src/migrations/013_netlify_integration.sql">
/**
 * Migration 013: Netlify Integration
 *
 * Purpose:
 * - Store encrypted Netlify PATs per user
 * - Track Netlify sites created via the platform
 * - Link deployments to Netlify sites
 * - Support per-user Netlify credentials (BYO-PAT model)
 *
 * Tables:
 * - core.user_integrations: Store encrypted credentials for external services
 * - core.netlify_sites: Track Netlify sites created by users
 *
 * Security:
 * - PATs encrypted using pgcrypto (AES-256)
 * - Encryption key stored in environment (ENCRYPTION_KEY)
 * - Only last 4 chars of tokens visible
 */

-- ============================================================================
-- USER INTEGRATIONS TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.user_integrations (
  id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id             UUID NOT NULL REFERENCES core.users(id) ON DELETE CASCADE,
  service             TEXT NOT NULL CHECK (service IN ('netlify', 'vercel', 'github', 'gitlab')),

  -- Encrypted credentials
  encrypted_token     BYTEA NOT NULL,  -- Encrypted PAT/token
  token_last_4        TEXT,            -- Last 4 chars for UI display

  -- Service-specific user info
  service_user_id     TEXT,            -- External service user ID
  service_email       TEXT,            -- Email from the external service
  service_username    TEXT,            -- Username from the external service

  -- Status
  is_verified         BOOLEAN DEFAULT false,
  verified_at         TIMESTAMPTZ,
  last_used_at        TIMESTAMPTZ,

  -- Metadata
  metadata            JSONB DEFAULT '{}',

  -- Timestamps
  created_at          TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at          TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- One integration per service per user
  UNIQUE (user_id, service)
);

CREATE INDEX idx_user_integrations_user_id ON core.user_integrations(user_id);
CREATE INDEX idx_user_integrations_service ON core.user_integrations(service);
CREATE INDEX idx_user_integrations_verified ON core.user_integrations(is_verified) WHERE is_verified = true;

-- ============================================================================
-- NETLIFY SITES TABLE
-- ============================================================================

CREATE TABLE IF NOT EXISTS core.netlify_sites (
  id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id             UUID NOT NULL REFERENCES core.users(id) ON DELETE CASCADE,
  app_id              UUID REFERENCES core.apps(id) ON DELETE SET NULL,
  session_id          UUID REFERENCES core.sessions(id) ON DELETE SET NULL,

  -- Netlify site details
  netlify_site_id     TEXT NOT NULL,   -- Netlify's site ID
  site_name           TEXT,            -- Site name/subdomain
  url                 TEXT NOT NULL,   -- Production URL (https://name.netlify.app)
  admin_url           TEXT,            -- Netlify admin URL
  ssl_url             TEXT,            -- SSL URL if different

  -- Site metadata
  created_via         TEXT DEFAULT 'eitherway',
  custom_domain       TEXT,            -- Custom domain if configured

  -- Status
  is_active           BOOLEAN DEFAULT true,
  last_deploy_id      TEXT,            -- Last Netlify deploy ID
  last_deploy_at      TIMESTAMPTZ,

  -- Timestamps
  created_at          TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at          TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- Ensure unique Netlify site IDs per user
  UNIQUE (user_id, netlify_site_id)
);

CREATE INDEX idx_netlify_sites_user_id ON core.netlify_sites(user_id);
CREATE INDEX idx_netlify_sites_app_id ON core.netlify_sites(app_id) WHERE app_id IS NOT NULL;
CREATE INDEX idx_netlify_sites_netlify_id ON core.netlify_sites(netlify_site_id);
CREATE INDEX idx_netlify_sites_is_active ON core.netlify_sites(is_active) WHERE is_active = true;

-- ============================================================================
-- ADD NETLIFY SITE REFERENCE TO DEPLOYMENTS
-- ============================================================================

-- Add column to link deployments to Netlify sites
ALTER TABLE core.deployments
  ADD COLUMN IF NOT EXISTS netlify_site_id UUID REFERENCES core.netlify_sites(id) ON DELETE SET NULL;

-- Add column for Netlify deploy ID
ALTER TABLE core.deployments
  ADD COLUMN IF NOT EXISTS netlify_deploy_id TEXT;

-- Add column for deployment title (shown in Netlify UI)
ALTER TABLE core.deployments
  ADD COLUMN IF NOT EXISTS deploy_title TEXT;

CREATE INDEX IF NOT EXISTS idx_deployments_netlify_site_id
  ON core.deployments(netlify_site_id) WHERE netlify_site_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_deployments_netlify_deploy_id
  ON core.deployments(netlify_deploy_id) WHERE netlify_deploy_id IS NOT NULL;

-- ============================================================================
-- ENCRYPTION HELPER FUNCTIONS
-- ============================================================================

/**
 * Encrypt a token using AES-256
 * Requires ENCRYPTION_KEY environment variable
 */
CREATE OR REPLACE FUNCTION encrypt_token(token TEXT, encryption_key TEXT)
RETURNS BYTEA AS $$
BEGIN
  RETURN pgp_sym_encrypt(token, encryption_key, 'cipher-algo=aes256');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

/**
 * Decrypt a token
 * Requires ENCRYPTION_KEY environment variable
 */
CREATE OR REPLACE FUNCTION decrypt_token(encrypted_token BYTEA, encryption_key TEXT)
RETURNS TEXT AS $$
BEGIN
  RETURN pgp_sym_decrypt(encrypted_token, encryption_key, 'cipher-algo=aes256');
EXCEPTION
  WHEN OTHERS THEN
    RETURN NULL; -- Return NULL on decryption failure
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

/**
 * Get last 4 characters of a token
 */
CREATE OR REPLACE FUNCTION get_token_last_4(token TEXT)
RETURNS TEXT AS $$
BEGIN
  IF length(token) < 4 THEN
    RETURN '****';
  END IF;
  RETURN right(token, 4);
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ============================================================================
-- UPDATE TRIGGERS
-- ============================================================================

-- Auto-update updated_at for user_integrations
CREATE TRIGGER user_integrations_updated_at
  BEFORE UPDATE ON core.user_integrations
  FOR EACH ROW
  EXECUTE FUNCTION core.update_updated_at();

-- Auto-update updated_at for netlify_sites
CREATE TRIGGER netlify_sites_updated_at
  BEFORE UPDATE ON core.netlify_sites
  FOR EACH ROW
  EXECUTE FUNCTION core.update_updated_at();

-- ============================================================================
-- VIEWS
-- ============================================================================

/**
 * View: User integrations with safe token display
 */
CREATE OR REPLACE VIEW core.user_integrations_safe AS
SELECT
  id,
  user_id,
  service,
  token_last_4,
  service_user_id,
  service_email,
  service_username,
  is_verified,
  verified_at,
  last_used_at,
  metadata,
  created_at,
  updated_at
FROM core.user_integrations;

/**
 * View: Netlify sites with deployment stats
 */
CREATE OR REPLACE VIEW core.netlify_sites_with_stats AS
SELECT
  ns.*,
  a.name AS app_name,
  u.email AS user_email,
  (
    SELECT COUNT(*)
    FROM core.deployments d
    WHERE d.netlify_site_id = ns.id
  ) AS total_deploys,
  (
    SELECT COUNT(*)
    FROM core.deployments d
    WHERE d.netlify_site_id = ns.id
      AND d.status = 'success'
  ) AS successful_deploys,
  (
    SELECT MAX(d.completed_at)
    FROM core.deployments d
    WHERE d.netlify_site_id = ns.id
      AND d.status = 'success'
  ) AS last_successful_deploy_at
FROM core.netlify_sites ns
LEFT JOIN core.apps a ON ns.app_id = a.id
LEFT JOIN core.users u ON ns.user_id = u.id;

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON TABLE core.user_integrations IS 'Store encrypted credentials for external services (Netlify, Vercel, etc.)';
COMMENT ON TABLE core.netlify_sites IS 'Track Netlify sites created and managed via EitherWay';

COMMENT ON COLUMN core.user_integrations.encrypted_token IS 'AES-256 encrypted PAT/token using pgcrypto';
COMMENT ON COLUMN core.user_integrations.token_last_4 IS 'Last 4 chars of token for UI display (security)';
COMMENT ON COLUMN core.user_integrations.service_user_id IS 'External service user ID (e.g., Netlify user ID)';

COMMENT ON COLUMN core.netlify_sites.netlify_site_id IS 'Netlify internal site ID';
COMMENT ON COLUMN core.netlify_sites.url IS 'Production site URL (e.g., https://name.netlify.app)';
COMMENT ON COLUMN core.netlify_sites.admin_url IS 'Netlify admin/settings URL';

COMMENT ON FUNCTION encrypt_token(TEXT, TEXT) IS 'Encrypt a token using AES-256 via pgcrypto';
COMMENT ON FUNCTION decrypt_token(BYTEA, TEXT) IS 'Decrypt a token encrypted with encrypt_token';
COMMENT ON FUNCTION get_token_last_4(TEXT) IS 'Get last 4 characters of a token for safe display';
</file>

<file path="packages/database/src/services/diff-builder.ts">
import { DatabaseClient } from '../client.js';
import { FilesRepository } from '../repositories/files.js';
import { createTwoFilesPatch } from 'diff';

export interface FileDiff {
  path: string;
  oldContent: string;
  newContent: string;
  patch: string;
  linesAdded: number;
  linesRemoved: number;
}

export interface DiffContext {
  changedFiles: FileDiff[];
  impactedFiles: Array<{
    path: string;
    reason: string;
  }>;
  totalChanges: {
    filesChanged: number;
    linesAdded: number;
    linesRemoved: number;
  };
}

export class DiffBuilder {
  private filesRepo: FilesRepository;

  constructor(private db: DatabaseClient) {
    this.filesRepo = new FilesRepository(db);
  }

  async buildDiff(_appId: string, fileId: string, newContent: string): Promise<FileDiff> {
    const file = await this.filesRepo.findById(fileId);
    if (!file) {
      throw new Error(`File ${fileId} not found`);
    }

    const currentVersion = await this.filesRepo.getHeadVersion(fileId);
    const oldContent = currentVersion?.content_text || '';

    const patch = createTwoFilesPatch(file.path, file.path, oldContent, newContent, 'current', 'proposed');

    const lines = patch.split('\n');
    const linesAdded = lines.filter((l) => l.startsWith('+')).length;
    const linesRemoved = lines.filter((l) => l.startsWith('-')).length;

    return {
      path: file.path,
      oldContent,
      newContent,
      patch,
      linesAdded,
      linesRemoved,
    };
  }

  async buildMultiFileDiff(
    appId: string,
    changes: Array<{ fileId: string; newContent: string }>,
  ): Promise<DiffContext> {
    const changedFiles: FileDiff[] = [];

    for (const change of changes) {
      const diff = await this.buildDiff(appId, change.fileId, change.newContent);
      changedFiles.push(diff);
    }

    const impactedFileIds = await this.getImpactedFiles(
      appId,
      changes.map((c) => c.fileId),
    );

    const impactedFiles = await Promise.all(
      impactedFileIds.map(async (id) => {
        const file = await this.filesRepo.findById(id);
        return {
          path: file?.path || 'unknown',
          reason: 'Referenced by changed file',
        };
      }),
    );

    const totalChanges = {
      filesChanged: changedFiles.length,
      linesAdded: changedFiles.reduce((sum, f) => sum + f.linesAdded, 0),
      linesRemoved: changedFiles.reduce((sum, f) => sum + f.linesRemoved, 0),
    };

    return {
      changedFiles,
      impactedFiles,
      totalChanges,
    };
  }

  formatDiffForPrompt(diffContext: DiffContext, maxLines = 500): string {
    const sections: string[] = [];

    sections.push('# Proposed Changes\n');

    if (diffContext.changedFiles.length > 0) {
      sections.push(`Files changed: ${diffContext.totalChanges.filesChanged}`);
      sections.push(`Lines added: +${diffContext.totalChanges.linesAdded}`);
      sections.push(`Lines removed: -${diffContext.totalChanges.linesRemoved}\n`);

      let totalLines = 0;
      for (const file of diffContext.changedFiles) {
        if (totalLines >= maxLines) {
          sections.push('... (diff truncated due to size)');
          break;
        }

        sections.push(`## ${file.path}`);
        sections.push('```diff');

        const patchLines = file.patch.split('\n').slice(4);
        const displayLines = patchLines.slice(0, Math.min(patchLines.length, maxLines - totalLines));

        sections.push(displayLines.join('\n'));
        sections.push('```\n');

        totalLines += displayLines.length;
      }
    }

    if (diffContext.impactedFiles.length > 0) {
      sections.push('## Potentially Impacted Files\n');
      diffContext.impactedFiles.slice(0, 10).forEach((f) => {
        sections.push(`- ${f.path} (${f.reason})`);
      });

      if (diffContext.impactedFiles.length > 10) {
        sections.push(`... and ${diffContext.impactedFiles.length - 10} more`);
      }
    }

    return sections.join('\n');
  }

  private async getImpactedFiles(appId: string, sourceFileIds: string[]): Promise<string[]> {
    if (sourceFileIds.length === 0) return [];

    const result = await this.db.query<{ dest_file_id: string }>(
      `WITH RECURSIVE impact AS (
        SELECT f.dest_file_id
        FROM core.file_references f
        WHERE f.app_id = $1 AND f.src_file_id = ANY($2::uuid[])

        UNION

        SELECT f.dest_file_id
        FROM impact i
        JOIN core.file_references f ON f.app_id = $1 AND f.src_file_id = i.dest_file_id
        WHERE (SELECT COUNT(*) FROM impact) < 100
      )
      SELECT DISTINCT dest_file_id FROM impact`,
      [appId, sourceFileIds],
    );

    return result.rows.map((r) => r.dest_file_id);
  }
}
</file>

<file path="packages/database/src/services/file-store.ts">
import { DatabaseClient } from '../client.js';
import { FilesRepository } from '../repositories/files.js';

export interface FileNode {
  name: string;
  path: string;
  type: 'file' | 'directory';
  size?: number;
  mimeType?: string;
  isDirectory?: boolean;
  children?: FileNode[];
}

export interface FileContent {
  content: string | Uint8Array;
  mimeType: string;
  path: string;
  version?: number;
}

export interface FileStore {
  list(appId: string, limit?: number): Promise<FileNode[]>;
  read(appId: string, path: string): Promise<FileContent>;
  write(appId: string, path: string, content: string | Buffer, mimeType?: string, userId?: string): Promise<void>;
  rename(appId: string, oldPath: string, newPath: string): Promise<void>;
  delete(appId: string, path: string): Promise<void>;
  getVersions(appId: string, path: string, limit?: number): Promise<any[]>;
}

export class PostgresFileStore implements FileStore {
  private filesRepo: FilesRepository;

  constructor(db: DatabaseClient) {
    this.filesRepo = new FilesRepository(db);
  }

  async list(appId: string, limit = 1000): Promise<FileNode[]> {
    const files = await this.filesRepo.findByApp(appId, limit);

    const buildTree = (files: any[]): FileNode[] => {
      const rootNodes: FileNode[] = [];
      const nodeMap = new Map<string, FileNode>();

      files.forEach((file) => {
        const node: FileNode = {
          name: file.path.split('/').pop() || file.path,
          path: file.path,
          type: 'file',
          size: file.size_bytes || 0,
          mimeType: file.mime_type || undefined,
        };
        nodeMap.set(file.path, node);
      });

      const dirMap = new Map<string, FileNode>();

      files.forEach((file) => {
        // Normalize path: remove leading slashes to prevent empty directory names
        const normalizedPath = file.path.replace(/^\/+/, '');
        const parts = normalizedPath.split('/');
        const node = nodeMap.get(file.path)!;

        if (parts.length === 1) {
          rootNodes.push(node);
        } else {
          for (let i = parts.length - 1; i > 0; i--) {
            const dirPath = parts.slice(0, i).join('/');
            const dirName = parts[i - 1];

            if (!dirMap.has(dirPath)) {
              const dirNode: FileNode = {
                name: dirName,
                path: dirPath,
                type: 'directory',
                isDirectory: true,
                children: [],
              };
              dirMap.set(dirPath, dirNode);
            }

            const parentDir = dirMap.get(dirPath)!;

            if (i === parts.length - 1) {
              if (!parentDir.children!.some((c) => c.path === node.path)) {
                parentDir.children!.push(node);
              }
            }
          }

          const topDir = parts[0];
          const topDirPath = topDir;
          if (!dirMap.has(topDirPath)) {
            dirMap.set(topDirPath, {
              name: topDir,
              path: topDirPath,
              type: 'directory',
              isDirectory: true,
              children: [],
            });
          }
        }
      });

      dirMap.forEach((dir, path) => {
        if (!path.includes('/')) {
          rootNodes.push(dir);
        } else {
          const parentPath = path.substring(0, path.lastIndexOf('/'));
          const parentDir = dirMap.get(parentPath);
          if (parentDir && !parentDir.children!.some((c) => c.path === dir.path)) {
            parentDir.children!.push(dir);
          }
        }
      });

      const sortNodes = (nodes: FileNode[]): FileNode[] => {
        return nodes
          .sort((a, b) => {
            if (a.type === b.type) return a.name.localeCompare(b.name);
            return a.type === 'directory' ? -1 : 1;
          })
          .map((node) => {
            if (node.children) {
              node.children = sortNodes(node.children);
            }
            return node;
          });
      };

      return sortNodes(rootNodes);
    };

    return buildTree(files);
  }

  async read(appId: string, path: string): Promise<FileContent> {
    const file = await this.filesRepo.findByAppAndPath(appId, path);

    if (!file) {
      throw new Error(`File not found: ${path}`);
    }

    const version = await this.filesRepo.getHeadVersion(file.id);

    if (!version) {
      throw new Error(`No version found for file: ${path}`);
    }

    const content = version.content_bytes || version.content_text || '';
    const mimeType = file.mime_type || 'text/plain';

    return {
      content,
      mimeType,
      path: file.path,
      version: version.version,
    };
  }

  async write(
    appId: string,
    path: string,
    content: string | Buffer,
    mimeType?: string,
    userId?: string,
  ): Promise<void> {
    await this.filesRepo.upsertFile(appId, path, content, userId, mimeType);
  }

  async rename(appId: string, oldPath: string, newPath: string): Promise<void> {
    const file = await this.filesRepo.findByAppAndPath(appId, oldPath);

    if (!file) {
      throw new Error(`File not found: ${oldPath}`);
    }

    const latestVersion = await this.filesRepo.getHeadVersion(file.id);

    if (!latestVersion) {
      throw new Error(`No version found for file: ${oldPath}`);
    }

    const content = latestVersion.content_bytes || latestVersion.content_text || '';

    await this.filesRepo.upsertFile(appId, newPath, content, undefined, file.mime_type || undefined);
    await this.filesRepo.delete(file.id);
  }

  async delete(appId: string, path: string): Promise<void> {
    const file = await this.filesRepo.findByAppAndPath(appId, path);

    if (!file) {
      throw new Error(`File not found: ${path}`);
    }

    await this.filesRepo.delete(file.id);
  }

  async getVersions(appId: string, path: string, limit = 50): Promise<any[]> {
    const file = await this.filesRepo.findByAppAndPath(appId, path);

    if (!file) {
      throw new Error(`File not found: ${path}`);
    }

    return this.filesRepo.getVersionHistory(file.id, limit);
  }
}
</file>

<file path="packages/database/src/services/memory-prelude.ts">
import { DatabaseClient } from '../client.js';
import {
  SessionsRepository,
  MessagesRepository,
  SessionMemoryRepository,
  WorkingSetRepository,
  EventsRepository,
  AppsRepository,
} from '../repositories/index.js';

export interface MemoryPrelude {
  sessionTitle: string;
  appName: string | null;
  workingDirectory: string | null;
  pinnedFiles: Array<{
    path: string;
    reason: string | null;
  }>;
  recentDecisions: Array<{
    kind: string;
    summary: string;
    timestamp: Date;
  }>;
  rollingSummary: string | null;
  keyFacts: Record<string, any>;
  constraints: string[];
}

export class MemoryPreludeService {
  private sessionsRepo: SessionsRepository;
  private memoryRepo: SessionMemoryRepository;
  private workingSetRepo: WorkingSetRepository;
  private eventsRepo: EventsRepository;
  private appsRepo: AppsRepository;

  constructor(db: DatabaseClient) {
    this.sessionsRepo = new SessionsRepository(db);
    new MessagesRepository(db);
    this.memoryRepo = new SessionMemoryRepository(db);
    this.workingSetRepo = new WorkingSetRepository(db);
    this.eventsRepo = new EventsRepository(db);
    this.appsRepo = new AppsRepository(db);
  }

  async buildPrelude(sessionId: string): Promise<MemoryPrelude> {
    const session = await this.sessionsRepo.findById(sessionId);
    if (!session) {
      throw new Error(`Session ${sessionId} not found`);
    }

    const app = session.app_id ? await this.appsRepo.findById(session.app_id) : null;
    const memory = await this.memoryRepo.findBySession(sessionId);
    const workingSet = await this.workingSetRepo.findBySessionWithFiles(sessionId);

    const recentEvents = await this.eventsRepo.findBySession(sessionId, 20);
    const decisionEvents = recentEvents.filter(
      (e) => e.kind && ['file.upserted', 'session.created', 'image.job.created'].includes(e.kind),
    );

    const recentDecisions = decisionEvents.map((e) => ({
      kind: e.kind || 'unknown',
      summary: this.summarizeEvent(e),
      timestamp: e.created_at,
    }));

    const pinnedFiles = workingSet.map((ws) => ({
      path: ws.file_path,
      reason: ws.reason,
    }));

    const keyFacts = memory?.facts || {};
    const constraints = this.deriveConstraints(app?.name, keyFacts);

    return {
      sessionTitle: session.title,
      appName: app?.name ?? null,
      workingDirectory: app ? `/app/${app.name}` : null,
      pinnedFiles,
      recentDecisions,
      rollingSummary: memory?.rolling_summary ?? null,
      keyFacts,
      constraints,
    };
  }

  formatAsSystemMessage(prelude: MemoryPrelude): string {
    const sections: string[] = [];

    sections.push(`Session: ${prelude.sessionTitle}`);

    if (prelude.appName) {
      sections.push(`App: ${prelude.appName}`);
    }

    if (prelude.workingDirectory) {
      sections.push(`Working Directory: ${prelude.workingDirectory}`);
    }

    if (prelude.rollingSummary) {
      sections.push(`\nContext: ${prelude.rollingSummary}`);
    }

    if (Object.keys(prelude.keyFacts).length > 0) {
      sections.push('\nKey Facts:');
      Object.entries(prelude.keyFacts).forEach(([key, value]) => {
        sections.push(`  - ${key}: ${JSON.stringify(value)}`);
      });
    }

    if (prelude.pinnedFiles.length > 0) {
      sections.push('\nPinned Files:');
      prelude.pinnedFiles.forEach((f) => {
        sections.push(`  - ${f.path}${f.reason ? ` (${f.reason})` : ''}`);
      });
    }

    if (prelude.recentDecisions.length > 0) {
      sections.push('\nRecent Actions:');
      prelude.recentDecisions.slice(0, 5).forEach((d) => {
        sections.push(`  - ${d.summary}`);
      });
    }

    if (prelude.constraints.length > 0) {
      sections.push('\nConstraints:');
      prelude.constraints.forEach((c) => {
        sections.push(`  - ${c}`);
      });
    }

    return sections.join('\n');
  }

  private summarizeEvent(event: any): string {
    const payload = event.payload || {};

    switch (event.kind) {
      case 'file.upserted':
        return `Updated ${payload.path || 'file'}`;
      case 'image.job.created':
        return `Generated image: ${(payload.prompt || '').substring(0, 50)}...`;
      case 'session.created':
        return `Started session: ${payload.title || 'untitled'}`;
      default:
        return event.kind || 'unknown action';
    }
  }

  private deriveConstraints(_appName: string | null | undefined, facts: Record<string, any>): string[] {
    const constraints: string[] = [
      'Tests must pass before completion',
      'Follow existing code style and patterns',
      'Preserve backward compatibility where possible',
    ];

    if (facts.framework === 'react') {
      constraints.push('Use React hooks, avoid class components');
    }

    if (facts.typescript) {
      constraints.push('Maintain type safety, no any types without justification');
    }

    if (facts.linter) {
      constraints.push('Code must pass linter checks');
    }

    return constraints;
  }
}
</file>

<file path="packages/database/src/services/prepared-queries.ts">
import { DatabaseClient } from '../client.js';
import type { Message, File, Session } from '../types.js';

export class PreparedQueries {
  constructor(private db: DatabaseClient) {}

  async getRecentMessages(sessionId: string, limit = 10): Promise<Message[]> {
    const result = await this.db.query<Message>(
      `SELECT id, session_id, role, content, model, token_count, created_at
       FROM core.messages
       WHERE session_id = $1
       ORDER BY created_at DESC
       LIMIT $2`,
      [sessionId, limit],
    );
    return result.rows.reverse();
  }

  async getSessionWithMemory(sessionId: string): Promise<{
    session: Session;
    recentMessages: Message[];
    memory: any;
  } | null> {
    const sessionResult = await this.db.query<Session>(`SELECT * FROM core.sessions WHERE id = $1`, [sessionId]);

    if (sessionResult.rows.length === 0) return null;

    const [messages, memoryResult] = await Promise.all([
      this.getRecentMessages(sessionId, 10),
      this.db.query(`SELECT * FROM core.session_memory WHERE session_id = $1`, [sessionId]),
    ]);

    return {
      session: sessionResult.rows[0],
      recentMessages: messages,
      memory: memoryResult.rows[0] || null,
    };
  }

  async getAppFiles(appId: string, limit = 1000): Promise<File[]> {
    const result = await this.db.query<File>(
      `SELECT id, app_id, path, is_binary, mime_type, size_bytes, sha256,
              head_version_id, created_at, updated_at
       FROM core.files
       WHERE app_id = $1
       ORDER BY path ASC
       LIMIT $2`,
      [appId, limit],
    );
    return result.rows;
  }

  async getFilesByPaths(appId: string, paths: string[]): Promise<Map<string, File>> {
    if (paths.length === 0) return new Map();

    const result = await this.db.query<File>(
      `SELECT * FROM core.files
       WHERE app_id = $1 AND path = ANY($2::text[])`,
      [appId, paths],
    );

    const map = new Map<string, File>();
    result.rows.forEach((file) => {
      map.set(file.path, file);
    });

    return map;
  }

  async getWorkingSetWithFiles(sessionId: string): Promise<Array<any>> {
    const result = await this.db.query(
      `SELECT session_id, app_id, file_id, reason, pinned_by, created_at,
              file_path, is_binary, mime_type, size_bytes, file_updated_at
       FROM core.working_set_enriched
       WHERE session_id = $1
       ORDER BY created_at ASC`,
      [sessionId],
    );
    return result.rows;
  }

  async bulkInsertMessages(
    messages: Array<{
      sessionId: string;
      role: 'user' | 'assistant' | 'system' | 'tool';
      content: any;
      model?: string;
      tokenCount?: number;
    }>,
  ): Promise<Message[]> {
    if (messages.length === 0) return [];

    const values = messages
      .map((_m, i) => {
        const base = i * 5;
        return `($${base + 1}, $${base + 2}, $${base + 3}, $${base + 4}, $${base + 5})`;
      })
      .join(', ');

    const params: any[] = [];
    messages.forEach((m) => {
      params.push(m.sessionId, m.role, JSON.stringify(m.content), m.model ?? null, m.tokenCount ?? null);
    });

    const result = await this.db.query<Message>(
      `INSERT INTO core.messages (session_id, role, content, model, token_count)
       VALUES ${values}
       RETURNING *`,
      params,
    );

    return result.rows;
  }
}
</file>

<file path="packages/database/src/types.ts">
export interface User {
  id: string;
  email: string;
  display_name: string | null;
  created_at: Date;
}

export interface Session {
  id: string;
  user_id: string;
  title: string;
  app_id: string | null;
  status: 'active' | 'archived';
  last_message_at: Date | null;
  created_at: Date;
  updated_at: Date;
}

export type MessageRole = 'user' | 'assistant' | 'system' | 'tool';

export interface Message {
  id: string;
  session_id: string;
  role: MessageRole;
  content: any;
  model: string | null;
  token_count: number | null;
  created_at: Date;
}

export interface App {
  id: string;
  owner_id: string;
  name: string;
  visibility: 'private' | 'team' | 'public';
  default_session_id: string | null;
  created_at: Date;
  updated_at: Date;
}

export interface File {
  id: string;
  app_id: string;
  path: string;
  is_binary: boolean;
  mime_type: string | null;
  size_bytes: number | null;
  sha256: Buffer | null;
  head_version_id: string | null;
  created_at: Date;
  updated_at: Date;
}

export interface FileVersion {
  id: string;
  file_id: string;
  version: number;
  parent_version_id: string | null;
  content_text: string | null;
  content_bytes: Buffer | null;
  diff_from_parent: any | null;
  created_by: string | null;
  created_at: Date;
}

export type ReferenceType = 'import' | 'style' | 'asset' | 'link' | 'test' | 'build' | 'env' | 'other';

export interface FileReference {
  id: string;
  app_id: string;
  src_file_id: string;
  dest_file_id: string | null;
  raw_target: string | null;
  symbol: string | null;
  ref_type: ReferenceType;
  created_at: Date;
}

export interface SessionMemory {
  session_id: string;
  rolling_summary: string | null;
  facts: any | null;
  last_compacted_message_id: string | null;
  updated_at: Date;
}

export interface WorkingSetItem {
  session_id: string;
  app_id: string;
  file_id: string;
  reason: string | null;
  pinned_by: string | null;
  created_at: Date;
}

export type ImageJobState = 'queued' | 'generating' | 'succeeded' | 'failed' | 'canceled';

export interface ImageJob {
  id: string;
  session_id: string | null;
  app_id: string | null;
  prompt: string;
  model: string;
  size: string | null;
  n: number;
  state: ImageJobState;
  requested_at: Date;
  started_at: Date | null;
  finished_at: Date | null;
  error: any | null;
}

export interface ImageAsset {
  id: string;
  job_id: string;
  position: number;
  mime_type: string;
  bytes: Buffer | null;
  storage_url: string | null;
  checksum: Buffer | null;
  width: number | null;
  height: number | null;
  created_at: Date;
}

export interface Event {
  id: string;
  session_id: string | null;
  app_id: string | null;
  actor: string | null;
  kind: string | null;
  payload: any | null;
  created_at: Date;
}

export type EmbeddingScope = 'file' | 'symbol' | 'session' | 'chunk';

export interface DocEmbedding {
  id: string;
  app_id: string;
  scope: EmbeddingScope;
  ref_id: string | null;
  chunk_idx: number | null;
  vector: number[];
  content_preview: string | null;
  metadata: any | null;
  created_at: Date;
  updated_at: Date;
}

export type SymbolKind =
  | 'function'
  | 'class'
  | 'interface'
  | 'type'
  | 'const'
  | 'variable'
  | 'component'
  | 'hook'
  | 'endpoint'
  | 'model'
  | 'other';

export interface SymbolIndex {
  id: string;
  app_id: string;
  file_id: string;
  symbol_name: string;
  symbol_kind: SymbolKind;
  is_exported: boolean;
  line_start: number | null;
  line_end: number | null;
  signature: string | null;
  doc_comment: string | null;
  metadata: any | null;
  created_at: Date;
  updated_at: Date;
}

export type UsageKind = 'import' | 'call' | 'reference' | 'extend' | 'implement';

export interface SymbolUsage {
  id: string;
  app_id: string;
  symbol_id: string;
  usage_file_id: string;
  usage_line: number | null;
  usage_kind: UsageKind | null;
  created_at: Date;
}

export interface ProjectMetadata {
  app_id: string;
  framework: string | null;
  language: string | null;
  package_manager: string | null;
  entry_points: any | null;
  routes_map: any | null;
  dependencies: any | null;
  dev_dependencies: any | null;
  scripts: any | null;
  readme_summary: string | null;
  last_analyzed: Date | null;
  created_at: Date;
  updated_at: Date;
}

export interface ContextCache {
  id: string;
  session_id: string;
  app_id: string | null;
  cache_key: string;
  context_data: any;
  token_count: number | null;
  expires_at: Date;
  created_at: Date;
}

export type JobStatus = 'pending' | 'running' | 'completed' | 'failed' | 'canceled';

export interface BackgroundJob {
  id: string;
  job_type: string;
  target_id: string | null;
  payload: any | null;
  status: JobStatus;
  scheduled_at: Date;
  started_at: Date | null;
  completed_at: Date | null;
  error: any | null;
  retries: number;
  max_retries: number;
  created_at: Date;
}

export interface UserDailyLimit {
  user_id: string;
  limit_date: Date;
  sessions_created: number;
}

export interface SessionDailyLimit {
  session_id: string;
  limit_date: Date;
  messages_sent: number;
}
</file>

<file path="packages/database/vitest.config.ts">
import { defineConfig } from 'vitest/config';
import { resolve } from 'path';
import { config } from 'dotenv';

config({ path: resolve(__dirname, '../../.env') });

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    setupFiles: [],
  },
});
</file>

<file path="packages/evaluations/src/run-evals.ts">
#!/usr/bin/env node
/**
 * Evaluation runner for Portion 1 acceptance tests
 */

import { runCalculatorEval } from './calculator-eval.js';

async function main() {
  console.log('=== Portion 1 Acceptance Tests ===\n');

  // Test 1: Calculator evaluation
  console.log('Test 1: Calculator Request (Dry Run)');
  console.log('Request: "Build me a calculator"');
  console.log('Expected: Analyze and Plan stages complete\n');

  const result = await runCalculatorEval(true);

  console.log('Results:');
  for (const check of result.checks) {
    const icon = check.passed ? '' : '';
    console.log(`  ${icon} ${check.name}`);
    if (check.details) {
      console.log(`     ${check.details}`);
    }
  }

  console.log('\n' + '='.repeat(50));
  console.log(`Overall: ${result.passed ? ' PASSED' : ' FAILED'}`);
  console.log('='.repeat(50) + '\n');

  if (!result.passed) {
    process.exit(1);
  }
}

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});
</file>

<file path="packages/runtime/src/index.ts">
/**
 * @eitherway/runtime - LLM client, tool runner, orchestration
 */

export { ModelClient } from './model-client.js';
export { ToolRunner, SecurityGuard } from './tool-runner.js';
export { Agent } from './agent.js';
export { DatabaseAgent } from './database-agent.js';
export { TranscriptRecorder } from './transcript.js';
export { ConfigLoader } from './config.js';
export { MetricsCollector } from './metrics.js';
export { RateLimiter } from './rate-limiter.js';

export type { AgentOptions, StreamingCallbacks, StreamingPhase } from './agent.js';
export type { DatabaseAgentOptions } from './database-agent.js';
export type { ModelResponse, StreamDelta } from './model-client.js';
export type { ToolMetrics } from './metrics.js';
</file>

<file path="packages/runtime/package.json">
{
  "name": "@eitherway/runtime",
  "version": "0.1.0",
  "description": "LLM client, tool runner, orchestration",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsx src/cli.ts",
    "test": "vitest run"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.32.1",
    "@eitherway/database": "workspace:*",
    "@eitherway/tools-core": "workspace:*",
    "@eitherway/tools-impl": "workspace:*",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/node": "^20.11.16",
    "typescript": "^5.3.3",
    "tsx": "^4.7.0"
  }
}
</file>

<file path="packages/tools-impl/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "composite": true,
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "references": [{ "path": "../tools-core" }, { "path": "../database" }]
}
</file>

<file path="packages/ui-frontend/app/components/chat/BaseChat.tsx">
import type { Message } from 'ai';
import React, { type RefCallback, useState, useEffect } from 'react';
import { ClientOnly } from 'remix-utils/client-only';
import { Menu } from '~/components/sidebar/Menu.client';
import { IconButton } from '~/components/ui/IconButton';
import { Workbench } from '~/components/workbench/Workbench.client';

import { classNames } from '~/utils/classNames';
import { Messages } from './Messages.client';
import { SendButton } from './SendButton.client';
import { useWalletConnection } from '~/lib/web3/hooks';
import { ContentBlock1 } from '~/components/landing/ContentBlock1';
import { PricingBlock } from '~/components/landing/PricingBlock';
import { FaqBlock } from '~/components/landing/FaqBlockBlue';
import { LastBlock } from '~/components/landing/LastBlock';
import { Footer } from '~/components/landing/Footer';
import { AuthDialog } from '~/components/auth/AuthDialog';

import styles from './BaseChat.module.scss';

interface BaseChatProps {
  textareaRef?: React.RefObject<HTMLTextAreaElement> | undefined;
  messageRef?: RefCallback<HTMLDivElement> | undefined;
  scrollRef?: RefCallback<HTMLDivElement> | undefined;
  showChat?: boolean;
  chatStarted?: boolean;
  isStreaming?: boolean;
  messages?: Message[];
  enhancingPrompt?: boolean;
  promptEnhanced?: boolean;
  input?: string;
  minTextareaHeight?: number;

  // Phase 2: Streaming indicators
  currentPhase?: 'pending' | 'thinking' | 'reasoning' | 'code-writing' | 'building' | 'completed' | null;
  reasoningText?: string;
  thinkingDuration?: number | null;
  fileOperations?: Array<{ operation: string; filePath: string }>;
  tokenUsage?: { inputTokens: number; outputTokens: number } | null;

  handleStop?: () => void;
  sendMessage?: (event: React.UIEvent, messageInput?: string) => void;
  handleInputChange?: (event: React.ChangeEvent<HTMLTextAreaElement>) => void;
  enhancePrompt?: () => void;
}

const EXAMPLE_PROMPTS = [{ text: 'Wallet' }, { text: 'Game' }, { text: 'Chat' }, { text: 'DeFi' }];

export const BaseChat = React.forwardRef<HTMLDivElement, BaseChatProps>(
  (
    {
      textareaRef,
      messageRef,
      scrollRef,
      showChat = true,
      chatStarted = false,
      isStreaming = false,
      enhancingPrompt = false,
      promptEnhanced = false,
      messages,
      input = '',
      minTextareaHeight = 131,

      // Phase 2: Streaming indicators
      currentPhase,
      reasoningText,
      thinkingDuration,
      fileOperations,
      tokenUsage,

      sendMessage,
      handleInputChange,
      enhancePrompt,
      handleStop,
    },
    ref,
  ) => {
    const { isConnected } = useWalletConnection();
    const [isAuthenticated, setIsAuthenticated] = useState(false);
    const [showAuthDialog, setShowAuthDialog] = useState(false);
    const [pendingMessage, setPendingMessage] = useState<string | null>(null);

    const TEXTAREA_MAX_HEIGHT = chatStarted ? 400 : 200;
    console.log(chatStarted);

    const isPasswordVerified = () => {
      if (typeof window === 'undefined') {
        return false;
      }

      if (!isConnected) {
        return false;
      }

      const savedPassword = localStorage.getItem('daily_password_verified');

      if (!savedPassword) {
        return false;
      }

      try {
        const { timestamp } = JSON.parse(savedPassword);
        const now = new Date().getTime();
        const sevenDays = 7 * 24 * 60 * 60 * 1000;

        if (now - timestamp > sevenDays) {
          localStorage.removeItem('daily_password_verified');
          return false;
        }

        return true;
      } catch {
        localStorage.removeItem('daily_password_verified');
        return false;
      }
    };

    const handleAuthenticated = (message?: string) => {
      setIsAuthenticated(true);

      if (message && sendMessage) {
        const fakeEvent = {} as React.UIEvent;
        sendMessage(fakeEvent, message);
        setPendingMessage(null);
      }
    };

    const isUserAuthenticated = isAuthenticated || isPasswordVerified();

    useEffect(() => {
      if (!isConnected) {
        localStorage.removeItem('daily_password_verified');
        setIsAuthenticated(false);
      } else if (isConnected && !isUserAuthenticated && pendingMessage) {
        // wallet connected but not authenticated, reopen dialog for password
        setShowAuthDialog(true);
      }
    }, [isConnected, isUserAuthenticated, pendingMessage]);

    return (
      <div
        ref={ref}
        className={classNames(
          styles.BaseChat,
          'relative flex flex-col min-h-[calc(100vh-128px)] w-full min-w-[320px] overflow-x-auto bg-eitherway-elements-background-depth-1',
        )}
        data-chat-visible={showChat}
      >
        <ClientOnly>{() => <Menu />}</ClientOnly>
        <div ref={scrollRef} className="flex w-full flex-1 min-h-[calc(100vh-128px)]">
          <div className={classNames(styles.Chat, 'flex flex-col px-6 flex-grow')}>
            {!chatStarted && (
              <div id="intro" className="mt-[128px] max-[768px]:mt-[64px] max-w-chat mx-auto relative z-1">
                <h1
                  className="text-[64px] leading-[77px] max-[768px]:text-[32px] max-[768px]:leading-[38px] font-medium mb-6 max-[768px]:mb-4 font-syne"
                  style={{
                    color: '#ffffff',
                    letterSpacing: '-0.05em',
                    textAlign: 'left',
                  }}
                >
                  Don't just imagine it.
                  <br />
                  Launch it.
                </h1>
                <p
                  className="text-[16px] leading-[150%] max-[768px]:text-[14px] max-[768px]:leading-[140%] font-medium mb-4 max-[768px]:mb-3 font-montserrat"
                  style={{
                    color: '#ffffff',
                    textAlign: 'left',
                  }}
                >
                  Eitherway turns your ideas into fully working, monetizable mobile apps with a single prompt.{' '}
                  <span className="font-bold italic ">No coding. No delays.</span> Just build, publish, and earn 
                  either way.
                </p>
              </div>
            )}
            <div
              className={classNames('pt-6 flex-1', {
                'flex flex-col max-h-[calc(100vh-128px)]': chatStarted,
              })}
            >
              <ClientOnly>
                {() => {
                  return chatStarted ? (
                    <Messages
                      ref={messageRef}
                      scrollRef={scrollRef}
                      className="flex flex-col w-full flex-1 max-w-chat px-4 pb-6 mx-auto z-1 min-h-0"
                      messages={messages}
                      isStreaming={isStreaming}
                      currentPhase={currentPhase}
                      reasoningText={reasoningText}
                      thinkingDuration={thinkingDuration}
                      fileOperations={fileOperations}
                      tokenUsage={tokenUsage}
                    />
                  ) : null;
                }}
              </ClientOnly>
              <div
                id="auth-chat"
                className={classNames('relative w-full max-w-chat mx-auto z-prompt mt-6', {
                  'sticky bottom-0': chatStarted,
                })}
              >
                <div
                  className={classNames('relative rounded-lg overflow-hidden bg-black')}
                  style={{
                    background: 'linear-gradient(180deg, #FFFFFF 0%, rgba(255, 255, 255, 0.15) 100%)',
                    padding: '1px',
                  }}
                >
                  <div className="w-full h-full bg-black rounded-lg">
                    <textarea
                      ref={textareaRef}
                      className={`w-full pl-4  pt-4 rounded-lg placeholder:text-white/50 pr-16 focus:outline-none resize-none text-md text-eitherway-elements-textPrimary bg-black`}
                      onKeyDown={(event) => {
                        if (event.key === 'Enter') {
                          if (event.shiftKey) {
                            return;
                          }

                          event.preventDefault();

                          if (isUserAuthenticated) {
                            sendMessage?.(event);
                          } else {
                            setPendingMessage(input);
                            setShowAuthDialog(true);
                          }
                        }
                      }}
                      value={input}
                      onChange={(event) => {
                        handleInputChange?.(event);
                      }}
                      style={{
                        minHeight: minTextareaHeight,
                        maxHeight: TEXTAREA_MAX_HEIGHT,
                      }}
                      placeholder={chatStarted ? "Let's change..." : "Let's build..."}
                      translate="no"
                    />
                    <ClientOnly>
                      {() => (
                        <SendButton
                          show={(input.length > 0 && input.trim() !== '') || isStreaming}
                          isStreaming={isStreaming}
                          onClick={(event) => {
                            if (isStreaming) {
                              handleStop?.();
                              return;
                            }

                            if (isUserAuthenticated) {
                              sendMessage?.(event);
                            } else {
                              setPendingMessage(input);
                              setShowAuthDialog(true);
                            }
                          }}
                        />
                      )}
                    </ClientOnly>
                    <div className="flex justify-between text-sm p-4 pt-2">
                      <div className="flex gap-1 items-center">
                        <IconButton
                          title={isStreaming ? 'Brand kit disabled while agent is working' : 'Upload brand assets'}
                          disabled={isStreaming}
                          className="text-eitherway-elements-textTertiary hover:text-eitherway-elements-textPrimary"
                          onClick={() => {
                            window.dispatchEvent(new CustomEvent('open-brand-kit'));
                          }}
                        >
                          <div className="i-ph:paperclip text-xl"></div>
                        </IconButton>
                        <IconButton
                          title="Enhance prompt"
                          disabled={input.length === 0 || enhancingPrompt}
                          className={classNames({
                            'opacity-100!': enhancingPrompt,
                            'text-eitherway-elements-item-contentAccent! pr-1.5 enabled:hover:bg-eitherway-elements-item-backgroundAccent!':
                              promptEnhanced,
                          })}
                          onClick={() => enhancePrompt?.()}
                        >
                          {enhancingPrompt ? (
                            <>
                              <img
                                src="/icons/chat/loader.svg"
                                alt="Loading"
                                className="w-5 h-5 text-eitherway-elements-loader-progress animate-spin"
                              />
                              <div className="ml-1.5">Enhancing prompt...</div>
                            </>
                          ) : (
                            <>
                              <div className="i-eitherway:stars text-xl"></div>
                              {promptEnhanced && <div className="ml-1.5">Prompt enhanced</div>}
                            </>
                          )}
                        </IconButton>
                      </div>
                      {input.length > 3 ? (
                        <div className="text-xs flex gap-1 items-center text-eitherway-elements-textTertiary">
                          Use <kbd className="kdb">Shift</kbd> + <kbd className="kdb">Return</kbd> for a new line
                        </div>
                      ) : null}
                    </div>
                  </div>
                </div>
                <div className=" pb-6">{/* Ghost Element */}</div>
                {!chatStarted && (
                  <div id="examples" className="flex flex-row items-center gap-4 w-full max-w-640px h-14 mx-auto">
                    {EXAMPLE_PROMPTS.map((examplePrompt, index) => {
                      return (
                        <button
                          key={index}
                          onClick={(event) => {
                            if (isUserAuthenticated) {
                              sendMessage?.(event, examplePrompt.text);
                            } else {
                              setPendingMessage(examplePrompt.text);
                              setShowAuthDialog(true);
                            }
                          }}
                          className="flex-1 h-14 bg-black border border-white/15 rounded-2xl cursor-pointer transition-all duration-200 font-montserrat text-sm text-white/75 text-center hover:text-white"
                        >
                          {examplePrompt.text}
                        </button>
                      );
                    })}
                  </div>
                )}
              </div>
            </div>
          </div>
          <ClientOnly>{() => <Workbench chatStarted={chatStarted} isStreaming={isStreaming} />}</ClientOnly>
        </div>

        {!chatStarted && (
          <div className="w-full">
            <ContentBlock1 />
            <PricingBlock />
            <FaqBlock />
            <LastBlock />
            <Footer />
          </div>
        )}

        <AuthDialog
          isOpen={showAuthDialog}
          onClose={() => setShowAuthDialog(false)}
          onAuthenticated={handleAuthenticated}
          pendingMessage={pendingMessage}
        />
      </div>
    );
  },
);
</file>

<file path="packages/ui-frontend/app/components/chat/Messages.client.tsx">
import type { Message } from 'ai';
import React from 'react';
import { classNames } from '~/utils/classNames';
import { AssistantMessage } from './AssistantMessage';
import { UserMessage } from './UserMessage';
import styles from './BaseChat.module.scss';

interface MessagesProps {
  id?: string;
  className?: string;
  isStreaming?: boolean;
  messages?: Message[];
  scrollRef?: (node: HTMLDivElement | null) => void;
  currentPhase?: 'pending' | 'thinking' | 'reasoning' | 'code-writing' | 'building' | 'completed' | null;
  reasoningText?: string;
  thinkingDuration?: number | null;
  fileOperations?: Array<{ operation: string; filePath: string }>;
  tokenUsage?: { inputTokens: number; outputTokens: number } | null;
}

interface ExtendedMessage extends Message {
  metadata?: {
    reasoningText?: string;
    thinkingDuration?: number | null;
    fileOperations?: Array<{ operation: string; filePath: string }>;
    tokenUsage?: { inputTokens: number; outputTokens: number } | null;
    phase?: 'pending' | 'thinking' | 'reasoning' | 'code-writing' | 'building' | 'completed' | null;
  };
}

export const Messages = React.forwardRef<HTMLDivElement, MessagesProps>((props: MessagesProps, ref) => {
  const {
    id,
    isStreaming = false,
    messages = [],
    scrollRef,
    currentPhase,
    reasoningText,
    thinkingDuration,
    fileOperations,
    tokenUsage,
  } = props;

  return (
    <div
      id={id}
      ref={(node) => {
        if (ref) {
          if (typeof ref === 'function') {
            ref(node);
          } else {
            ref.current = node;
          }
        }

        if (scrollRef) {
          scrollRef(node);
        }
      }}
      className={classNames(
        props.className,
        styles.chatScroll,
        'border border-eitherway-elements-borderColor bg-black/90 backdrop-blur-[3px] rounded-lg overflow-y-auto overflow-x-hidden p-6',
      )}
    >
      {messages.length > 0
        ? messages.map((message, index) => {
            const { role, content } = message as ExtendedMessage;
            const isUserMessage = role === 'user';
            const isFirst = index === 0;
            const isLast = index === messages.length - 1;

            // For assistant messages, use saved metadata or current streaming state
            const extendedMessage = message as ExtendedMessage;
            const messageMetadata = extendedMessage.metadata || {};

            // Determine what to display based on whether this is the last (streaming) message or old message
            const displayReasoningText = isLast
              ? messageMetadata.reasoningText || reasoningText // Last message: prefer saved, fallback to streaming state
              : messageMetadata.reasoningText || ''; // Old message: only use saved

            const displayPhase = isLast ? currentPhase || messageMetadata.phase || null : messageMetadata.phase || null;

            const displayThinkingDuration = isLast
              ? (messageMetadata.thinkingDuration ?? thinkingDuration)
              : (messageMetadata.thinkingDuration ?? null);

            const displayFileOperations = isLast
              ? messageMetadata.fileOperations || fileOperations
              : messageMetadata.fileOperations || [];

            const displayTokenUsage = isLast
              ? messageMetadata.tokenUsage || tokenUsage
              : messageMetadata.tokenUsage || null;

            // Debug: Log what we're displaying for each message
            if (!isUserMessage) {
              console.log(` [Render Message ${index}]`, {
                isLast,
                messageId: (message as any).id,
                hasMetadata: !!extendedMessage.metadata,
                metadataKeys: extendedMessage.metadata ? Object.keys(extendedMessage.metadata) : [],
                savedReasoning: messageMetadata.reasoningText?.length || 0,
                displayReasoning: displayReasoningText?.length || 0,
                streamingReasoning: reasoningText?.length || 0,
                // Show first 100 chars of reasoning
                savedReasoningPreview: messageMetadata.reasoningText?.substring(0, 100) || 'NONE',
                displayReasoningPreview: displayReasoningText?.substring(0, 100) || 'NONE',
              });
            }

            return (
              <div
                key={index}
                className={classNames('flex gap-4 relative', {
                  'p-4 bg-black/50 border border-eitherway-elements-borderColor rounded-lg': !isUserMessage,
                  'px-6 py-2 bg-white/10 rounded-lg ml-auto w-fit max-w-[60%]': isUserMessage,
                  'mt-4': !isFirst,
                })}
              >
                <div
                  className={classNames('grid grid-col-1', {
                    'w-full': !isUserMessage,
                    'w-fit': isUserMessage,
                  })}
                >
                  {isUserMessage ? (
                    <UserMessage content={content} />
                  ) : (
                    <AssistantMessage
                      content={content}
                      isStreaming={isStreaming && isLast}
                      phase={displayPhase}
                      reasoningText={displayReasoningText}
                      thinkingDuration={displayThinkingDuration}
                      fileOperations={displayFileOperations}
                      tokenUsage={displayTokenUsage}
                    />
                  )}
                </div>
              </div>
            );
          })
        : null}
    </div>
  );
});
</file>

<file path="packages/ui-frontend/app/components/editor/codemirror/indent.ts">
import { indentLess } from '@codemirror/commands';
import { indentUnit } from '@codemirror/language';
import { EditorSelection, EditorState, Line, type ChangeSpec } from '@codemirror/state';
import { EditorView, type KeyBinding } from '@codemirror/view';

export const indentKeyBinding: KeyBinding = {
  key: 'Tab',
  run: indentMore,
  shift: indentLess,
};

function indentMore({ state, dispatch }: EditorView) {
  if (state.readOnly) {
    return false;
  }

  dispatch(
    state.update(
      changeBySelectedLine(state, (from, to, changes) => {
        changes.push({ from, to, insert: state.facet(indentUnit) });
      }),
      { userEvent: 'input.indent' },
    ),
  );

  return true;
}

function changeBySelectedLine(
  state: EditorState,
  cb: (from: number, to: number | undefined, changes: ChangeSpec[], line: Line) => void,
) {
  return state.changeByRange((range) => {
    const changes: ChangeSpec[] = [];

    const line = state.doc.lineAt(range.from);

    // just insert single indent unit at the current cursor position
    if (range.from === range.to) {
      cb(range.from, undefined, changes, line);
    } else if (range.from < range.to && range.to <= line.to) {
      cb(range.from, range.to, changes, line);
    } else {
      let atLine = -1;

      for (let pos = range.from; pos <= range.to; ) {
        const line = state.doc.lineAt(pos);

        if (line.number > atLine && (range.empty || range.to > line.from)) {
          cb(line.from, undefined, changes, line);
          atLine = line.number;
        }

        pos = line.to + 1;
      }
    }

    const changeSet = state.changes(changes);

    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1)),
    };
  });
}
</file>

<file path="packages/ui-frontend/app/components/preview/MobilePreview.tsx">
/**
 * Mobile Preview Component
 *
 * iPhone 17 Pro Max Preview with PWA Validation
 * - Device: iPhone 17 Pro Max (430932 logical pixels, 3x retina)
 * - Orientation: Portrait/Landscape toggle
 * - PWA Status: Real-time validation display
 */

import { useState, useEffect } from 'react';

// TYPES

interface PWAValidationResult {
  status: 'passed' | 'failed' | 'warning';
  overall_score: number;
  manifest_score: number;
  service_worker_score: number;
  icons_score: number;
  manifest_valid: boolean;
  service_worker_registered: boolean;
  icons_valid: boolean;
  is_https: boolean;
  has_viewport_meta: boolean;
  offline_ready: boolean;
  validation_errors: string[];
  manifest_errors: string[];
  manifest_warnings: string[];
  service_worker_errors: string[];
}

interface MobilePreviewProps {
  previewUrl: string;
  appId: string;
  sessionId: string;
  onClose?: () => void;
}

// CONSTANTS

const IPHONE_17_PRO_MAX = {
  name: 'iPhone 17 Pro Max',
  width: 430, // Logical pixels (portrait)
  height: 932, // Logical pixels (portrait)
  pixelRatio: 3.0,
  userAgent:
    'Mozilla/5.0 (iPhone; CPU iPhone OS 18_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1',
  borderRadius: 60,
  notchHeight: 30,
};

// MOBILE PREVIEW COMPONENT

export function MobilePreview({ previewUrl, appId, sessionId, onClose }: MobilePreviewProps) {
  const [orientation, setOrientation] = useState<'portrait' | 'landscape'>('portrait');
  const [pwaValidation, setPwaValidation] = useState<PWAValidationResult | null>(null);
  const [isValidating, setIsValidating] = useState(false);
  const [showPwaDetails, setShowPwaDetails] = useState(false);

  const width = orientation === 'portrait' ? IPHONE_17_PRO_MAX.width : IPHONE_17_PRO_MAX.height;
  const height = orientation === 'portrait' ? IPHONE_17_PRO_MAX.height : IPHONE_17_PRO_MAX.width;

  // Scale factor to fit on screen (max 90% of viewport)
  const scale = Math.min((window.innerWidth * 0.5) / width, (window.innerHeight * 0.85) / height, 1);

  /**
   * Run PWA validation
   */
  const runPWAValidation = async () => {
    setIsValidating(true);
    try {
      const response = await fetch(`/api/apps/${appId}/preview/pwa/validate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: sessionId,
          url: previewUrl,
        }),
      });

      const data = await response.json();
      if (data.success && data.validation) {
        setPwaValidation({
          status: data.validation.status,
          overall_score: data.validation.overall_score,
          manifest_score: data.validation.manifest_score,
          service_worker_score: data.validation.service_worker_score,
          icons_score: data.validation.icons_score,
          manifest_valid: data.validation.manifest_valid,
          service_worker_registered: data.validation.service_worker_registered,
          icons_valid: data.validation.icons_valid,
          is_https: data.validation.is_https,
          has_viewport_meta: data.validation.has_viewport_meta,
          offline_ready: data.validation.offline_ready,
          validation_errors: data.validation.validation_errors,
          manifest_errors: data.validation.manifest_errors,
          manifest_warnings: data.validation.manifest_warnings,
          service_worker_errors: data.validation.service_worker_errors,
        });
      }
    } catch (error: any) {
      console.error('PWA validation error:', error);
    } finally {
      setIsValidating(false);
    }
  };

  useEffect(() => {
    const loadLatestValidation = async () => {
      try {
        const response = await fetch(`/api/apps/${appId}/preview/pwa/latest`);
        const data = await response.json();
        if (data.success && data.validation) {
          setPwaValidation(data.validation);
        }
      } catch (error) {
        console.error('Failed to load latest validation:', error);
      }
    };

    loadLatestValidation();
  }, [appId]);

  return (
    <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
      <div className="bg-gray-900 rounded-2xl shadow-2xl max-w-7xl w-full max-h-[95vh] flex overflow-hidden">
        {/* Left Panel - Device Preview */}
        <div className="flex-1 flex flex-col items-center justify-center p-8 bg-gradient-to-br from-gray-900 to-gray-800">
          {/* Header */}
          <div className="mb-6 flex items-center justify-between w-full max-w-2xl">
            <div>
              <h2 className="text-2xl font-bold text-white">{IPHONE_17_PRO_MAX.name}</h2>
              <p className="text-sm text-gray-400">
                {width}{height} @ {IPHONE_17_PRO_MAX.pixelRatio}x
              </p>
            </div>

            <div className="flex gap-2">
              {/* Orientation Toggle */}
              <button
                onClick={() => setOrientation(orientation === 'portrait' ? 'landscape' : 'portrait')}
                className="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg transition-colors flex items-center gap-2"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                  />
                </svg>
                {orientation === 'portrait' ? 'Portrait' : 'Landscape'}
              </button>

              {/* Close Button */}
              <button
                onClick={onClose}
                className="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-colors"
              >
                Close
              </button>
            </div>
          </div>

          {/* Device Frame */}
          <div
            className="relative bg-black rounded-[3rem] shadow-2xl border-[14px] border-gray-800 transition-all duration-500 ease-in-out"
            style={{
              width: `${width}px`,
              height: `${height}px`,
              transform: `scale(${scale})`,
              transformOrigin: 'center',
            }}
          >
            {/* Notch (portrait only) */}
            {orientation === 'portrait' && (
              <div className="absolute top-0 left-1/2 -translate-x-1/2 w-40 h-7 bg-black rounded-b-3xl z-10"></div>
            )}

            {/* Screen */}
            <div className="absolute inset-0 overflow-hidden rounded-[2.5rem]">
              <iframe
                src={previewUrl}
                className="w-full h-full border-0"
                title="Mobile Preview"
                sandbox="allow-scripts allow-same-origin allow-forms allow-popups allow-modals"
              />
            </div>

            {/* Home Indicator (bottom bar) */}
            <div className="absolute bottom-2 left-1/2 -translate-x-1/2 w-32 h-1 bg-white/30 rounded-full"></div>
          </div>
        </div>

        {/* Right Panel - PWA Validation */}
        <div className="w-96 bg-gray-800 p-6 overflow-y-auto border-l border-gray-700">
          <h3 className="text-xl font-bold text-white mb-4">PWA Validation</h3>

          {/* Validate Button */}
          <button
            onClick={runPWAValidation}
            disabled={isValidating}
            className="w-full py-3 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white rounded-lg font-medium transition-colors mb-6"
          >
            {isValidating ? 'Validating...' : 'Run PWA Check'}
          </button>

          {/* Validation Results */}
          {pwaValidation && (
            <div className="space-y-4">
              {/* Overall Score */}
              <div className="bg-gray-900 rounded-lg p-4">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-sm font-medium text-gray-400">Overall Score</span>
                  <span
                    className={`text-2xl font-bold ${
                      pwaValidation.overall_score >= 90
                        ? 'text-green-400'
                        : pwaValidation.overall_score >= 60
                          ? 'text-yellow-400'
                          : 'text-red-400'
                    }`}
                  >
                    {pwaValidation.overall_score}/100
                  </span>
                </div>
                <div className="w-full bg-gray-700 rounded-full h-2 overflow-hidden">
                  <div
                    className={`h-full transition-all duration-500 ${
                      pwaValidation.overall_score >= 90
                        ? 'bg-green-500'
                        : pwaValidation.overall_score >= 60
                          ? 'bg-yellow-500'
                          : 'bg-red-500'
                    }`}
                    style={{ width: `${pwaValidation.overall_score}%` }}
                  ></div>
                </div>
              </div>

              {/* Status Badge */}
              <div className="flex items-center gap-2">
                <div
                  className={`px-3 py-1 rounded-full text-sm font-medium ${
                    pwaValidation.status === 'passed'
                      ? 'bg-green-900 text-green-200'
                      : pwaValidation.status === 'warning'
                        ? 'bg-yellow-900 text-yellow-200'
                        : 'bg-red-900 text-red-200'
                  }`}
                >
                  {pwaValidation.status.toUpperCase()}
                </div>
              </div>

              {/* Component Scores */}
              <div className="space-y-2">
                <ScoreBar label="Manifest" score={pwaValidation.manifest_score} max={40} />
                <ScoreBar label="Service Worker" score={pwaValidation.service_worker_score} max={30} />
                <ScoreBar label="Icons" score={pwaValidation.icons_score} max={20} />
              </div>

              {/* Checklist */}
              <div className="space-y-2">
                <CheckItem label="HTTPS Enabled" checked={pwaValidation.is_https} />
                <CheckItem label="Manifest Valid" checked={pwaValidation.manifest_valid} />
                <CheckItem label="Service Worker" checked={pwaValidation.service_worker_registered} />
                <CheckItem label="Icons Valid" checked={pwaValidation.icons_valid} />
                <CheckItem label="Viewport Meta" checked={pwaValidation.has_viewport_meta} />
                <CheckItem label="Offline Ready" checked={pwaValidation.offline_ready} />
              </div>

              {/* Errors & Warnings */}
              {(pwaValidation.validation_errors.length > 0 ||
                pwaValidation.manifest_errors.length > 0 ||
                pwaValidation.service_worker_errors.length > 0) && (
                <div className="bg-red-900/20 border border-red-700 rounded-lg p-4">
                  <h4 className="text-sm font-semibold text-red-400 mb-2">Errors</h4>
                  <ul className="text-xs text-red-300 space-y-1">
                    {[
                      ...pwaValidation.validation_errors,
                      ...pwaValidation.manifest_errors,
                      ...pwaValidation.service_worker_errors,
                    ].map((error, i) => (
                      <li key={i}> {error}</li>
                    ))}
                  </ul>
                </div>
              )}

              {pwaValidation.manifest_warnings.length > 0 && (
                <div className="bg-yellow-900/20 border border-yellow-700 rounded-lg p-4">
                  <h4 className="text-sm font-semibold text-yellow-400 mb-2">Warnings</h4>
                  <ul className="text-xs text-yellow-300 space-y-1">
                    {pwaValidation.manifest_warnings.map((warning, i) => (
                      <li key={i}> {warning}</li>
                    ))}
                  </ul>
                </div>
              )}

              {/* Details Toggle */}
              <button
                onClick={() => setShowPwaDetails(!showPwaDetails)}
                className="w-full py-2 bg-gray-700 hover:bg-gray-600 text-white text-sm rounded-lg transition-colors"
              >
                {showPwaDetails ? 'Hide' : 'Show'} Details
              </button>

              {showPwaDetails && (
                <div className="bg-gray-900 rounded-lg p-4 text-xs text-gray-300 font-mono">
                  <pre className="whitespace-pre-wrap overflow-x-auto">{JSON.stringify(pwaValidation, null, 2)}</pre>
                </div>
              )}
            </div>
          )}

          {!pwaValidation && !isValidating && (
            <div className="text-center text-gray-500 mt-8">
              <svg
                className="w-16 h-16 mx-auto mb-4 text-gray-600"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                />
              </svg>
              <p>Run PWA validation to check your app</p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

function ScoreBar({ label, score, max }: { label: string; score: number; max: number }) {
  const percentage = (score / max) * 100;

  return (
    <div>
      <div className="flex items-center justify-between text-xs text-gray-400 mb-1">
        <span>{label}</span>
        <span>
          {score}/{max}
        </span>
      </div>
      <div className="w-full bg-gray-700 rounded-full h-1.5 overflow-hidden">
        <div className="h-full bg-blue-500 transition-all duration-500" style={{ width: `${percentage}%` }}></div>
      </div>
    </div>
  );
}

function CheckItem({ label, checked }: { label: string; checked: boolean }) {
  return (
    <div className="flex items-center gap-2 text-sm">
      <div className={`w-5 h-5 rounded flex items-center justify-center ${checked ? 'bg-green-600' : 'bg-red-600'}`}>
        {checked ? (
          <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
          </svg>
        ) : (
          <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M6 18L18 6M6 6l12 12" />
          </svg>
        )}
      </div>
      <span className={checked ? 'text-green-400' : 'text-red-400'}>{label}</span>
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/lib/persistence/db.ts">
import type { Message } from 'ai';
import { createScopedLogger } from '~/utils/logger';
import type { ChatHistoryItem } from './useChatHistory';

const logger = createScopedLogger('ChatHistory');

// this is used at the top level and never rejects
export async function openDatabase(): Promise<IDBDatabase | undefined> {
  return new Promise((resolve) => {
    try {
      if (!window.indexedDB) {
        logger.warn('IndexedDB not available in this browser');
        resolve(undefined);
        return;
      }

      // Try to open the database with better error handling
      const request = indexedDB.open('eitherwayHistory', 2);

      request.onupgradeneeded = (event: IDBVersionChangeEvent) => {
        try {
          const db = (event.target as IDBOpenDBRequest).result;

          if (db.objectStoreNames.contains('chats')) {
            try {
              db.deleteObjectStore('chats');
            } catch (e) {
              logger.warn('Could not delete old chats store:', e);
            }
          }

          const store = db.createObjectStore('chats', { keyPath: 'id' });
          store.createIndex('id', 'id', { unique: true });
          store.createIndex('urlId', 'urlId', { unique: false });

          logger.info('IndexedDB schema created/updated successfully');
        } catch (error) {
          logger.error('Error during database upgrade:', error);
        }
      };

      request.onsuccess = (event: Event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        logger.info('IndexedDB opened successfully');

        // Test if we can actually use the database
        try {
          const transaction = db.transaction('chats', 'readonly');
          transaction.oncomplete = () => {
            logger.info('IndexedDB test transaction successful');
          };
          transaction.onerror = () => {
            logger.warn('IndexedDB test transaction failed');
          };
        } catch (e) {
          logger.warn('Cannot create test transaction:', e);
        }

        resolve(db);
      };

      request.onerror = (event: Event) => {
        const error = (event.target as IDBOpenDBRequest).error;
        logger.error('Failed to open IndexedDB:', error?.message || 'Unknown error');

        // Common error explanations
        if (error?.name === 'InvalidStateError') {
          logger.info('IndexedDB may be blocked by privacy settings or incognito mode');
        } else if (error?.name === 'QuotaExceededError') {
          logger.info('Storage quota exceeded - clear browser data to fix');
        } else if (error?.name === 'UnknownError') {
          logger.info('IndexedDB blocked - check browser permissions');
        }

        resolve(undefined);
      };

      request.onblocked = () => {
        logger.warn('IndexedDB blocked - close other tabs or restart browser');
        resolve(undefined);
      };
    } catch (error) {
      logger.error('Exception opening database:', error);
      resolve(undefined);
    }
  });
}

export async function getAll(db: IDBDatabase): Promise<ChatHistoryItem[]> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction('chats', 'readonly');
    const store = transaction.objectStore('chats');
    const request = store.getAll();

    request.onsuccess = () => resolve(request.result as ChatHistoryItem[]);
    request.onerror = () => reject(request.error);
  });
}

export async function setMessages(
  db: IDBDatabase,
  id: string,
  messages: Message[],
  urlId?: string,
  description?: string,
): Promise<void> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction('chats', 'readwrite');
    const store = transaction.objectStore('chats');

    const request = store.put({
      id,
      messages,
      urlId,
      description,
      timestamp: new Date().toISOString(),
    });

    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

export async function getMessages(db: IDBDatabase, id: string): Promise<ChatHistoryItem> {
  const byId = await getMessagesById(db, id);
  if (byId) {
    return byId;
  }

  const byUrlId = await getMessagesByUrlId(db, id);
  if (byUrlId) {
    return byUrlId;
  }

  return byId || byUrlId;
}

export async function getMessagesByUrlId(db: IDBDatabase, id: string): Promise<ChatHistoryItem> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction('chats', 'readonly');
    const store = transaction.objectStore('chats');
    const index = store.index('urlId');
    const request = index.get(id);

    request.onsuccess = () => {
      const result = request.result as ChatHistoryItem;
      resolve(result);
    };
    request.onerror = () => {
      reject(request.error);
    };
  });
}

export async function getMessagesById(db: IDBDatabase, id: string): Promise<ChatHistoryItem> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction('chats', 'readonly');
    const store = transaction.objectStore('chats');
    const request = store.get(id);

    request.onsuccess = () => {
      const result = request.result as ChatHistoryItem;
      resolve(result);
    };
    request.onerror = () => {
      reject(request.error);
    };
  });
}

export async function deleteById(db: IDBDatabase, id: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction('chats', 'readwrite');
    const store = transaction.objectStore('chats');
    const request = store.delete(id);

    request.onsuccess = () => resolve(undefined);
    request.onerror = () => reject(request.error);
  });
}

export async function getNextId(db: IDBDatabase): Promise<string> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction('chats', 'readonly');
    const store = transaction.objectStore('chats');
    const request = store.getAllKeys();

    request.onsuccess = () => {
      const highestId = request.result.reduce((cur, acc) => Math.max(+cur, +acc), 0);
      resolve(String(+highestId + 1));
    };

    request.onerror = () => reject(request.error);
  });
}

export async function getUrlId(db: IDBDatabase, id: string): Promise<string> {
  const idList = await getUrlIds(db);

  if (!idList.includes(id)) {
    return id;
  } else {
    let i = 2;

    while (idList.includes(`${id}-${i}`)) {
      i++;
    }

    return `${id}-${i}`;
  }
}

async function getUrlIds(db: IDBDatabase): Promise<string[]> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction('chats', 'readonly');
    const store = transaction.objectStore('chats');
    const idList: string[] = [];

    const request = store.openCursor();

    request.onsuccess = (event: Event) => {
      const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result;

      if (cursor) {
        idList.push(cursor.value.urlId);
        cursor.continue();
      } else {
        resolve(idList);
      }
    };

    request.onerror = () => {
      reject(request.error);
    };
  });
}
</file>

<file path="packages/ui-frontend/app/lib/runtime/action-runner.ts">
import { WebContainer } from '@webcontainer/api';
import { map, type MapStore } from 'nanostores';

function dirname(path: string): string {
  const parts = path.split('/');

  if (parts.length <= 1) {
    return '.';
  }

  parts.pop();

  return parts.join('/') || '/';
}

const nodePath = { dirname };
import type { EitherwayAction } from '~/types/actions';
import { createScopedLogger } from '~/utils/logger';
import { loadThemeLock, saveThemeLock } from '~/lib/runtime/theme-lock';
import { mergeStylesCss } from '~/lib/runtime/style-preserver';
import { unreachable } from '~/utils/unreachable';
import type { ActionCallbackData } from './message-parser';

const logger = createScopedLogger('ActionRunner');

export type ActionStatus = 'pending' | 'running' | 'complete' | 'aborted' | 'failed';

export type BaseActionState = EitherwayAction & {
  status: Exclude<ActionStatus, 'failed'>;
  abort: () => void;
  executed: boolean;
  abortSignal: AbortSignal;
  operationType?: 'create' | 'modify';
};

export type FailedActionState = EitherwayAction &
  Omit<BaseActionState, 'status'> & {
    status: Extract<ActionStatus, 'failed'>;
    error: string;
  };

export type ActionState = BaseActionState | FailedActionState;

type BaseActionUpdate = Partial<Pick<BaseActionState, 'status' | 'abort' | 'executed' | 'operationType'>>;

export type ActionStateUpdate =
  | BaseActionUpdate
  | (Omit<BaseActionUpdate, 'status'> & { status: 'failed'; error: string });

type ActionsMap = MapStore<Record<string, ActionState>>;

export class ActionRunner {
  #webcontainer: Promise<WebContainer>;
  #currentExecutionPromise: Promise<void> = Promise.resolve();

  actions: ActionsMap = map({});

  constructor(webcontainerPromise: Promise<WebContainer>) {
    this.#webcontainer = webcontainerPromise;
  }

  /**
   * Compute a stable, unique key for actions across messages.
   * Without this, action IDs like "0", "1" collide between messages.
   */
  #keyFor(data: Pick<ActionCallbackData, 'messageId' | 'actionId'>): string {
    return `${data.messageId}:${data.actionId}`;
  }

  addAction(data: ActionCallbackData) {
    const key = this.#keyFor(data);

    const actions = this.actions.get();
    const action = actions[key];

    if (action) {
      // action already added
      return;
    }

    const abortController = new AbortController();

    this.actions.setKey(key, {
      ...data.action,
      status: 'pending',
      executed: false,
      abort: () => {
        abortController.abort();
        this.#updateAction(key, { status: 'aborted' });
      },
      abortSignal: abortController.signal,
    });

    // Do not mark as "running" here  set it when the action actually executes
  }

  async runAction(data: ActionCallbackData) {
    const key = this.#keyFor(data);
    const action = this.actions.get()[key];

    if (!action) {
      unreachable(`Action ${key} not found`);
    }

    if (action.executed) {
      return;
    }

    this.#updateAction(key, { ...action, ...data.action, executed: true });

    this.#currentExecutionPromise = this.#currentExecutionPromise
      .then(() => {
        return this.#executeAction(key);
      })
      .catch((error) => {
        console.error('Action failed:', error);
      });
  }

  async #executeAction(key: string) {
    const action = this.actions.get()[key];

    this.#updateAction(key, { status: 'running' });

    // Determine the actual operation type for file actions
    let actionDescription: string;
    let operationType: 'create' | 'modify' | undefined;

    if (action.type === 'file') {
      const webcontainer = await this.#webcontainer;
      let fileExists = false;
      try {
        await webcontainer.fs.readFile(action.filePath, 'utf8');
        fileExists = true;
      } catch {
        fileExists = false;
      }

      operationType = fileExists ? 'modify' : 'create';
      actionDescription = fileExists ? `Modifying file: ${action.filePath}` : `Creating file: ${action.filePath}`;

      this.#updateAction(key, { operationType });
    } else {
      actionDescription = `Running command: ${action.content?.substring(0, 100)}...`;
    }

    logger.info(`Starting action ${key}: ${actionDescription}`);

    try {
      switch (action.type) {
        case 'shell': {
          await this.#runShellAction(action);
          break;
        }
        case 'file': {
          await this.#runFileAction(action);
          break;
        }
      }

      this.#updateAction(key, { status: action.abortSignal.aborted ? 'aborted' : 'complete' });
      logger.info(`Completed action ${key}: ${actionDescription}`);
    } catch (error) {
      this.#updateAction(key, { status: 'failed', error: 'Action failed' });
      logger.error(`Action ${key} failed:`, error);

      // re-throw the error to be caught in the promise chain
      throw error;
    }
  }

  async #runShellAction(action: ActionState) {
    if (action.type !== 'shell') {
      unreachable('Expected shell action');
    }

    const webcontainer = await this.#webcontainer;

    const process = await webcontainer.spawn('jsh', ['-c', action.content], {
      env: { npm_config_yes: true },
    });

    action.abortSignal.addEventListener('abort', () => {
      process.kill();
    });

    process.output.pipeTo(
      new WritableStream({
        write(data) {
          logger.debug(data);
        },
      }),
    );

    // Do not block the queue on long-running dev servers
    const isLongRunning =
      /\bnpm\s+(run\s+)?(dev|start)\b/.test(action.content) ||
      /\b(vite|next|nuxt|remix|astro)\b/.test(action.content) ||
      /\b(http-server|live-server)\b/.test(action.content) ||
      /python3?\s+-m\s+http\.server/.test(action.content);

    if (!isLongRunning) {
      const exitCode = await process.exit;
      logger.debug(`Process terminated with code ${exitCode}`);
    } else {
      logger.info('Long-running dev server detected  not awaiting process.exit to keep the queue unblocked');
    }
  }

  async #runFileAction(action: ActionState) {
    if (action.type !== 'file') {
      unreachable('Expected file action');
    }

    const webcontainer = await this.#webcontainer;

    let folder = nodePath.dirname(action.filePath);

    folder = folder.replace(/\/+$/g, '');

    if (folder !== '.') {
      try {
        await webcontainer.fs.mkdir(folder, { recursive: true });
        logger.debug('Created folder', folder);
      } catch (error) {
        logger.error('Failed to create folder\n\n', error);
      }
    }

    try {
      let fileExists = false;
      try {
        await webcontainer.fs.readFile(action.filePath, 'utf8');
        fileExists = true;
      } catch {
        fileExists = false;
      }

      // For critical files that exist, we should modify, not recreate
      if (fileExists && this.shouldUseModify(action.filePath)) {
        // Modify existing file - this preserves file identity for hot-reload
        let contentToWrite = action.content;
        const basename = action.filePath.split('/').pop() || action.filePath;
        if (basename === 'styles.css') {
          // Merge-on-write for styles.css: preserve locked theme tokens unless an explicit change
          const existing = (await webcontainer.fs.readFile(action.filePath, 'utf8')) as unknown as string;
          const lock = await loadThemeLock(webcontainer.fs);
          const { css, updatedLock } = mergeStylesCss(action.content, existing, lock.colors || {});
          contentToWrite = css;
          if (updatedLock) {
            await saveThemeLock(webcontainer.fs, { colors: updatedLock, updatedAt: Date.now() });
          }
        } else if (basename === 'index.html') {
          // Inject dark mode for index.html
          contentToWrite = this.#injectDarkMode(contentToWrite);
        }
        await webcontainer.fs.writeFile(action.filePath, contentToWrite);
        logger.debug(`Modified file ${action.filePath}`);
      } else {
        let contentToWrite = action.content;
        const basename = action.filePath.split('/').pop() || action.filePath;
        if (basename === 'styles.css') {
          // On create, write as-is; do not set lock yet
          // The first post-build modify will establish the lock
        } else if (basename === 'index.html') {
          // Inject dark mode for index.html
          contentToWrite = this.#injectDarkMode(contentToWrite);
        }
        await webcontainer.fs.writeFile(action.filePath, contentToWrite);
        logger.debug(`Created file ${action.filePath}`);
      }
    } catch (error) {
      logger.error('Failed to write file\n\n', error);
    }
  }

  shouldUseModify(filePath: string): boolean {
    // Critical files that should always be modified, not recreated
    const criticalFiles = ['index.html', 'main.js', 'main.ts', 'app.js', 'app.ts', 'styles.css', 'base.css'];

    const filename = filePath.split('/').pop() || '';
    return criticalFiles.includes(filename);
  }

  #injectYouTubeFix(htmlContent: string): string {
    // Don't inject if already present
    if (htmlContent.includes('YouTube Embed Handler for WebContainer')) {
      return htmlContent;
    }

    const youtubeFixScript = `
<style>
  a.youtube-preview {
    position: relative;
    display: block !important;
    width: 100%;
    padding-bottom: 56.25%; /* 16:9 aspect ratio */
    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
    border-radius: 12px;
    overflow: hidden;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    text-decoration: none !important;
    color: inherit !important;
  }
  a.youtube-preview:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 12px rgba(0, 0, 0, 0.15);
    text-decoration: none !important;
  }
  .youtube-preview-inner {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background-size: cover;
    background-position: center;
  }
  .youtube-preview-inner::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(to bottom,
      rgba(0,0,0,0.1) 0%,
      rgba(0,0,0,0.2) 50%,
      rgba(0,0,0,0.7) 100%);
  }
  .youtube-preview-content {
    position: relative;
    z-index: 2;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    padding: 20px;
    text-align: center;
  }
  .youtube-play-button {
    width: 72px;
    height: 52px;
    background: #ff0000;
    border-radius: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(255, 0, 0, 0.3);
  }
  .youtube-preview:hover .youtube-play-button {
    background: #ff0000;
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(255, 0, 0, 0.4);
  }
  .youtube-play-icon {
    width: 0;
    height: 0;
    border-left: 24px solid white;
    border-top: 14px solid transparent;
    border-bottom: 14px solid transparent;
    margin-left: 4px;
  }
  .youtube-preview-text {
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-width: 400px;
  }
  .youtube-title {
    color: white;
    font-size: 16px;
    font-weight: 600;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
  }
  .youtube-subtitle {
    color: rgba(255, 255, 255, 0.9);
    font-size: 13px;
    line-height: 1.4;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
  }
  .youtube-badge {
    position: absolute;
    top: 12px;
    right: 12px;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(10px);
    color: white;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 11px;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 6px;
    z-index: 3;
  }
  .youtube-badge-icon {
    width: 14px;
    height: 14px;
    fill: #00ff88;
  }
</style>
<script>
// YouTube Embed Handler for WebContainer Environment
(function() {
  'use strict';

  // Fix for missing palette colors (if any)
  if (typeof window.staticLoadtimePalette === 'object' && !window.staticLoadtimePalette.gx_no_16) {
    window.staticLoadtimePalette.gx_no_16 = '#1a1a1a';
  }

  // Function to extract video ID from various YouTube URL formats
  function getYouTubeVideoId(url) {
    const patterns = [
      /youtube\\.com\\/embed\\/([^?&]+)/,
      /youtube\\.com\\/watch\\?v=([^&]+)/,
      /youtu\\.be\\/([^?&]+)/,
      /youtube-nocookie\\.com\\/embed\\/([^?&]+)/
    ];

    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match) return match[1];
    }
    return null;
  }

  function createYouTubePreview(videoId, width, height) {
    const preview = document.createElement('a');
    preview.href = 'https://www.youtube.com/watch?v=' + videoId;
    preview.target = '_blank';
    preview.rel = 'noopener noreferrer';
    preview.className = 'youtube-preview';
    preview.style.display = 'block';
    preview.style.textDecoration = 'none';
    if (width && width !== '100%') preview.style.maxWidth = width;

    const inner = document.createElement('div');
    inner.className = 'youtube-preview-inner';
    inner.style.backgroundImage = 'url(https://img.youtube.com/vi/' + videoId + '/maxresdefault.jpg), url(https://img.youtube.com/vi/' + videoId + '/hqdefault.jpg)';

    const badge = document.createElement('div');
    badge.className = 'youtube-badge';
    badge.innerHTML = '<svg class="youtube-badge-icon" viewBox="0 0 24 24"><path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5z"/></svg> Preview Mode';

    const content = document.createElement('div');
    content.className = 'youtube-preview-content';

    const playButton = document.createElement('div');
    playButton.className = 'youtube-play-button';
    playButton.innerHTML = '<div class="youtube-play-icon"></div>';

    const textWrapper = document.createElement('div');
    textWrapper.className = 'youtube-preview-text';

    const title = document.createElement('div');
    title.className = 'youtube-title';
    title.textContent = 'Click to Watch on YouTube';

    const subtitle = document.createElement('div');
    subtitle.className = 'youtube-subtitle';
    subtitle.textContent = 'Opens in new tab  WebContainer preview mode  Videos embed normally after deployment';

    textWrapper.appendChild(title);
    textWrapper.appendChild(subtitle);

    content.appendChild(playButton);
    content.appendChild(textWrapper);

    inner.appendChild(badge);
    inner.appendChild(content);
    preview.appendChild(inner);

    // Ensure click opens in new tab (belt and suspenders approach)
    preview.onclick = function(e) {
      e.preventDefault();
      const url = 'https://www.youtube.com/watch?v=' + videoId;
      console.log('Opening YouTube video:', url);

      // Try window.open first
      try {
        const newWindow = window.open(url, '_blank', 'noopener,noreferrer');
        if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
          // If popup blocked, create a temporary link and click it
          const tempLink = document.createElement('a');
          tempLink.href = url;
          tempLink.target = '_blank';
          tempLink.rel = 'noopener noreferrer';
          tempLink.style.display = 'none';
          document.body.appendChild(tempLink);
          tempLink.click();
          document.body.removeChild(tempLink);
        }
      } catch (err) {
        console.error('Failed to open YouTube:', err);
        // Last resort: navigate current window
        window.location.href = url;
      }
    };

    return preview;
  }

  // Replace YouTube iframes with preview
  function replaceYouTubeEmbeds() {
    const iframes = document.querySelectorAll('iframe[src*="youtube.com"], iframe[src*="youtu.be"], iframe[src*="youtube-nocookie.com"]');
    console.log('Found ' + iframes.length + ' YouTube iframes to replace');

    iframes.forEach(iframe => {
      console.log('Processing iframe with src:', iframe.src);
      const videoId = getYouTubeVideoId(iframe.src);

      if (videoId) {
        console.log('Extracted video ID:', videoId);
        const preview = createYouTubePreview(videoId, iframe.width, iframe.height);

        // Make sure click handler works
        preview.style.cursor = 'pointer';

        // Preserve any wrapper styling
        if (iframe.parentElement) {
          iframe.parentElement.replaceChild(preview, iframe);
          console.log('Replaced iframe with preview for video:', videoId);
        }
      } else {
        console.warn('Could not extract video ID from:', iframe.src);
      }
    });
  }

  // Run replacement when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', replaceYouTubeEmbeds);
  } else {
    // Small delay to ensure iframes are rendered
    setTimeout(replaceYouTubeEmbeds, 100);
  }

  // Monitor for dynamically added iframes
  const observer = new MutationObserver(function(mutations) {
    let hasNewIframes = false;
    mutations.forEach(function(mutation) {
      mutation.addedNodes.forEach(function(node) {
        if (node.nodeName === 'IFRAME' && node.src &&
            (node.src.includes('youtube') || node.src.includes('youtu.be'))) {
          hasNewIframes = true;
        }
      });
    });
    if (hasNewIframes) {
      setTimeout(replaceYouTubeEmbeds, 100);
    }
  });

  if (document.body) {
    observer.observe(document.body, { childList: true, subtree: true });
  }

  // Expose global function for manual usage
  window.embedYouTube = function(container, videoUrl) {
    const videoId = getYouTubeVideoId(videoUrl) || videoUrl;
    const preview = createYouTubePreview(videoId);

    if (typeof container === 'string') {
      const element = document.querySelector(container);
      if (element) {
        element.innerHTML = '';
        element.appendChild(preview);
      }
    } else if (container instanceof HTMLElement) {
      container.innerHTML = '';
      container.appendChild(preview);
    }

    return preview;
  };
})();
</script>`;

    // Inject the script before closing </body> or </head> tag
    if (htmlContent.includes('</body>')) {
      return htmlContent.replace('</body>', `${youtubeFixScript}\n</body>`);
    } else if (htmlContent.includes('</head>')) {
      return htmlContent.replace('</head>', `${youtubeFixScript}\n</head>`);
    } else if (htmlContent.includes('</html>')) {
      return htmlContent.replace('</html>', `${youtubeFixScript}\n</html>`);
    }

    // If no suitable tag found, append to the end
    return htmlContent + youtubeFixScript;
  }

  #injectDarkMode(htmlContent: string): string {
    const darkModeScript = `
<script>
// Dark Mode Implementation
(function() {
  const THEME_ICONS = {
    // New sun icon for dark mode
    light: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 50 50" fill="white"><path d="M 24.90625 3.96875 C 24.863281 3.976563 24.820313 3.988281 24.78125 4 C 24.316406 4.105469 23.988281 4.523438 24 5 L 24 11 C 23.996094 11.359375 24.183594 11.695313 24.496094 11.878906 C 24.808594 12.058594 25.191406 12.058594 25.503906 11.878906 C 25.816406 11.695313 26.003906 11.359375 26 11 L 26 5 C 26.011719 4.710938 25.894531 4.433594 25.6875 4.238281 C 25.476563 4.039063 25.191406 3.941406 24.90625 3.96875 Z M 10.65625 9.84375 C 10.28125 9.910156 9.980469 10.183594 9.875 10.546875 C 9.769531 10.914063 9.878906 11.304688 10.15625 11.5625 L 14.40625 15.8125 C 14.648438 16.109375 15.035156 16.246094 15.410156 16.160156 C 15.78125 16.074219 16.074219 15.78125 16.160156 15.410156 C 16.246094 15.035156 16.109375 14.648438 15.8125 14.40625 L 11.5625 10.15625 C 11.355469 9.933594 11.054688 9.820313 10.75 9.84375 C 10.71875 9.84375 10.6875 9.84375 10.65625 9.84375 Z M 39.03125 9.84375 C 38.804688 9.875 38.59375 9.988281 38.4375 10.15625 L 34.1875 14.40625 C 33.890625 14.648438 33.753906 15.035156 33.839844 15.410156 C 33.925781 15.78125 34.21875 16.074219 34.589844 16.160156 C 34.964844 16.246094 35.351563 16.109375 35.59375 15.8125 L 39.84375 11.5625 C 40.15625 11.265625 40.246094 10.800781 40.0625 10.410156 C 39.875 10.015625 39.460938 9.789063 39.03125 9.84375 Z M 25 15 C 19.484375 15 15 19.484375 15 25 C 15 30.515625 19.484375 35 25 35 C 30.515625 35 35 30.515625 35 25 C 35 19.484375 30.515625 15 25 15 Z M 4.71875 24 C 4.167969 24.078125 3.78125 24.589844 3.859375 25.140625 C 3.9375 25.691406 4.449219 26.078125 5 26 L 11 26 C 11.359375 26.003906 11.695313 25.816406 11.878906 25.503906 C 12.058594 25.191406 12.058594 24.808594 11.878906 24.496094 C 11.695313 24.183594 11.359375 23.996094 11 24 L 5 24 C 4.96875 24 4.9375 24 4.90625 24 C 4.875 24 4.84375 24 4.8125 24 C 4.78125 24 4.75 24 4.71875 24 Z M 38.71875 24 C 38.167969 24.078125 37.78125 24.589844 37.859375 25.140625 C 37.9375 25.691406 38.449219 26.078125 39 26 L 45 26 C 45.359375 26.003906 45.695313 25.816406 45.878906 25.503906 C 46.058594 25.191406 46.058594 24.808594 45.878906 24.496094 C 45.695313 24.183594 45.359375 23.996094 45 24 L 39 24 C 38.96875 24 38.9375 24 38.90625 24 C 38.875 24 38.84375 24 38.8125 24 C 38.78125 24 38.75 24 38.71875 24 Z M 15 33.875 C 14.773438 33.90625 14.5625 34.019531 14.40625 34.1875 L 10.15625 38.4375 C 9.859375 38.679688 9.722656 39.066406 9.808594 39.441406 C 9.894531 39.8125 10.1875 40.105469 10.558594 40.191406 C 10.933594 40.277344 11.320313 40.140625 11.5625 39.84375 L 15.8125 35.59375 C 16.109375 35.308594 16.199219 34.867188 16.039063 34.488281 C 15.882813 34.109375 15.503906 33.867188 15.09375 33.875 C 15.0625 33.875 15.03125 33.875 15 33.875 Z M 34.6875 33.875 C 34.3125 33.941406 34.011719 34.214844 33.90625 34.578125 C 33.800781 34.945313 33.910156 35.335938 34.1875 35.59375 L 38.4375 39.84375 C 38.679688 40.140625 39.066406 40.277344 39.441406 40.191406 C 39.8125 40.105469 40.105469 39.8125 40.191406 39.441406 C 40.277344 39.066406 40.140625 38.679688 39.84375 38.4375 L 35.59375 34.1875 C 35.40625 33.988281 35.148438 33.878906 34.875 33.875 C 34.84375 33.875 34.8125 33.875 34.78125 33.875 C 34.75 33.875 34.71875 33.875 34.6875 33.875 Z M 24.90625 37.96875 C 24.863281 37.976563 24.820313 37.988281 24.78125 38 C 24.316406 38.105469 23.988281 38.523438 24 39 L 24 45 C 23.996094 45.359375 24.183594 45.695313 24.496094 45.878906 C 24.808594 46.058594 25.191406 46.058594 25.503906 45.878906 C 25.816406 45.695313 26.003906 45.359375 26 45 L 26 39 C 26.011719 38.710938 25.894531 38.433594 25.6875 38.238281 C 25.476563 38.039063 25.191406 37.941406 24.90625 37.96875 Z"></path></svg>',
    // Moon icon for light mode
    dark: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="none"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>'
  };

  function toggleTheme(e) {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    const current = document.documentElement.getAttribute('data-theme') || 'light';
    const next = current === 'dark' ? 'light' : 'dark';
    document.documentElement.setAttribute('data-theme', next);
    localStorage.setItem('theme', next);
    updateThemeIcon(next);
  }

  function updateThemeIcon(theme) {
    const btn = document.getElementById('theme-toggle');
    if (btn) {
      btn.innerHTML = theme === 'dark' ? THEME_ICONS.light : THEME_ICONS.dark;
    }
  }

  const savedTheme = localStorage.getItem('theme') || 'light';
  document.documentElement.setAttribute('data-theme', savedTheme);

  function createThemeToggle() {
    let btn = document.getElementById('theme-toggle');

    if (btn) {
      // Button exists - ensure it has handler and icon
      if (!btn.onclick || !btn.hasAttribute('data-handler-attached')) {
        btn.onclick = toggleTheme;
        btn.setAttribute('data-handler-attached', 'true');
      }
      // Always update icon to ensure it's correct
      updateThemeIcon(savedTheme);
    } else {
      btn = document.createElement('button');
      btn.id = 'theme-toggle';
      btn.onclick = toggleTheme;
      btn.setAttribute('data-handler-attached', 'true');
      btn.setAttribute('aria-label', 'Toggle theme');

      // First try to place in header/navbar if it has enough structure
      const header = document.querySelector('header, nav, .header, .navbar, .nav-header');

      if (header && header.children.length > 0) {
        const hasFlexOrGrid = window.getComputedStyle(header).display.includes('flex') ||
                              window.getComputedStyle(header).display.includes('grid');

        if (hasFlexOrGrid) {
          // Place inline in header
          btn.style.cssText = 'width:40px;height:40px;border-radius:50%;background:rgba(0,0,0,0.5);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);border:2px solid rgba(255,255,255,0.2);cursor:pointer;display:flex;align-items:center;justify-content:center;margin-left:auto;flex-shrink:0;';

          const wrapper = document.createElement('div');
          wrapper.style.cssText = 'display:flex;align-items:center;margin-left:auto;';
          wrapper.appendChild(btn);

          // Find the best insertion point
          const lastChild = header.lastElementChild;
          if (lastChild && (lastChild.tagName === 'DIV' || lastChild.tagName === 'NAV')) {
            lastChild.appendChild(wrapper);
          } else {
            header.appendChild(wrapper);
          }
        } else {
          // Use fixed positioning for non-flex headers
          btn.style.cssText = 'position:fixed;top:1rem;right:1rem;z-index:9999;width:48px;height:48px;border-radius:50%;background:rgba(0,0,0,0.5);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);border:2px solid rgba(255,255,255,0.2);cursor:pointer;display:flex;align-items:center;justify-content:center;';
          document.body.appendChild(btn);
        }
      } else {
        // Fallback to fixed position
        btn.style.cssText = 'position:fixed;top:1rem;right:1rem;z-index:9999;width:48px;height:48px;border-radius:50%;background:rgba(0,0,0,0.5);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);border:2px solid rgba(255,255,255,0.2);cursor:pointer;display:flex;align-items:center;justify-content:center;';
        document.body.appendChild(btn);
      }

      updateThemeIcon(savedTheme);
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', createThemeToggle);
  } else {
    createThemeToggle();
  }

  // Fallback with delay to ensure header is rendered
  setTimeout(createThemeToggle, 100);
  setTimeout(createThemeToggle, 500);

  // Make function globally available but protect from being overridden
  if (!window.toggleTheme || typeof window.toggleTheme !== 'function') {
    window.toggleTheme = toggleTheme;
  }

  // Protect our button from being broken by other scripts
  setInterval(() => {
    const btn = document.getElementById('theme-toggle');
    if (btn && (!btn.onclick || !btn.hasAttribute('data-handler-attached'))) {
      btn.onclick = toggleTheme;
      btn.setAttribute('data-handler-attached', 'true');
      updateThemeIcon(localStorage.getItem('theme') || 'light');
    }
  }, 1000);
})();
</script>`;

    // Inject before closing body tag
    if (htmlContent.includes('</body>')) {
      return htmlContent.replace('</body>', `${darkModeScript}\n</body>`);
    } else if (htmlContent.includes('</html>')) {
      return htmlContent.replace('</html>', `${darkModeScript}\n</html>`);
    }

    return htmlContent + darkModeScript;
  }

  #updateAction(id: string, newState: ActionStateUpdate) {
    const actions = this.actions.get();

    this.actions.setKey(id, { ...actions[id], ...newState });
  }
}
</file>

<file path="packages/ui-frontend/app/lib/runtime/message-parser.ts">
import type { ActionType, EitherwayAction, EitherwayActionData, FileAction, ShellAction } from '~/types/actions';
import type { EitherwayArtifactData } from '~/types/artifact';
import { createScopedLogger } from '~/utils/logger';
import { unreachable } from '~/utils/unreachable';

const ARTIFACT_TAG_OPEN = '<eitherwayArtifact';
const ARTIFACT_TAG_CLOSE = '</eitherwayArtifact>';
const ARTIFACT_ACTION_TAG_OPEN = '<eitherwayAction';
const ARTIFACT_ACTION_TAG_CLOSE = '</eitherwayAction>';

const logger = createScopedLogger('MessageParser');

export interface ArtifactCallbackData extends EitherwayArtifactData {
  messageId: string;
}

export interface ActionCallbackData {
  artifactId: string;
  messageId: string;
  actionId: string;
  action: EitherwayAction;
}

export type ArtifactCallback = (data: ArtifactCallbackData) => void;
export type ActionCallback = (data: ActionCallbackData) => void;

export interface ParserCallbacks {
  onArtifactOpen?: ArtifactCallback;
  onArtifactClose?: ArtifactCallback;
  onActionOpen?: ActionCallback;
  onActionClose?: ActionCallback;
}

interface ElementFactoryProps {
  messageId: string;
  artifactId: string;
}

type ElementFactory = (props: ElementFactoryProps) => string;

export interface StreamingMessageParserOptions {
  callbacks?: ParserCallbacks;
  artifactElement?: ElementFactory;
}

interface MessageState {
  position: number;
  insideArtifact: boolean;
  insideAction: boolean;
  currentArtifact?: EitherwayArtifactData;
  currentAction: EitherwayActionData;
  actionId: number;
}

export class StreamingMessageParser {
  #messages = new Map<string, MessageState>();

  constructor(private _options: StreamingMessageParserOptions = {}) {}

  parse(messageId: string, input: string) {
    let state = this.#messages.get(messageId);

    if (!state) {
      state = {
        position: 0,
        insideAction: false,
        insideArtifact: false,
        currentAction: { content: '' },
        actionId: 0,
      };

      this.#messages.set(messageId, state);
    }

    let output = '';
    let i = state.position;
    let earlyBreak = false;

    while (i < input.length) {
      if (state.insideArtifact) {
        const currentArtifact = state.currentArtifact;

        if (currentArtifact === undefined) {
          unreachable('Artifact not initialized');
        }

        if (state.insideAction) {
          const closeIndex = input.indexOf(ARTIFACT_ACTION_TAG_CLOSE, i);

          const currentAction = state.currentAction;

          if (closeIndex !== -1) {
            currentAction.content += input.slice(i, closeIndex);

            let content = currentAction.content.trim();

            if ('type' in currentAction && currentAction.type === 'file') {
              content += '\n';
            }

            currentAction.content = content;

            this._options.callbacks?.onActionClose?.({
              artifactId: currentArtifact.id,
              messageId,

              /**
               * We decrement the id because it's been incremented already
               * when `onActionOpen` was emitted to make sure the ids are
               * the same.
               */
              actionId: String(state.actionId - 1),

              action: currentAction as EitherwayAction,
            });

            state.insideAction = false;
            state.currentAction = { content: '' };

            i = closeIndex + ARTIFACT_ACTION_TAG_CLOSE.length;
          } else {
            break;
          }
        } else {
          const actionOpenIndex = input.indexOf(ARTIFACT_ACTION_TAG_OPEN, i);
          const artifactCloseIndex = input.indexOf(ARTIFACT_TAG_CLOSE, i);

          if (actionOpenIndex !== -1 && (artifactCloseIndex === -1 || actionOpenIndex < artifactCloseIndex)) {
            const actionEndIndex = input.indexOf('>', actionOpenIndex);

            if (actionEndIndex !== -1) {
              state.insideAction = true;

              state.currentAction = this.#parseActionTag(input, actionOpenIndex, actionEndIndex);

              this._options.callbacks?.onActionOpen?.({
                artifactId: currentArtifact.id,
                messageId,
                actionId: String(state.actionId++),
                action: state.currentAction as EitherwayAction,
              });

              i = actionEndIndex + 1;
            } else {
              break;
            }
          } else if (artifactCloseIndex !== -1) {
            this._options.callbacks?.onArtifactClose?.({ messageId, ...currentArtifact });

            state.insideArtifact = false;
            state.currentArtifact = undefined;

            i = artifactCloseIndex + ARTIFACT_TAG_CLOSE.length;
          } else {
            break;
          }
        }
      } else if (input[i] === '<' && input[i + 1] !== '/') {
        let j = i;
        let potentialTag = '';

        while (j < input.length && potentialTag.length < ARTIFACT_TAG_OPEN.length) {
          potentialTag += input[j];

          if (potentialTag === ARTIFACT_TAG_OPEN) {
            const nextChar = input[j + 1];

            if (nextChar && nextChar !== '>' && nextChar !== ' ') {
              output += input.slice(i, j + 1);
              i = j + 1;
              break;
            }

            const openTagEnd = input.indexOf('>', j);

            if (openTagEnd !== -1) {
              const artifactTag = input.slice(i, openTagEnd + 1);

              const artifactTitle = this.#extractAttribute(artifactTag, 'title') as string;
              const artifactId = this.#extractAttribute(artifactTag, 'id') as string;

              if (!artifactTitle) {
                logger.warn('Artifact title missing');
              }

              if (!artifactId) {
                logger.warn('Artifact id missing');
              }

              state.insideArtifact = true;

              const currentArtifact = {
                id: artifactId,
                title: artifactTitle,
              } satisfies EitherwayArtifactData;

              state.currentArtifact = currentArtifact;

              this._options.callbacks?.onArtifactOpen?.({ messageId, ...currentArtifact });

              const artifactFactory = this._options.artifactElement ?? createArtifactElement;

              output += artifactFactory({ messageId, artifactId });

              i = openTagEnd + 1;
            } else {
              earlyBreak = true;
            }

            break;
          } else if (!ARTIFACT_TAG_OPEN.startsWith(potentialTag)) {
            output += input.slice(i, j + 1);
            i = j + 1;
            break;
          }

          j++;
        }

        if (j === input.length && ARTIFACT_TAG_OPEN.startsWith(potentialTag)) {
          break;
        }
      } else {
        output += input[i];
        i++;
      }

      if (earlyBreak) {
        break;
      }
    }

    state.position = i;

    return output;
  }

  reset() {
    this.#messages.forEach((state, messageId) => {
      if (state.insideArtifact) {
        logger.warn(`Message ${messageId} ended with unclosed artifact - response may have been truncated`);
      }
      if (state.insideAction) {
        logger.warn(`Message ${messageId} ended with unclosed action - response may have been truncated`);
      }
    });

    this.#messages.clear();
  }

  // Method to check if current parsing state has incomplete elements
  checkIncomplete(messageId: string): { insideArtifact: boolean; insideAction: boolean } | null {
    const state = this.#messages.get(messageId);
    if (!state) return null;

    return {
      insideArtifact: state.insideArtifact,
      insideAction: state.insideAction,
    };
  }

  #parseActionTag(input: string, actionOpenIndex: number, actionEndIndex: number) {
    const actionTag = input.slice(actionOpenIndex, actionEndIndex + 1);

    const actionType = this.#extractAttribute(actionTag, 'type') as ActionType;

    const actionAttributes = {
      type: actionType,
      content: '',
    };

    if (actionType === 'file') {
      const filePath = this.#extractAttribute(actionTag, 'filePath') as string;

      if (!filePath) {
        logger.debug('File path not specified');
      }

      (actionAttributes as FileAction).filePath = filePath;
    } else if (actionType !== 'shell') {
      logger.warn(`Unknown action type '${actionType}'`);
    }

    return actionAttributes as FileAction | ShellAction;
  }

  #extractAttribute(tag: string, attributeName: string): string | undefined {
    const match = tag.match(new RegExp(`${attributeName}="([^"]*)"`, 'i'));
    return match ? match[1] : undefined;
  }
}

const createArtifactElement: ElementFactory = (props) => {
  const elementProps = [
    'class="__eitherwayArtifact__"',
    ...Object.entries(props).map(([key, value]) => {
      return `data-${camelToDashCase(key)}=${JSON.stringify(value)}`;
    }),
  ];

  return `<div ${elementProps.join(' ')}></div>`;
};

function camelToDashCase(input: string) {
  return input.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
</file>

<file path="packages/ui-frontend/app/lib/services/price-pipeline.ts">
import { createScopedLogger } from '~/utils/logger';

const logger = createScopedLogger('PricePipeline');

export interface PriceResult {
  value: number;
  source: string;
  confidence: number;
  timestamp: number;
}

interface CacheEntry {
  data: PriceResult;
  expires: number;
}

export class PricePipeline {
  private cache = new Map<string, CacheEntry>();
  private cacheTTL = 60 * 1000; // 60 seconds
  private negativeCacheTTL = 15 * 1000; // 15 seconds for failures

  async getPrice(chainId: number, tokenAddress: string): Promise<PriceResult | undefined> {
    const cacheKey = `${chainId}:${tokenAddress}`;

    const cached = this.getFromCache(cacheKey);
    if (cached) {
      logger.debug(`Price cache hit for ${cacheKey}`);
      return cached;
    }

    const tiers = [
      () => this.tryChainlink(chainId, tokenAddress),
      () => this.tryHttpProvider(chainId, tokenAddress),
      () => this.tryDexTwap(chainId, tokenAddress),
    ];

    for (const [index, tier] of tiers.entries()) {
      try {
        const result = await tier();
        if (result) {
          logger.info(`Price found via tier ${index} for ${cacheKey}: $${result.value}`);
          this.setCache(cacheKey, result);
          return result;
        }
      } catch (error) {
        logger.debug(`Price tier ${index} failed for ${cacheKey}:`, error);
      }
    }

    logger.warn(`No price found for ${cacheKey} across all tiers`);
    this.setNegativeCache(cacheKey);
    return undefined;
  }

  private async tryChainlink(chainId: number, tokenAddress: string): Promise<PriceResult | undefined> {
    if (!this.isChainlinkSupported(chainId)) {
      return undefined;
    }

    const feeds: Record<string, string> = {
      '1:native': '0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419', // ETH/USD on mainnet
      '1:0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': '0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6', // USDC/USD
      '137:native': '0xAB594600376Ec9fD91F8e885dADF0CE036862dE0', // MATIC/USD on Polygon
    };

    const feedAddress = feeds[`${chainId}:${tokenAddress}`];
    if (!feedAddress) {
      return undefined;
    }

    // For now, fallback to CoinGecko since we don't have direct RPC access to Chainlink
    // In production, this would query the Chainlink oracle contract
    logger.debug(`Chainlink feed ${feedAddress} found, falling back to CoinGecko for price`);
    return this.fetchFromCoinGecko(chainId, tokenAddress);
  }

  private async tryHttpProvider(chainId: number, tokenAddress: string): Promise<PriceResult | undefined> {
    const providers = this.getAvailableHttpProviders();

    for (const provider of providers) {
      try {
        const result = await this.fetchFromProvider(provider, chainId, tokenAddress);
        if (result) {
          return {
            ...result,
            confidence: 0.7,
          };
        }
      } catch (error) {
        logger.debug(`HTTP provider ${provider} failed:`, error);
      }
    }

    return undefined;
  }

  private async tryDexTwap(chainId: number, tokenAddress: string, timeoutMs = 1500): Promise<PriceResult | undefined> {
    const timeout = new Promise<undefined>((resolve) => setTimeout(() => resolve(undefined), timeoutMs));

    const twapPromise = this.fetchDexTwap(chainId, tokenAddress);

    const result = await Promise.race([twapPromise, timeout]);

    if (result) {
      return {
        ...result,
        confidence: 0.5,
      };
    }

    return undefined;
  }

  private async fetchFromProvider(
    provider: string,
    chainId: number,
    tokenAddress: string,
  ): Promise<PriceResult | undefined> {
    switch (provider) {
      case 'coingecko':
        return this.fetchFromCoinGecko(chainId, tokenAddress);
      case 'cryptocompare':
        return this.fetchFromCryptoCompare(chainId, tokenAddress);
      default:
        return undefined;
    }
  }

  private async fetchFromCoinGecko(chainId: number, tokenAddress: string): Promise<PriceResult | undefined> {
    const platformMap: Record<number, string> = {
      1: 'ethereum',
      137: 'polygon-pos',
      56: 'binance-smart-chain',
      42161: 'arbitrum-one',
    };

    const platform = platformMap[chainId];
    if (!platform) return undefined;

    try {
      let apiUrl: string;
      let id: string;

      if (tokenAddress === 'native') {
        const nativeIds: Record<number, string> = {
          1: 'ethereum',
          137: 'matic-network',
          56: 'binancecoin',
          42161: 'ethereum',
        };

        id = nativeIds[chainId];
        if (!id) return undefined;
      } else {
        // For non-native tokens, use contract address
        id = tokenAddress.toLowerCase();
      }

      // Use CoinGecko free API
      const baseUrl = 'https://api.coingecko.com/api/v3';

      if (tokenAddress === 'native') {
        // For native tokens, use simple price endpoint
        apiUrl = `${baseUrl}/simple/price?ids=${id}&vs_currencies=usd&include_24hr_change=true`;
      } else {
        // For contract addresses, use token price endpoint
        apiUrl = `${baseUrl}/simple/token_price/${platform}?contract_addresses=${tokenAddress}&vs_currencies=usd&include_24hr_change=true`;
      }

      const headers: HeadersInit = {
        Accept: 'application/json',
      };

      if (process.env.COINGECKO_API_KEY) {
        headers['x-cg-demo-api-key'] = process.env.COINGECKO_API_KEY;
      }

      const response = await fetch(apiUrl, {
        headers,
        signal: AbortSignal.timeout(5000), // 5 second timeout
      });

      if (!response.ok) {
        logger.warn(`CoinGecko API returned ${response.status} for ${tokenAddress}`);
        return undefined;
      }

      const data = await response.json();

      let priceData;
      if (tokenAddress === 'native') {
        priceData = data[id];
      } else {
        priceData = data[tokenAddress.toLowerCase()];
      }

      if (!priceData || !priceData.usd) {
        logger.warn(`No price data found for ${tokenAddress} from CoinGecko`);
        return undefined;
      }

      return {
        value: priceData.usd,
        source: 'coingecko',
        confidence: 0.8,
        timestamp: Date.now(),
      };
    } catch (error) {
      logger.error(`CoinGecko API error for ${tokenAddress}:`, error);
      return undefined;
    }
  }

  private async fetchFromCryptoCompare(chainId: number, tokenAddress: string): Promise<PriceResult | undefined> {
    return undefined;
  }

  private async fetchDexTwap(chainId: number, tokenAddress: string): Promise<PriceResult | undefined> {
    return undefined;
  }

  private isChainlinkSupported(chainId: number): boolean {
    const supportedChains = [1, 137, 56, 42161, 10, 43114];
    return supportedChains.includes(chainId);
  }

  private getAvailableHttpProviders(): string[] {
    const providers: string[] = [];

    if (process.env.COINGECKO_API_KEY) {
      providers.push('coingecko');
    }
    if (process.env.CRYPTOCOMPARE_API_KEY) {
      providers.push('cryptocompare');
    }
    if (process.env.COINMARKETCAP_API_KEY) {
      providers.push('coinmarketcap');
    }

    if (!providers.length) {
      providers.push('coingecko');
    }

    return providers;
  }

  private getFromCache(key: string): PriceResult | undefined {
    const entry = this.cache.get(key);
    if (!entry) return undefined;

    if (Date.now() > entry.expires) {
      this.cache.delete(key);
      return undefined;
    }

    return entry.data;
  }

  private setCache(key: string, data: PriceResult): void {
    this.cache.set(key, {
      data,
      expires: Date.now() + this.cacheTTL,
    });
  }

  private setNegativeCache(key: string): void {
    this.cache.set(key, {
      data: {
        value: 0,
        source: 'none',
        confidence: 0,
        timestamp: Date.now(),
      },
      expires: Date.now() + this.negativeCacheTTL,
    });
  }
}
</file>

<file path="packages/ui-frontend/app/lib/stores/brandKit.ts">
import { map } from 'nanostores';

const loadFromLocalStorage = () => {
  if (typeof window === 'undefined') return { pendingBrandKitId: null, dirty: false };

  // Detect page refresh using sessionStorage marker
  // sessionStorage clears on page reload but persists during SPA navigation
  const pageSessionMarker = sessionStorage.getItem('brandKitPageSession');
  const isPageRefresh = !pageSessionMarker;

  if (isPageRefresh) {
    // Mark this session so subsequent loads don't clear the state
    sessionStorage.setItem('brandKitPageSession', 'active');

    // Clear any temporary brand kit data on page refresh
    // Temporary brand kits should NOT persist across page reloads
    console.log('[brandKitStore] Page refresh detected - clearing temporary brand kit from localStorage');
    localStorage.removeItem('brandKitState');

    return { pendingBrandKitId: null, dirty: false };
  }

  // Not a page refresh - load from localStorage normally
  try {
    const stored = localStorage.getItem('brandKitState');
    if (stored) {
      const parsed = JSON.parse(stored);
      return {
        pendingBrandKitId: parsed.pendingBrandKitId || null,
        dirty: parsed.dirty || false,
      };
    }
  } catch (error) {
    console.warn('Failed to load brand kit state from localStorage:', error);
  }

  return { pendingBrandKitId: null, dirty: false };
};

export const brandKitStore = map<{
  pendingBrandKitId: string | null;
  dirty: boolean;
}>(loadFromLocalStorage());

// Subscribe to changes and persist to localStorage
if (typeof window !== 'undefined') {
  brandKitStore.subscribe((state) => {
    try {
      localStorage.setItem('brandKitState', JSON.stringify(state));
    } catch (error) {
      console.warn('Failed to save brand kit state to localStorage:', error);
    }
  });
}
</file>

<file path="packages/ui-frontend/app/lib/stores/workbench.ts">
import { atom, map, type MapStore, type ReadableAtom, type WritableAtom } from 'nanostores';
import type { EditorDocument, ScrollPosition } from '~/components/editor/codemirror/CodeMirrorEditor';
import { ActionRunner } from '~/lib/runtime/action-runner';
import type { ActionCallbackData, ArtifactCallbackData } from '~/lib/runtime/message-parser';
import { webcontainer } from '~/lib/webcontainer/index';
import type { ITerminal } from '~/types/terminal';
import { unreachable } from '~/utils/unreachable';
import { EditorStore } from './editor';
import { FilesStore, type FileMap } from './files';
import { PreviewsStore } from './previews';
import { TerminalStore } from './terminal';

export interface ArtifactState {
  id: string;
  title: string;
  closed: boolean;
  runner: ActionRunner;
}

export type ArtifactUpdateState = Pick<ArtifactState, 'title' | 'closed'>;

type Artifacts = MapStore<Record<string, ArtifactState>>;

export type WorkbenchViewType = 'code' | 'preview';

export class WorkbenchStore {
  #previewsStore = new PreviewsStore(webcontainer);
  #filesStore = new FilesStore(webcontainer);
  #editorStore = new EditorStore(this.#filesStore);
  #terminalStore = new TerminalStore(webcontainer);

  artifacts: Artifacts = import.meta.hot?.data.artifacts ?? map({});

  showWorkbench: WritableAtom<boolean> = import.meta.hot?.data.showWorkbench ?? atom(false);
  currentView: WritableAtom<WorkbenchViewType> = import.meta.hot?.data.currentView ?? atom('preview');
  unsavedFiles: WritableAtom<Set<string>> = import.meta.hot?.data.unsavedFiles ?? atom(new Set<string>());
  modifiedFiles = new Set<string>();
  artifactIdList: string[] = [];

  // deploy status
  isAppReadyForDeploy: WritableAtom<boolean> = import.meta.hot?.data.isAppReadyForDeploy ?? atom(false);

  constructor() {
    if (import.meta.hot) {
      import.meta.hot.data.artifacts = this.artifacts;
      import.meta.hot.data.unsavedFiles = this.unsavedFiles;
      import.meta.hot.data.showWorkbench = this.showWorkbench;
      import.meta.hot.data.currentView = this.currentView;
      import.meta.hot.data.isAppReadyForDeploy = this.isAppReadyForDeploy;
    }
  }

  get previews() {
    return this.#previewsStore.previews;
  }

  get files() {
    return this.#filesStore.files;
  }

  get currentDocument(): ReadableAtom<EditorDocument | undefined> {
    return this.#editorStore.currentDocument;
  }

  get selectedFile(): ReadableAtom<string | undefined> {
    return this.#editorStore.selectedFile;
  }

  get firstArtifact(): ArtifactState | undefined {
    return this.#getArtifact(this.artifactIdList[0]);
  }

  get filesCount(): number {
    return this.#filesStore.filesCount;
  }

  get showTerminal() {
    return this.#terminalStore.showTerminal;
  }

  toggleTerminal(value?: boolean) {
    this.#terminalStore.toggleTerminal(value);
  }

  attachTerminal(terminal: ITerminal) {
    this.#terminalStore.attachTerminal(terminal);
  }

  onTerminalResize(cols: number, rows: number) {
    this.#terminalStore.onTerminalResize(cols, rows);
  }

  setDocuments(files: FileMap) {
    this.#editorStore.setDocuments(files);

    if (this.#filesStore.filesCount > 0 && this.currentDocument.get() === undefined) {
      // we find the first file and select it
      for (const [filePath, dirent] of Object.entries(files)) {
        if (dirent?.type === 'file') {
          this.setSelectedFile(filePath);
          break;
        }
      }
    }
  }

  setShowWorkbench(show: boolean) {
    this.showWorkbench.set(show);
  }

  setCurrentDocumentContent(newContent: string) {
    const filePath = this.currentDocument.get()?.filePath;

    if (!filePath) {
      return;
    }

    const originalContent = this.#filesStore.getFile(filePath)?.content;
    const unsavedChanges = originalContent !== undefined && originalContent !== newContent;

    this.#editorStore.updateFile(filePath, newContent);

    const currentDocument = this.currentDocument.get();

    if (currentDocument) {
      const previousUnsavedFiles = this.unsavedFiles.get();

      if (unsavedChanges && previousUnsavedFiles.has(currentDocument.filePath)) {
        return;
      }

      const newUnsavedFiles = new Set(previousUnsavedFiles);

      if (unsavedChanges) {
        newUnsavedFiles.add(currentDocument.filePath);
      } else {
        newUnsavedFiles.delete(currentDocument.filePath);
      }

      this.unsavedFiles.set(newUnsavedFiles);
    }
  }

  setCurrentDocumentScrollPosition(position: ScrollPosition) {
    const editorDocument = this.currentDocument.get();

    if (!editorDocument) {
      return;
    }

    const { filePath } = editorDocument;

    this.#editorStore.updateScrollPosition(filePath, position);
  }

  setSelectedFile(filePath: string | undefined) {
    this.#editorStore.setSelectedFile(filePath);
  }

  async saveFile(filePath: string) {
    const documents = this.#editorStore.documents.get();
    const document = documents[filePath];

    if (document === undefined) {
      return;
    }

    await this.#filesStore.saveFile(filePath, document.value);

    const newUnsavedFiles = new Set(this.unsavedFiles.get());
    newUnsavedFiles.delete(filePath);

    this.unsavedFiles.set(newUnsavedFiles);
  }

  async saveCurrentDocument() {
    const currentDocument = this.currentDocument.get();

    if (currentDocument === undefined) {
      return;
    }

    await this.saveFile(currentDocument.filePath);
  }

  resetCurrentDocument() {
    const currentDocument = this.currentDocument.get();

    if (currentDocument === undefined) {
      return;
    }

    const { filePath } = currentDocument;
    const file = this.#filesStore.getFile(filePath);

    if (!file) {
      return;
    }

    this.setCurrentDocumentContent(file.content);
  }

  async saveAllFiles() {
    for (const filePath of this.unsavedFiles.get()) {
      await this.saveFile(filePath);
    }
  }

  getFileModifcations() {
    return this.#filesStore.getFileModifications();
  }

  resetAllFileModifications() {
    this.#filesStore.resetFileModifications();
  }

  abortAllActions() {}

  addArtifact({ messageId, title, id }: ArtifactCallbackData) {
    // Key artifacts by their artifact id, not message id, to allow multiple artifacts per message
    const artifact = this.#getArtifact(id);

    if (artifact) {
      return;
    }

    if (!this.artifactIdList.includes(id)) {
      this.artifactIdList.push(id);
    }

    this.artifacts.setKey(id, { id, title, closed: false, runner: new ActionRunner(webcontainer) });
  }

  updateArtifact({ id }: ArtifactCallbackData, state: Partial<ArtifactUpdateState>) {
    const artifact = this.#getArtifact(id);

    if (!artifact) {
      return;
    }

    this.artifacts.setKey(id, { ...artifact, ...state });
  }

  async addAction(data: ActionCallbackData) {
    const { artifactId } = data;

    const artifact = this.#getArtifact(artifactId);

    if (!artifact) {
      unreachable('Artifact not found');
    }

    artifact.runner.addAction(data);
  }

  async runAction(data: ActionCallbackData) {
    const { artifactId } = data;

    const artifact = this.#getArtifact(artifactId);

    if (!artifact) {
      unreachable('Artifact not found');
    }

    artifact.runner.runAction(data);
  }

  #getArtifact(id: string) {
    const artifacts = this.artifacts.get();
    return artifacts[id];
  }

  /**
   * Manually register a preview URL (fallback when port event doesn't fire)
   */
  registerPreview(port: number, url: string) {
    this.#previewsStore.registerPreview(port, url);
  }
}

export const workbenchStore = new WorkbenchStore();
</file>

<file path="packages/ui-frontend/app/lib/webcontainer/debug.ts">
import { webcontainer } from './index';
import { createScopedLogger } from '~/utils/logger';

const logger = createScopedLogger('WebContainerDebug');

export async function debugWebContainer() {
  try {
    const wc = await webcontainer;

    logger.info('WebContainer initialized successfully');

    // Listen to all port events for debugging
    wc.on('port', (port, type, url) => {
      logger.info(` Port Event Debug:`, {
        port,
        type,
        url,
        timestamp: new Date().toISOString(),
      });

      if (url.includes('localhost')) {
        logger.warn(` Localhost URL detected: ${url}`);
        logger.warn('WebContainer should provide a unique URL like https://[id].webcontainerapp.io');
      } else {
        logger.info(` WebContainer URL: ${url}`);
      }
    });

    // Listen to server ready events
    wc.on('server-ready', (port, url) => {
      logger.info(` Server Ready - Port: ${port}, URL: ${url}`);
    });

    const fs = wc.fs;
    const processes = typeof wc.spawn !== 'undefined' ? 'Available' : 'Not Available';

    logger.info('WebContainer Capabilities:', {
      fileSystem: fs ? 'Ready' : 'Not Ready',
      processes,
      platform: typeof navigator !== 'undefined' ? navigator.platform : 'Unknown',
    });
  } catch (error) {
    logger.error('Failed to debug WebContainer:', error);
  }
}

if (typeof window !== 'undefined') {
  debugWebContainer();
}
</file>

<file path="packages/ui-frontend/app/utils/streamClient.ts">
/**
 * Streaming client for Fastify SSE backend
 * Connects to /api/stream-test endpoint and processes Server-Sent Events
 */

export interface StreamOptions {
  prompt: string;
  chunkSize?: number;
  delayMs?: number;
  onChunk: (chunk: string) => void;
  onComplete: () => void;
  onError: (error: string) => void;
}

export interface StreamController {
  abort: () => void;
}

const BACKEND_URL = typeof window !== 'undefined' ? 'http://localhost:4000' : 'http://localhost:4000';

/**
 * Stream from Fastify backend using fetch + ReadableStream
 * POST to /api/stream-test with JSON body
 */
export async function streamFromFastify(options: StreamOptions): Promise<StreamController> {
  const { prompt, chunkSize = 20, delayMs = 150, onChunk, onComplete, onError } = options;

  let aborted = false;
  let reader: ReadableStreamDefaultReader<Uint8Array> | null = null;

  const abort = () => {
    aborted = true;
    if (reader) {
      reader.cancel();
    }
  };

  try {
    const response = await fetch(`${BACKEND_URL}/api/stream-test`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        prompt,
        chunkSize,
        delayMs,
      }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    if (!response.body) {
      throw new Error('No response body');
    }

    reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (!aborted) {
      const { done, value } = await reader.read();

      if (done) {
        break;
      }

      // Decode the chunk
      const chunk = decoder.decode(value, { stream: true });
      buffer += chunk;

      const lines = buffer.split('\n\n');

      // Keep the last incomplete line in the buffer
      buffer = lines.pop() || '';

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const jsonStr = line.substring(6); // Remove "data: " prefix
            const data = JSON.parse(jsonStr);

            if (data.type === 'start') {
              // Agent started
              continue;
            } else if (data.type === 'chunk') {
              onChunk(data.data);
            } else if (data.type === 'complete') {
              onComplete();
              return { abort };
            } else if (data.type === 'error') {
              onError(data.error || 'Unknown error');
              return { abort };
            }
          } catch (parseError) {
            console.error('Failed to parse SSE data:', parseError);
          }
        }
      }
    }

    if (aborted) {
      onError('Stream aborted by user');
    }
  } catch (error) {
    if (!aborted) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      onError(errorMessage);
    }
  }

  return { abort };
}
</file>

<file path="packages/ui-frontend/backend/app.ts">
import Fastify from 'fastify';
import type { FastifyInstance } from 'fastify';
import cors from '@fastify/cors';
import { streamAgentResponse, streamLoremChunks, formatSSE, type StreamOptions } from './streaming.js';

/**
 * Minimal Fastify app - stripped from robust backend
 * Removes: DB, telemetry, wizard complexity, @openai/agents
 * Keeps: Server setup, CORS, SSE streaming pattern
 */
export function buildApp(): FastifyInstance {
  const app = Fastify({
    logger: {
      level: 'info',
      transport: {
        target: 'pino-pretty',
        options: {
          translateTime: 'HH:MM:ss Z',
          ignore: 'pid,hostname',
        },
      },
    },
  });

  // Register CORS
  app.register(cors, {
    origin: true, // Allow all origins in development
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    credentials: true,
    exposedHeaders: ['Content-Type', 'Cache-Control', 'Connection', 'X-Accel-Buffering'],
  });

  // Health check
  app.get('/health', async () => {
    return {
      status: 'ok',
      timestamp: new Date().toISOString(),
      message: 'Minimal Fastify server running',
    };
  });

  app.get('/api/stream-test', async (request, reply) => {
    const { chunkSize, delayMs, text } = request.query as {
      chunkSize?: string;
      delayMs?: string;
      text?: string;
    };

    const options: StreamOptions = {
      chunkSize: chunkSize ? parseInt(chunkSize, 10) : 20,
      delayMs: delayMs ? parseInt(delayMs, 10) : 300,
      text,
    };

    reply.raw.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      Connection: 'keep-alive',
      'X-Accel-Buffering': 'no', // Disable nginx buffering
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type',
    });

    try {
      // Stream chunks as SSE
      for await (const chunk of streamLoremChunks(options)) {
        const event = {
          type: 'chunk',
          data: chunk,
          timestamp: new Date().toISOString(),
        };
        reply.raw.write(formatSSE(event));
      }

      reply.raw.write(
        formatSSE({
          type: 'complete',
          timestamp: new Date().toISOString(),
        }),
      );

      app.log.info('Stream completed successfully');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      app.log.error(`Stream error: ${errorMessage}`);

      reply.raw.write(
        formatSSE({
          type: 'error',
          error: errorMessage,
          timestamp: new Date().toISOString(),
        }),
      );
    } finally {
      reply.raw.end();
    }
  });

  // POST /api/stream-test - Agent-style Input  Output streaming (SSE)
  app.post('/api/stream-test', async (request, reply) => {
    const { prompt, chunkSize, delayMs, text } = request.body as {
      prompt?: string;
      chunkSize?: number;
      delayMs?: number;
      text?: string;
    };

    if (!prompt) {
      return reply.status(400).send({
        error: 'Missing required field: prompt',
      });
    }

    const options: StreamOptions = {
      chunkSize: chunkSize || 20,
      delayMs: delayMs || 300,
      text,
    };

    reply.raw.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      Connection: 'keep-alive',
      'X-Accel-Buffering': 'no',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type',
    });

    try {
      // Stream agent response
      for await (const event of streamAgentResponse(prompt, options)) {
        reply.raw.write(formatSSE(event));
      }

      app.log.info(`Agent stream completed for prompt: ${prompt}`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      app.log.error(`Agent stream error: ${errorMessage}`);

      reply.raw.write(
        formatSSE({
          type: 'error',
          error: errorMessage,
          timestamp: new Date().toISOString(),
        }),
      );
    } finally {
      reply.raw.end();
    }
  });

  // Stripped from robust /api/wizard/requirements/preview
  app.get('/api/wizard/stream', async (request, reply) => {
    const { brief, chunkSize, delayMs } = request.query as {
      brief?: string;
      chunkSize?: string;
      delayMs?: string;
    };

    if (!brief || brief.length < 10) {
      return reply.status(400).send({
        error: 'Brief must be at least 10 characters',
      });
    }

    const options: StreamOptions = {
      chunkSize: chunkSize ? parseInt(chunkSize, 10) : 20,
      delayMs: delayMs ? parseInt(delayMs, 10) : 300,
      text: `Processing brief: "${brief}"\n\nSuggestions: ${LOREM_TEXT}`,
    };

    reply.raw.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      Connection: 'keep-alive',
      'X-Accel-Buffering': 'no',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type',
    });

    const startTime = Date.now();

    try {
      app.log.info(
        {
          briefLength: brief.length,
          briefPreview: brief.substring(0, 50),
        },
        'Starting wizard stream',
      );

      // Stream suggestions (mimics RequirementsExtractor.streamSuggestions)
      for await (const chunk of streamLoremChunks(options)) {
        const event = {
          type: 'suggestion',
          data: chunk,
          timestamp: new Date().toISOString(),
        };
        reply.raw.write(formatSSE(event));
      }

      const completionEvent = {
        type: 'complete',
        duration: Date.now() - startTime,
        timestamp: new Date().toISOString(),
      };
      reply.raw.write(formatSSE(completionEvent));

      app.log.info(
        {
          duration: Date.now() - startTime,
        },
        'Wizard stream completed',
      );
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      app.log.error(`Wizard stream error: ${errorMessage}`);

      const errorEvent = {
        type: 'error',
        error: errorMessage,
        timestamp: new Date().toISOString(),
      };
      reply.raw.write(formatSSE(errorEvent));
    } finally {
      reply.raw.end();
    }
  });

  return app;
}

// Lorem text for wizard endpoint
const LOREM_TEXT = `Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.`;
</file>

<file path="packages/ui-frontend/backend/server.ts">
import { buildApp } from './app.js';

/**
 * Minimal Fastify server entry point
 * Stripped from robust backend at /tmp/eitherway-fastify/src/server/server.ts
 * Removes: @openai/agents SDK, database, complex wizard logic
 * Keeps: Server setup, SSE streaming pattern
 */

const start = async () => {
  try {
    const app = buildApp();

    const port = parseInt(process.env.FASTIFY_PORT || '4000');
    const host = process.env.HOST || '0.0.0.0';

    await app.listen({ port, host });

    app.log.info('='.repeat(60));
    app.log.info(`Minimal Fastify Server Running`);
    app.log.info('='.repeat(60));
    app.log.info(``);
    app.log.info(`Server:        http://${host}:${port}`);
    app.log.info(`Health Check:  http://${host}:${port}/health`);
    app.log.info(``);
    app.log.info(`Streaming Endpoints:`);
    app.log.info(`   GET  /api/stream-test             - Simple Lorem streaming (SSE)`);
    app.log.info(`   POST /api/stream-test             - Agent Input  Output streaming`);
    app.log.info(`   GET  /api/wizard/stream           - Wizard-style streaming`);
    app.log.info(``);
    app.log.info(`Example requests:`);
    app.log.info(`   curl -N "http://localhost:${port}/api/stream-test?chunkSize=10&delayMs=200"`);
    app.log.info(
      `   curl -N -X POST http://localhost:${port}/api/stream-test -H "Content-Type: application/json" -d '{"prompt": "Build a todo app"}'`,
    );
    app.log.info(`   curl -N "http://localhost:${port}/api/wizard/stream?brief=I+need+a+blog"`);
    app.log.info(``);
    app.log.info('='.repeat(60));
  } catch (err) {
    console.error('Error: Server failed to start:', err);
    process.exit(1);
  }
};

start();
</file>

<file path="packages/ui-frontend/package.json">
{
  "name": "@eitherway/ui-frontend",
  "description": "Eitherway AI Agent Frontend (Remix)",
  "private": true,
  "license": "MIT",
  "packageManager": "pnpm@9.4.0",
  "sideEffects": false,
  "type": "module",
  "scripts": {
    "build": "remix vite:build",
    "dev": "remix vite:dev",
    "test": "vitest --run",
    "test:watch": "vitest",
    "lint": "eslint --cache --cache-location ./node_modules/.cache/eslint .",
    "lint:fix": "npm run lint -- --fix",
    "start": "node server.js",
    "typecheck": "tsc",
    "preview": "pnpm run build && pnpm run start",
    "backend": "tsx backend/server.ts",
    "backend:dev": "tsx --watch backend/server.ts"
  },
  "engines": {
    "node": ">=18.18.0"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^0.0.39",
    "@codemirror/autocomplete": "^6.17.0",
    "@codemirror/commands": "^6.6.0",
    "@codemirror/lang-cpp": "^6.0.2",
    "@codemirror/lang-css": "^6.2.1",
    "@codemirror/lang-html": "^6.4.9",
    "@codemirror/lang-javascript": "^6.2.2",
    "@codemirror/lang-json": "^6.0.1",
    "@codemirror/lang-markdown": "^6.2.5",
    "@codemirror/lang-python": "^6.1.6",
    "@codemirror/lang-sass": "^6.0.2",
    "@codemirror/lang-wast": "^6.0.2",
    "@codemirror/language": "^6.10.2",
    "@codemirror/search": "^6.5.6",
    "@codemirror/state": "^6.4.1",
    "@codemirror/view": "^6.28.4",
    "@fastify/cors": "^11.1.0",
    "@iconify-json/ph": "^1.1.13",
    "@iconify-json/svg-spinners": "^1.1.2",
    "@lezer/highlight": "^1.2.0",
    "@nanostores/react": "^0.7.2",
    "@radix-ui/react-dialog": "^1.1.1",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@react-oauth/google": "^0.12.2",
    "@remix-run/express": "^2.17.0",
    "@remix-run/node": "^2.17.0",
    "@remix-run/react": "^2.17.0",
    "@remix-run/serve": "^2.17.0",
    "@reown/appkit": "^1.7.17",
    "@reown/appkit-adapter-wagmi": "^1.7.17",
    "@splinetool/react-spline": "^4.1.0",
    "@tanstack/react-query": "^5.84.1",
    "@uiw/codemirror-theme-vscode": "^4.23.0",
    "@unocss/reset": "^0.61.0",
    "@webcontainer/api": "1.3.0-internal.10",
    "@xterm/addon-fit": "^0.10.0",
    "@xterm/addon-web-links": "^0.11.0",
    "@xterm/xterm": "^5.5.0",
    "ai": "^3.3.4",
    "date-fns": "^3.6.0",
    "diff": "^5.2.0",
    "express": "^4.18.2",
    "fastify": "^5.6.1",
    "framer-motion": "^11.2.12",
    "isbot": "^4.1.0",
    "istextorbinary": "^9.5.0",
    "jose": "^5.6.3",
    "nanostores": "^0.10.3",
    "openai": "^5.20.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-hotkeys-hook": "^4.5.0",
    "react-markdown": "^9.0.1",
    "react-resizable-panels": "^2.0.20",
    "react-toastify": "^10.0.5",
    "rehype-raw": "^7.0.0",
    "rehype-sanitize": "^6.0.0",
    "remark-gfm": "^4.0.0",
    "remix-island": "^0.2.0",
    "remix-utils": "^7.6.0",
    "shiki": "^1.9.1",
    "unist-util-visit": "^5.0.0",
    "viem": "^2.33.2",
    "wagmi": "^2.16.1"
  },
  "devDependencies": {
    "@blitz/eslint-plugin": "0.1.0",
    "@playwright/test": "^1.55.0",
    "@remix-run/dev": "^2.17.0",
    "@types/diff": "^5.2.1",
    "@types/react": "^18.2.20",
    "@types/react-dom": "^18.2.7",
    "fast-glob": "^3.3.2",
    "is-ci": "^3.0.1",
    "node-fetch": "^3.3.2",
    "pino-pretty": "^13.1.1",
    "prettier": "^3.3.2",
    "sass": "^1.90.0",
    "sass-embedded": "^1.90.0",
    "tsx": "^4.20.6",
    "typescript": "^5.5.2",
    "unified": "^11.0.5",
    "unocss": "^0.61.3",
    "vite": "^5.3.1",
    "vite-plugin-node-polyfills": "^0.22.0",
    "vite-plugin-optimize-css-modules": "^1.1.0",
    "vite-tsconfig-paths": "^4.3.2",
    "vitest": "^2.0.1",
    "zod": "^3.23.8"
  },
  "resolutions": {
    "@typescript-eslint/utils": "^8.0.0-alpha.30",
    "@remix-run/react": "^2.17.0",
    "@remix-run/router": "^1.23.0"
  }
}
</file>

<file path="packages/ui-frontend/tsconfig.json">
{
  "compilerOptions": {
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "types": ["@remix-run/node", "vite/client"],
    "isolatedModules": true,
    "esModuleInterop": true,
    "jsx": "react-jsx",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "target": "ESNext",
    "strict": true,
    "allowJs": true,
    "skipLibCheck": true,
    "verbatimModuleSyntax": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "~/*": ["./app/*"]
    },

    // vite takes care of building everything, not tsc
    "noEmit": true
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    "**/.server/**/*.ts",
    "**/.server/**/*.tsx",
    "**/.client/**/*.ts",
    "**/.client/**/*.tsx"
  ],
  "exclude": ["eitherwayalmostdone/**"]
}
</file>

<file path="packages/ui-server/src/events/logger.ts">
import type { StreamEvent } from './types.js';

/**
 * Stream event logger for observability and debugging
 */

interface EventLogEntry {
  direction: 'inbound' | 'outbound';
  event: StreamEvent;
  timestamp: number;
}

// In-memory event log (last 100 events)
const eventLog: EventLogEntry[] = [];
const MAX_LOG_SIZE = 100;

/**
 * Log a stream event
 */
export function logStreamEvent(direction: 'inbound' | 'outbound', event: StreamEvent): void {
  const entry: EventLogEntry = {
    direction,
    event,
    timestamp: Date.now(),
  };

  eventLog.push(entry);

  // Keep log bounded
  if (eventLog.length > MAX_LOG_SIZE) {
    eventLog.shift();
  }

  // Console log in development (with color coding)
  if (process.env.NODE_ENV !== 'production') {
    const arrow = direction === 'outbound' ? '' : '';
    const color = direction === 'outbound' ? '\x1b[32m' : '\x1b[34m'; // green or blue
    const reset = '\x1b[0m';

    console.log(`${color}[Stream ${arrow}]${reset} ${event.kind}`, {
      ...event,
      ts: undefined, // Hide timestamp in console for brevity
    });
  }
}

/**
 * Get recent event log entries
 */
export function getEventLog(limit?: number): EventLogEntry[] {
  const entries = limit ? eventLog.slice(-limit) : [...eventLog];
  return entries;
}

/**
 * Clear event log
 */
export function clearEventLog(): void {
  eventLog.length = 0;
}

/**
 * Get event statistics
 */
export function getEventStats() {
  const stats = {
    total: eventLog.length,
    byKind: {} as Record<string, number>,
    byDirection: {
      inbound: 0,
      outbound: 0,
    },
    avgEventGap: 0,
  };

  let totalGap = 0;
  let prevTimestamp = 0;

  for (const entry of eventLog) {
    // Count by kind
    stats.byKind[entry.event.kind] = (stats.byKind[entry.event.kind] || 0) + 1;

    // Count by direction
    stats.byDirection[entry.direction]++;

    // Calculate gaps
    if (prevTimestamp > 0) {
      totalGap += entry.timestamp - prevTimestamp;
    }
    prevTimestamp = entry.timestamp;
  }

  if (eventLog.length > 1) {
    stats.avgEventGap = totalGap / (eventLog.length - 1);
  }

  return stats;
}

/**
 * Export event log as JSON (for debugging/replay)
 */
export function exportEventLog(): string {
  return JSON.stringify(eventLog, null, 2);
}
</file>

<file path="packages/ui-server/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "noUnusedParameters": false,
    "skipLibCheck": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  postgres:
    image: pgvector/pgvector:pg16
    container_name: eitherway-postgres
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-eitherway}
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres}"]
      interval: 5s
      timeout: 5s
      retries: 5
    networks:
      - eitherway

volumes:
  postgres_data:
    driver: local

networks:
  eitherway:
    driver: bridge
</file>

<file path="package.json">
{
  "name": "eitherway-agent",
  "version": "0.1.0",
  "private": true,
  "description": "Single-agent AI for app creation using Claude Sonnet 4.5",
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "setup": "bash scripts/setup.sh",
    "setup:https": "bash scripts/setup-https.sh",
    "init-workspace": "bash scripts/init-workspace.sh",
    "build": "npm run build --workspaces",
    "test": "npm run test --workspaces",
    "dev": "npm run dev -w @eitherway/runtime",
    "eval": "npm run eval -w @eitherway/evaluations",
    "server": "npm run dev -w @eitherway/ui-server",
    "ui": "npm run dev -w @eitherway/ui-frontend",
    "ui:build": "npm run build -w @eitherway/ui-frontend",
    "clean": "rm -rf node_modules packages/*/node_modules packages/*/dist workspace",
    "lint": "eslint . --ext .ts,.tsx,.js,.jsx",
    "lint:fix": "npm run lint -- --fix",
    "format": "prettier --write \"**/*.{ts,tsx,js,jsx,json,md}\"",
    "format:check": "prettier --check \"**/*.{ts,tsx,js,jsx,json,md}\""
  },
  "devDependencies": {
    "@types/node": "^20.11.16",
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "@typescript-eslint/parser": "^7.0.0",
    "eslint": "^8.57.0",
    "prettier": "^3.3.2",
    "tsx": "^4.7.0",
    "typescript": "^5.3.3",
    "vitest": "^3.2.4"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "dependencies": {
    "vite": "7.1.9"
  },
  "packageManager": "pnpm@9.12.3+sha512.cce0f9de9c5a7c95bef944169cc5dfe8741abfb145078c0d508b868056848a87c81e626246cb60967cbd7fd29a6c062ef73ff840d96b3c86c40ac92cf4a813ee"
}
</file>

<file path="packages/database/src/migrations/runner.ts">
#!/usr/bin/env node
import { DatabaseClient, createDatabaseClient } from '../client.js';
import { readFile, readdir } from 'fs/promises';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

interface Migration {
  id: number;
  name: string;
  filename: string;
  sql: string;
}

async function ensureMigrationsTable(db: DatabaseClient): Promise<void> {
  await db.query(`
    CREATE TABLE IF NOT EXISTS migrations (
      id SERIAL PRIMARY KEY,
      name TEXT NOT NULL UNIQUE,
      applied_at TIMESTAMPTZ NOT NULL DEFAULT now()
    )
  `);
}

async function getAppliedMigrations(db: DatabaseClient): Promise<Set<string>> {
  const result = await db.query<{ name: string }>('SELECT name FROM migrations ORDER BY id');
  return new Set(result.rows.map((r) => r.name));
}

async function loadMigrations(): Promise<Migration[]> {
  const migrationsDir = __dirname;
  const files = await readdir(migrationsDir);

  const sqlFiles = files.filter((f) => f.endsWith('.sql')).sort();

  const migrations: Migration[] = [];

  for (const filename of sqlFiles) {
    const match = filename.match(/^(\d+)_(.+)\.sql$/);
    if (!match) continue;

    const id = parseInt(match[1], 10);
    const name = match[2];
    const filepath = join(migrationsDir, filename);
    const sql = await readFile(filepath, 'utf-8');

    migrations.push({ id, name, filename, sql });
  }

  return migrations.sort((a, b) => a.id - b.id);
}

async function applyMigration(db: DatabaseClient, migration: Migration): Promise<void> {
  console.log(`Applying migration ${migration.id}: ${migration.name}`);

  await db.transaction(async (client) => {
    await client.query(migration.sql);

    await client.query('INSERT INTO migrations (name) VALUES ($1)', [migration.name]);
  });

  console.log(` Migration ${migration.id} applied successfully`);
}

async function runMigrations(): Promise<void> {
  const db = createDatabaseClient();

  try {
    console.log('Connecting to database...');
    const healthy = await db.healthCheck();
    if (!healthy) {
      throw new Error('Database health check failed');
    }
    console.log(' Connected to database\n');

    await ensureMigrationsTable(db);

    const applied = await getAppliedMigrations(db);
    const migrations = await loadMigrations();

    const pending = migrations.filter((m) => !applied.has(m.name));

    if (pending.length === 0) {
      console.log('No pending migrations');
      return;
    }

    console.log(`Found ${pending.length} pending migration(s)\n`);

    for (const migration of pending) {
      await applyMigration(db, migration);
    }

    console.log(`\n All migrations completed successfully`);
  } catch (error: any) {
    console.error('\n Migration failed:', error.message);
    if (error.stack) {
      console.error(error.stack);
    }
    process.exit(1);
  } finally {
    await db.close();
  }
}

runMigrations();
</file>

<file path="packages/database/src/repositories/deployments.ts">
/**
 * Deployment & Export Repositories
 *
 * Manages deployment history and export records.
 */

import type { DatabaseClient } from '../client.js';

// TYPES

export interface Deployment {
  id: string;
  app_id: string;
  user_id: string;
  session_id: string | null;
  deployment_type: 'github_pages' | 'netlify' | 'vercel' | 'custom';
  status: 'pending' | 'building' | 'deploying' | 'success' | 'failed' | 'cancelled';
  repository_url: string | null;
  repository_owner: string | null;
  repository_name: string | null;
  branch: string | null;
  commit_sha: string | null;
  deployment_url: string | null;
  preview_url: string | null;
  build_command: string | null;
  output_directory: string | null;
  environment_vars: Record<string, string>;
  started_at: Date | null;
  completed_at: Date | null;
  duration_ms: number | null;
  error_message: string | null;
  error_stack: string | null;
  created_at: Date;
  updated_at: Date;
}

export interface Export {
  id: string;
  app_id: string;
  user_id: string;
  session_id: string | null;
  export_type: 'zip' | 'tar' | 'git_bundle';
  status: 'pending' | 'processing' | 'success' | 'failed';
  file_count: number | null;
  total_size_bytes: number | null;
  compressed_size_bytes: number | null;
  file_path: string | null;
  include_node_modules: boolean;
  include_git_history: boolean;
  exclude_patterns: string[];
  started_at: Date | null;
  completed_at: Date | null;
  duration_ms: number | null;
  download_count: number;
  last_downloaded_at: Date | null;
  error_message: string | null;
  created_at: Date;
}

export interface DeploymentLog {
  id: string;
  deployment_id: string;
  log_level: 'debug' | 'info' | 'warning' | 'error' | 'critical';
  message: string;
  details: any;
  step_name: string | null;
  step_index: number | null;
  created_at: Date;
}

// DEPLOYMENTS REPOSITORY

export class DeploymentsRepository {
  constructor(private db: DatabaseClient) {}

  async getById(id: string): Promise<Deployment | null> {
    const result = await this.db.query<Deployment>(
      'SELECT * FROM core.deployments WHERE id = $1',
      [id]
    );

    return result.rows[0] || null;
  }

  async getByAppId(appId: string, limit: number = 20): Promise<Deployment[]> {
    const result = await this.db.query<Deployment>(
      `SELECT * FROM core.deployments
       WHERE app_id = $1
       ORDER BY created_at DESC
       LIMIT $2`,
      [appId, limit]
    );

    return result.rows;
  }

  async getLatestSuccessful(appId: string): Promise<Deployment | null> {
    const result = await this.db.query<Deployment>(
      `SELECT * FROM core.deployments
       WHERE app_id = $1 AND status = 'success'
       ORDER BY created_at DESC
       LIMIT 1`,
      [appId]
    );

    return result.rows[0] || null;
  }

  async getSummary(appId: string): Promise<{
    total_deployments: number;
    successful_deployments: number;
    failed_deployments: number;
    in_progress_deployments: number;
    avg_build_time_ms: number;
    last_successful_deployment: Date;
    success_rate: number;
  } | null> {
    const result = await this.db.query(
      'SELECT * FROM core.deployment_summary WHERE app_id = $1',
      [appId]
    );

    return result.rows[0] || null;
  }

  async getLogs(deploymentId: string): Promise<DeploymentLog[]> {
    const result = await this.db.query<DeploymentLog>(
      `SELECT * FROM core.deployment_logs
       WHERE deployment_id = $1
       ORDER BY created_at ASC`,
      [deploymentId]
    );

    return result.rows;
  }

  async getRecent(limit: number = 100): Promise<any[]> {
    const result = await this.db.query(
      `SELECT * FROM core.recent_deployments LIMIT $1`,
      [limit]
    );

    return result.rows;
  }

  async updateStatus(id: string, status: Deployment['status']): Promise<void> {
    await this.db.query(
      'UPDATE core.deployments SET status = $1 WHERE id = $2',
      [status, id]
    );
  }

  /**
   * Cancel deployment
   */
  async cancel(id: string): Promise<boolean> {
    const result = await this.db.query(
      `UPDATE core.deployments
       SET status = 'cancelled', completed_at = now()
       WHERE id = $1 AND status IN ('pending', 'building', 'deploying')`,
      [id]
    );

    return (result.rowCount || 0) > 0;
  }

  /**
   * Cleanup old failed deployments
   */
  async cleanupFailed(appId: string): Promise<number> {
    const result = await this.db.query<{ cleaned: number }>(
      'SELECT cleanup_old_failed_deployments($1) as cleaned',
      [appId]
    );

    return result.rows[0]?.cleaned || 0;
  }
}

// EXPORTS REPOSITORY

export class ExportsRepository {
  constructor(private db: DatabaseClient) {}

  async getById(id: string): Promise<Export | null> {
    const result = await this.db.query<Export>(
      'SELECT * FROM core.exports WHERE id = $1',
      [id]
    );

    return result.rows[0] || null;
  }

  async getByAppId(appId: string, limit: number = 20): Promise<Export[]> {
    const result = await this.db.query<Export>(
      `SELECT * FROM core.exports
       WHERE app_id = $1
       ORDER BY created_at DESC
       LIMIT $2`,
      [appId, limit]
    );

    return result.rows;
  }

  async getStatistics(appId: string): Promise<{
    total_exports: number;
    successful_exports: number;
    total_downloads: number;
    avg_export_size_bytes: number;
    last_export_at: Date;
  } | null> {
    const result = await this.db.query(
      'SELECT * FROM core.export_statistics WHERE app_id = $1',
      [appId]
    );

    return result.rows[0] || null;
  }

  /**
   * Track download
   */
  async trackDownload(id: string): Promise<void> {
    await this.db.query(
      `UPDATE core.exports
       SET download_count = download_count + 1,
           last_downloaded_at = now()
       WHERE id = $1`,
      [id]
    );
  }

  /**
   * Cleanup old exports
   */
  async cleanup(appId: string, keepCount: number = 50): Promise<number> {
    const result = await this.db.query(
      `DELETE FROM core.exports
       WHERE id IN (
         SELECT id FROM core.exports
         WHERE app_id = $1
         ORDER BY created_at DESC
         OFFSET $2
       )`,
      [appId, keepCount]
    );

    return result.rowCount || 0;
  }
}
</file>

<file path="packages/database/src/repositories/netlify.ts">
/**
 * Netlify Integration Repositories
 *
 * Manages user integrations and Netlify sites.
 */

import type { DatabaseClient } from '../client.js';

// TYPES

export interface UserIntegration {
  id: string;
  user_id: string;
  service: 'netlify' | 'vercel' | 'github' | 'gitlab';
  encrypted_token: Buffer;
  token_last_4: string | null;
  service_user_id: string | null;
  service_email: string | null;
  service_username: string | null;
  is_verified: boolean;
  verified_at: Date | null;
  last_used_at: Date | null;
  metadata: Record<string, any>;
  created_at: Date;
  updated_at: Date;
}

export interface NetlifySite {
  id: string;
  user_id: string;
  app_id: string | null;
  session_id: string | null;
  netlify_site_id: string;
  site_name: string | null;
  url: string;
  admin_url: string | null;
  ssl_url: string | null;
  created_via: string;
  custom_domain: string | null;
  is_active: boolean;
  last_deploy_id: string | null;
  last_deploy_at: Date | null;
  created_at: Date;
  updated_at: Date;
}

export interface CreateIntegrationData {
  user_id: string;
  service: 'netlify' | 'vercel' | 'github' | 'gitlab';
  token: string; // Plain text token (will be encrypted)
  service_user_id?: string;
  service_email?: string;
  service_username?: string;
  metadata?: Record<string, any>;
}

export interface CreateNetlifySiteData {
  user_id: string;
  app_id?: string;
  session_id?: string;
  netlify_site_id: string;
  site_name?: string;
  url: string;
  admin_url?: string;
  ssl_url?: string;
  created_via?: string;
}

// USER INTEGRATIONS REPOSITORY

export class UserIntegrationsRepository {
  constructor(private db: DatabaseClient, private encryptionKey: string) {
    if (!encryptionKey) {
      throw new Error('Encryption key is required for UserIntegrationsRepository');
    }
  }

  async upsert(data: CreateIntegrationData): Promise<UserIntegration> {
    const tokenLast4 = data.token.length >= 4 ? data.token.slice(-4) : '****';

    const result = await this.db.query<UserIntegration>(
      `INSERT INTO core.user_integrations (
        user_id, service, encrypted_token, token_last_4,
        service_user_id, service_email, service_username, metadata
      )
      VALUES (
        $1, $2,
        encrypt_token($3, $4),
        $5, $6, $7, $8, $9
      )
      ON CONFLICT (user_id, service)
      DO UPDATE SET
        encrypted_token = encrypt_token($3, $4),
        token_last_4 = $5,
        service_user_id = COALESCE($6, user_integrations.service_user_id),
        service_email = COALESCE($7, user_integrations.service_email),
        service_username = COALESCE($8, user_integrations.service_username),
        metadata = COALESCE($9, user_integrations.metadata),
        updated_at = now()
      RETURNING *`,
      [
        data.user_id,
        data.service,
        data.token,
        this.encryptionKey,
        tokenLast4,
        data.service_user_id || null,
        data.service_email || null,
        data.service_username || null,
        data.metadata || {}
      ]
    );

    return result.rows[0];
  }

  async get(userId: string, service: string): Promise<UserIntegration | null> {
    const result = await this.db.query<UserIntegration>(
      `SELECT * FROM core.user_integrations
       WHERE user_id = $1 AND service = $2`,
      [userId, service]
    );

    return result.rows[0] || null;
  }

  async getDecryptedToken(userId: string, service: string): Promise<string | null> {
    const result = await this.db.query<{ token: string }>(
      `SELECT decrypt_token(encrypted_token, $1) as token
       FROM core.user_integrations
       WHERE user_id = $2 AND service = $3`,
      [this.encryptionKey, userId, service]
    );

    return result.rows[0]?.token || null;
  }

  /**
   * Mark integration as verified
   */
  async markVerified(userId: string, service: string): Promise<void> {
    await this.db.query(
      `UPDATE core.user_integrations
       SET is_verified = true, verified_at = now()
       WHERE user_id = $1 AND service = $2`,
      [userId, service]
    );
  }

  async updateLastUsed(userId: string, service: string): Promise<void> {
    await this.db.query(
      `UPDATE core.user_integrations
       SET last_used_at = now()
       WHERE user_id = $1 AND service = $2`,
      [userId, service]
    );
  }

  async delete(userId: string, service: string): Promise<boolean> {
    const result = await this.db.query(
      `DELETE FROM core.user_integrations
       WHERE user_id = $1 AND service = $2`,
      [userId, service]
    );

    return (result.rowCount || 0) > 0;
  }

  async getAllForUser(userId: string): Promise<UserIntegration[]> {
    const result = await this.db.query<UserIntegration>(
      `SELECT * FROM core.user_integrations_safe
       WHERE user_id = $1
       ORDER BY created_at DESC`,
      [userId]
    );

    return result.rows;
  }
}

// NETLIFY SITES REPOSITORY

export class NetlifySitesRepository {
  constructor(private db: DatabaseClient) {}

  async create(data: CreateNetlifySiteData): Promise<NetlifySite> {
    const result = await this.db.query<NetlifySite>(
      `INSERT INTO core.netlify_sites (
        user_id, app_id, session_id, netlify_site_id,
        site_name, url, admin_url, ssl_url, created_via
      )
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      ON CONFLICT (user_id, netlify_site_id)
      DO UPDATE SET
        app_id = COALESCE($2, netlify_sites.app_id),
        session_id = COALESCE($3, netlify_sites.session_id),
        site_name = COALESCE($5, netlify_sites.site_name),
        url = $6,
        admin_url = COALESCE($7, netlify_sites.admin_url),
        ssl_url = COALESCE($8, netlify_sites.ssl_url),
        updated_at = now()
      RETURNING *`,
      [
        data.user_id,
        data.app_id || null,
        data.session_id || null,
        data.netlify_site_id,
        data.site_name || null,
        data.url,
        data.admin_url || null,
        data.ssl_url || null,
        data.created_via || 'eitherway'
      ]
    );

    return result.rows[0];
  }

  async getById(id: string): Promise<NetlifySite | null> {
    const result = await this.db.query<NetlifySite>(
      'SELECT * FROM core.netlify_sites WHERE id = $1',
      [id]
    );

    return result.rows[0] || null;
  }

  async getByNetlifySiteId(userId: string, netlifySiteId: string): Promise<NetlifySite | null> {
    const result = await this.db.query<NetlifySite>(
      `SELECT * FROM core.netlify_sites
       WHERE user_id = $1 AND netlify_site_id = $2`,
      [userId, netlifySiteId]
    );

    return result.rows[0] || null;
  }

  async getByAppId(appId: string): Promise<NetlifySite | null> {
    const result = await this.db.query<NetlifySite>(
      `SELECT * FROM core.netlify_sites
       WHERE app_id = $1 AND is_active = true
       ORDER BY created_at DESC
       LIMIT 1`,
      [appId]
    );

    return result.rows[0] || null;
  }

  async getAllForUser(userId: string, limit: number = 50): Promise<NetlifySite[]> {
    const result = await this.db.query<NetlifySite>(
      `SELECT * FROM core.netlify_sites
       WHERE user_id = $1
       ORDER BY created_at DESC
       LIMIT $2`,
      [userId, limit]
    );

    return result.rows;
  }

  async updateLastDeploy(id: string, deployId: string): Promise<void> {
    await this.db.query(
      `UPDATE core.netlify_sites
       SET last_deploy_id = $1, last_deploy_at = now()
       WHERE id = $2`,
      [deployId, id]
    );
  }

  /**
   * Mark site as inactive
   */
  async markInactive(id: string): Promise<void> {
    await this.db.query(
      'UPDATE core.netlify_sites SET is_active = false WHERE id = $1',
      [id]
    );
  }

  async delete(id: string): Promise<boolean> {
    const result = await this.db.query(
      'DELETE FROM core.netlify_sites WHERE id = $1',
      [id]
    );

    return (result.rowCount || 0) > 0;
  }

  async getWithStats(id: string): Promise<any> {
    const result = await this.db.query(
      `SELECT * FROM core.netlify_sites_with_stats WHERE id = $1`,
      [id]
    );

    return result.rows[0] || null;
  }
}
</file>

<file path="packages/database/src/services/deployment-service.ts">
/**
 * Deployment Service
 *
 * Handles GitHub Pages deployment with build execution and status tracking.
 * Uses `gh` CLI for GitHub integration.
 *
 * Features:
 * - Execute build commands (npm run build, etc.)
 * - Deploy to GitHub Pages (gh-pages branch)
 * - Track deployment status and logs
 * - Store deployment URLs
 */

import { spawn } from 'child_process';
import { promises as fs } from 'fs';
import { join } from 'path';
import type { DatabaseClient } from '../client.js';

// TYPES

export interface DeploymentConfig {
  appId: string;
  userId: string;
  sessionId?: string;
  repositoryUrl: string;
  branch?: string;
  buildCommand?: string;
  outputDirectory?: string;
  environmentVars?: Record<string, string>;
}

export interface DeploymentResult {
  id: string;
  status: 'success' | 'failed';
  deploymentUrl?: string;
  error?: string;
  duration: number;
  logs: DeploymentLogEntry[];
}

export interface DeploymentLogEntry {
  level: 'debug' | 'info' | 'warning' | 'error' | 'critical';
  message: string;
  details?: any;
  stepName?: string;
  stepIndex?: number;
  timestamp: Date;
}

export type DeploymentStatus = 'pending' | 'building' | 'deploying' | 'success' | 'failed' | 'cancelled';

// DEPLOYMENT SERVICE

export class DeploymentService {
  private db: DatabaseClient;

  constructor(db: DatabaseClient) {
    this.db = db;
  }

  /**
   * Deploy app to GitHub Pages
   */
  async deployToGitHubPages(config: DeploymentConfig, workingDir: string): Promise<DeploymentResult> {
    const startTime = Date.now();
    const logs: DeploymentLogEntry[] = [];

    const repoInfo = this.parseGitHubUrl(config.repositoryUrl);
    if (!repoInfo) {
      throw new Error('Invalid GitHub repository URL');
    }

    const deploymentId = await this.createDeployment({
      app_id: config.appId,
      user_id: config.userId,
      session_id: config.sessionId,
      deployment_type: 'github_pages',
      repository_url: config.repositoryUrl,
      repository_owner: repoInfo.owner,
      repository_name: repoInfo.name,
      branch: config.branch || 'gh-pages',
      build_command: config.buildCommand || 'npm run build',
      output_directory: config.outputDirectory || 'dist',
      environment_vars: config.environmentVars || {}
    });

    try {
      await this.updateDeploymentStatus(deploymentId, 'building');
      this.addLog(logs, 'info', 'Starting deployment process', {}, 'initialize', 0);

      // Step 1: Install dependencies (if needed)
      const hasPackageJson = await this.fileExists(join(workingDir, 'package.json'));
      if (hasPackageJson) {
        this.addLog(logs, 'info', 'Installing dependencies...', {}, 'install', 1);
        await this.runCommand('npm', ['install'], workingDir, logs);
      }

      // Step 2: Run build command
      if (config.buildCommand) {
        this.addLog(logs, 'info', `Running build command: ${config.buildCommand}`, {}, 'build', 2);
        const [command, ...args] = config.buildCommand.split(' ');
        await this.runCommand(command, args, workingDir, logs, config.environmentVars);
      }

      // Step 3: Verify build output
      const outputDir = join(workingDir, config.outputDirectory || 'dist');
      const outputExists = await this.fileExists(outputDir);
      if (!outputExists) {
        throw new Error(`Build output directory not found: ${config.outputDirectory}`);
      }
      this.addLog(logs, 'info', 'Build completed successfully', { outputDir }, 'build', 2);

      // Step 4: Initialize Git repository (if needed)
      await this.updateDeploymentStatus(deploymentId, 'deploying');
      const hasGit = await this.fileExists(join(workingDir, '.git'));
      if (!hasGit) {
        this.addLog(logs, 'info', 'Initializing Git repository...', {}, 'git', 3);
        await this.runCommand('git', ['init'], workingDir, logs);
        await this.runCommand('git', ['remote', 'add', 'origin', config.repositoryUrl], workingDir, logs);
      }

      // Step 5: Create gh-pages branch and commit
      this.addLog(logs, 'info', 'Preparing gh-pages deployment...', {}, 'deploy', 4);

      await this.runCommand('git', ['checkout', '--orphan', config.branch || 'gh-pages'], workingDir, logs);

      // Copy build output to root
      await this.runCommand('cp', ['-r', `${outputDir}/*`, '.'], workingDir, logs);

      // Commit changes
      await this.runCommand('git', ['add', '.'], workingDir, logs);
      await this.runCommand('git', ['commit', '-m', 'Deploy to GitHub Pages'], workingDir, logs);

      // Step 6: Push to GitHub
      this.addLog(logs, 'info', 'Pushing to GitHub...', {}, 'deploy', 4);
      await this.runCommand('git', ['push', '-f', 'origin', config.branch || 'gh-pages'], workingDir, logs);

      // Step 7: Get deployment URL
      const deploymentUrl = `https://${repoInfo.owner}.github.io/${repoInfo.name}/`;
      this.addLog(logs, 'info', `Deployment successful: ${deploymentUrl}`, { deploymentUrl }, 'complete', 5);

      await this.updateDeployment(deploymentId, {
        status: 'success',
        deployment_url: deploymentUrl,
        started_at: new Date(startTime),
        completed_at: new Date()
      });

      // Store logs
      await this.storeLogs(deploymentId, logs);

      const duration = Date.now() - startTime;

      return {
        id: deploymentId,
        status: 'success',
        deploymentUrl,
        duration,
        logs
      };

    } catch (error: any) {
      this.addLog(logs, 'error', `Deployment failed: ${error.message}`, { error: error.stack }, 'error', -1);

      await this.updateDeployment(deploymentId, {
        status: 'failed',
        error_message: error.message,
        error_stack: error.stack,
        started_at: new Date(startTime),
        completed_at: new Date()
      });

      // Store logs
      await this.storeLogs(deploymentId, logs);

      const duration = Date.now() - startTime;

      return {
        id: deploymentId,
        status: 'failed',
        error: error.message,
        duration,
        logs
      };
    }
  }

  private async createDeployment(data: any): Promise<string> {
    const result = await this.db.query<{ id: string }>(
      `INSERT INTO core.deployments (
        app_id, user_id, session_id, deployment_type,
        repository_url, repository_owner, repository_name,
        branch, build_command, output_directory, environment_vars
      )
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      RETURNING id`,
      [
        data.app_id,
        data.user_id,
        data.session_id || null,
        data.deployment_type,
        data.repository_url,
        data.repository_owner,
        data.repository_name,
        data.branch,
        data.build_command,
        data.output_directory,
        JSON.stringify(data.environment_vars)
      ]
    );

    return result.rows[0].id;
  }

  private async updateDeploymentStatus(deploymentId: string, status: DeploymentStatus): Promise<void> {
    await this.db.query(
      'UPDATE core.deployments SET status = $1 WHERE id = $2',
      [status, deploymentId]
    );
  }

  private async updateDeployment(deploymentId: string, updates: any): Promise<void> {
    const fields: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    Object.entries(updates).forEach(([key, value]) => {
      fields.push(`${key} = $${paramIndex++}`);
      values.push(value);
    });

    values.push(deploymentId);
    await this.db.query(
      `UPDATE core.deployments SET ${fields.join(', ')} WHERE id = $${paramIndex}`,
      values
    );
  }

  /**
   * Store deployment logs
   */
  private async storeLogs(deploymentId: string, logs: DeploymentLogEntry[]): Promise<void> {
    for (const log of logs) {
      await this.db.query(
        `INSERT INTO core.deployment_logs (
          deployment_id, log_level, message, details, step_name, step_index
        )
        VALUES ($1, $2, $3, $4, $5, $6)`,
        [
          deploymentId,
          log.level,
          log.message,
          log.details ? JSON.stringify(log.details) : null,
          log.stepName || null,
          log.stepIndex || null
        ]
      );
    }
  }

  /**
   * Run shell command and capture output
   */
  private runCommand(
    command: string,
    args: string[],
    cwd: string,
    logs: DeploymentLogEntry[],
    env?: Record<string, string>
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      const proc = spawn(command, args, {
        cwd,
        env: { ...process.env, ...env },
        shell: true
      });

      let stdout = '';
      let stderr = '';

      proc.stdout?.on('data', (data) => {
        const output = data.toString();
        stdout += output;
        this.addLog(logs, 'debug', output.trim(), {}, undefined, undefined);
      });

      proc.stderr?.on('data', (data) => {
        const output = data.toString();
        stderr += output;
        this.addLog(logs, 'warning', output.trim(), {}, undefined, undefined);
      });

      proc.on('close', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`Command failed with code ${code}: ${command} ${args.join(' ')}\n${stderr}`));
        }
      });

      proc.on('error', (error) => {
        reject(error);
      });
    });
  }

  /**
   * Add log entry
   */
  private addLog(
    logs: DeploymentLogEntry[],
    level: DeploymentLogEntry['level'],
    message: string,
    details?: any,
    stepName?: string,
    stepIndex?: number
  ): void {
    // Skip empty messages
    if (!message || message.trim() === '') return;

    logs.push({
      level,
      message,
      details,
      stepName,
      stepIndex,
      timestamp: new Date()
    });
  }

  /**
   * Parse GitHub repository URL
   */
  private parseGitHubUrl(url: string): { owner: string; name: string } | null {
    // Support both HTTPS and SSH URLs
    const httpsPattern = /github\.com\/([^\/]+)\/([^\/\.]+)/;
    const sshPattern = /git@github\.com:([^\/]+)\/([^\/\.]+)/;

    let match = url.match(httpsPattern) || url.match(sshPattern);
    if (!match) return null;

    return {
      owner: match[1],
      name: match[2].replace(/\.git$/, '')
    };
  }

  private async fileExists(path: string): Promise<boolean> {
    try {
      await fs.access(path);
      return true;
    } catch {
      return false;
    }
  }

  async getDeployment(deploymentId: string): Promise<any> {
    const result = await this.db.query(
      'SELECT * FROM core.deployments WHERE id = $1',
      [deploymentId]
    );

    return result.rows[0] || null;
  }

  async getDeploymentLogs(deploymentId: string): Promise<DeploymentLogEntry[]> {
    const result = await this.db.query<any>(
      `SELECT log_level, message, details, step_name, step_index, created_at
       FROM core.deployment_logs
       WHERE deployment_id = $1
       ORDER BY created_at ASC`,
      [deploymentId]
    );

    return result.rows.map(row => ({
      level: row.log_level,
      message: row.message,
      details: row.details,
      stepName: row.step_name,
      stepIndex: row.step_index,
      timestamp: row.created_at
    }));
  }

  async getDeploymentsByApp(appId: string, limit: number = 10): Promise<any[]> {
    const result = await this.db.query(
      `SELECT * FROM core.deployments
       WHERE app_id = $1
       ORDER BY created_at DESC
       LIMIT $2`,
      [appId, limit]
    );

    return result.rows;
  }

  async getLatestSuccessfulDeployment(appId: string): Promise<any> {
    const result = await this.db.query(
      `SELECT * FROM core.deployments
       WHERE app_id = $1 AND status = 'success'
       ORDER BY created_at DESC
       LIMIT 1`,
      [appId]
    );

    return result.rows[0] || null;
  }

  /**
   * Cancel deployment
   */
  async cancelDeployment(deploymentId: string): Promise<void> {
    await this.updateDeployment(deploymentId, {
      status: 'cancelled',
      completed_at: new Date()
    });
  }
}
</file>

<file path="packages/database/src/services/palette-extractor.ts">
/**
 * Color Palette Extractor
 *
 * Uses sharp to analyze images and extract dominant colors.
 * Implements k-means clustering for accurate color extraction.
 *
 * Features:
 * - Extract dominant colors from images
 * - Calculate prominence scores
 * - Convert between color spaces (RGB, HEX, HSL)
 * - Filter out similar colors
 */

import sharp from 'sharp';

// TYPES

export interface RGB {
  r: number;
  g: number;
  b: number;
}

export interface HSL {
  h: number;
  s: number;
  l: number;
}

export interface ExtractedColor {
  hex: string;
  rgb: RGB;
  hsl: HSL;
  prominence: number;      // 0-1 score
  pixelPercentage: number; // 0-100 percentage
}

export interface PaletteExtractionOptions {
  maxColors?: number;         // Default: 5
  minProminence?: number;     // Default: 0.05 (5%)
  similarityThreshold?: number; // Default: 30 (Euclidean distance)
}

export interface PaletteExtractionResult {
  colors: ExtractedColor[];
  totalPixels: number;
  dimensions: { width: number; height: number };
}

// EXTRACTOR CLASS

export class PaletteExtractor {
  private static readonly DEFAULT_OPTIONS: Required<PaletteExtractionOptions> = {
    maxColors: 5,
    minProminence: 0.05,
    similarityThreshold: 30
  };

  /**
   * Extract color palette from image buffer
   *
   * @param imageBuffer - Image data (PNG, JPEG, WebP, etc.)
   * @param options - Extraction options
   * @returns Extracted color palette
   */
  async extract(
    imageBuffer: Buffer,
    options: PaletteExtractionOptions = {}
  ): Promise<PaletteExtractionResult> {
    const opts = { ...PaletteExtractor.DEFAULT_OPTIONS, ...options };

    const image = sharp(imageBuffer);
    const metadata = await image.metadata();

    if (!metadata.width || !metadata.height) {
      throw new Error('Unable to determine image dimensions');
    }

    const { width, height } = metadata;
    const totalPixels = width * height;

    // Resize image to max 200x200 for performance (preserves aspect ratio)
    const resized = await image
      .resize(200, 200, { fit: 'inside' })
      .raw()
      .toBuffer({ resolveWithObject: true });

    const pixels = resized.data;
    const channels = resized.info.channels;

    // Extract pixel colors
    const colorCounts = new Map<string, { rgb: RGB; count: number }>();

    for (let i = 0; i < pixels.length; i += channels) {
      const r = pixels[i];
      const g = pixels[i + 1];
      const b = pixels[i + 2];
      const a = channels === 4 ? pixels[i + 3] : 255;

      // Skip transparent pixels
      if (a < 128) continue;

      // Quantize colors to reduce variation (group similar colors)
      const quantized = this.quantizeColor({ r, g, b }, 16);
      const key = `${quantized.r},${quantized.g},${quantized.b}`;

      const existing = colorCounts.get(key);
      if (existing) {
        existing.count++;
      } else {
        colorCounts.set(key, { rgb: quantized, count: 1 });
      }
    }

    // Convert to array and sort by frequency
    const sortedColors = Array.from(colorCounts.values())
      .sort((a, b) => b.count - a.count);

    // Extract top colors and filter by similarity
    const extractedColors: ExtractedColor[] = [];
    const resizedPixels = resized.info.width * resized.info.height;

    for (const { rgb, count } of sortedColors) {
      const prominence = count / resizedPixels;
      if (prominence < opts.minProminence) continue;

      const isSimilar = extractedColors.some(existing =>
        this.colorDistance(rgb, existing.rgb) < opts.similarityThreshold
      );

      if (isSimilar) continue;

      // Convert color formats
      const hex = this.rgbToHex(rgb);
      const hsl = this.rgbToHsl(rgb);
      const pixelPercentage = (count / resizedPixels) * 100;

      extractedColors.push({
        hex,
        rgb,
        hsl,
        prominence,
        pixelPercentage
      });

      // Stop when we have enough colors
      if (extractedColors.length >= opts.maxColors) break;
    }

    return {
      colors: extractedColors,
      totalPixels,
      dimensions: { width, height }
    };
  }

  /**
   * Quantize color to reduce variation
   * Groups colors into buckets of size `factor`
   */
  private quantizeColor(rgb: RGB, factor: number): RGB {
    return {
      r: Math.round(rgb.r / factor) * factor,
      g: Math.round(rgb.g / factor) * factor,
      b: Math.round(rgb.b / factor) * factor
    };
  }

  /**
   * Calculate Euclidean distance between two RGB colors
   * Returns value 0-441 (sqrt(255^2 * 3))
   */
  private colorDistance(c1: RGB, c2: RGB): number {
    const rDiff = c1.r - c2.r;
    const gDiff = c1.g - c2.g;
    const bDiff = c1.b - c2.b;

    return Math.sqrt(rDiff * rDiff + gDiff * gDiff + bDiff * bDiff);
  }

  /**
   * Convert RGB to hexadecimal color string
   */
  private rgbToHex(rgb: RGB): string {
    const toHex = (n: number) => {
      const hex = Math.round(n).toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };

    return `#${toHex(rgb.r)}${toHex(rgb.g)}${toHex(rgb.b)}`.toUpperCase();
  }

  /**
   * Convert RGB to HSL color space
   * H: 0-360, S: 0-100, L: 0-100
   */
  private rgbToHsl(rgb: RGB): HSL {
    const r = rgb.r / 255;
    const g = rgb.g / 255;
    const b = rgb.b / 255;

    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const diff = max - min;

    let h = 0;
    let s = 0;
    const l = (max + min) / 2;

    if (diff !== 0) {
      s = l > 0.5 ? diff / (2 - max - min) : diff / (max + min);

      switch (max) {
        case r:
          h = ((g - b) / diff + (g < b ? 6 : 0)) / 6;
          break;
        case g:
          h = ((b - r) / diff + 2) / 6;
          break;
        case b:
          h = ((r - g) / diff + 4) / 6;
          break;
      }
    }

    return {
      h: Math.round(h * 360),
      s: Math.round(s * 100),
      l: Math.round(l * 100)
    };
  }

  static isAcceptableColor(rgb: RGB, options: { minSaturation?: number } = {}): boolean {
    const { minSaturation = 10 } = options;

    const max = Math.max(rgb.r, rgb.g, rgb.b);
    const min = Math.min(rgb.r, rgb.g, rgb.b);
    const diff = max - min;

    if (max === 0) return false;

    const saturation = (diff / max) * 100;

    // Reject grayscale colors
    if (saturation < minSaturation) return false;

    // Reject very dark colors (sum < 30)
    if (rgb.r + rgb.g + rgb.b < 30) return false;

    // Reject very light colors (sum > 735)
    if (rgb.r + rgb.g + rgb.b > 735) return false;

    return true;
  }

  static suggestColorName(hsl: HSL): string {
    const { h, s, l } = hsl;

    // Grayscale
    if (s < 10) {
      if (l < 20) return 'Black';
      if (l < 40) return 'Dark Gray';
      if (l < 60) return 'Gray';
      if (l < 80) return 'Light Gray';
      return 'White';
    }

    // Chromatic colors
    if (h < 15 || h >= 345) return 'Red';
    if (h < 45) return 'Orange';
    if (h < 75) return 'Yellow';
    if (h < 165) return 'Green';
    if (h < 195) return 'Cyan';
    if (h < 255) return 'Blue';
    if (h < 285) return 'Purple';
    if (h < 315) return 'Magenta';
    return 'Pink';
  }
}
</file>

<file path="packages/database/src/services/rate-limiter.ts">
import { DatabaseClient } from '../client.js';
import type { UserDailyLimit, SessionDailyLimit } from '../types.js';

const MAX_SESSIONS_PER_DAY = 5;
const MAX_MESSAGES_PER_SESSION_PER_DAY = 5;

export interface RateLimitResult {
  allowed: boolean;
  current: number;
  limit: number;
  resetsAt: Date;
}

export class RateLimiter {
  constructor(private db: DatabaseClient) {}

  /**
   * Get current UTC date as a string (YYYY-MM-DD)
   */
  private getCurrentUtcDate(): string {
    const now = new Date();
    return now.toISOString().split('T')[0];
  }

  /**
   * Get the UTC midnight timestamp for the next day
   */
  private getNextUtcMidnight(): Date {
    const now = new Date();
    const tomorrow = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + 1, 0, 0, 0, 0));
    return tomorrow;
  }

  /**
   * Check if a user can create a new session
   * @returns RateLimitResult with allowed status and current count
   */
  async checkSessionCreation(userId: string): Promise<RateLimitResult> {
    const currentDate = this.getCurrentUtcDate();

    const result = await this.db.query<UserDailyLimit>(
      `SELECT user_id, limit_date, sessions_created
       FROM core.user_daily_limits
       WHERE user_id = $1 AND limit_date = $2`,
      [userId, currentDate],
    );

    const current = result.rows.length > 0 ? result.rows[0].sessions_created : 0;
    const allowed = current < MAX_SESSIONS_PER_DAY;

    return {
      allowed,
      current,
      limit: MAX_SESSIONS_PER_DAY,
      resetsAt: this.getNextUtcMidnight(),
    };
  }

  /**
   * Increment the session creation count for a user
   * Should be called after successfully creating a session
   */
  async incrementSessionCount(userId: string): Promise<void> {
    const currentDate = this.getCurrentUtcDate();

    await this.db.query(
      `INSERT INTO core.user_daily_limits (user_id, limit_date, sessions_created)
       VALUES ($1, $2, 1)
       ON CONFLICT (user_id, limit_date)
       DO UPDATE SET sessions_created = core.user_daily_limits.sessions_created + 1`,
      [userId, currentDate],
    );
  }

  /**
   * Check if a session can send a new message
   * @returns RateLimitResult with allowed status and current count
   */
  async checkMessageSending(sessionId: string): Promise<RateLimitResult> {
    const currentDate = this.getCurrentUtcDate();

    const result = await this.db.query<SessionDailyLimit>(
      `SELECT session_id, limit_date, messages_sent
       FROM core.session_daily_limits
       WHERE session_id = $1 AND limit_date = $2`,
      [sessionId, currentDate],
    );

    const current = result.rows.length > 0 ? result.rows[0].messages_sent : 0;
    const allowed = current < MAX_MESSAGES_PER_SESSION_PER_DAY;

    return {
      allowed,
      current,
      limit: MAX_MESSAGES_PER_SESSION_PER_DAY,
      resetsAt: this.getNextUtcMidnight(),
    };
  }

  /**
   * Increment the message count for a session
   * Should be called after successfully creating a message
   */
  async incrementMessageCount(sessionId: string): Promise<void> {
    const currentDate = this.getCurrentUtcDate();

    await this.db.query(
      `INSERT INTO core.session_daily_limits (session_id, limit_date, messages_sent)
       VALUES ($1, $2, 1)
       ON CONFLICT (session_id, limit_date)
       DO UPDATE SET messages_sent = core.session_daily_limits.messages_sent + 1`,
      [sessionId, currentDate],
    );
  }

  /**
   * Get the current session count for a user (for display purposes)
   */
  async getUserSessionCount(userId: string): Promise<number> {
    const currentDate = this.getCurrentUtcDate();

    const result = await this.db.query<UserDailyLimit>(
      `SELECT sessions_created
       FROM core.user_daily_limits
       WHERE user_id = $1 AND limit_date = $2`,
      [userId, currentDate],
    );

    return result.rows.length > 0 ? result.rows[0].sessions_created : 0;
  }

  /**
   * Get the current message count for a session (for display purposes)
   */
  async getSessionMessageCount(sessionId: string): Promise<number> {
    const currentDate = this.getCurrentUtcDate();

    const result = await this.db.query<SessionDailyLimit>(
      `SELECT messages_sent
       FROM core.session_daily_limits
       WHERE session_id = $1 AND limit_date = $2`,
      [sessionId, currentDate],
    );

    return result.rows.length > 0 ? result.rows[0].messages_sent : 0;
  }
}
</file>

<file path="packages/database/src/tests/fixtures.ts">
import { DatabaseClient } from '../client.js';
import {
  UsersRepository,
  SessionsRepository,
  MessagesRepository,
  AppsRepository,
  FilesRepository,
  FileReferencesRepository,
  SessionMemoryRepository,
  WorkingSetRepository,
} from '../repositories/index.js';

export class TestFixtures {
  private usersRepo: UsersRepository;
  private sessionsRepo: SessionsRepository;
  private messagesRepo: MessagesRepository;
  private appsRepo: AppsRepository;
  private filesRepo: FilesRepository;
  private fileRefsRepo: FileReferencesRepository;
  private memoryRepo: SessionMemoryRepository;
  private workingSetRepo: WorkingSetRepository;

  constructor(private db: DatabaseClient) {
    this.usersRepo = new UsersRepository(db);
    this.sessionsRepo = new SessionsRepository(db);
    this.messagesRepo = new MessagesRepository(db);
    this.appsRepo = new AppsRepository(db);
    this.filesRepo = new FilesRepository(db);
    this.fileRefsRepo = new FileReferencesRepository(db);
    this.memoryRepo = new SessionMemoryRepository(db);
    this.workingSetRepo = new WorkingSetRepository(db);
  }

  async createRealisticSession(): Promise<{
    user: any;
    session: any;
    app: any;
    files: any[];
    messages: any[];
  }> {
    const user = await this.usersRepo.create(
      `test-${Date.now()}-${Math.random().toString(36).substring(7)}@example.com`,
      'Test User',
    );

    const app = await this.appsRepo.create(user.id, 'Todo App', 'private');

    const session = await this.sessionsRepo.create(user.id, 'Build a todo app with dark mode', app.id);

    const fileContents = [
      {
        path: 'src/App.tsx',
        content: `import React from 'react';
import { TodoList } from './components/TodoList';
import { ThemeProvider } from './context/ThemeContext';

export default function App() {
  return (
    <ThemeProvider>
      <div className="app">
        <h1>Todo App</h1>
        <TodoList />
      </div>
    </ThemeProvider>
  );
}`,
      },
      {
        path: 'src/components/TodoList.tsx',
        content: `import React, { useState } from 'react';
import { Todo } from '../types';

export function TodoList() {
  const [todos, setTodos] = useState<Todo[]>([]);

  return (
    <div className="todo-list">
      {todos.map(todo => (
        <div key={todo.id}>{todo.text}</div>
      ))}
    </div>
  );
}`,
      },
      {
        path: 'src/context/ThemeContext.tsx',
        content: `import React, { createContext, useState } from 'react';

export const ThemeContext = createContext<any>(null);

export function ThemeProvider({ children }: any) {
  const [theme, setTheme] = useState('light');

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}`,
      },
      {
        path: 'src/types.ts',
        content: `export interface Todo {
  id: string;
  text: string;
  completed: boolean;
}

export type Theme = 'light' | 'dark';`,
      },
      {
        path: 'package.json',
        content: JSON.stringify(
          {
            name: 'todo-app',
            version: '1.0.0',
            dependencies: {
              react: '^18.2.0',
              'react-dom': '^18.2.0',
            },
          },
          null,
          2,
        ),
      },
    ];

    const files = [];
    for (const fc of fileContents) {
      const file = await this.filesRepo.upsertFile(app.id, fc.path, fc.content, user.id, 'text/typescript');
      files.push(file);
    }

    await this.fileRefsRepo.create(app.id, files[0].id, 'import', { destFileId: files[1].id });
    await this.fileRefsRepo.create(app.id, files[0].id, 'import', { destFileId: files[2].id });
    await this.fileRefsRepo.create(app.id, files[1].id, 'import', { destFileId: files[3].id });

    const conversationMessages = [
      { role: 'user' as const, text: 'Build me a todo app with React' },
      { role: 'assistant' as const, text: "I'll create a todo app with React. Let me start with the basic structure." },
      { role: 'user' as const, text: 'Add dark mode support' },
      {
        role: 'assistant' as const,
        text: "I've added a ThemeContext for dark mode support. You can now toggle between light and dark themes.",
      },
      { role: 'user' as const, text: 'Make the todos persistent' },
      { role: 'assistant' as const, text: "I'll add localStorage persistence for the todos." },
    ];

    const messages = [];
    for (const msg of conversationMessages) {
      const message = await this.messagesRepo.create(
        session.id,
        msg.role,
        { text: msg.text },
        'claude-sonnet-4-5',
        Math.floor(msg.text.length / 4),
      );
      messages.push(message);
    }

    await this.memoryRepo.upsert(session.id, {
      rollingSummary:
        'User requested a todo app with React. Added dark mode via ThemeContext. Working on localStorage persistence.',
      facts: {
        framework: 'react',
        features: ['dark-mode', 'persistence'],
        typescript: true,
      },
      lastCompactedMessageId: messages[messages.length - 1].id.toString(),
    });

    await this.workingSetRepo.add(session.id, app.id, files[0].id, 'Main app component', 'agent');

    await this.workingSetRepo.add(session.id, app.id, files[2].id, 'Theme context for dark mode', 'user');

    await this.db.query(`REFRESH MATERIALIZED VIEW core.working_set_enriched`);

    await this.sessionsRepo.touchLastMessage(session.id);

    return { user, session, app, files, messages };
  }

  async cleanup(userId: string): Promise<void> {
    const apps = await this.db.query<{ id: string }>(`SELECT id FROM core.apps WHERE owner_id = $1`, [userId]);

    for (const app of apps.rows) {
      await this.appsRepo.delete(app.id);
    }

    await this.db.query(`DELETE FROM core.sessions WHERE user_id = $1`, [userId]);
    await this.usersRepo.delete(userId);
  }
}
</file>

<file path="packages/database/src/tests/image-generation.test.ts">
import { describe, it, beforeAll, afterAll, expect } from 'vitest';
import { createDatabaseClient, DatabaseClient, ImageGenerationService, ImageJobsRepository } from '../index.js';

describe('Image Generation Pipeline Smoke Tests', () => {
  let db: DatabaseClient;
  let imageService: ImageGenerationService;
  let jobsRepo: ImageJobsRepository;

  beforeAll(async () => {
    db = createDatabaseClient();
    imageService = new ImageGenerationService(db);
    jobsRepo = new ImageJobsRepository(db);

    const healthy = await db.healthCheck();
    expect(healthy).toBe(true);
  });

  afterAll(async () => {
    await db.close();
  });

  it('should create an image generation job', async () => {
    const jobId = await imageService.generateImage({
      prompt: 'A small red cube on a white background',
      model: 'dall-e-3',
      size: '1024x1024',
      quality: 'standard',
      n: 1,
    });

    expect(jobId).toBeDefined();

    const job = await jobsRepo.findById(jobId);
    expect(job).toBeDefined();
    expect(job?.state).toMatch(/queued|generating/);
    expect(job?.prompt).toBe('A small red cube on a white background');
  });

  it('should poll and complete an image generation job', { timeout: 90000 }, async () => {
    const jobId = await imageService.generateImage({
      prompt: 'A simple geometric shape',
      model: 'dall-e-3',
      size: '1024x1024',
      n: 1,
    });

    const result = await imageService.pollJobUntilComplete(jobId, 60000);

    expect(result.job.state).toBe('succeeded');
    expect(result.assets).toHaveLength(1);

    const asset = result.assets[0];
    expect(asset.mime_type).toMatch(/image\/(png|jpeg)/);
    expect(asset.width).toBe(1024);
    expect(asset.height).toBe(1024);

    const fullAsset = await imageService.getAsset(asset.id);
    expect(fullAsset).toBeDefined();
    expect(fullAsset?.bytes).toBeInstanceOf(Buffer);
    expect(fullAsset?.bytes.length).toBeGreaterThan(0);

    const isPNG =
      fullAsset!.bytes[0] === 0x89 &&
      fullAsset!.bytes[1] === 0x50 &&
      fullAsset!.bytes[2] === 0x4e &&
      fullAsset!.bytes[3] === 0x47;

    const isJPEG = fullAsset!.bytes[0] === 0xff && fullAsset!.bytes[1] === 0xd8;

    expect(isPNG || isJPEG).toBe(true);
  });

  it('should verify image bytes are not corrupted', { timeout: 90000 }, async () => {
    const jobId = await imageService.generateImage({
      prompt: 'A blue square',
      model: 'dall-e-3',
      size: '1024x1024',
    });

    const result = await imageService.pollJobUntilComplete(jobId, 60000);

    expect(result.job.state).toBe('succeeded');

    const fullAsset = await imageService.getAsset(result.assets[0].id);
    expect(fullAsset).toBeDefined();

    const bytes = fullAsset!.bytes;

    const isPNG = bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4e && bytes[3] === 0x47;

    if (isPNG) {
      const hasIENDChunk = bytes.includes(Buffer.from('IEND'));
      expect(hasIENDChunk).toBe(true);
    } else {
      const isJPEG = bytes[0] === 0xff && bytes[1] === 0xd8;
      expect(isJPEG).toBe(true);

      const hasEOI = bytes[bytes.length - 2] === 0xff && bytes[bytes.length - 1] === 0xd9;
      expect(hasEOI).toBe(true);
    }

    expect(result.assets[0].checksum).toBeDefined();
    expect(result.assets[0].checksum).toBeInstanceOf(Buffer);
  });

  it('should handle job state transitions', async () => {
    const job = await jobsRepo.create('Test prompt', 'dall-e-3', { size: '1024x1024', n: 1 });

    expect(job.state).toBe('queued');

    const started = await jobsRepo.markStarted(job.id);
    expect(started.state).toBe('generating');
    expect(started.started_at).toBeDefined();

    const succeeded = await jobsRepo.markSucceeded(job.id);
    expect(succeeded.state).toBe('succeeded');
    expect(succeeded.finished_at).toBeDefined();
  });

  it('should handle job failures', async () => {
    const job = await jobsRepo.create('Test failure', 'dall-e-3');

    const failed = await jobsRepo.markFailed(job.id, {
      message: 'Test error',
      code: 'TEST_ERROR',
    });

    expect(failed.state).toBe('failed');
    expect(failed.error).toBeDefined();
    expect(failed.error?.message).toBe('Test error');
  });
});
</file>

<file path="packages/database/src/tests/smoke.test.ts">
import { describe, it, beforeAll, afterAll, expect } from 'vitest';
import {
  createDatabaseClient,
  DatabaseClient,
  UsersRepository,
  SessionsRepository,
  MessagesRepository,
  AppsRepository,
  FilesRepository,
  SessionMemoryRepository,
  WorkingSetRepository,
  EventsRepository,
} from '../index.js';

describe('Database Smoke Tests', () => {
  let db: DatabaseClient;
  let usersRepo: UsersRepository;
  let sessionsRepo: SessionsRepository;
  let messagesRepo: MessagesRepository;
  let appsRepo: AppsRepository;
  let filesRepo: FilesRepository;
  let memoryRepo: SessionMemoryRepository;
  let workingSetRepo: WorkingSetRepository;
  let eventsRepo: EventsRepository;

  beforeAll(async () => {
    db = createDatabaseClient();
    usersRepo = new UsersRepository(db);
    sessionsRepo = new SessionsRepository(db);
    messagesRepo = new MessagesRepository(db);
    appsRepo = new AppsRepository(db);
    filesRepo = new FilesRepository(db);
    memoryRepo = new SessionMemoryRepository(db);
    workingSetRepo = new WorkingSetRepository(db);
    eventsRepo = new EventsRepository(db);

    const healthy = await db.healthCheck();
    expect(healthy).toBe(true);
  });

  afterAll(async () => {
    await db.close();
  });

  it('should create and retrieve a user', async () => {
    const email = `test-${Date.now()}@example.com`;
    const user = await usersRepo.create(email, 'Test User');

    expect(user.email).toBe(email);
    expect(user.display_name).toBe('Test User');

    const retrieved = await usersRepo.findById(user.id);
    expect(retrieved?.email).toBe(email);

    await usersRepo.delete(user.id);
  });

  it('should create session and add messages', async () => {
    const user = await usersRepo.create(`session-test-${Date.now()}@example.com`, 'Session Test');
    const session = await sessionsRepo.create(user.id, 'Test Session');

    expect(session.title).toBe('Test Session');
    expect(session.user_id).toBe(user.id);

    const message1 = await messagesRepo.create(session.id, 'user', { text: 'Hello' }, 'claude-sonnet-4-5', 10);

    expect(message1.role).toBe('user');

    await messagesRepo.create(session.id, 'assistant', { text: 'Hi there!' }, 'claude-sonnet-4-5', 5);

    const messages = await messagesRepo.findBySession(session.id);
    expect(messages).toHaveLength(2);

    await sessionsRepo.delete(session.id);
    await usersRepo.delete(user.id);
  });

  it('should create app and upsert files', async () => {
    const user = await usersRepo.create(`app-test-${Date.now()}@example.com`, 'App Test');
    const app = await appsRepo.create(user.id, 'Test App', 'private');

    expect(app.name).toBe('Test App');
    expect(app.owner_id).toBe(user.id);

    const file1 = await filesRepo.upsertFile(app.id, 'index.js', 'console.log("Hello");', user.id, 'text/javascript');

    expect(file1.path).toBe('index.js');
    expect(file1.app_id).toBe(app.id);

    const file2 = await filesRepo.upsertFile(app.id, 'index.js', 'console.log("Updated");', user.id, 'text/javascript');

    expect(file2.id).toBe(file1.id);

    const versions = await filesRepo.getVersionHistory(file1.id);
    expect(versions).toHaveLength(2);

    const files = await filesRepo.findByApp(app.id);
    expect(files).toHaveLength(1);

    await appsRepo.delete(app.id);
    await usersRepo.delete(user.id);
  });

  it('should manage session memory', async () => {
    const user = await usersRepo.create(`memory-test-${Date.now()}@example.com`, 'Memory Test');
    const session = await sessionsRepo.create(user.id, 'Memory Test Session');

    const memory1 = await memoryRepo.upsert(session.id, {
      rollingSummary: 'User asked about weather',
      facts: { location: 'San Francisco' },
    });

    expect(memory1.rolling_summary).toBe('User asked about weather');

    await memoryRepo.addFact(session.id, 'temperature', '72F');

    const retrieved = await memoryRepo.findBySession(session.id);
    expect(retrieved?.facts).toHaveProperty('location', 'San Francisco');
    expect(retrieved?.facts).toHaveProperty('temperature', '72F');

    await sessionsRepo.delete(session.id);
    await usersRepo.delete(user.id);
  });

  it('should manage working set', async () => {
    const user = await usersRepo.create(`ws-test-${Date.now()}@example.com`, 'WS Test');
    const session = await sessionsRepo.create(user.id, 'WS Test Session');
    const app = await appsRepo.create(user.id, 'WS Test App');
    const file = await filesRepo.upsertFile(app.id, 'test.js', 'code', user.id);

    const item = await workingSetRepo.add(session.id, app.id, file.id, 'Currently editing', 'user');

    expect(item.session_id).toBe(session.id);
    expect(item.file_id).toBe(file.id);

    const items = await workingSetRepo.findBySession(session.id);
    expect(items).toHaveLength(1);

    await workingSetRepo.remove(session.id, file.id);

    const afterRemove = await workingSetRepo.findBySession(session.id);
    expect(afterRemove).toHaveLength(0);

    await appsRepo.delete(app.id);
    await sessionsRepo.delete(session.id);
    await usersRepo.delete(user.id);
  });

  it('should log events', async () => {
    const event = await eventsRepo.log('test.event', { message: 'Test event' }, { actor: 'system' });

    expect(event.kind).toBe('test.event');
    expect(event.actor).toBe('system');

    const events = await eventsRepo.findByKind('test.event', 1);
    expect(events.length).toBeGreaterThan(0);
  });
});
</file>

<file path="packages/evaluations/package.json">
{
  "name": "@eitherway/evaluations",
  "version": "0.1.0",
  "description": "Scripted evaluations and golden transcripts",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "test": "vitest run",
    "eval": "tsx src/run-evals.ts"
  },
  "dependencies": {
    "@eitherway/runtime": "workspace:*"
  },
  "devDependencies": {
    "typescript": "^5.3.3",
    "tsx": "^4.7.0"
  }
}
</file>

<file path="packages/runtime/src/config.ts">
/**
 * Configuration loader
 */

import { readFile } from 'fs/promises';
import { resolve } from 'path';
import type { ClaudeConfig, AgentConfig } from '@eitherway/tools-core';

export class ConfigLoader {
  private configDir: string;

  constructor(configDir: string = './configs') {
    this.configDir = configDir;
  }

  /**
   * Load Claude/Anthropic configuration
   */
  async loadClaudeConfig(): Promise<ClaudeConfig> {
    const configPath = resolve(this.configDir, 'anthropic.json');

    try {
      const content = await readFile(configPath, 'utf-8');
      const config = JSON.parse(content) as ClaudeConfig;

      // Validate required fields
      if (!config.apiKey) {
        throw new Error('API key is required in anthropic.json');
      }

      if (!config.model) {
        config.model = 'claude-sonnet-4-5-20250929';
      }

      // Set defaults
      const claudeConfig: ClaudeConfig = {
        apiKey: config.apiKey,
        model: config.model,
        maxTokens: config.maxTokens || 8192,
        temperature: config.temperature ?? 0.2,
        streaming: config.streaming ?? true,
        provider: config.provider || 'anthropic',
        providerConfig: config.providerConfig,
        thinking: config.thinking,
        promptCaching: config.promptCaching,
      };

      // Only include topP if explicitly set (Claude 4.5 doesn't allow both temperature and topP)
      if (config.topP !== undefined) {
        claudeConfig.topP = config.topP;
      }

      return claudeConfig;
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        throw new Error(
          `Config file not found: ${configPath}\n` +
            `Please copy configs/anthropic.example.json to configs/anthropic.json and add your API key.`,
        );
      }
      throw error;
    }
  }

  /**
   * Load agent configuration
   */
  async loadAgentConfig(): Promise<AgentConfig> {
    const configPath = resolve(this.configDir, 'agent.json');

    try {
      const content = await readFile(configPath, 'utf-8');
      const config = JSON.parse(content) as AgentConfig;

      return config;
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        throw new Error(`Config file not found: ${configPath}`);
      }
      throw error;
    }
  }

  /**
   * Load both configurations
   */
  async loadAll(): Promise<{ claudeConfig: ClaudeConfig; agentConfig: AgentConfig }> {
    const [claudeConfig, agentConfig] = await Promise.all([this.loadClaudeConfig(), this.loadAgentConfig()]);

    return { claudeConfig, agentConfig };
  }
}
</file>

<file path="packages/runtime/src/metrics.ts">
/**
 * Structured logging and metrics for tool execution
 */

import type { AgentConfig } from '@eitherway/tools-core';

export interface ToolMetrics {
  tool: string;
  latency_ms: number;
  input_size: number;
  output_size: number;
  file_count?: number;
  success: boolean;
  error?: string;
  timestamp: string;
}

export class MetricsCollector {
  private metrics: ToolMetrics[] = [];
  private config: AgentConfig;

  constructor(config: AgentConfig) {
    this.config = config;
  }

  /**
   * Record tool execution metrics
   */
  recordToolExecution(metrics: ToolMetrics): void {
    this.metrics.push(metrics);

    // Structured log output
    const level = metrics.success ? 'info' : 'error';
    const status = metrics.success ? '' : '';

    this.log(
      level,
      `[TOOL] ${status} ${metrics.tool} | ` +
        `${metrics.latency_ms}ms | ` +
        `in:${this.formatSize(metrics.input_size)} | ` +
        `out:${this.formatSize(metrics.output_size)}` +
        (metrics.file_count !== undefined ? ` | files:${metrics.file_count}` : '') +
        (metrics.error ? ` | error: ${metrics.error}` : ''),
    );
  }

  /**
   * Get all collected metrics
   */
  getMetrics(): ToolMetrics[] {
    return [...this.metrics];
  }

  /**
   * Get summary statistics
   */
  getSummary(): {
    totalCalls: number;
    successRate: number;
    avgLatency: number;
    totalInputSize: number;
    totalOutputSize: number;
    byTool: Record<string, { calls: number; avgLatency: number }>;
  } {
    const totalCalls = this.metrics.length;
    const successCount = this.metrics.filter((m) => m.success).length;
    const avgLatency = totalCalls > 0 ? this.metrics.reduce((sum, m) => sum + m.latency_ms, 0) / totalCalls : 0;

    const byTool: Record<string, { calls: number; avgLatency: number }> = {};

    for (const metric of this.metrics) {
      if (!byTool[metric.tool]) {
        byTool[metric.tool] = { calls: 0, avgLatency: 0 };
      }
      byTool[metric.tool].calls++;
      byTool[metric.tool].avgLatency =
        (byTool[metric.tool].avgLatency * (byTool[metric.tool].calls - 1) + metric.latency_ms) /
        byTool[metric.tool].calls;
    }

    return {
      totalCalls,
      successRate: totalCalls > 0 ? successCount / totalCalls : 0,
      avgLatency,
      totalInputSize: this.metrics.reduce((sum, m) => sum + m.input_size, 0),
      totalOutputSize: this.metrics.reduce((sum, m) => sum + m.output_size, 0),
      byTool,
    };
  }

  /**
   * Get summary as formatted string
   */
  getSummaryString(): string {
    const summary = this.getSummary();

    if (summary.totalCalls === 0) {
      return 'No tools executed';
    }

    const lines: string[] = [
      `Total calls: ${summary.totalCalls}`,
      `Success rate: ${(summary.successRate * 100).toFixed(1)}%`,
      `Avg latency: ${summary.avgLatency.toFixed(0)}ms`,
    ];

    // Add per-tool breakdown
    const toolNames = Object.keys(summary.byTool).sort();
    if (toolNames.length > 0) {
      lines.push('Per-tool:');
      for (const tool of toolNames) {
        const stats = summary.byTool[tool];
        lines.push(`  - ${tool}: ${stats.calls} calls, ${stats.avgLatency.toFixed(0)}ms avg`);
      }
    }

    return lines.join('\n');
  }

  /**
   * Clear metrics
   */
  clear(): void {
    this.metrics = [];
  }

  /**
   * Format byte size for display
   */
  private formatSize(bytes: number): string {
    if (bytes < 1024) return `${bytes}B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)}KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)}MB`;
  }

  /**
   * Log with level filtering
   */
  private log(level: 'debug' | 'info' | 'warn' | 'error', message: string): void {
    const levels = { debug: 0, info: 1, warn: 2, error: 3 };
    const configLevel = levels[this.config.logging.level];
    const messageLevel = levels[level];

    if (messageLevel >= configLevel) {
      const timestamp = new Date().toISOString();
      const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;

      if (level === 'error') {
        console.error(logMessage);
      } else {
        console.log(logMessage);
      }
    }
  }
}
</file>

<file path="packages/runtime/src/rate-limiter.ts">
/**
 * Rate limiting for external API calls
 */

export interface RateLimitConfig {
  maxRequests: number;
  windowMs: number;
}

export class RateLimiter {
  private requests: Map<string, number[]>;
  private config: Map<string, RateLimitConfig>;

  constructor() {
    this.requests = new Map();
    this.config = new Map();

    // Default rate limits
    this.setLimit('websearch', { maxRequests: 10, windowMs: 60000 }); // 10 per minute
    this.setLimit('eithergen', { maxRequests: 5, windowMs: 60000 }); // 5 per minute
  }

  /**
   * Set rate limit for a specific tool
   */
  setLimit(tool: string, config: RateLimitConfig): void {
    this.config.set(tool, config);
  }

  /**
   * Check if request is allowed
   */
  async checkLimit(tool: string): Promise<{ allowed: boolean; retryAfter?: number }> {
    const config = this.config.get(tool);
    if (!config) {
      // No rate limit configured
      return { allowed: true };
    }

    const now = Date.now();
    const requests = this.requests.get(tool) || [];

    // Remove expired requests
    const validRequests = requests.filter((time) => now - time < config.windowMs);

    if (validRequests.length >= config.maxRequests) {
      // Rate limit exceeded
      const oldestRequest = validRequests[0];
      const retryAfter = Math.ceil((oldestRequest + config.windowMs - now) / 1000);

      return {
        allowed: false,
        retryAfter,
      };
    }

    // Record this request
    validRequests.push(now);
    this.requests.set(tool, validRequests);

    return { allowed: true };
  }

  /**
   * Reset rate limit for a tool
   */
  reset(tool: string): void {
    this.requests.delete(tool);
  }

  /**
   * Get current usage
   */
  getUsage(tool: string): { current: number; max: number; windowMs: number } | null {
    const config = this.config.get(tool);
    if (!config) return null;

    const now = Date.now();
    const requests = this.requests.get(tool) || [];
    const validRequests = requests.filter((time) => now - time < config.windowMs);

    return {
      current: validRequests.length,
      max: config.maxRequests,
      windowMs: config.windowMs,
    };
  }
}
</file>

<file path="packages/runtime/src/transcript.ts">
/**
 * Transcript capture and logging
 */

import { writeFile, mkdir } from 'fs/promises';
import { resolve } from 'path';
import type { Transcript, TranscriptEntry, AgentConfig } from '@eitherway/tools-core';

export class TranscriptRecorder {
  private currentTranscript: Transcript | null = null;
  private config: AgentConfig;

  constructor(config: AgentConfig) {
    this.config = config;
  }

  /**
   * Start a new transcript
   */
  startTranscript(request: string): string {
    const id = this.generateId();
    const startTime = new Date().toISOString();

    this.currentTranscript = {
      id,
      startTime,
      entries: [],
      request,
    };

    this.log('info', `Started transcript ${id}`);
    return id;
  }

  /**
   * Add an entry to the current transcript
   */
  addEntry(entry: TranscriptEntry): void {
    if (!this.currentTranscript) {
      this.log('warn', 'Attempted to add entry without active transcript');
      return;
    }

    this.currentTranscript.entries.push(entry);
  }

  /**
   * End the current transcript
   */
  endTranscript(id: string, result?: string): void {
    if (!this.currentTranscript || this.currentTranscript.id !== id) {
      this.log('warn', `Transcript ${id} not found or mismatch`);
      return;
    }

    this.currentTranscript.endTime = new Date().toISOString();
    this.currentTranscript.result = result;

    this.log('info', `Ended transcript ${id}`);
  }

  /**
   * Save current transcript to disk
   */
  async saveCurrentTranscript(): Promise<void> {
    if (!this.currentTranscript) {
      return;
    }

    if (!this.config.logging.captureTranscripts) {
      return;
    }

    try {
      const dir = this.config.logging.transcriptDir;
      await mkdir(dir, { recursive: true });

      const filename = `transcript-${this.currentTranscript.id}.json`;
      const filepath = resolve(dir, filename);

      await writeFile(filepath, JSON.stringify(this.currentTranscript, null, 2), 'utf-8');

      this.log('info', `Saved transcript to ${filepath}`);
    } catch (error: any) {
      this.log('error', `Failed to save transcript: ${error.message}`);
    }
  }

  /**
   * Get current transcript
   */
  getCurrentTranscript(): Transcript | null {
    return this.currentTranscript ? { ...this.currentTranscript } : null;
  }

  /**
   * Log a message
   */
  private log(level: 'debug' | 'info' | 'warn' | 'error', message: string): void {
    const levels = { debug: 0, info: 1, warn: 2, error: 3 };
    const configLevel = levels[this.config.logging.level];
    const messageLevel = levels[level];

    if (messageLevel >= configLevel) {
      const timestamp = new Date().toISOString();
      const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`;

      if (level === 'error') {
        console.error(logMessage);
      } else {
        console.log(logMessage);
      }
    }
  }

  /**
   * Generate unique ID for transcript
   */
  private generateId(): string {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2, 9);
    return `${timestamp}-${random}`;
  }
}
</file>

<file path="packages/runtime/src/verifier.ts">
/**
 * VerifierRunner: Automatic verification of workspace changes
 * Runs tests, linting, and builds to ensure changes are valid
 */

import { spawn } from 'child_process';
import { readFile } from 'fs/promises';
import { resolve } from 'path';

export interface VerifyStep {
  name: string;
  ok: boolean;
  output?: string;
  duration?: number;
}

export interface VerifyResult {
  steps: VerifyStep[];
  passed: boolean;
  totalDuration: number;
}

export class VerifierRunner {
  constructor(private workingDir: string) {}

  /**
   * Run verification checks based on project type
   */
  async run(): Promise<VerifyResult> {
    const startTime = Date.now();
    const pkgPath = resolve(this.workingDir, 'package.json');

    let pkg: any = null;
    try {
      const content = await readFile(pkgPath, 'utf-8');
      pkg = JSON.parse(content);
    } catch {
      // No package.json - likely a static project
    }

    const steps: VerifyStep[] = [];

    if (pkg) {
      // Node.js project - run available scripts in order
      const scriptChecks = [
        { script: 'typecheck', name: 'Type Check' },
        { script: 'lint', name: 'Lint' },
        { script: 'test', name: 'Test' },
        { script: 'build', name: 'Build' },
      ];

      for (const check of scriptChecks) {
        if (pkg.scripts?.[check.script]) {
          const stepStartTime = Date.now();
          const result = await this.runCommand(['npm', 'run', check.script]);
          const duration = Date.now() - stepStartTime;

          steps.push({
            name: check.name,
            ok: result.ok,
            output: result.output,
            duration,
          });

          // If a critical step fails, stop verification
          if (!result.ok && (check.script === 'typecheck' || check.script === 'test')) {
            break;
          }
        }
      }
    } else {
      // Static project - basic sanity checks
      steps.push(await this.runStaticChecks());
    }

    const totalDuration = Date.now() - startTime;
    const passed = steps.length > 0 ? steps.every((s) => s.ok) : true;

    return {
      steps,
      passed,
      totalDuration,
    };
  }

  /**
   * Run basic sanity checks for static projects
   */
  private async runStaticChecks(): Promise<VerifyStep> {
    const indexPath = resolve(this.workingDir, 'index.html');

    try {
      const content = await readFile(indexPath, 'utf-8');

      // Basic HTML validation
      const hasDoctype = content.trim().toLowerCase().startsWith('<!doctype html');
      const hasClosingHtml = content.includes('</html>');

      if (hasDoctype && hasClosingHtml) {
        return {
          name: 'Static Validation',
          ok: true,
          output: 'index.html appears well-formed',
          duration: 0,
        };
      } else {
        return {
          name: 'Static Validation',
          ok: false,
          output: 'index.html may be malformed (missing doctype or closing tag)',
          duration: 0,
        };
      }
    } catch {
      return {
        name: 'Static Validation',
        ok: true,
        output: 'No index.html found - skipping validation',
        duration: 0,
      };
    }
  }

  /**
   * Execute a shell command and return result
   */
  private runCommand(cmd: string[]): Promise<{ ok: boolean; output: string }> {
    return new Promise((resolve) => {
      const proc = spawn(cmd[0], cmd.slice(1), {
        cwd: this.workingDir,
        shell: process.platform === 'win32',
        env: { ...process.env, CI: 'true', NODE_ENV: 'test' },
      });

      let output = '';
      const outputLimit = 5000; // Limit output to 5000 chars

      proc.stdout.on('data', (data) => {
        if (output.length < outputLimit) {
          output += data.toString();
        }
      });

      proc.stderr.on('data', (data) => {
        if (output.length < outputLimit) {
          output += data.toString();
        }
      });

      proc.on('close', (code) => {
        if (output.length >= outputLimit) {
          output = output.slice(0, outputLimit) + '\n... (output truncated)';
        }

        resolve({
          ok: code === 0,
          output: output.trim(),
        });
      });

      proc.on('error', (error) => {
        resolve({
          ok: false,
          output: `Failed to execute command: ${error.message}`,
        });
      });

      // Timeout after 60 seconds
      setTimeout(() => {
        proc.kill();
        resolve({
          ok: false,
          output: 'Command timed out after 60 seconds',
        });
      }, 60000);
    });
  }

  /**
   * Format verification result as a concise summary
   */
  static formatSummary(result: VerifyResult): string {
    if (result.steps.length === 0) {
      return ' No verification steps configured';
    }

    const lines: string[] = ['\n**Verification Results:**'];

    for (const step of result.steps) {
      const icon = step.ok ? '' : '';
      const time = step.duration ? ` (${step.duration}ms)` : '';
      lines.push(`  ${icon} ${step.name}${time}`);

      // Include brief error output for failed steps
      if (!step.ok && step.output) {
        const errorLines = step.output.split('\n').slice(0, 5); // First 5 lines
        for (const line of errorLines) {
          if (line.trim()) {
            lines.push(`    ${line.trim()}`);
          }
        }
      }
    }

    const summary = result.passed ? 'All checks passed ' : 'Some checks failed ';
    lines.push(`\n${summary} (${result.totalDuration}ms total)`);

    return lines.join('\n');
  }
}
</file>

<file path="packages/tools-core/src/types.ts">
/**
 * Core type definitions for tools, messages, and configuration
 */

// Tool definition matching Anthropic's Messages API schema
export interface ToolDefinition {
  name: string;
  description: string;
  input_schema: {
    type: 'object';
    properties: Record<string, any>;
    required?: string[];
    additionalProperties?: boolean;
  };
}

// Tool input/output structures
export interface ToolUse {
  type: 'tool_use';
  id: string;
  name: string;
  input: Record<string, any>;
}

export interface ToolResult {
  type: 'tool_result';
  tool_use_id: string;
  content: string | Array<{ type: string; [key: string]: any }>;
  is_error?: boolean;
}

// Message types
export type MessageRole = 'user' | 'assistant';

export interface MessageContent {
  type: 'text' | 'tool_use' | 'tool_result' | 'server_tool_use' | 'web_search_tool_result';
  [key: string]: any;
}

export interface Message {
  role: MessageRole;
  content: string | MessageContent[];
}

// Claude API types
export interface ClaudeConfig {
  apiKey: string;
  model: string;
  maxTokens: number;
  temperature: number;
  topP?: number; // Optional - Claude 4.5 doesn't allow both temperature and topP
  streaming: boolean;
  provider: 'anthropic' | 'vertex' | 'bedrock';
  providerConfig?: {
    anthropic?: { baseURL: string };
    vertex?: { projectId: string; location: string; model: string };
    bedrock?: { region: string; modelId: string };
  };
  thinking?: {
    enabled: boolean;
    budget?: 'low' | 'medium' | 'high';
  };
  promptCaching?: {
    enabled: boolean;
  };
}

// Agent configuration
export interface AgentConfig {
  policy: {
    deterministic: boolean;
    singleAgent: boolean;
    parallelTools: boolean;
  };
  security: {
    allowedWorkspaces: string[];
    deniedPaths: string[];
    maxFileSize: number;
    secretPatterns: string[];
    redactSecrets: boolean;
  };
  limits: {
    maxToolPayloadSize: number;
    maxConcurrentTools: number;
    maxSearchResults: number;
    chunkSize: number;
  };
  logging: {
    level: 'debug' | 'info' | 'warn' | 'error';
    captureTranscripts: boolean;
    transcriptDir: string;
    logFile: string;
  };
  tools: {
    webSearch?: {
      enabled: boolean;
      maxUses?: number;
      allowedDomains?: string[];
      blockedDomains?: string[];
    };
    imagegen: {
      provider: string;
      defaultSize: string;
      supportedProviders: string[];
    };
  };
}

// Tool executor interface
export interface ToolExecutor {
  name: string;
  execute(input: Record<string, any>, context: ExecutionContext): Promise<ToolExecutorResult>;
}

export interface ExecutionContext {
  workingDir: string;
  allowedPaths: string[];
  deniedPaths: string[];
  config: AgentConfig;
  // Database integration (optional) - when present, tools should use DB instead of filesystem
  fileStore?: any; // FileStore from @eitherway/database
  appId?: string; // App ID for database file operations
  sessionId?: string; // Session ID for context
}

export interface ToolExecutorResult {
  content: string;
  isError: boolean;
  metadata?: Record<string, any>;
}

// Transcript capture
export interface TranscriptEntry {
  timestamp: string;
  role: MessageRole;
  content: string | MessageContent[];
  metadata?: {
    model?: string;
    tokenUsage?: {
      input: number;
      output: number;
    };
    stopReason?: string;
  };
}

export interface Transcript {
  id: string;
  startTime: string;
  endTime?: string;
  entries: TranscriptEntry[];
  request: string;
  result?: string;
}
</file>

<file path="packages/tools-core/src/validator.ts">
/**
 * Tool input validation using Ajv (JSON Schema validator)
 */

import Ajv, { ValidateFunction } from 'ajv';
import addFormats from 'ajv-formats';
import { TOOL_SCHEMAS } from './schemas.js';
import { ToolDefinition } from './types.js';

export class ToolValidator {
  private ajv: Ajv;
  private validators: Map<string, ValidateFunction>;

  constructor() {
    this.ajv = new Ajv({
      allErrors: true,
      useDefaults: true,
      coerceTypes: false,
      strict: true,
    });

    addFormats(this.ajv);
    this.validators = new Map();

    // Compile all tool schemas
    this.compileSchemas();
  }

  private compileSchemas(): void {
    for (const [name, schema] of Object.entries(TOOL_SCHEMAS)) {
      const validator = this.ajv.compile(schema.input_schema);
      this.validators.set(name, validator);
    }
  }

  /**
   * Validate tool input against its schema
   */
  validate(toolName: string, input: Record<string, any>): ValidationResult {
    const validator = this.validators.get(toolName);

    if (!validator) {
      return {
        valid: false,
        errors: [`Unknown tool: ${toolName}`],
      };
    }

    const valid = validator(input);

    if (!valid && validator.errors) {
      return {
        valid: false,
        errors: validator.errors.map((err) => {
          const path = err.instancePath || 'input';
          return `${path}: ${err.message}`;
        }),
      };
    }

    return { valid: true, errors: [] };
  }

  /**
   * Get schema for a specific tool
   */
  getSchema(toolName: string): ToolDefinition | undefined {
    return TOOL_SCHEMAS[toolName];
  }

  /**
   * Check if a tool exists
   */
  hasToolSchema(toolName: string): boolean {
    return this.validators.has(toolName);
  }

  /**
   * Get all available tool names
   */
  getAvailableTools(): string[] {
    return Array.from(this.validators.keys());
  }
}

export interface ValidationResult {
  valid: boolean;
  errors: string[];
}

// Singleton instance
let validatorInstance: ToolValidator | null = null;

export function getValidator(): ToolValidator {
  if (!validatorInstance) {
    validatorInstance = new ToolValidator();
  }
  return validatorInstance;
}
</file>

<file path="packages/tools-impl/src/security.ts">
/**
 * Security utilities for path validation
 * Duplicated from runtime for tools-impl independence
 */

import type { AgentConfig } from '@eitherway/tools-core';

export class SecurityGuard {
  private allowedPaths: string[];
  private deniedPaths: string[];
  private secretPatterns: RegExp[];

  constructor(config: AgentConfig['security']) {
    this.allowedPaths = config.allowedWorkspaces;
    this.deniedPaths = config.deniedPaths;
    this.secretPatterns = config.secretPatterns.map((p) => new RegExp(p, 'g'));
  }

  /**
   * Check if a path is allowed
   */
  isPathAllowed(path: string): boolean {
    // Check denied paths first
    for (const denied of this.deniedPaths) {
      if (this.matchGlob(path, denied)) {
        return false;
      }
    }

    // Check allowed paths
    for (const allowed of this.allowedPaths) {
      if (this.matchGlob(path, allowed)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Redact secrets from content
   */
  redactSecrets(content: string): string {
    let redacted = content;
    for (const pattern of this.secretPatterns) {
      redacted = redacted.replace(pattern, '[REDACTED]');
    }
    return redacted;
  }

  /**
   * Simple glob matching (supports ** and *)
   */
  private matchGlob(path: string, pattern: string): boolean {
    const regex = this.globToRegExp(pattern);
    return regex.test(path);
  }

  // Convert a glob to a RegExp with proper ** semantics:
  //  - "**/"   => "(?:.*/)?", i.e., zero or more directories (including none)
  //  - "**"    => ".*"
  //  - "*"     => "[^/]*"
  //  - "?"     => "[^/]"
  private globToRegExp(pattern: string): RegExp {
    const specials = /[.+^${}()|[\]\\]/;
    let i = 0;
    let out = '^';
    while (i < pattern.length) {
      const ch = pattern[i];
      if (ch === '*') {
        const next = pattern[i + 1];
        if (next === '*') {
          const hasSlash = pattern[i + 2] === '/';
          if (hasSlash) {
            out += '(?:.*/)?'; // zero or more directories, including none
            i += 3;
          } else {
            out += '.*'; // any characters, including '/'
            i += 2;
          }
        } else {
          out += '[^/]*'; // any chars except '/'
          i += 1;
        }
      } else if (ch === '?') {
        out += '[^/]';
        i += 1;
      } else {
        out += specials.test(ch) ? '\\' + ch : ch;
        i += 1;
      }
    }
    out += '$';
    return new RegExp(out);
  }
}
</file>

<file path="packages/tools-impl/package.json">
{
  "name": "@eitherway/tools-impl",
  "version": "0.1.0",
  "description": "Tool implementations (either-*, websearch, eithergen)",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "test": "vitest run"
  },
  "dependencies": {
    "@eitherway/tools-core": "workspace:*",
    "@eitherway/database": "workspace:*",
    "fast-glob": "^3.3.2"
  },
  "devDependencies": {
    "@types/node": "^20.11.16",
    "typescript": "^5.3.3"
  }
}
</file>

<file path="packages/ui-frontend/app/components/workbench/Workbench.client.tsx">
import { useStore } from '@nanostores/react';
import { motion, type HTMLMotionProps, type Variants } from 'framer-motion';
import { computed } from 'nanostores';
import { memo, useCallback, useEffect } from 'react';
import { toast } from 'react-toastify';
import { chatStore } from '~/lib/stores/chat';
import {
  type OnChangeCallback as OnEditorChange,
  type OnScrollCallback as OnEditorScroll,
} from '~/components/editor/codemirror/CodeMirrorEditor';
import { IconButton } from '~/components/ui/IconButton';
import { PanelHeaderButton } from '~/components/ui/PanelHeaderButton';
import { Slider, type SliderOptions } from '~/components/ui/Slider';
import { workbenchStore, type WorkbenchViewType } from '~/lib/stores/workbench';
import { classNames } from '~/utils/classNames';
import { cubicEasingFn } from '~/utils/easings';
import { EditorPanel } from './EditorPanel';
import { Preview } from './Preview';

interface WorkspaceProps {
  chatStarted?: boolean;
  isStreaming?: boolean;
}

const viewTransition = { ease: cubicEasingFn };

const sliderOptions: SliderOptions<WorkbenchViewType> = {
  left: {
    value: 'code',
    text: 'Code',
  },
  right: {
    value: 'preview',
    text: 'Preview',
  },
};

const workbenchVariants = {
  closed: {
    width: 0,
    transition: {
      duration: 0.2,
      ease: cubicEasingFn,
    },
  },
  open: {
    width: 'var(--workbench-width)',
    transition: {
      duration: 0.2,
      ease: cubicEasingFn,
    },
  },
} satisfies Variants;

export const Workbench = memo(({ chatStarted, isStreaming }: WorkspaceProps) => {
  const hasPreview = useStore(computed(workbenchStore.previews, (previews) => previews.length > 0));
  const showWorkbench = useStore(workbenchStore.showWorkbench);
  const { showChat } = useStore(chatStore);
  const selectedFile = useStore(workbenchStore.selectedFile);
  const currentDocument = useStore(workbenchStore.currentDocument);
  const unsavedFiles = useStore(workbenchStore.unsavedFiles);
  const files = useStore(workbenchStore.files);
  const selectedView = useStore(workbenchStore.currentView);

  const setSelectedView = (view: WorkbenchViewType) => {
    workbenchStore.currentView.set(view);
  };

  useEffect(() => {
    if (hasPreview) {
      setSelectedView('preview');
    }
  }, [hasPreview]);

  useEffect(() => {
    workbenchStore.setDocuments(files);
  }, [files]);

  const onEditorChange = useCallback<OnEditorChange>((update) => {
    workbenchStore.setCurrentDocumentContent(update.content);
  }, []);

  const onEditorScroll = useCallback<OnEditorScroll>((position) => {
    workbenchStore.setCurrentDocumentScrollPosition(position);
  }, []);

  const onFileSelect = useCallback((filePath: string | undefined) => {
    workbenchStore.setSelectedFile(filePath);
  }, []);

  const onFileSave = useCallback(() => {
    const currentDoc = workbenchStore.currentDocument.get();
    const fileName = currentDoc?.filePath.split('/').pop() || 'file';

    console.log('[Workbench] Saving file:', currentDoc?.filePath);

    workbenchStore
      .saveCurrentDocument()
      .then(() => {
        console.log('[Workbench]  File saved successfully');
        toast.success(`Saved ${fileName}`, {
          position: 'bottom-right',
          autoClose: 2000,
        });
      })
      .catch((error) => {
        console.error('[Workbench]  Save failed:', error);
        // Error toast is already shown by FilesStore, but we can add a fallback
        if (!error.message.includes('Backend sync failed')) {
          toast.error(`Failed to save ${fileName}: ${error.message}`, {
            position: 'bottom-right',
            autoClose: 5000,
          });
        }
      });
  }, []);

  const onFileReset = useCallback(() => {
    workbenchStore.resetCurrentDocument();
  }, []);

  return (
    (chatStarted || showWorkbench) && (
      <motion.div
        initial="closed"
        animate={showWorkbench ? 'open' : 'closed'}
        variants={workbenchVariants}
        className="z-workbench"
      >
        <div
          className={classNames(
            'fixed top-[calc(var(--header-height)+1.5rem)] bottom-6 w-[var(--workbench-inner-width)] mr-4 z-0 transition-[left,width] duration-200 eitherway-ease-cubic-bezier',
            {
              'left-[var(--workbench-left)]': showWorkbench,
              'left-[100%]': !showWorkbench,
            },
          )}
        >
          <div
            className={classNames('absolute inset-0 pr-6', {
              'pl-6': showWorkbench && !showChat,
            })}
          >
            <div className="h-full flex flex-col bg-eitherway-elements-background-depth-2 border border-eitherway-elements-borderColor shadow-sm rounded-lg overflow-hidden">
              <div className="flex items-center px-3 py-2 border-b border-eitherway-elements-borderColor">
                <Slider selected={selectedView} options={sliderOptions} setSelected={setSelectedView} />
                <div className="ml-auto" />
                {selectedView === 'code' && (
                  <PanelHeaderButton
                    className="mr-1 text-sm"
                    onClick={() => {
                      workbenchStore.toggleTerminal(!workbenchStore.showTerminal.get());
                    }}
                  >
                    <div className="i-ph:terminal" />
                    Toggle Terminal
                  </PanelHeaderButton>
                )}
                <IconButton
                  icon="i-eitherway:chat"
                  className="mr-1"
                  size="sm"
                  onClick={() => {
                    chatStore.setKey('showChat', !showChat);
                  }}
                />
                <IconButton
                  icon="i-ph:x-circle"
                  className="-mr-1"
                  size="xl"
                  onClick={() => {
                    workbenchStore.showWorkbench.set(false);
                  }}
                />
              </div>
              <div className="relative flex-1 overflow-hidden">
                <View
                  initial={{ x: selectedView === 'code' ? 0 : '-100%' }}
                  animate={{ x: selectedView === 'code' ? 0 : '-100%' }}
                >
                  <EditorPanel
                    editorDocument={currentDocument}
                    isStreaming={isStreaming}
                    selectedFile={selectedFile}
                    files={files}
                    unsavedFiles={unsavedFiles}
                    onFileSelect={onFileSelect}
                    onEditorScroll={onEditorScroll}
                    onEditorChange={onEditorChange}
                    onFileSave={onFileSave}
                    onFileReset={onFileReset}
                  />
                </View>
                <View
                  initial={{ x: selectedView === 'preview' ? 0 : '100%' }}
                  animate={{ x: selectedView === 'preview' ? 0 : '100%' }}
                >
                  <Preview />
                </View>
              </div>
            </div>
          </div>
        </div>
      </motion.div>
    )
  );
});

interface ViewProps extends HTMLMotionProps<'div'> {
  children: JSX.Element;
}

const View = memo(({ children, ...props }: ViewProps) => {
  return (
    <motion.div className="absolute inset-0" transition={viewTransition} {...props}>
      {children}
    </motion.div>
  );
});
</file>

<file path="packages/ui-server/src/routes/netlify.ts">
/**
 * Netlify API Routes
 *
 * Endpoints:
 * - POST   /api/netlify/validate-token       - Validate Netlify PAT and save it
 * - POST   /api/netlify/deploy                - Deploy to Netlify
 * - GET    /api/netlify/sites                 - Get user's Netlify sites
 * - GET    /api/netlify/sites/:siteId         - Get specific site details
 * - GET    /api/netlify/logs/token            - Get WebSocket access token for logs
 * - DELETE /api/netlify/token                 - Remove Netlify integration
 */

import type { FastifyInstance } from 'fastify';
import type { DatabaseClient } from '@eitherway/database';
import {
  NetlifyService,
  PostgresFileStore,
  UserIntegrationsRepository,
  NetlifySitesRepository,
  DeploymentsRepository,
  UsersRepository,
  SessionsRepository,
  AppsRepository
} from '@eitherway/database';

function isValidUUID(str: string): boolean {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(str);
}

async function getOrCreateDemoUser(db: DatabaseClient): Promise<string> {
  const usersRepo = new UsersRepository(db);

  // Try to find existing demo user
  const existingUser = await usersRepo.findByEmail('demo-user@eitherway.local');
  if (existingUser) {
    return existingUser.id;
  }

  const demoUser = await usersRepo.create('demo-user@eitherway.local', 'Demo User');
  return demoUser.id;
}

export async function registerNetlifyRoutes(
  fastify: FastifyInstance,
  db: DatabaseClient,
  workspaceDir: string
) {
  const encryptionKey = process.env.ENCRYPTION_KEY;
  if (!encryptionKey) {
    console.warn('[Netlify] ENCRYPTION_KEY not set - Netlify integration will not work');
    return;
  }

  const fileStore = new PostgresFileStore(db);
  const netlifyService = new NetlifyService(db, fileStore, encryptionKey);
  const userIntegrations = new UserIntegrationsRepository(db, encryptionKey);
  const netlifySites = new NetlifySitesRepository(db);
  const deployments = new DeploymentsRepository(db);

  // TOKEN MANAGEMENT

  /**
   * POST /api/netlify/validate-token
   * Validate and save Netlify PAT
   */
  fastify.post<{
    Body: {
      userId: string;
      token: string;
    };
  }>('/api/netlify/validate-token', async (request, reply) => {
    let { userId, token } = request.body;

    if (!userId || !token) {
      return reply.code(400).send({
        success: false,
        error: 'Missing required fields: userId, token'
      });
    }

    try {
      if (userId === 'demo-user' || !isValidUUID(userId)) {
        userId = await getOrCreateDemoUser(db);
      }

      const result = await netlifyService.saveUserToken(userId, token);

      if (!result.success) {
        return reply.code(401).send({
          success: false,
          error: result.error || 'Failed to validate token'
        });
      }

      const integration = await userIntegrations.get(userId, 'netlify');

      return reply.code(200).send({
        success: true,
        message: 'Token validated and saved successfully',
        integration: integration ? {
          id: integration.id,
          service: integration.service,
          token_last_4: integration.token_last_4,
          service_email: integration.service_email,
          is_verified: integration.is_verified,
          verified_at: integration.verified_at
        } : null
      });

    } catch (error: any) {
      console.error('[Netlify] Error validating token:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to validate token',
        message: error.message
      });
    }
  });

  fastify.get<{
    Querystring: { userId: string };
  }>('/api/netlify/integration', async (request, reply) => {
    const { userId } = request.query;

    if (!userId) {
      return reply.code(400).send({
        success: false,
        error: 'Missing required field: userId'
      });
    }

    try {
      const integration = await userIntegrations.get(userId, 'netlify');

      if (!integration) {
        return reply.code(404).send({
          success: false,
          error: 'No Netlify integration found'
        });
      }

      return reply.code(200).send({
        success: true,
        integration: {
          id: integration.id,
          service: integration.service,
          token_last_4: integration.token_last_4,
          service_email: integration.service_email,
          service_username: integration.service_username,
          is_verified: integration.is_verified,
          verified_at: integration.verified_at,
          last_used_at: integration.last_used_at
        }
      });

    } catch (error: any) {
      console.error('[Netlify] Error fetching integration:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to fetch integration',
        message: error.message
      });
    }
  });

  fastify.delete<{
    Body: { userId: string };
  }>('/api/netlify/token', async (request, reply) => {
    const { userId } = request.body;

    if (!userId) {
      return reply.code(400).send({
        success: false,
        error: 'Missing required field: userId'
      });
    }

    try {
      const deleted = await userIntegrations.delete(userId, 'netlify');

      if (!deleted) {
        return reply.code(404).send({
          success: false,
          error: 'No Netlify integration found'
        });
      }

      return reply.code(200).send({
        success: true,
        message: 'Netlify integration removed successfully'
      });

    } catch (error: any) {
      console.error('[Netlify] Error removing token:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to remove token',
        message: error.message
      });
    }
  });

  // DEPLOYMENT

  /**
   * POST /api/netlify/deploy
   * Deploy app to Netlify
   */
  fastify.post<{
    Body: {
      appId: string;
      userId: string;
      sessionId?: string;
      siteName?: string;
      deployTitle?: string;
      includeNodeModules?: boolean;
    };
  }>('/api/netlify/deploy', async (request, reply) => {
    let {
      appId,
      userId,
      sessionId,
      siteName,
      deployTitle,
      includeNodeModules
    } = request.body;

    if (!appId || !userId) {
      return reply.code(400).send({
        success: false,
        error: 'Missing required fields: appId, userId'
      });
    }

    try {
      if (userId === 'demo-user' || !isValidUUID(userId)) {
        userId = await getOrCreateDemoUser(db);
      }

      // CRITICAL FIX: Ensure app exists in database
      // If sessionId provided, look up the session and get/create app_id
      // This mirrors the logic from server.ts WebSocket agent (lines 528-554)
      const sessionsRepo = new SessionsRepository(db);
      const appsRepo = new AppsRepository(db);

      let validatedAppId = appId;

      if (sessionId && sessionId === appId) {
        console.log(`[Netlify] appId matches sessionId, looking up session: ${sessionId}`);
        const session = await sessionsRepo.findById(sessionId);

        if (!session) {
          return reply.code(404).send({
            success: false,
            error: 'Session not found'
          });
        }

        if (session.app_id) {
          validatedAppId = session.app_id;
          console.log(`[Netlify] Using existing app_id from session: ${validatedAppId}`);
        } else {
          console.log(`[Netlify] Session has no app_id, creating one...`);
          const appTitle = session.title || 'Generated App';
          const app = await appsRepo.create(session.user_id, appTitle, 'private');
          validatedAppId = app.id;

          await sessionsRepo.update(sessionId, { app_id: validatedAppId } as any);
          console.log(`[Netlify] Created app: ${validatedAppId} for session: ${sessionId}`);
        }
      } else {
        // Verify that the appId exists in the apps table
        console.log(`[Netlify] Verifying app exists: ${appId}`);
        try {
          const app = await appsRepo.findById(appId);
          if (!app) {
            // If app doesn't exist and we have a sessionId, try to look up via session
            if (sessionId) {
              console.log(`[Netlify] App not found, trying to get from session: ${sessionId}`);
              const session = await sessionsRepo.findById(sessionId);

              if (session?.app_id) {
                validatedAppId = session.app_id;
                console.log(`[Netlify] Using app_id from session: ${validatedAppId}`);
              } else if (session) {
                const appTitle = session.title || 'Generated App';
                const newApp = await appsRepo.create(session.user_id, appTitle, 'private');
                validatedAppId = newApp.id;
                await sessionsRepo.update(sessionId, { app_id: validatedAppId } as any);
                console.log(`[Netlify] Created app: ${validatedAppId} for session: ${sessionId}`);
              } else {
                return reply.code(404).send({
                  success: false,
                  error: 'Session not found'
                });
              }
            } else {
              return reply.code(404).send({
                success: false,
                error: 'App not found and no session provided to create one'
              });
            }
          }
        } catch (error: any) {
          console.error('[Netlify] Error verifying app:', error);
          return reply.code(400).send({
            success: false,
            error: `Invalid app ID: ${error.message}`
          });
        }
      }

      console.log(`[Netlify] Starting deployment for app ${validatedAppId}`);

      const result = await netlifyService.deploy({
        appId: validatedAppId,
        userId,
        sessionId,
        siteName,
        deployTitle,
        includeNodeModules
      });

      if (!result.success) {
        return reply.code(400).send({
          success: false,
          error: result.error || 'Deployment failed'
        });
      }

      return reply.code(200).send({
        success: true,
        message: 'Deployment initiated successfully',
        data: {
          siteId: result.siteId,
          deployId: result.deployId,
          siteUrl: result.siteUrl,
          adminUrl: result.adminUrl,
          deployUrl: result.deployUrl
        }
      });

    } catch (error: any) {
      console.error('[Netlify] Deployment error:', error);
      return reply.code(500).send({
        success: false,
        error: 'Deployment failed',
        message: error.message
      });
    }
  });

  // SITES MANAGEMENT

  fastify.get<{
    Querystring: { userId: string; limit?: string };
  }>('/api/netlify/sites', async (request, reply) => {
    const { userId, limit } = request.query;

    if (!userId) {
      return reply.code(400).send({
        success: false,
        error: 'Missing required field: userId'
      });
    }

    try {
      const sites = await netlifySites.getAllForUser(
        userId,
        limit ? parseInt(limit, 10) : 50
      );

      return reply.code(200).send({
        success: true,
        sites
      });

    } catch (error: any) {
      console.error('[Netlify] Error fetching sites:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to fetch sites',
        message: error.message
      });
    }
  });

  fastify.get<{
    Params: { siteId: string };
  }>('/api/netlify/sites/:siteId', async (request, reply) => {
    const { siteId } = request.params;

    try {
      const site = await netlifySites.getWithStats(siteId);

      if (!site) {
        return reply.code(404).send({
          success: false,
          error: 'Site not found'
        });
      }

      return reply.code(200).send({
        success: true,
        site
      });

    } catch (error: any) {
      console.error('[Netlify] Error fetching site:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to fetch site',
        message: error.message
      });
    }
  });

  fastify.get<{
    Params: { appId: string };
  }>('/api/netlify/sites/app/:appId', async (request, reply) => {
    const { appId } = request.params;

    try {
      const site = await netlifySites.getByAppId(appId);

      if (!site) {
        return reply.code(404).send({
          success: false,
          error: 'No site found for this app'
        });
      }

      return reply.code(200).send({
        success: true,
        site
      });

    } catch (error: any) {
      console.error('[Netlify] Error fetching site by app:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to fetch site',
        message: error.message
      });
    }
  });

  // DEPLOYMENT HISTORY

  fastify.get<{
    Params: { appId: string };
    Querystring: { limit?: string };
  }>('/api/netlify/deployments/:appId', async (request, reply) => {
    const { appId } = request.params;
    const limit = parseInt(request.query.limit || '20', 10);

    try {
      const allDeployments = await deployments.getByAppId(appId, limit);
      const netlifyDeployments = allDeployments.filter(
        d => d.deployment_type === 'netlify'
      );

      return reply.code(200).send({
        success: true,
        deployments: netlifyDeployments
      });

    } catch (error: any) {
      console.error('[Netlify] Error fetching deployments:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to fetch deployments',
        message: error.message
      });
    }
  });

  fastify.get<{
    Params: { appId: string; deploymentId: string };
  }>('/api/netlify/deployments/:appId/:deploymentId', async (request, reply) => {
    const { deploymentId } = request.params;

    try {
      const deployment = await deployments.getById(deploymentId);

      if (!deployment) {
        return reply.code(404).send({
          success: false,
          error: 'Deployment not found'
        });
      }

      return reply.code(200).send({
        success: true,
        deployment
      });

    } catch (error: any) {
      console.error('[Netlify] Error fetching deployment:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to fetch deployment',
        message: error.message
      });
    }
  });

  // LOGS ACCESS

  fastify.get<{
    Querystring: {
      siteId: string;
      deployId: string;
    };
  }>('/api/netlify/logs/token', async (request, reply) => {
    const { siteId, deployId } = request.query;

    if (!siteId || !deployId) {
      return reply.code(400).send({
        success: false,
        error: 'Missing required fields: siteId, deployId'
      });
    }

    try {
      const serverToken = process.env.NETLIFY_SERVER_TOKEN;
      const accessToken = await netlifyService.getLogsAccessToken(
        siteId,
        deployId,
        serverToken
      );

      if (!accessToken) {
        return reply.code(503).send({
          success: false,
          error: 'Logs access not configured. Please set NETLIFY_SERVER_TOKEN.'
        });
      }

      return reply.code(200).send({
        success: true,
        accessToken: accessToken.accessToken,
        siteId: accessToken.siteId,
        deployId: accessToken.deployId,
        websocketUrl: 'wss://socketeer.services.netlify.com/build/logs'
      });

    } catch (error: any) {
      console.error('[Netlify] Error getting logs token:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to get logs access token',
        message: error.message
      });
    }
  });

  console.log('[Netlify] Routes registered successfully');
}
</file>

<file path="packages/database/src/repositories/brand-kits.ts">
/**
 * Brand Kit Repositories
 *
 * Data access layer for:
 * - Brand kits
 * - Brand assets
 * - Brand colors
 */

import { DatabaseClient } from '../client.js';

// TYPES

export interface BrandKit {
  id: string;
  user_id: string;
  name: string;
  description: string | null;
  status: 'active' | 'archived' | 'deleted';
  version: number;
  created_at: Date;
  updated_at: Date;
}

export interface BrandAsset {
  id: string;
  brand_kit_id: string;
  user_id: string;
  asset_type: 'logo' | 'image' | 'icon' | 'pattern';
  file_name: string;
  storage_key: string;
  storage_provider: 's3' | 'gcs' | 'local';
  mime_type: string;
  file_size_bytes: number;
  width_px: number | null;
  height_px: number | null;
  processing_status: 'pending' | 'processing' | 'completed' | 'failed';
  processing_error: string | null;
  metadata: Record<string, any>;
  uploaded_at: Date;
  processed_at: Date | null;
  created_at: Date;
}

export interface BrandColor {
  id: string;
  brand_kit_id: string;
  asset_id: string | null;
  color_hex: string;
  color_rgb: { r: number; g: number; b: number };
  color_hsl: { h: number; s: number; l: number } | null;
  color_name: string | null;
  color_role: 'primary' | 'secondary' | 'accent' | 'neutral' | 'extracted' | null;
  prominence_score: number | null;
  pixel_percentage: number | null;
  display_order: number;
  created_at: Date;
  updated_at: Date;
}

// BRAND KITS REPOSITORY

export class BrandKitsRepository {
  constructor(private db: DatabaseClient) {}

  async create(
    userId: string,
    name: string,
    description?: string
  ): Promise<BrandKit> {
    const result = await this.db.query(
      `INSERT INTO core.brand_kits (user_id, name, description)
       VALUES ($1, $2, $3)
       RETURNING *`,
      [userId, name, description || null]
    );

    return result.rows[0];
  }

  /**
   * Find brand kit by ID
   */
  async findById(id: string): Promise<BrandKit | null> {
    const result = await this.db.query(
      `SELECT * FROM core.brand_kits WHERE id = $1 AND status != 'deleted'`,
      [id]
    );

    return result.rows[0] || null;
  }

  /**
   * Find all brand kits for a user
   */
  async findByUserId(userId: string, status: 'active' | 'archived' | 'all' = 'active'): Promise<BrandKit[]> {
    const query = status === 'all'
      ? `SELECT * FROM core.brand_kits WHERE user_id = $1 AND status != 'deleted' ORDER BY created_at DESC`
      : `SELECT * FROM core.brand_kits WHERE user_id = $1 AND status = $2 ORDER BY created_at DESC`;

    const params = status === 'all' ? [userId] : [userId, status];

    const result = await this.db.query(query, params);

    return result.rows;
  }

  async update(
    id: string,
    updates: Partial<Pick<BrandKit, 'name' | 'description' | 'status'>>
  ): Promise<BrandKit | null> {
    const fields: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    if (updates.name !== undefined) {
      fields.push(`name = $${paramIndex++}`);
      values.push(updates.name);
    }

    if (updates.description !== undefined) {
      fields.push(`description = $${paramIndex++}`);
      values.push(updates.description);
    }

    if (updates.status !== undefined) {
      fields.push(`status = $${paramIndex++}`);
      values.push(updates.status);
    }

    if (fields.length === 0) {
      return this.findById(id);
    }

    values.push(id);

    const result = await this.db.query(
      `UPDATE core.brand_kits
       SET ${fields.join(', ')}
       WHERE id = $${paramIndex}
       RETURNING *`,
      values
    );

    return result.rows[0] || null;
  }

  async delete(id: string): Promise<boolean> {
    const result = await this.db.query(
      `UPDATE core.brand_kits SET status = 'deleted' WHERE id = $1`,
      [id]
    );

    return result.rowCount !== null && result.rowCount > 0;
  }
}

// BRAND ASSETS REPOSITORY

export class BrandAssetsRepository {
  constructor(private db: DatabaseClient) {}

  async create(params: {
    brandKitId: string;
    userId: string;
    assetType: BrandAsset['asset_type'];
    fileName: string;
    storageKey: string;
    storageProvider: BrandAsset['storage_provider'];
    mimeType: string;
    fileSizeBytes: number;
    widthPx?: number;
    heightPx?: number;
    metadata?: Record<string, any>;
  }): Promise<BrandAsset> {
    const result = await this.db.query(
      `INSERT INTO core.brand_assets
       (brand_kit_id, user_id, asset_type, file_name, storage_key, storage_provider,
        mime_type, file_size_bytes, width_px, height_px, metadata)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
       RETURNING *`,
      [
        params.brandKitId,
        params.userId,
        params.assetType,
        params.fileName,
        params.storageKey,
        params.storageProvider,
        params.mimeType,
        params.fileSizeBytes,
        params.widthPx || null,
        params.heightPx || null,
        JSON.stringify(params.metadata || {})
      ]
    );

    return result.rows[0];
  }

  /**
   * Find asset by ID
   */
  async findById(id: string): Promise<BrandAsset | null> {
    const result = await this.db.query(
      `SELECT * FROM core.brand_assets WHERE id = $1`,
      [id]
    );

    return result.rows[0] || null;
  }

  /**
   * Find all assets for a brand kit
   */
  async findByBrandKitId(brandKitId: string): Promise<BrandAsset[]> {
    const result = await this.db.query(
      `SELECT * FROM core.brand_assets WHERE brand_kit_id = $1 ORDER BY created_at DESC`,
      [brandKitId]
    );

    return result.rows;
  }

  async updateProcessingStatus(
    id: string,
    status: BrandAsset['processing_status'],
    error?: string
  ): Promise<BrandAsset | null> {
    const result = await this.db.query(
      `UPDATE core.brand_assets
       SET processing_status = $1,
           processing_error = $2,
           processed_at = CASE WHEN $1 IN ('completed', 'failed') THEN now() ELSE processed_at END
       WHERE id = $3
       RETURNING *`,
      [status, error || null, id]
    );

    return result.rows[0] || null;
  }

  async updateDimensions(
    id: string,
    width: number,
    height: number
  ): Promise<BrandAsset | null> {
    const result = await this.db.query(
      `UPDATE core.brand_assets
       SET width_px = $1, height_px = $2
       WHERE id = $3
       RETURNING *`,
      [width, height, id]
    );

    return result.rows[0] || null;
  }

  async delete(id: string): Promise<boolean> {
    const result = await this.db.query(
      `DELETE FROM core.brand_assets WHERE id = $1`,
      [id]
    );

    return result.rowCount !== null && result.rowCount > 0;
  }
}

// BRAND COLORS REPOSITORY

export class BrandColorsRepository {
  constructor(private db: DatabaseClient) {}

  async create(params: {
    brandKitId: string;
    assetId?: string;
    colorHex: string;
    colorRgb: { r: number; g: number; b: number };
    colorHsl?: { h: number; s: number; l: number };
    colorName?: string;
    colorRole?: BrandColor['color_role'];
    prominenceScore?: number;
    pixelPercentage?: number;
    displayOrder?: number;
  }): Promise<BrandColor> {
    const result = await this.db.query(
      `INSERT INTO core.brand_colors
       (brand_kit_id, asset_id, color_hex, color_rgb, color_hsl, color_name,
        color_role, prominence_score, pixel_percentage, display_order)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
       RETURNING *`,
      [
        params.brandKitId,
        params.assetId || null,
        params.colorHex,
        JSON.stringify(params.colorRgb),
        params.colorHsl ? JSON.stringify(params.colorHsl) : null,
        params.colorName || null,
        params.colorRole || null,
        params.prominenceScore || null,
        params.pixelPercentage || null,
        params.displayOrder || 0
      ]
    );

    return result.rows[0];
  }

  /**
   * Bulk create colors
   */
  async bulkCreate(colors: Array<Parameters<typeof this.create>[0]>): Promise<BrandColor[]> {
    if (colors.length === 0) return [];

    const values: any[] = [];
    const placeholders: string[] = [];
    let paramIndex = 1;

    colors.forEach((color) => {
      placeholders.push(`($${paramIndex++}, $${paramIndex++}, $${paramIndex++}, $${paramIndex++}, $${paramIndex++}, $${paramIndex++}, $${paramIndex++}, $${paramIndex++}, $${paramIndex++}, $${paramIndex++})`);
      values.push(
        color.brandKitId,
        color.assetId || null,
        color.colorHex,
        JSON.stringify(color.colorRgb),
        color.colorHsl ? JSON.stringify(color.colorHsl) : null,
        color.colorName || null,
        color.colorRole || null,
        color.prominenceScore || null,
        color.pixelPercentage || null,
        color.displayOrder || 0
      );
    });

    const result = await this.db.query(
      `INSERT INTO core.brand_colors
       (brand_kit_id, asset_id, color_hex, color_rgb, color_hsl, color_name,
        color_role, prominence_score, pixel_percentage, display_order)
       VALUES ${placeholders.join(', ')}
       RETURNING *`,
      values
    );

    return result.rows;
  }

  /**
   * Find colors by brand kit ID
   */
  async findByBrandKitId(brandKitId: string): Promise<BrandColor[]> {
    const result = await this.db.query(
      `SELECT * FROM core.brand_colors
       WHERE brand_kit_id = $1
       ORDER BY display_order ASC, prominence_score DESC NULLS LAST`,
      [brandKitId]
    );

    return result.rows;
  }

  /**
   * Find colors by asset ID
   */
  async findByAssetId(assetId: string): Promise<BrandColor[]> {
    const result = await this.db.query(
      `SELECT * FROM core.brand_colors
       WHERE asset_id = $1
       ORDER BY prominence_score DESC NULLS LAST`,
      [assetId]
    );

    return result.rows;
  }

  async update(
    id: string,
    updates: Partial<Pick<BrandColor, 'color_name' | 'color_role' | 'display_order'>>
  ): Promise<BrandColor | null> {
    const fields: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    if (updates.color_name !== undefined) {
      fields.push(`color_name = $${paramIndex++}`);
      values.push(updates.color_name);
    }

    if (updates.color_role !== undefined) {
      fields.push(`color_role = $${paramIndex++}`);
      values.push(updates.color_role);
    }

    if (updates.display_order !== undefined) {
      fields.push(`display_order = $${paramIndex++}`);
      values.push(updates.display_order);
    }

    if (fields.length === 0) return null;

    values.push(id);

    const result = await this.db.query(
      `UPDATE core.brand_colors
       SET ${fields.join(', ')}
       WHERE id = $${paramIndex}
       RETURNING *`,
      values
    );

    return result.rows[0] || null;
  }

  async delete(id: string): Promise<boolean> {
    const result = await this.db.query(
      `DELETE FROM core.brand_colors WHERE id = $1`,
      [id]
    );

    return result.rowCount !== null && result.rowCount > 0;
  }

  async deleteByAssetId(assetId: string): Promise<number> {
    const result = await this.db.query(
      `DELETE FROM core.brand_colors WHERE asset_id = $1`,
      [assetId]
    );

    return result.rowCount || 0;
  }

  async deleteByBrandKitId(brandKitId: string): Promise<number> {
    const result = await this.db.query(
      `DELETE FROM core.brand_colors WHERE brand_kit_id = $1`,
      [brandKitId]
    );

    return result.rowCount || 0;
  }
}
</file>

<file path="packages/database/src/services/export-service.ts">
/**
 * Export Service
 *
 * Generates ZIP archives of application files for download.
 *
 * Features:
 * - Create ZIP archives from file store
 * - Support exclude patterns
 * - Track export history
 * - Calculate file sizes
 * - Stream ZIP to client
 */

import archiver from 'archiver';
import type { DatabaseClient } from '../client.js';
import type { PostgresFileStore } from './file-store.js';

// TYPES

export interface ExportConfig {
  appId: string;
  userId: string;
  sessionId?: string;
  exportType?: 'zip' | 'tar';
  includeNodeModules?: boolean;
  includeGitHistory?: boolean;
  excludePatterns?: string[];
}

export interface ExportResult {
  id: string;
  status: 'success' | 'failed';
  fileCount?: number;
  totalSize?: number;
  compressedSize?: number;
  error?: string;
  duration: number;
}

export interface ExportStats {
  fileCount: number;
  totalSizeBytes: number;
}

// EXPORT SERVICE

export class ExportService {
  private db: DatabaseClient;
  private fileStore: PostgresFileStore;

  constructor(db: DatabaseClient, fileStore: PostgresFileStore) {
    this.db = db;
    this.fileStore = fileStore;
  }

  async createZipExport(config: ExportConfig): Promise<{ buffer: Buffer; exportId: string; stats: ExportStats }> {
    const startTime = Date.now();

    // Default exclude patterns
    const defaultExcludes = [
      '.git',
      '.DS_Store',
      'Thumbs.db',
      '.env',
      '.env.local',
      '.env.*.local',
      'node_modules'
    ];

    const excludePatterns = [
      ...defaultExcludes,
      ...(config.excludePatterns || [])
    ];

    if (config.includeNodeModules) {
      const index = excludePatterns.indexOf('node_modules');
      if (index > -1) excludePatterns.splice(index, 1);
    }

    if (config.includeGitHistory) {
      const index = excludePatterns.indexOf('.git');
      if (index > -1) excludePatterns.splice(index, 1);
    }

    const exportId = await this.createExport({
      app_id: config.appId,
      user_id: config.userId,
      session_id: config.sessionId,
      export_type: config.exportType || 'zip',
      include_node_modules: config.includeNodeModules || false,
      include_git_history: config.includeGitHistory || false,
      exclude_patterns: excludePatterns
    });

    try {
      await this.updateExportStatus(exportId, 'processing');

      const fileTree = await this.fileStore.list(config.appId);

      // Flatten tree structure and extract only actual files (not directories)
      const flattenFiles = (nodes: any[]): any[] => {
        const result: any[] = [];
        for (const node of nodes) {
          if (node.type === 'file' && !node.isDirectory) {
            result.push(node);
          }
          if (node.children && node.children.length > 0) {
            result.push(...flattenFiles(node.children));
          }
        }
        return result;
      };

      const files = flattenFiles(fileTree);

      if (!files || files.length === 0) {
        throw new Error('No files found in the application workspace. Please create some files before exporting.');
      }

      // Filter files based on exclude patterns
      const filteredFiles = files.filter(file => {
        return !this.shouldExclude(file.path, excludePatterns);
      });

      if (filteredFiles.length === 0) {
        throw new Error('All files were excluded by filters. Try including more files or adjusting exclude patterns.');
      }

      const stats: ExportStats = {
        fileCount: filteredFiles.length,
        totalSizeBytes: 0
      };

      const archive = archiver('zip', {
        zlib: { level: 9 } // Maximum compression
      });

      // Collect all chunks into a buffer to prevent data loss
      const chunks: Buffer[] = [];
      let compressedSize = 0;

      archive.on('data', (chunk: Buffer) => {
        chunks.push(chunk);
        compressedSize += chunk.length;
      });

      for (const file of filteredFiles) {
        try {
          const fileContent = await this.fileStore.read(config.appId, file.path);
          if (fileContent && fileContent.content) {
            let content: Buffer;

            if (typeof fileContent.content === 'string') {
              content = Buffer.from(fileContent.content, 'utf-8');
            } else if (fileContent.content instanceof Uint8Array) {
              content = Buffer.from(fileContent.content);
            } else {
              // Fallback: assume it's already a Buffer or can be converted
              content = Buffer.from(fileContent.content as any);
            }

            archive.append(content, { name: file.path });
            stats.totalSizeBytes += content.length;
          }
        } catch (error) {
          console.error(`[Export] Failed to add file ${file.path}:`, error);
          // Continue with other files
        }
      }

      // Finalize archive and wait for completion
      const finalizePromise = new Promise<void>((resolve, reject) => {
        archive.on('end', () => resolve());
        archive.on('error', (err: Error) => reject(err));
      });

      // Start finalization process
      await archive.finalize();

      // Wait for archive to finish writing all data
      await finalizePromise;

      // Combine all chunks into a single buffer
      const zipBuffer = Buffer.concat(chunks);

      const duration = Date.now() - startTime;
      await this.updateExport(exportId, {
        status: 'success',
        file_count: stats.fileCount,
        total_size_bytes: stats.totalSizeBytes,
        compressed_size_bytes: compressedSize,
        started_at: new Date(startTime),
        completed_at: new Date(),
        duration_ms: duration
      });

      return {
        buffer: zipBuffer,
        exportId,
        stats
      };

    } catch (error: any) {
      await this.updateExport(exportId, {
        status: 'failed',
        error_message: error.message,
        started_at: new Date(startTime),
        completed_at: new Date()
      });

      throw error;
    }
  }

  private async createExport(data: any): Promise<string> {
    const result = await this.db.query<{ id: string }>(
      `INSERT INTO core.exports (
        app_id, user_id, session_id, export_type,
        include_node_modules, include_git_history, exclude_patterns
      )
      VALUES ($1, $2, $3, $4, $5, $6, $7)
      RETURNING id`,
      [
        data.app_id,
        data.user_id,
        data.session_id || null,
        data.export_type,
        data.include_node_modules,
        data.include_git_history,
        data.exclude_patterns
      ]
    );

    return result.rows[0].id;
  }

  private async updateExportStatus(exportId: string, status: 'pending' | 'processing' | 'success' | 'failed'): Promise<void> {
    await this.db.query(
      'UPDATE core.exports SET status = $1 WHERE id = $2',
      [status, exportId]
    );
  }

  private async updateExport(exportId: string, updates: any): Promise<void> {
    const fields: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    Object.entries(updates).forEach(([key, value]) => {
      fields.push(`${key} = $${paramIndex++}`);
      values.push(value);
    });

    values.push(exportId);
    await this.db.query(
      `UPDATE core.exports SET ${fields.join(', ')} WHERE id = $${paramIndex}`,
      values
    );
  }

  /**
   * Track export download
   */
  async trackDownload(exportId: string): Promise<void> {
    await this.db.query(
      `UPDATE core.exports
       SET download_count = download_count + 1,
           last_downloaded_at = now()
       WHERE id = $1`,
      [exportId]
    );
  }

  private shouldExclude(path: string, excludePatterns: string[]): boolean {
    for (const pattern of excludePatterns) {
      // Simple pattern matching (support * wildcard)
      const regexPattern = pattern
        .replace(/\./g, '\\.')
        .replace(/\*/g, '.*');
      const regex = new RegExp(`^${regexPattern}$|/${regexPattern}/|/${regexPattern}$`);

      if (regex.test(path)) {
        return true;
      }

      // Also check if path starts with pattern (for directories)
      if (path.startsWith(pattern + '/') || path === pattern) {
        return true;
      }
    }

    return false;
  }

  async getExport(exportId: string): Promise<any> {
    const result = await this.db.query(
      'SELECT * FROM core.exports WHERE id = $1',
      [exportId]
    );

    return result.rows[0] || null;
  }

  async getExportsByApp(appId: string, limit: number = 10): Promise<any[]> {
    const result = await this.db.query(
      `SELECT * FROM core.exports
       WHERE app_id = $1
       ORDER BY created_at DESC
       LIMIT $2`,
      [appId, limit]
    );

    return result.rows;
  }

  async getExportStatistics(appId: string): Promise<any> {
    const result = await this.db.query(
      'SELECT * FROM core.export_statistics WHERE app_id = $1',
      [appId]
    );

    return result.rows[0] || null;
  }

  async cleanupOldExports(appId: string, keepCount: number = 50): Promise<number> {
    const result = await this.db.query(
      `DELETE FROM core.exports
       WHERE id IN (
         SELECT id FROM core.exports
         WHERE app_id = $1
         ORDER BY created_at DESC
         OFFSET $2
       )`,
      [appId, keepCount]
    );

    return result.rowCount || 0;
  }
}
</file>

<file path="packages/database/src/services/netlify-service.ts">
/**
 * Netlify Service
 *
 * Service layer for interacting with Netlify Build API.
 * Handles site creation, deployments, and log streaming.
 *
 * Reference: https://docs.netlify.com/api/get-started/
 */

import type { DatabaseClient } from '../client.js';
import type { PostgresFileStore } from './file-store.js';
import { UserIntegrationsRepository, NetlifySitesRepository } from '../repositories/netlify.js';
import { DeploymentsRepository } from '../repositories/deployments.js';
import archiver from 'archiver';
import FormData from 'form-data';
import { mkdir, writeFile, rm, readdir, readFile } from 'fs/promises';
import { join } from 'path';
import { tmpdir } from 'os';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

// TYPES

export interface NetlifyDeployConfig {
  appId: string;
  userId: string;
  sessionId?: string;
  siteName?: string;
  deployTitle?: string;
  includeNodeModules?: boolean;
}

export interface NetlifyDeployResult {
  success: boolean;
  siteId?: string;
  deployId?: string;
  siteUrl?: string;
  adminUrl?: string;
  deployUrl?: string;
  error?: string;
}

export interface NetlifyTokenValidationResult {
  valid: boolean;
  userId?: string;
  email?: string;
  fullName?: string;
  error?: string;
}

export interface NetlifyLogsAccessToken {
  accessToken: string;
  siteId: string;
  deployId: string;
}

// NETLIFY SERVICE

export class NetlifyService {
  private db: DatabaseClient;
  private fileStore: PostgresFileStore;
  private userIntegrations: UserIntegrationsRepository;
  private netlifySites: NetlifySitesRepository;
  private deployments: DeploymentsRepository;

  constructor(
    db: DatabaseClient,
    fileStore: PostgresFileStore,
    encryptionKey: string
  ) {
    this.db = db;
    this.fileStore = fileStore;
    this.userIntegrations = new UserIntegrationsRepository(db, encryptionKey);
    this.netlifySites = new NetlifySitesRepository(db);
    this.deployments = new DeploymentsRepository(db);
  }

  async validateToken(token: string): Promise<NetlifyTokenValidationResult> {
    try {
      const response = await fetch('https://api.netlify.com/api/v1/user', {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        return {
          valid: false,
          error: `Invalid token: ${response.status} ${response.statusText}`
        };
      }

      const data = await response.json() as any;

      return {
        valid: true,
        userId: data.id,
        email: data.email,
        fullName: data.full_name || data.name
      };
    } catch (error: any) {
      return {
        valid: false,
        error: error.message
      };
    }
  }

  async saveUserToken(
    userId: string,
    token: string
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const validation = await this.validateToken(token);
      if (!validation.valid) {
        return { success: false, error: validation.error };
      }

      await this.userIntegrations.upsert({
        user_id: userId,
        service: 'netlify',
        token,
        service_user_id: validation.userId,
        service_email: validation.email,
        service_username: validation.fullName
      });

      // Mark as verified
      await this.userIntegrations.markVerified(userId, 'netlify');

      return { success: true };
    } catch (error: any) {
      return { success: false, error: error.message };
    }
  }

  async getUserToken(userId: string): Promise<string | null> {
    return await this.userIntegrations.getDecryptedToken(userId, 'netlify');
  }

  /**
   * Ensure Netlify site exists (create if needed)
   */
  async ensureSite(
    userId: string,
    appId: string,
    siteName?: string,
    sessionId?: string
  ): Promise<{ siteId: string; url: string; adminUrl: string; netlifyId: string }> {
    const existingSite = await this.netlifySites.getByAppId(appId);
    if (existingSite) {
      return {
        siteId: existingSite.id,
        url: existingSite.url,
        adminUrl: existingSite.admin_url || '',
        netlifyId: existingSite.netlify_site_id
      };
    }

    const token = await this.getUserToken(userId);
    if (!token) {
      throw new Error('No Netlify token found for user');
    }

    const requestBody: any = {
      created_via: 'eitherway'
    };

    if (sessionId) {
      requestBody.session_id = sessionId;
    }

    if (siteName) {
      requestBody.name = siteName;
    }

    const response = await fetch('https://api.netlify.com/api/v1/sites', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to create Netlify site: ${response.status} ${error}`);
    }

    const siteData = await response.json() as any;

    const site = await this.netlifySites.create({
      user_id: userId,
      app_id: appId,
      session_id: sessionId,
      netlify_site_id: siteData.id,
      site_name: siteData.name,
      url: siteData.url || `https://${siteData.name}.netlify.app`,
      admin_url: siteData.admin_url,
      ssl_url: siteData.ssl_url
    });

    return {
      siteId: site.id,
      url: site.url,
      adminUrl: site.admin_url || '',
      netlifyId: site.netlify_site_id
    };
  }

  /**
   * Deploy to Netlify using Build API (ZIP upload)
   */
  async deploy(config: NetlifyDeployConfig): Promise<NetlifyDeployResult> {
    try {
      const token = await this.getUserToken(config.userId);
      if (!token) {
        return {
          success: false,
          error: 'No Netlify token configured. Please add your token in settings.'
        };
      }

      // Ensure site exists
      console.log('[NetlifyService] Ensuring Netlify site exists for app:', config.appId);
      const site = await this.ensureSite(
        config.userId,
        config.appId,
        config.siteName,
        config.sessionId
      );
      console.log('[NetlifyService] Site ready:', {
        siteId: site.siteId,
        netlifyId: site.netlifyId,
        url: site.url
      });

      const deploymentId = await this.createDeploymentRecord(config, site.siteId);
      console.log('[NetlifyService] Created deployment record:', deploymentId);

      await this.deployments.updateStatus(deploymentId, 'building');

      console.log('[NetlifyService] Creating ZIP buffer for app:', config.appId);
      const zipBuffer = await this.createZipBuffer(config);
      console.log('[NetlifyService] ZIP buffer created:', {
        size: zipBuffer.length,
        sizeKB: (zipBuffer.length / 1024).toFixed(2)
      });

      if (zipBuffer.length < 100) {
        const errorMsg = 'ZIP file is empty or too small. No files found in the application workspace. Please ensure files have been created first.';
        console.error('[NetlifyService]', errorMsg);
        await this.updateDeploymentError(deploymentId, errorMsg);
        return {
          success: false,
          error: errorMsg
        };
      }

      // Upload to Netlify Build API
      const deployTitle = config.deployTitle || `Deploy from EitherWay - ${new Date().toISOString()}`;

      const formData = new FormData();
      formData.append('title', deployTitle);
      formData.append('zip', zipBuffer, {
        filename: 'site.zip',
        contentType: 'application/zip'
      });

      console.log('[NetlifyService] Uploading to Netlify Deploy API:', {
        url: `https://api.netlify.com/api/v1/sites/${site.netlifyId}/deploys`,
        title: deployTitle,
        siteId: site.netlifyId,
        zipSize: zipBuffer.length
      });

      // Netlify Deploy API expects the ZIP as the request body, not as multipart form-data
      // Deploy title goes in a header
      const deployResponse = await fetch(
        `https://api.netlify.com/api/v1/sites/${site.netlifyId}/deploys`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/zip',
            'Content-Length': zipBuffer.length.toString()
          },
          body: zipBuffer
        }
      );

      console.log('[NetlifyService] Netlify API response:', {
        status: deployResponse.status,
        statusText: deployResponse.statusText,
        ok: deployResponse.ok
      });

      if (!deployResponse.ok) {
        const errorText = await deployResponse.text();
        console.error('[NetlifyService] Netlify API error:', {
          status: deployResponse.status,
          statusText: deployResponse.statusText,
          errorText,
          headers: Object.fromEntries(deployResponse.headers.entries())
        });
        await this.updateDeploymentError(deploymentId, `Deploy failed: ${errorText}`);
        return {
          success: false,
          error: `Netlify deployment failed: ${deployResponse.status} ${deployResponse.statusText} - ${errorText}`
        };
      }

      const deployData = await deployResponse.json() as any;

      await this.updateDeploymentSuccess(deploymentId, site, deployData);

      await this.netlifySites.updateLastDeploy(site.siteId, deployData.deploy_id || deployData.id);

      return {
        success: true,
        siteId: site.siteId,
        deployId: deployData.deploy_id || deployData.id,
        siteUrl: site.url,
        adminUrl: site.adminUrl,
        deployUrl: deployData.deploy_url || site.url
      };

    } catch (error: any) {
      console.error('[NetlifyService] Deploy error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  async getLogsAccessToken(
    siteId: string,
    deployId: string,
    serverToken?: string
  ): Promise<NetlifyLogsAccessToken | null> {
    if (!serverToken) {
      console.warn('[NetlifyService] Server token not configured for logs access');
      return null;
    }

    try {
      const response = await fetch(
        `https://app.netlify.com/access-control/generate-access-control-token?deploy_id=${deployId}&site_id=${siteId}`,
        {
          headers: {
            'Authorization': `Bearer ${serverToken}`
          }
        }
      );

      if (!response.ok) {
        console.error('[NetlifyService] Failed to get logs access token:', response.status);
        return null;
      }

      const data = await response.json() as any;

      return {
        accessToken: data.access_token,
        siteId,
        deployId
      };
    } catch (error) {
      console.error('[NetlifyService] Error getting logs access token:', error);
      return null;
    }
  }

  /**
   * Check if project is a Vite/React project
   */
  private async isViteProject(appId: string): Promise<boolean> {
    try {
      const packageJsonContent = await this.fileStore.read(appId, 'package.json');
      if (!packageJsonContent || !packageJsonContent.content) {
        return false;
      }

      const packageJson = JSON.parse(packageJsonContent.content as string);

      // Check if vite is in dependencies or devDependencies
      const deps = { ...packageJson.dependencies, ...packageJson.devDependencies };
      return Boolean(deps?.vite || deps?.['@vitejs/plugin-react']);
    } catch (error) {
      console.log('[NetlifyService] Could not detect Vite project:', error);
      return false;
    }
  }

  /**
   * Export all files to a temporary directory
   */
  private async exportFilesToTemp(appId: string, excludePatterns: string[]): Promise<string> {
    const tempDir = join(tmpdir(), `eitherway-deploy-${appId}-${Date.now()}`);
    await mkdir(tempDir, { recursive: true });

    console.log('[NetlifyService] Exporting files to:', tempDir);

    const fileTree = await this.fileStore.list(appId);
    const flattenFiles = (nodes: any[]): any[] => {
      const result: any[] = [];
      for (const node of nodes) {
        if (node.type === 'file' && !node.isDirectory) {
          result.push(node);
        }
        if (node.children && node.children.length > 0) {
          result.push(...flattenFiles(node.children));
        }
      }
      return result;
    };

    const files = flattenFiles(fileTree);

    for (const file of files) {
      if (this.shouldExclude(file.path, excludePatterns)) {
        continue;
      }

      try {
        const fileContent = await this.fileStore.read(appId, file.path);
        if (fileContent && fileContent.content) {
          const fullPath = join(tempDir, file.path);
          const dirPath = join(fullPath, '..');

          await mkdir(dirPath, { recursive: true });

          // Handle both text and binary files correctly
          if (typeof fileContent.content === 'string') {
            // Text file - write as UTF-8 string
            await writeFile(fullPath, fileContent.content, 'utf-8');
          } else {
            // Binary file - write as Buffer without encoding
            const buffer = fileContent.content instanceof Uint8Array
              ? Buffer.from(fileContent.content)
              : Buffer.from(fileContent.content as any);
            await writeFile(fullPath, buffer);
          }
        }
      } catch (error) {
        console.error(`[NetlifyService] Failed to export file ${file.path}:`, error);
      }
    }

    console.log('[NetlifyService] Files exported to:', tempDir);
    return tempDir;
  }

  /**
   * Build Vite project
   */
  private async buildViteProject(tempDir: string): Promise<string> {
    console.log('[NetlifyService] Installing dependencies...');
    console.log('[NetlifyService] NODE_ENV:', process.env.NODE_ENV || 'undefined');
    console.log('[NetlifyService] Temp directory:', tempDir);

    try {
      // Verify package.json exists
      const packageJsonPath = join(tempDir, 'package.json');
      try {
        const packageJsonContent = await readFile(packageJsonPath, 'utf-8');
        console.log('[NetlifyService] package.json found:', packageJsonContent.substring(0, 200));
      } catch (err) {
        throw new Error(`package.json not found in temp directory: ${tempDir}`);
      }

      // List files in temp dir for debugging
      const files = await readdir(tempDir);
      console.log('[NetlifyService] Files in temp dir:', files.join(', '));

      // Install dependencies - Use --production=false to force install of devDependencies
      // In production, NODE_ENV=production causes npm to skip devDependencies by default
      // But we need build tools like vite, which are typically in devDependencies
      console.log('[NetlifyService] Running: npm install --production=false');
      const { stdout: installOut, stderr: installErr } = await execAsync('npm install --production=false', {
        cwd: tempDir,
        timeout: 180000, // 3 minutes timeout
        maxBuffer: 10 * 1024 * 1024 // 10MB buffer
      });

      console.log('[NetlifyService] npm install completed');
      if (installOut) {
        console.log('[NetlifyService] npm install output:', installOut.substring(0, 500));
      }
      if (installErr) {
        // Log all stderr, even warnings
        console.log('[NetlifyService] npm install stderr:', installErr.substring(0, 500));
        // Throw if stderr contains actual errors (not just warnings)
        if (installErr.toLowerCase().includes('error') && !installErr.toLowerCase().includes('npm warn')) {
          throw new Error(`npm install failed: ${installErr.substring(0, 1000)}`);
        }
      }

      // Verify vite is installed by checking if the module exists
      console.log('[NetlifyService] Verifying vite installation...');
      const viteModulePath = join(tempDir, 'node_modules', 'vite');
      try {
        await readdir(viteModulePath);
        console.log('[NetlifyService] Vite module found at:', viteModulePath);
      } catch (err) {
        throw new Error(`Vite not installed. node_modules/vite does not exist. npm install may have failed.`);
      }

      console.log('[NetlifyService] Building Vite project...');

      // Build the project
      const { stdout: buildOut, stderr: buildErr } = await execAsync('npm run build', {
        cwd: tempDir,
        timeout: 180000, // 3 minutes timeout
        maxBuffer: 10 * 1024 * 1024 // 10MB buffer
      });

      if (buildOut) {
        console.log('[NetlifyService] npm run build output:', buildOut.substring(0, 500));
      }
      if (buildErr) {
        console.log('[NetlifyService] npm run build stderr:', buildErr.substring(0, 500));
        // Throw if build actually failed (not just warnings)
        if (buildErr.toLowerCase().includes('error') && !buildErr.toLowerCase().includes('warn')) {
          throw new Error(`Build failed: ${buildErr.substring(0, 1000)}`);
        }
      }

      console.log('[NetlifyService] Build completed successfully');

      // Verify dist folder exists
      const distPath = join(tempDir, 'dist');
      try {
        await readdir(distPath);
        console.log('[NetlifyService] Verified dist folder exists:', distPath);
      } catch (err) {
        throw new Error(`Build succeeded but dist folder not found at: ${distPath}`);
      }

      return distPath;
    } catch (error: any) {
      console.error('[NetlifyService] Build failed:', error);
      throw new Error(`Build failed: ${error.message}`);
    }
  }

  /**
   * Create ZIP from a directory
   */
  private async createZipFromDirectory(sourceDir: string): Promise<Buffer> {
    const archive = archiver('zip', { zlib: { level: 9 } });
    const chunks: Buffer[] = [];

    archive.on('data', (chunk: Buffer) => chunks.push(chunk));

    const files = await this.getFilesRecursive(sourceDir);

    console.log('[NetlifyService] Adding', files.length, 'files to ZIP');

    for (const { relativePath, fullPath } of files) {
      archive.file(fullPath, { name: relativePath });
    }

    // Add Netlify configuration for SPA routing
    const netlifyToml = `[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200
`;
    archive.append(netlifyToml, { name: 'netlify.toml' });

    const finalizePromise = new Promise<void>((resolve, reject) => {
      archive.on('end', () => resolve());
      archive.on('error', (err: Error) => reject(err));
    });

    await archive.finalize();
    await finalizePromise;

    return Buffer.concat(chunks);
  }

  /**
   * Get all files recursively from a directory
   */
  private async getFilesRecursive(dir: string, baseDir: string = dir): Promise<Array<{ relativePath: string; fullPath: string }>> {
    const files: Array<{ relativePath: string; fullPath: string }> = [];
    const entries = await readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = join(dir, entry.name);

      if (entry.isDirectory()) {
        const subFiles = await this.getFilesRecursive(fullPath, baseDir);
        files.push(...subFiles);
      } else if (entry.isFile()) {
        const relativePath = fullPath.substring(baseDir.length + 1);
        files.push({ relativePath, fullPath });
      }
    }

    return files;
  }

  private async createZipBuffer(config: NetlifyDeployConfig): Promise<Buffer> {
    // Check if this is a Vite project
    const isVite = await this.isViteProject(config.appId);
    console.log('[NetlifyService] Project type:', isVite ? 'Vite/React (will build)' : 'Static (direct deploy)');

    // Default excludes
    const excludePatterns = ['.git', '.DS_Store', '.env', '.env.local'];
    if (!config.includeNodeModules) {
      excludePatterns.push('node_modules');
    }

    if (isVite) {
      // VITE PROJECT PATH: Build and deploy dist/
      let tempDir: string | null = null;
      let distDir: string | null = null;

      try {
        // Export files to temp directory
        tempDir = await this.exportFilesToTemp(config.appId, excludePatterns);

        // Build the project
        distDir = await this.buildViteProject(tempDir);

        // Create ZIP from dist directory
        const zipBuffer = await this.createZipFromDirectory(distDir);

        // Cleanup
        await rm(tempDir, { recursive: true, force: true });

        return zipBuffer;
      } catch (error) {
        // Cleanup on error
        console.error('[NetlifyService] Build failed, cleaning up temp dir:', tempDir);
        if (tempDir) {
          await rm(tempDir, { recursive: true, force: true }).catch(() => {});
        }
        throw error;
      }
    } else {
      // STATIC PROJECT PATH: Direct deploy
      const archive = archiver('zip', { zlib: { level: 9 } });

      // Collect all chunks
      const chunks: Buffer[] = [];
      archive.on('data', (chunk: Buffer) => chunks.push(chunk));

      console.log('[NetlifyService] Fetching file tree for app:', config.appId);
      const fileTree = await this.fileStore.list(config.appId);
      console.log('[NetlifyService] File tree nodes:', fileTree.length);

      // Flatten tree
      const flattenFiles = (nodes: any[]): any[] => {
        const result: any[] = [];
        for (const node of nodes) {
          if (node.type === 'file' && !node.isDirectory) {
            result.push(node);
          }
          if (node.children && node.children.length > 0) {
            result.push(...flattenFiles(node.children));
          }
        }
        return result;
      };

      const files = flattenFiles(fileTree);
      console.log('[NetlifyService] Total files to zip:', files.length);
      if (files.length === 0) {
        console.warn('[NetlifyService] WARNING: No files found in app! ZIP will be empty!');
      } else {
        console.log('[NetlifyService] Files:', files.slice(0, 10).map(f => f.path).join(', '), files.length > 10 ? `... and ${files.length - 10} more` : '');
      }

      // Filter and add files
      for (const file of files) {
        // Skip excluded files
        if (this.shouldExclude(file.path, excludePatterns)) {
          continue;
        }

        try {
          const fileContent = await this.fileStore.read(config.appId, file.path);
          if (fileContent && fileContent.content) {
            let content: Buffer;

            if (typeof fileContent.content === 'string') {
              content = Buffer.from(fileContent.content, 'utf-8');
            } else if (fileContent.content instanceof Uint8Array) {
              content = Buffer.from(fileContent.content);
            } else {
              content = Buffer.from(fileContent.content as any);
            }

            archive.append(content, { name: file.path });
          }
        } catch (error) {
          console.error(`[NetlifyService] Failed to add file ${file.path}:`, error);
        }
      }

      // Add Netlify configuration for SPA routing (if index.html exists)
      const hasIndexHtml = files.some(f => f.path === 'index.html');
      if (hasIndexHtml) {
        const netlifyToml = `[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200
`;
        archive.append(netlifyToml, { name: 'netlify.toml' });
      }

      // Finalize and wait for completion
      const finalizePromise = new Promise<void>((resolve, reject) => {
        archive.on('end', () => resolve());
        archive.on('error', (err: Error) => reject(err));
      });

      await archive.finalize();
      await finalizePromise;

      return Buffer.concat(chunks);
    }
  }

  private shouldExclude(path: string, patterns: string[]): boolean {
    for (const pattern of patterns) {
      if (path.startsWith(pattern + '/') || path === pattern) {
        return true;
      }
    }
    return false;
  }

  private async createDeploymentRecord(
    config: NetlifyDeployConfig,
    netlifySiteId: string
  ): Promise<string> {
    const result = await this.db.query<{ id: string }>(
      `INSERT INTO core.deployments (
        app_id, user_id, session_id, deployment_type,
        netlify_site_id, deploy_title, status, started_at
      )
      VALUES ($1, $2, $3, 'netlify', $4, $5, 'pending', now())
      RETURNING id`,
      [
        config.appId,
        config.userId,
        config.sessionId || null,
        netlifySiteId,
        config.deployTitle || `Deploy - ${new Date().toISOString()}`
      ]
    );

    return result.rows[0].id;
  }

  private async updateDeploymentSuccess(
    deploymentId: string,
    site: any,
    deployData: any
  ): Promise<void> {
    await this.db.query(
      `UPDATE core.deployments
       SET status = 'success',
           netlify_deploy_id = $1,
           deployment_url = $2,
           completed_at = now()
       WHERE id = $3`,
      [
        deployData.deploy_id || deployData.id,
        site.url,
        deploymentId
      ]
    );
  }

  private async updateDeploymentError(deploymentId: string, error: string): Promise<void> {
    await this.db.query(
      `UPDATE core.deployments
       SET status = 'failed',
           error_message = $1,
           completed_at = now()
       WHERE id = $2`,
      [error, deploymentId]
    );
  }
}
</file>

<file path="packages/database/src/tests/golden.test.ts">
import { describe, it, beforeAll, afterAll, expect } from 'vitest';
import { createDatabaseClient, DatabaseClient } from '../index.js';
import { TestFixtures } from './fixtures.js';
import { MemoryPreludeService } from '../services/memory-prelude.js';
import { ImpactedFilesAnalyzer } from '../services/impacted-analyzer.js';
import { PreparedQueries } from '../services/prepared-queries.js';
import { IntegrityChecker } from '../services/integrity-checker.js';

describe('Phase 3 Golden Tests', () => {
  let db: DatabaseClient;
  let fixtures: TestFixtures;

  beforeAll(async () => {
    db = createDatabaseClient();
    fixtures = new TestFixtures(db);

    const healthy = await db.healthCheck();
    expect(healthy).toBe(true);
  });

  afterAll(async () => {
    await db.close();
  });

  it('should resume a 2-week-old session seamlessly', async () => {
    const { user, session } = await fixtures.createRealisticSession();

    const preludeService = new MemoryPreludeService(db);
    const prelude = await preludeService.buildPrelude(session.id);

    expect(prelude.sessionTitle).toBe('Build a todo app with dark mode');
    expect(prelude.appName).toBe('Todo App');
    expect(prelude.rollingSummary).toContain('todo app');
    expect(prelude.rollingSummary).toContain('dark mode');
    expect(prelude.pinnedFiles).toHaveLength(2);
    expect(prelude.keyFacts.framework).toBe('react');
    expect(prelude.keyFacts.typescript).toBe(true);

    const formatted = preludeService.formatAsSystemMessage(prelude);
    expect(formatted).toContain('Session: Build a todo app with dark mode');
    expect(formatted).toContain('App: Todo App');
    expect(formatted).toContain('Pinned Files:');
    expect(formatted).toContain('Constraints:');

    const preparedQueries = new PreparedQueries(db);
    const sessionData = await preparedQueries.getSessionWithMemory(session.id);

    expect(sessionData).not.toBeNull();
    expect(sessionData?.session.id).toBe(session.id);
    expect(sessionData?.recentMessages.length).toBeGreaterThan(0);
    expect(sessionData?.memory).not.toBeNull();

    await fixtures.cleanup(user.id);
  });

  it('should detect impacted files when changing shared component', async () => {
    const { user, app, files } = await fixtures.createRealisticSession();

    const themeContextFile = files.find((f) => f.path === 'src/context/ThemeContext.tsx');
    expect(themeContextFile).toBeDefined();

    const analyzer = new ImpactedFilesAnalyzer(db);
    const impact = await analyzer.analyzeImpact(app.id, themeContextFile!.id);

    expect(impact.sourceFile.path).toBe('src/context/ThemeContext.tsx');
    expect(impact.impactedFiles.length).toBeGreaterThan(0);

    const impactedPaths = impact.impactedFiles.map((f) => f.path);
    expect(impactedPaths).toContain('src/App.tsx');

    const summary = await analyzer.getImpactSummary(app.id, themeContextFile!.id);
    expect(summary.directImpacts).toBeGreaterThan(0);
    expect(summary.totalImpacts).toBeGreaterThanOrEqual(summary.directImpacts);

    await fixtures.cleanup(user.id);
  });

  it('should verify file and image integrity', async () => {
    const { user, app, files } = await fixtures.createRealisticSession();

    const checker = new IntegrityChecker(db);
    const fileResults = await checker.verifyFileChecksums(app.id);

    expect(fileResults.length).toBe(files.length);
    const allValid = fileResults.every((r) => r.matches);
    expect(allValid).toBe(true);

    await fixtures.cleanup(user.id);
  });

  it('should efficiently query working set and files', async () => {
    const { user, session, app } = await fixtures.createRealisticSession();

    const preparedQueries = new PreparedQueries(db);

    const startTime = Date.now();
    const workingSet = await preparedQueries.getWorkingSetWithFiles(session.id);
    const queryTime = Date.now() - startTime;

    expect(workingSet.length).toBe(2);
    expect(queryTime).toBeLessThan(100);

    workingSet.forEach((item) => {
      expect(item.file_path).toBeDefined();
      expect(item.mime_type).toBeDefined();
    });

    const paths = ['src/App.tsx', 'src/types.ts', 'nonexistent.ts'];
    const fileMap = await preparedQueries.getFilesByPaths(app.id, paths);

    expect(fileMap.size).toBe(2);
    expect(fileMap.has('src/App.tsx')).toBe(true);
    expect(fileMap.has('src/types.ts')).toBe(true);
    expect(fileMap.has('nonexistent.ts')).toBe(false);

    await fixtures.cleanup(user.id);
  });

  it('should handle session context with performance', async () => {
    const { user, session } = await fixtures.createRealisticSession();

    const preparedQueries = new PreparedQueries(db);

    const startTime = Date.now();
    const sessionData = await preparedQueries.getSessionWithMemory(session.id);
    const queryTime = Date.now() - startTime;

    expect(sessionData).not.toBeNull();
    expect(queryTime).toBeLessThan(50);

    expect(sessionData?.session.title).toBe('Build a todo app with dark mode');
    expect(sessionData?.recentMessages.length).toBeGreaterThan(0);
    expect(sessionData?.memory.rolling_summary).toBeDefined();

    await fixtures.cleanup(user.id);
  });
});
</file>

<file path="packages/database/package.json">
{
  "name": "@eitherway/database",
  "version": "0.1.0",
  "description": "PostgreSQL database layer for EitherWay",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "migrate": "node --env-file=../../.env --import tsx/esm src/migrations/runner.ts",
    "migrate:create": "node --env-file=../../.env --import tsx/esm src/migrations/create.ts",
    "test": "vitest run"
  },
  "dependencies": {
    "archiver": "^7.0.1",
    "diff": "^5.1.0",
    "form-data": "^4.0.0",
    "openai": "^4.77.3",
    "pg": "^8.11.3",
    "sharp": "^0.33.5",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/archiver": "^6.0.2",
    "@types/diff": "^7.0.2",
    "@types/form-data": "^2.5.0",
    "@types/node": "^20.11.16",
    "@types/pg": "^8.10.9",
    "dotenv": "^17.2.3",
    "tsx": "^4.7.0",
    "typescript": "^5.3.3",
    "vitest": "^3.2.4"
  }
}
</file>

<file path="packages/runtime/src/cli.ts">
#!/usr/bin/env node
/**
 * CLI for the EitherWay agent
 */

import { Agent } from './agent.js';
import { ConfigLoader } from './config.js';
import { getAllExecutors } from '@eitherway/tools-impl';

async function main() {
  const args = process.argv.slice(2);

  if (args.length === 0 || args.includes('--help') || args.includes('-h')) {
    console.log(`
EitherWay Agent CLI - App creation with Claude Sonnet 4.5

Usage:
  npm run dev [options] "<request>"

Options:
  --dry-run         Show what would be executed without making changes
  --config-dir DIR  Configuration directory (default: ./configs)
  --help, -h        Show this help message

Examples:
  npm run dev "Build me a calculator"
  npm run dev --dry-run "Create a todo app"

Configuration:
  1. Copy configs/anthropic.example.json to configs/anthropic.json
  2. Add your Anthropic API key
  3. Adjust agent.json settings as needed
`);
    process.exit(0);
  }

  // Parse options
  let dryRun = false;
  let configDir = './configs';
  let request = '';

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--dry-run') {
      dryRun = true;
    } else if (args[i] === '--config-dir') {
      configDir = args[++i];
    } else {
      request = args.slice(i).join(' ');
      break;
    }
  }

  if (!request) {
    console.error('Error: No request provided');
    process.exit(1);
  }

  try {
    // Load configuration
    const loader = new ConfigLoader(configDir);
    const { claudeConfig, agentConfig } = await loader.loadAll();

    // Create agent
    const agent = new Agent({
      workingDir: process.cwd(),
      claudeConfig,
      agentConfig,
      executors: getAllExecutors(),
      dryRun,
      webSearch: agentConfig.tools.webSearch,
    });

    console.log('\n=== EitherWay Agent ===');
    console.log(`Model: ${claudeConfig.model}`);
    console.log(`Dry Run: ${dryRun ? 'YES' : 'NO'}`);
    console.log(`Request: ${request}`);
    console.log('======================\n');

    // Process request
    const response = await agent.processRequest(request);

    // Save transcript
    await agent.saveTranscript();

    console.log('\n======================');
    console.log('Final Response:');
    console.log(response);
    console.log('======================\n');
  } catch (error: any) {
    console.error('\n Error:', error.message);
    if (error.stack) {
      console.error('\nStack trace:');
      console.error(error.stack);
    }
    process.exit(1);
  }
}

main();
</file>

<file path="packages/runtime/src/tool-runner.ts">
/**
 * Tool Runner with validation, allowlist, idempotency, metrics, and rate limiting
 */

import crypto from 'crypto';
import { getValidator } from '@eitherway/tools-core';
import type {
  ToolExecutor,
  ToolExecutorResult,
  ToolUse,
  ToolResult,
  ExecutionContext,
  AgentConfig,
} from '@eitherway/tools-core';
import { MetricsCollector } from './metrics.js';
import { RateLimiter } from './rate-limiter.js';

export class ToolRunner {
  private executors: Map<string, ToolExecutor>;
  private context: ExecutionContext;
  private executionCache: Map<string, ToolExecutorResult>;
  private validator = getValidator();
  private metrics: MetricsCollector;
  private rateLimiter: RateLimiter;

  constructor(executors: ToolExecutor[], workingDir: string, config: AgentConfig) {
    this.executors = new Map();
    for (const executor of executors) {
      this.executors.set(executor.name, executor);
    }

    this.context = {
      workingDir,
      allowedPaths: config.security.allowedWorkspaces,
      deniedPaths: config.security.deniedPaths,
      config,
    };

    this.executionCache = new Map();
    this.metrics = new MetricsCollector(config);
    this.rateLimiter = new RateLimiter();
  }

  /**
   * Execute a single tool use with metrics and rate limiting
   */
  async executeTool(toolUse: ToolUse): Promise<ToolResult> {
    const { id, name, input } = toolUse;
    const startTime = Date.now();

    // Check if tool exists
    const executor = this.executors.get(name);
    if (!executor) {
      return {
        type: 'tool_result',
        tool_use_id: id,
        content: `Error: Unknown tool '${name}'`,
        is_error: true,
      };
    }

    // Validate input against schema
    const validation = this.validator.validate(name, input);
    if (!validation.valid) {
      return {
        type: 'tool_result',
        tool_use_id: id,
        content: `Validation error: ${validation.errors.join(', ')}`,
        is_error: true,
      };
    }

    // Rate limiting for external APIs
    if (name.startsWith('websearch') || name.startsWith('eithergen')) {
      const rateCheck = await this.rateLimiter.checkLimit(name.split('--')[0]);
      if (!rateCheck.allowed) {
        return {
          type: 'tool_result',
          tool_use_id: id,
          content: `Rate limit exceeded for ${name}. Retry after ${rateCheck.retryAfter} seconds.`,
          is_error: true,
        };
      }
    }

    // Check idempotency (hash-based deduplication)
    const cacheKey = this.getCacheKey(name, input);
    const cached = this.executionCache.get(cacheKey);
    if (cached) {
      return {
        type: 'tool_result',
        tool_use_id: id,
        content: cached.content,
        is_error: cached.isError,
      };
    }

    try {
      // Execute the tool
      const result = await executor.execute(input, this.context);

      // Calculate metrics
      const latency = Date.now() - startTime;
      const inputSize = JSON.stringify(input).length;
      const outputSize = result.content.length;
      const fileCount = result.metadata?.matchCount || result.metadata?.fileCount;

      // Record metrics
      this.metrics.recordToolExecution({
        tool: name,
        latency_ms: latency,
        input_size: inputSize,
        output_size: outputSize,
        file_count: fileCount,
        success: !result.isError,
        error: result.isError ? result.content : undefined,
        timestamp: new Date().toISOString(),
      });

      // Cache the result
      this.executionCache.set(cacheKey, result);

      return {
        type: 'tool_result',
        tool_use_id: id,
        content: result.content,
        is_error: result.isError,
      };
    } catch (error: any) {
      const errorMessage = error?.message || String(error);
      const latency = Date.now() - startTime;

      // Record error metrics
      this.metrics.recordToolExecution({
        tool: name,
        latency_ms: latency,
        input_size: JSON.stringify(input).length,
        output_size: errorMessage.length,
        success: false,
        error: errorMessage,
        timestamp: new Date().toISOString(),
      });

      return {
        type: 'tool_result',
        tool_use_id: id,
        content: `Execution error: ${errorMessage}`,
        is_error: true,
      };
    }
  }

  /**
   * Execute multiple tools with parallel execution where safe
   * Reads run in parallel; writes are serialized per-path
   */
  async executeTools(toolUses: ToolUse[]): Promise<ToolResult[]> {
    if (toolUses.length === 0) return [];
    if (toolUses.length === 1) return [await this.executeTool(toolUses[0])];

    // Classify tools into reads and writes
    const reads: ToolUse[] = [];
    const writesByPath = new Map<string, ToolUse[]>();

    for (const tu of toolUses) {
      const isWrite = this.isWriteTool(tu.name);

      if (!isWrite) {
        reads.push(tu);
      } else {
        // Group writes by their target path
        const path = this.extractPath(tu.input);
        if (!writesByPath.has(path)) {
          writesByPath.set(path, []);
        }
        writesByPath.get(path)!.push(tu);
      }
    }

    // Execute reads in parallel (with concurrency limit)
    const concurrencyLimit = this.context.config.limits.maxConcurrentTools || 4;
    const readResults = await this.runWithConcurrency(reads, concurrencyLimit);

    // Execute writes: each path group runs sequentially, different paths in parallel
    const writeGroups = Array.from(writesByPath.values());
    const writeResults = await this.runWriteGroupsInParallel(writeGroups, concurrencyLimit);

    // Combine and sort results back to original order
    const resultMap = new Map<string, ToolResult>();
    for (const result of [...readResults, ...writeResults]) {
      resultMap.set(result.tool_use_id, result);
    }

    return toolUses.map((tu) => resultMap.get(tu.id)!);
  }

  /**
   * Determine if a tool performs writes
   */
  private isWriteTool(name: string): boolean {
    return name === 'either-write' || name === 'either-line-replace' || name === 'eithergen--generate_image';
  }

  /**
   * Extract file path from tool input (used for grouping writes)
   */
  private extractPath(input: Record<string, any>): string {
    return (input?.path as string) || '__no_path__';
  }

  /**
   * Run tools in parallel with concurrency limit
   */
  private async runWithConcurrency(tools: ToolUse[], limit: number): Promise<ToolResult[]> {
    if (tools.length === 0) return [];

    const results: ToolResult[] = new Array(tools.length);
    let activeCount = 0;
    let currentIndex = 0;

    return new Promise((resolve) => {
      const startNext = () => {
        while (activeCount < limit && currentIndex < tools.length) {
          const index = currentIndex++;
          const tool = tools[index];
          activeCount++;

          this.executeTool(tool).then((result) => {
            results[index] = result;
            activeCount--;
            if (currentIndex < tools.length) {
              startNext();
            } else if (activeCount === 0) {
              resolve(results);
            }
          });
        }
      };

      startNext();
    });
  }

  /**
   * Execute write groups: sequential within each group, parallel across groups
   */
  private async runWriteGroupsInParallel(groups: ToolUse[][], limit: number): Promise<ToolResult[]> {
    const allResults: ToolResult[] = [];
    let activeCount = 0;
    let currentIndex = 0;

    return new Promise((resolve) => {
      if (groups.length === 0) {
        resolve([]);
        return;
      }

      const startNext = () => {
        while (activeCount < limit && currentIndex < groups.length) {
          const group = groups[currentIndex++];
          activeCount++;

          this.executeSequentially(group).then((results) => {
            allResults.push(...results);
            activeCount--;
            if (currentIndex < groups.length) {
              startNext();
            } else if (activeCount === 0) {
              resolve(allResults);
            }
          });
        }
      };

      startNext();
    });
  }

  /**
   * Execute tools sequentially (for same-path writes)
   */
  private async executeSequentially(tools: ToolUse[]): Promise<ToolResult[]> {
    const results: ToolResult[] = [];
    for (const tool of tools) {
      results.push(await this.executeTool(tool));
    }
    return results;
  }

  /**
   * Generate cache key for idempotency
   */
  private getCacheKey(name: string, input: Record<string, any>): string {
    const payload = JSON.stringify({ name, input });
    return crypto.createHash('sha256').update(payload).digest('hex');
  }

  /**
   * Clear execution cache (useful between turns)
   */
  clearCache(): void {
    this.executionCache.clear();
  }

  /**
   * Get available tool names
   */
  getAvailableTools(): string[] {
    return Array.from(this.executors.keys());
  }

  /**
   * Check if a tool is available
   */
  hasExecutor(name: string): boolean {
    return this.executors.has(name);
  }

  /**
   * Get metrics collector
   */
  getMetrics(): MetricsCollector {
    return this.metrics;
  }

  /**
   * Get rate limiter
   */
  getRateLimiter(): RateLimiter {
    return this.rateLimiter;
  }

  /**
   * Set database context for file operations
   */
  setDatabaseContext(fileStore: any, appId: string, sessionId?: string): void {
    this.context.fileStore = fileStore;
    this.context.appId = appId;
    this.context.sessionId = sessionId;
  }

  /**
   * Clear database context
   */
  clearDatabaseContext(): void {
    delete this.context.fileStore;
    delete this.context.appId;
    delete this.context.sessionId;
  }
}

/**
 * Security utilities for path validation
 */
export class SecurityGuard {
  private allowedPaths: string[];
  private deniedPaths: string[];
  private secretPatterns: RegExp[];

  constructor(config: AgentConfig['security']) {
    this.allowedPaths = config.allowedWorkspaces;
    this.deniedPaths = config.deniedPaths;
    this.secretPatterns = config.secretPatterns.map((p) => new RegExp(p, 'g'));
  }

  /**
   * Check if a path is allowed
   */
  isPathAllowed(path: string): boolean {
    // Check denied paths first
    for (const denied of this.deniedPaths) {
      if (this.matchGlob(path, denied)) {
        return false;
      }
    }

    // Check allowed paths
    for (const allowed of this.allowedPaths) {
      if (this.matchGlob(path, allowed)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Redact secrets from content
   */
  redactSecrets(content: string): string {
    let redacted = content;
    for (const pattern of this.secretPatterns) {
      redacted = redacted.replace(pattern, '[REDACTED]');
    }
    return redacted;
  }

  /**
   * Simple glob matching (supports ** and *)
   */
  private matchGlob(path: string, pattern: string): boolean {
    const regex = this.globToRegExp(pattern);
    return regex.test(path);
  }

  // Convert a glob to a RegExp with proper ** semantics:
  //  - "**/"   => "(?:.*/)?", i.e., zero or more directories (including none)
  //  - "**"    => ".*"
  //  - "*"     => "[^/]*"
  //  - "?"     => "[^/]"
  private globToRegExp(pattern: string): RegExp {
    const specials = /[.+^${}()|[\]\\]/;
    let i = 0;
    let out = '^';
    while (i < pattern.length) {
      const ch = pattern[i];
      if (ch === '*') {
        const next = pattern[i + 1];
        if (next === '*') {
          const hasSlash = pattern[i + 2] === '/';
          if (hasSlash) {
            out += '(?:.*/)?'; // zero or more directories, including none
            i += 3;
          } else {
            out += '.*'; // any characters, including '/'
            i += 2;
          }
        } else {
          out += '[^/]*'; // any chars except '/'
          i += 1;
        }
      } else if (ch === '?') {
        out += '[^/]';
        i += 1;
      } else {
        out += specials.test(ch) ? '\\' + ch : ch;
        i += 1;
      }
    }
    out += '$';
    return new RegExp(out);
  }
}
</file>

<file path="packages/tools-impl/src/either-view.ts">
/**
 * either-view: Read files with hash and metadata
 */

import { readFile } from 'fs/promises';
import { resolve } from 'path';
import { createHash } from 'crypto';
import type { ToolExecutor, ExecutionContext, ToolExecutorResult } from '@eitherway/tools-core';
import { SecurityGuard } from './security.js';

export class EitherViewExecutor implements ToolExecutor {
  name = 'either-view';

  async execute(input: Record<string, any>, context: ExecutionContext): Promise<ToolExecutorResult> {
    const { path, max_bytes = 1048576, encoding = 'utf-8' } = input;

    // Security check
    const guard = new SecurityGuard(context.config.security);
    if (!guard.isPathAllowed(path)) {
      return {
        content: `Error: Access denied to path '${path}'. Path is not in allowed workspaces.`,
        isError: true,
      };
    }

    // Use database if fileStore is available
    if (context.fileStore && context.appId) {
      return this.executeWithDatabase(path, max_bytes, encoding, context);
    }

    // Otherwise use filesystem
    const fullPath = resolve(context.workingDir, path);

    try {
      // Read file with size limit
      const content = await readFile(fullPath, encoding as BufferEncoding);

      // Calculate SHA-256 hash
      const sha256 = createHash('sha256').update(content).digest('hex');

      // Count lines
      const lineCount = content.split('\n').length;

      // Check if truncation needed
      const isTruncated = content.length > max_bytes;

      if (isTruncated) {
        const truncated = content.slice(0, max_bytes);
        const truncatedLines = truncated.split('\n').length;

        return {
          content: `${truncated}\n\n[File truncated: ${content.length} bytes, showing first ${max_bytes} bytes]`,
          isError: false,
          metadata: {
            path,
            encoding,
            size: content.length,
            sha256,
            line_count: lineCount,
            truncated: true,
            shown_lines: truncatedLines,
          },
        };
      }

      // Return full content with metadata
      return {
        content,
        isError: false,
        metadata: {
          path,
          encoding,
          size: content.length,
          sha256,
          line_count: lineCount,
          truncated: false,
        },
      };
    } catch (error: any) {
      return {
        content: `Error reading file '${path}': ${error.message}`,
        isError: true,
      };
    }
  }

  /**
   * Execute using database FileStore
   */
  private async executeWithDatabase(
    path: string,
    max_bytes: number,
    encoding: string,
    context: ExecutionContext,
  ): Promise<ToolExecutorResult> {
    const { fileStore, appId } = context;

    try {
      // Read file from database
      const fileData = await fileStore.read(appId, path);

      // Convert content to string
      let content: string;
      if (typeof fileData.content === 'string') {
        content = fileData.content;
      } else if (Buffer.isBuffer(fileData.content)) {
        content = fileData.content.toString(encoding as BufferEncoding);
      } else {
        content = Buffer.from(fileData.content).toString(encoding as BufferEncoding);
      }

      // Calculate SHA-256 hash
      const sha256 = createHash('sha256').update(content).digest('hex');

      // Count lines
      const lineCount = content.split('\n').length;

      // Check if truncation needed
      const isTruncated = content.length > max_bytes;

      if (isTruncated) {
        const truncated = content.slice(0, max_bytes);
        const truncatedLines = truncated.split('\n').length;

        return {
          content: `${truncated}\n\n[File truncated: ${content.length} bytes, showing first ${max_bytes} bytes]`,
          isError: false,
          metadata: {
            path,
            encoding,
            size: content.length,
            sha256,
            line_count: lineCount,
            truncated: true,
            shown_lines: truncatedLines,
            storage: 'database',
          },
        };
      }

      // Return full content with metadata
      return {
        content,
        isError: false,
        metadata: {
          path,
          encoding,
          size: content.length,
          sha256,
          line_count: lineCount,
          truncated: false,
          storage: 'database',
        },
      };
    } catch (error: any) {
      return {
        content: `Error reading file '${path}' from database: ${error.message}`,
        isError: true,
      };
    }
  }
}
</file>

<file path="packages/tools-impl/src/either-write.ts">
/**
 * either-write: Create new files with diff summary
 */

import { writeFile, mkdir, access, readFile } from 'fs/promises';
import { resolve, dirname } from 'path';
import { createHash } from 'crypto';
import type { ToolExecutor, ExecutionContext, ToolExecutorResult } from '@eitherway/tools-core';
import { SecurityGuard } from './security.js';

export class EitherWriteExecutor implements ToolExecutor {
  name = 'either-write';

  async execute(input: Record<string, any>, context: ExecutionContext): Promise<ToolExecutorResult> {
    const { path, content, overwrite = false, create_dirs = true } = input;

    // Security check
    const guard = new SecurityGuard(context.config.security);
    if (!guard.isPathAllowed(path)) {
      return {
        content: `Error: Access denied to path '${path}'. Path is not in allowed workspaces.`,
        isError: true,
      };
    }

    // Use database if fileStore is available
    if (context.fileStore && context.appId) {
      return this.executeWithDatabase(path, content, context);
    }

    // Otherwise use filesystem
    const fullPath = resolve(context.workingDir, path);

    try {
      let isExisting = false;
      let oldContent = '';
      let oldSha256 = '';

      // Check if file exists
      try {
        await access(fullPath);
        isExisting = true;

        if (!overwrite) {
          return {
            content: `Error: File '${path}' already exists. Set overwrite=true to replace it.`,
            isError: true,
          };
        }

        // Read existing content for diff
        oldContent = await readFile(fullPath, 'utf-8');
        oldSha256 = createHash('sha256').update(oldContent).digest('hex');
      } catch {
        // File doesn't exist, which is fine
      }

      // Create parent directories if needed
      if (create_dirs) {
        const dir = dirname(fullPath);
        await mkdir(dir, { recursive: true });
      }

      // Size limit check
      const maxSize = context.config.limits.maxToolPayloadSize;
      if (content.length > maxSize) {
        return {
          content: `Error: Content size (${content.length} bytes) exceeds limit (${maxSize} bytes)`,
          isError: true,
        };
      }

      // Write file
      await writeFile(fullPath, content, 'utf-8');

      // Calculate new hash
      const newSha256 = createHash('sha256').update(content).digest('hex');
      const lineCount = content.split('\n').length;

      // Generate diff summary
      let diffSummary: string;
      if (isExisting) {
        const oldLines = oldContent.split('\n');
        const newLines = content.split('\n');
        diffSummary = this.generateDiffSummary(path, oldLines, newLines);
      } else {
        // New file - show first few lines
        const lines = content.split('\n');
        const preview = lines
          .slice(0, 10)
          .map((line: string, idx: number) => `${idx + 1}+ ${line}`)
          .join('\n');
        const more = lines.length > 10 ? `\n... ${lines.length - 10} more lines` : '';
        diffSummary = `+++ ${path} (new file)\n${preview}${more}`;
      }

      return {
        content: `Successfully wrote '${path}'\n\n${diffSummary}`,
        isError: false,
        metadata: {
          path,
          size: content.length,
          sha256: newSha256,
          line_count: lineCount,
          overwritten: isExisting,
          old_sha256: oldSha256 || undefined,
        },
      };
    } catch (error: any) {
      return {
        content: `Error writing file '${path}': ${error.message}`,
        isError: true,
      };
    }
  }

  /**
   * Execute using database FileStore
   */
  private async executeWithDatabase(
    path: string,
    content: string,
    context: ExecutionContext,
  ): Promise<ToolExecutorResult> {
    const { fileStore, appId } = context;

    try {
      // Check if file exists in database
      let isExisting = false;
      let oldContent = '';

      try {
        const existingFile = await fileStore.read(appId, path);
        isExisting = true;

        // Convert content to string if it's a buffer
        if (typeof existingFile.content === 'string') {
          oldContent = existingFile.content;
        } else if (Buffer.isBuffer(existingFile.content)) {
          oldContent = existingFile.content.toString('utf-8');
        } else {
          oldContent = Buffer.from(existingFile.content).toString('utf-8');
        }
      } catch {
        // File doesn't exist, which is fine for new files
      }

      // Write to database
      await fileStore.write(appId, path, content);

      // Calculate hash and line count
      const newSha256 = createHash('sha256').update(content).digest('hex');
      const lineCount = content.split('\n').length;

      // Generate diff summary
      let diffSummary: string;
      if (isExisting) {
        const oldLines = oldContent.split('\n');
        const newLines = content.split('\n');
        diffSummary = this.generateDiffSummary(path, oldLines, newLines);
      } else {
        // New file - show first few lines
        const lines = content.split('\n');
        const preview = lines
          .slice(0, 10)
          .map((line: string, idx: number) => `${idx + 1}+ ${line}`)
          .join('\n');
        const more = lines.length > 10 ? `\n... ${lines.length - 10} more lines` : '';
        diffSummary = `+++ ${path} (new file)\n${preview}${more}`;
      }

      return {
        content: `Successfully wrote '${path}' to database\n\n${diffSummary}`,
        isError: false,
        metadata: {
          path,
          size: content.length,
          sha256: newSha256,
          line_count: lineCount,
          overwritten: isExisting,
          storage: 'database',
        },
      };
    } catch (error: any) {
      return {
        content: `Error writing file '${path}' to database: ${error.message}`,
        isError: true,
      };
    }
  }

  /**
   * Generate a simple diff summary
   */
  private generateDiffSummary(path: string, oldLines: string[], newLines: string[]): string {
    const maxPreview = 20;
    const diff: string[] = [`--- ${path} (before)`, `+++ ${path} (after)`];

    // Simple line-by-line diff for preview
    const minLen = Math.min(oldLines.length, newLines.length, maxPreview);

    for (let i = 0; i < minLen; i++) {
      if (oldLines[i] !== newLines[i]) {
        diff.push(`${i + 1}- ${oldLines[i]}`);
        diff.push(`${i + 1}+ ${newLines[i]}`);
      }
    }

    // Handle length differences
    if (newLines.length > oldLines.length) {
      const added = newLines.length - oldLines.length;
      diff.push(`... +${added} lines added`);
    } else if (oldLines.length > newLines.length) {
      const removed = oldLines.length - newLines.length;
      diff.push(`... -${removed} lines removed`);
    }

    return diff.join('\n');
  }
}
</file>

<file path="packages/tools-impl/src/imagegen.ts">
/**
 * eithergen--generate_image: Database-backed image generation
 *
 * CRITICAL: This tool uses the ImageGenerationService which:
 * - Uses response_format: 'b64_json' to avoid TTL expiration
 * - Stores images in PostgreSQL (compatible with VFS)
 * - Validates images with sharp
 * - Polls until completion
 */

import type { ToolExecutor, ExecutionContext, ToolExecutorResult } from '@eitherway/tools-core';
import { SecurityGuard } from './security.js';
import { ImageGenerationService, createDatabaseClient, PostgresFileStore } from '@eitherway/database';

export class ImageGenExecutor implements ToolExecutor {
  name = 'eithergen--generate_image';

  async execute(input: Record<string, any>, context: ExecutionContext): Promise<ToolExecutorResult> {
    const { prompt, path, size = '1024x1024', quality = 'standard' } = input;

    // Security check
    const guard = new SecurityGuard(context.config.security);
    if (!guard.isPathAllowed(path)) {
      return {
        content: `Error: Access denied to path '${path}'. Path is not in allowed workspaces.`,
        isError: true,
      };
    }

    // Validate OPENAI_API_KEY
    if (!process.env.OPENAI_API_KEY) {
      return {
        content: `Error: OpenAI API key not configured.\n\nTo enable:\n1. Get API key from https://platform.openai.com/api-keys\n2. Set environment variable: export OPENAI_API_KEY=your_key`,
        isError: true,
      };
    }

    try {
      // Get database client and services
      const db = createDatabaseClient();
      const imageService = new ImageGenerationService(db);

      // Extract sessionId and appId from context if available
      const sessionId = context.sessionId;
      const appId = context.appId;

      if (!appId) {
        // DO NOT close db - it's a singleton shared by all tools
        return {
          content: `Error: No app context found. Image generation requires an active app/session.`,
          isError: true,
        };
      }

      // Map size to DALL-E 3 supported sizes
      const dalleSize = this.mapSize(size);

      // Start image generation job
      const jobId = await imageService.generateImage({
        prompt,
        model: 'dall-e-3',
        size: dalleSize,
        quality: quality as 'standard' | 'hd',
        n: 1,
        sessionId,
        appId,
      });

      // Poll until complete (60 second timeout)
      const result = await imageService.pollJobUntilComplete(jobId, 60000, 500);

      if (result.job.state !== 'succeeded') {
        // DO NOT close db - it's a singleton shared by all tools
        return {
          content: `Error: Image generation failed.\nJob ID: ${jobId}\nState: ${result.job.state}\nError: ${JSON.stringify(result.job.error)}`,
          isError: true,
        };
      }

      if (!result.assets || result.assets.length === 0) {
        // DO NOT close db - it's a singleton shared by all tools
        return {
          content: `Error: No image assets generated.\nJob ID: ${jobId}`,
          isError: true,
        };
      }

      // Get the actual image bytes
      const assetId = result.assets[0].id;
      const asset = await imageService.getAsset(assetId);

      if (!asset) {
        // DO NOT close db - it's a singleton shared by all tools
        return {
          content: `Error: Failed to retrieve generated image.\nAsset ID: ${assetId}`,
          isError: true,
        };
      }

      // Save to VFS (database-backed file system)
      const fileStore = new PostgresFileStore(db);
      const mimeType = asset.mimeType;
      const extension = mimeType === 'image/png' ? '.png' : '.jpg';

      // Ensure path has correct extension
      let finalPath = path;
      if (!finalPath.endsWith('.png') && !finalPath.endsWith('.jpg') && !finalPath.endsWith('.jpeg')) {
        finalPath = path + extension;
      }

      await fileStore.write(appId, finalPath, asset.bytes, mimeType);

      // DO NOT close db - it's a singleton shared by all tools
      // The server manages database lifecycle, not individual tools

      // Build public URL for the image
      const serverOrigin = process.env.SERVER_ORIGIN || 'http://localhost:3001';
      const assetUrl = `${serverOrigin}/api/images/assets/${assetId}`;

      // Determine the correct path for HTML/code usage
      // Vite serves files from public/ directory at the root path
      // So public/image.png should be referenced as /image.png
      let htmlPath = finalPath;
      if (finalPath.startsWith('public/') || finalPath.startsWith('/public/')) {
        // Remove the public/ prefix for Vite
        htmlPath = '/' + finalPath.replace(/^\/?public\//, '');
      } else if (!finalPath.startsWith('/')) {
        // Ensure absolute path
        htmlPath = '/' + finalPath;
      }

      return {
        content: ` Image generated and saved successfully!

 Saved to: ${finalPath}
  IMPORTANT: Use this path in your HTML/code: ${htmlPath}

Example usage:
<img src="${htmlPath}" alt="${prompt.substring(0, 50)}...">

Details:
- Prompt: "${prompt}"
- Size: ${dalleSize}
- Quality: ${quality}
- Format: ${mimeType}
- File size: ${(asset.bytes.length / 1024).toFixed(2)} KB
- Job ID: ${jobId}
- Asset ID: ${assetId}

The image is now available in the file system and will display in the preview.`,
        isError: false,
        metadata: {
          path: finalPath,
          prompt,
          size: dalleSize,
          quality,
          jobId,
          assetId,
          assetUrl,
          mimeType,
          fileSize: asset.bytes.length,
          width: result.assets[0].width,
          height: result.assets[0].height,
        },
      };
    } catch (error: any) {
      return {
        content: `Image generation error: ${error.message}\n\nStack trace:\n${error.stack}`,
        isError: true,
      };
    }
  }

  private mapSize(size: string): '1024x1024' | '1792x1024' | '1024x1792' {
    // DALL-E 3 supports: 1024x1024, 1024x1792, 1792x1024
    const [w, h] = size.split('x').map(Number);
    if (w >= 1024 && h >= 1024) {
      if (w > h) return '1792x1024';
      if (h > w) return '1024x1792';
      return '1024x1024';
    }
    return '1024x1024'; // Default
  }
}
</file>

<file path="packages/tools-impl/src/index.ts">
/**
 * @eitherway/tools-impl - Tool executor implementations
 */

export { EitherViewExecutor } from './either-view.js';
export { EitherSearchFilesExecutor } from './either-search-files.js';
export { EitherWriteExecutor } from './either-write.js';
export { EitherLineReplaceExecutor } from './either-line-replace.js';
export { ImageGenExecutor } from './imagegen.js';
export { SecurityGuard } from './security.js';

import { EitherViewExecutor } from './either-view.js';
import { EitherSearchFilesExecutor } from './either-search-files.js';
import { EitherWriteExecutor } from './either-write.js';
import { EitherLineReplaceExecutor } from './either-line-replace.js';
import { ImageGenExecutor } from './imagegen.js';
import type { ToolExecutor } from '@eitherway/tools-core';

/**
 * Get all tool executors
 */
export function getAllExecutors(): ToolExecutor[] {
  return [
    new EitherViewExecutor(),
    new EitherSearchFilesExecutor(),
    new EitherWriteExecutor(),
    new EitherLineReplaceExecutor(),
    new ImageGenExecutor(),
  ];
}
</file>

<file path="packages/ui-frontend/app/components/workbench/Preview.tsx">
import { useStore } from '@nanostores/react';
import { memo, useCallback, useEffect, useRef, useState } from 'react';
import { IconButton } from '~/components/ui/IconButton';
import { workbenchStore } from '~/lib/stores/workbench';
import { chatStore } from '~/lib/stores/chat';
import { previewModeStore } from '~/lib/stores/preview-mode';
import { PortDropdown } from './PortDropdown';
import { createScopedLogger } from '~/utils/logger';

const logger = createScopedLogger('Preview');

export const Preview = memo(() => {
  const iframeRef = useRef<HTMLIFrameElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const [activePreviewIndex, setActivePreviewIndex] = useState(0);
  const [isPortDropdownOpen, setIsPortDropdownOpen] = useState(false);
  const previewMode = useStore(previewModeStore);

  // Subscribe to streaming phase for building overlay
  const { currentPhase } = useStore(chatStore);

  // Debug logging for phase changes and reset timer when code-writing starts
  useEffect(() => {
    console.log(' [Preview] currentPhase changed to:', currentPhase);

    if (currentPhase === 'code-writing') {
      setBuildStartTime(Date.now());
      setElapsedSeconds(0);
      logger.info('  Build timer reset - code-writing phase started');
    }
  }, [currentPhase]);

  // always start with building status when Preview component mounts
  const [buildStatus, setBuildStatus] = useState<'building' | 'ready'>('building');
  const [buildMessage, setBuildMessage] = useState('Setting up your app...');
  const [buildStartTime, setBuildStartTime] = useState<number>(Date.now());
  const [elapsedSeconds, setElapsedSeconds] = useState(0);
  const [isMonitoring, setIsMonitoring] = useState(true);
  const buildTimeoutRef = useRef<NodeJS.Timeout>();
  const timerIntervalRef = useRef<NodeJS.Timeout>();
  const hasSelectedPreview = useRef(false);
  const previews = useStore(workbenchStore.previews);
  const activePreview = previews[activePreviewIndex];
  const artifacts = useStore(workbenchStore.artifacts);

  const [url, setUrl] = useState('');
  const [iframeUrl, setIframeUrl] = useState<string | undefined>();

  useEffect(() => {
    const current = workbenchStore.isAppReadyForDeploy.get();
    if (activePreview && !current) {
      workbenchStore.isAppReadyForDeploy.set(true);
    } else if (!activePreview && current) {
      workbenchStore.isAppReadyForDeploy.set(false);
    }
  }, [activePreview]);

  useEffect(() => {
    if (!activePreview) {
      setUrl('');
      setIframeUrl(undefined);
      workbenchStore.isAppReadyForDeploy.set(false);

      return;
    }

    const { baseUrl } = activePreview;

    // always update when we have an active preview
    setUrl(baseUrl);
    setIframeUrl(baseUrl);

    setBuildStatus('ready');
    setIsMonitoring(false);

    workbenchStore.isAppReadyForDeploy.set(true);

    // clear timers when preview is ready
    if (buildTimeoutRef.current) {
      clearTimeout(buildTimeoutRef.current);
      buildTimeoutRef.current = undefined;
    }

    if (timerIntervalRef.current) {
      clearInterval(timerIntervalRef.current);
      timerIntervalRef.current = undefined;
    }
  }, [activePreview]); // remove iframeUrl from dependencies to avoid infinite loop

  // timer effect to update elapsed seconds
  useEffect(() => {
    if (buildStatus === 'building') {
      // start the timer
      setElapsedSeconds(0);
      timerIntervalRef.current = setInterval(() => {
        setElapsedSeconds(Math.floor((Date.now() - buildStartTime) / 1000));
      }, 1000);

      return () => {
        if (timerIntervalRef.current) {
          clearInterval(timerIntervalRef.current);
        }
      };
    }

    return () => {
      if (timerIntervalRef.current) {
        clearInterval(timerIntervalRef.current);
      }
    };
  }, [buildStatus, buildStartTime]);

  // monitor action status for better feedback (keeping original logic for loader)
  useEffect(() => {
    // if we don't have a preview yet, we're building
    if (!activePreview && !iframeUrl) {
      setBuildStatus('building');
    }

    const allArtifacts = Object.values(artifacts);

    if (allArtifacts.length === 0) {
      // no artifacts yet but Preview is mounted = build is starting
      return;
    }

    const latestArtifact = allArtifacts[allArtifacts.length - 1];

    if (!latestArtifact?.runner) {
      return;
    }

    const actions = latestArtifact.runner.actions.get();
    const actionsList = Object.values(actions);
    const hasRunning = actionsList.some((a) => a.status === 'running');
    const hasPending = actionsList.some((a) => a.status === 'pending');
    const allComplete =
      actionsList.length > 0 && actionsList.every((a) => a.status === 'complete' || a.status === 'aborted');

    if ((hasRunning || hasPending) && !activePreview) {
      setBuildStatus('building');
    }

    if (allComplete && !activePreview) {
      // all actions complete but no preview - likely port detection issue
      const message = 'Starting development server...';

      setBuildMessage(message);

      // Opportunistically ensure index.html links CSS for correct theming
      (async () => {
        try {
          const { webcontainer } = await import('~/lib/webcontainer');
          const wc = await webcontainer;
          let html = '';
          try {
            html = (await wc.fs.readFile('/index.html', 'utf8')) as unknown as string;
          } catch {
            return; // no index.html created; skip
          }

          const needsBase = !html.includes('<link rel="stylesheet" href="/base.css">');
          const needsStyles =
            !html.includes('<link rel="stylesheet" href="/styles.css">') &&
            !html.includes('href="styles.css"') &&
            !html.includes('href="./styles.css"');
          let needsEnv = false;
          try {
            await wc.fs.readFile('/scripts/env-loader.js', 'utf8');
            needsEnv = !html.includes('/scripts/env-loader.js');
          } catch {}

          if (!needsBase && !needsStyles && !needsEnv) return;

          const insertion = [
            needsBase ? '<link rel="stylesheet" href="/base.css">' : '',
            needsStyles ? '<link rel="stylesheet" href="/styles.css">' : '',
            needsEnv ? '<script type="module" src="/scripts/env-loader.js"></script>' : '',
          ]
            .filter(Boolean)
            .join('\n  ');

          if (html.includes('<head>')) {
            html = html.replace('<head>', `<head>\n  ${insertion}`);
          } else if (html.includes('<html')) {
            html = html.replace(/<html[^>]*>/, (m) => `${m}\n<head>\n  ${insertion}\n</head>`);
          } else {
            html = `${insertion}\n${html}`;
          }

          await wc.fs.writeFile('/index.html', html);
        } catch {
          // ignore
        }
      })();

      if (!buildTimeoutRef.current) {
        buildTimeoutRef.current = setTimeout(() => {
          const timeoutMessage = 'Taking a bit longer than usual...';

          setBuildMessage(timeoutMessage);
        }, 15000); // 15 second grace period
      }
    } else if (actionsList.length > 0) {
      const runningAction = actionsList.find((a) => a.status === 'running');

      if (runningAction) {
        if (runningAction.type === 'shell') {
          // show friendly messages instead of raw commands
          let message = '';

          if (runningAction.content.includes('npm install')) {
            message = 'Installing dependencies...';
          } else if (runningAction.content.includes('vite') || runningAction.content.includes('dev')) {
            message = 'Starting development server...';
          } else {
            message = 'Setting up environment...';
          }

          setBuildMessage(message);
        } else if (runningAction.type === 'file') {
          const message = 'Creating application files...';

          setBuildMessage(message);
        }
      } else {
        // default message when no specific action is running
        const pendingCount = actionsList.filter((a) => a.status === 'pending').length;
        let message = '';

        if (pendingCount > 0) {
          message = `Processing ${pendingCount} remaining tasks...`;
        } else {
          message = 'Finalizing setup...';
        }

        setBuildMessage(message);
      }
    }
  }, [artifacts, activePreview, buildStatus, isMonitoring, iframeUrl]);

  useEffect(() => {
    setBuildStartTime(Date.now());
  }, []);

  useEffect(() => {
    if (previews.length > 0 && activePreview) {
      workbenchStore.isAppReadyForDeploy.set(true);
      setBuildStatus('ready');
    }
  }, [previews.length]);

  const validateUrl = useCallback(
    (value: string) => {
      if (!activePreview) {
        return false;
      }

      const { baseUrl } = activePreview;

      if (value === baseUrl) {
        return true;
      } else if (value.startsWith(baseUrl)) {
        return ['/', '?', '#'].includes(value.charAt(baseUrl.length));
      }

      return false;
    },
    [activePreview],
  );

  const findMinPortIndex = useCallback(
    (minIndex: number, preview: { port: number }, index: number, array: { port: number }[]) => {
      return preview.port < array[minIndex].port ? index : minIndex;
    },
    [],
  );

  useEffect(() => {
    if (previews.length > 1 && !hasSelectedPreview.current) {
      const minPortIndex = previews.reduce(findMinPortIndex, 0);

      setActivePreviewIndex(minPortIndex);
    }
  }, [previews]);

  const reloadPreview = useCallback(() => {
    if (iframeRef.current) {
      iframeRef.current.src = iframeRef.current.src;
    }
  }, []);

  // Auto-reload preview when files are edited and saved
  useEffect(() => {
    const handleFileUpdate = () => {
      setTimeout(() => {
        reloadPreview();
      }, 500);
    };

    const handleStaticReload = () => {
      // Static servers need immediate reload after file sync from AI
      logger.info('Static reload triggered - reloading preview');
      reloadPreview();
    };

    window.addEventListener('webcontainer:file-updated', handleFileUpdate);
    window.addEventListener('webcontainer:static-reload', handleStaticReload);

    return () => {
      window.removeEventListener('webcontainer:file-updated', handleFileUpdate);
      window.removeEventListener('webcontainer:static-reload', handleStaticReload);
    };
  }, [reloadPreview]);

  return (
    <div className="w-full h-full flex flex-col">
      {isPortDropdownOpen && (
        <div className="z-iframe-overlay w-full h-full absolute" onClick={() => setIsPortDropdownOpen(false)} />
      )}
      <div className="bg-eitherway-elements-background-depth-2 p-2 flex items-center gap-1.5">
        <IconButton icon="i-ph:arrow-clockwise" onClick={reloadPreview} />
        <IconButton
          icon={previewMode === 'mobile' ? 'i-ph:device-mobile' : 'i-ph:desktop'}
          onClick={() => previewModeStore.set(previewMode === 'mobile' ? 'desktop' : 'mobile')}
          title={previewMode === 'mobile' ? 'Switch to Desktop View' : 'Switch to Mobile View'}
        />
        <div
          className="flex items-center gap-1 flex-grow bg-eitherway-elements-preview-addressBar-background border border-eitherway-elements-borderColor text-eitherway-elements-preview-addressBar-text rounded-full px-3 py-1 text-sm hover:bg-eitherway-elements-preview-addressBar-backgroundHover hover:focus-within:bg-eitherway-elements-preview-addressBar-backgroundActive focus-within:bg-eitherway-elements-preview-addressBar-backgroundActive
        focus-within-border-eitherway-elements-borderColorActive focus-within:text-eitherway-elements-preview-addressBar-textActive"
        >
          <input
            ref={inputRef}
            className="w-full bg-transparent outline-none"
            type="text"
            value={url}
            onChange={(event) => {
              setUrl(event.target.value);
            }}
            onKeyDown={(event) => {
              if (event.key === 'Enter' && validateUrl(url)) {
                setIframeUrl(url);

                if (inputRef.current) {
                  inputRef.current.blur();
                }
              }
            }}
          />
        </div>
        {previews.length > 1 && (
          <PortDropdown
            activePreviewIndex={activePreviewIndex}
            setActivePreviewIndex={setActivePreviewIndex}
            isDropdownOpen={isPortDropdownOpen}
            setHasSelectedPreview={(value) => (hasSelectedPreview.current = value)}
            setIsDropdownOpen={setIsPortDropdownOpen}
            previews={previews}
          />
        )}
      </div>
      <div className="flex-1 border-t border-eitherway-elements-borderColor relative">
        {activePreview && iframeUrl ? (
          <>
            {previewMode === 'mobile' ? (
              /* Mobile View - iPhone 17 Pro Max Frame */
              <div className="w-full h-full flex items-center justify-center bg-gray-900 overflow-auto">
                <div className="flex items-center justify-center p-4 min-h-full">
                  <div
                    className="relative bg-black rounded-[3rem] shadow-2xl border-[14px] border-gray-800 flex-shrink-0"
                    style={{
                      width: 'min(430px, calc(100vw - 2rem))',
                      height: 'min(932px, calc(100vh - 200px))',
                    }}
                  >
                    {/* Notch */}
                    <div className="absolute top-0 left-1/2 -translate-x-1/2 w-40 h-7 bg-black rounded-b-3xl z-10"></div>

                    {/* Screen */}
                    <div className="absolute inset-0 overflow-hidden rounded-[2.5rem]">
                      <iframe
                        ref={iframeRef}
                        className="border-none w-full h-full"
                        src={iframeUrl}
                        title="App Preview"
                        sandbox="allow-scripts allow-same-origin allow-forms allow-popups allow-modals allow-downloads allow-presentation allow-popups-to-escape-sandbox"
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; fullscreen; gyroscope; picture-in-picture; web-share"
                      />
                    </div>

                    {/* Home Indicator */}
                    <div className="absolute bottom-2 left-1/2 -translate-x-1/2 w-32 h-1 bg-white/30 rounded-full"></div>
                  </div>
                </div>
              </div>
            ) : (
              /* Desktop View */
              <iframe
                ref={iframeRef}
                className="border-none w-full h-full"
                src={iframeUrl}
                title="App Preview"
                sandbox="allow-scripts allow-same-origin allow-forms allow-popups allow-modals allow-downloads allow-presentation allow-popups-to-escape-sandbox"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; fullscreen; gyroscope; picture-in-picture; web-share"
              />
            )}
            {/* Building overlay when AI is generating code */}
            {(() => {
              const shouldShow = currentPhase === 'code-writing' || currentPhase === 'building';
              console.log(' [Preview Overlay] Should show?', shouldShow, 'Phase:', currentPhase);
              return shouldShow ? (
                <div className="absolute inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-10">
                  <div className="flex flex-col gap-4 items-center">
                    <div className="relative w-12 h-12">
                      <div className="absolute inset-0 border-4 border-white/20 rounded-full"></div>
                      <div className="absolute inset-0 border-4 border-blue-500 rounded-full border-t-transparent animate-spin"></div>
                    </div>
                    <div className="text-white font-medium">
                      {currentPhase === 'code-writing' ? 'Generating code...' : 'Building preview...'}
                    </div>
                  </div>
                </div>
              ) : null;
            })()}
          </>
        ) : (
          <div className="flex flex-col gap-6 w-full h-full justify-center items-center p-8 text-center">
            {buildStatus === 'building' ? (
              <>
                <div className="relative w-16 h-16">
                  <div className="absolute inset-0 border-4 border-gray-200 rounded-full"></div>
                  <div className="absolute inset-0 border-4 border-blue-500 rounded-full border-t-transparent animate-spin"></div>
                </div>
                <div className="flex flex-col gap-2">
                  <div className="font-righteous text-[20px] leading-[100%] text-white">{buildMessage}</div>
                  <div className="text-sm text-gray-500">
                    <span className="tabular-nums">{elapsedSeconds}s</span>
                  </div>
                </div>
                {elapsedSeconds > 30 && (
                  <div className="text-xs text-gray-400 max-w-md mt-2">
                    Great things take time! Your app is being crafted with care.
                  </div>
                )}
              </>
            ) : buildStatus === 'ready' && !activePreview ? (
              <>
                <div className="relative w-16 h-16">
                  <div className="absolute inset-0 border-4 border-green-500 rounded-full flex items-center justify-center">
                    <svg className="w-8 h-8 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
                    </svg>
                  </div>
                </div>
                <div className="font-righteous text-[20px] leading-[100%] text-white">Build Complete!</div>
                <div className="text-sm text-gray-500">Your app is ready to preview</div>
              </>
            ) : null}
          </div>
        )}
      </div>
    </div>
  );
});
</file>

<file path="packages/ui-frontend/app/utils/brandAssetSync.ts">
/**
 * Brand Asset Synchronization to WebContainer
 * Mirrors uploaded brand assets (logos, fonts, etc.) into WebContainer filesystem
 */

import type { WebContainer } from '@webcontainer/api';
import { createScopedLogger } from './logger';
import { BACKEND_URL } from '~/config/api';

const logger = createScopedLogger('BrandAssetSync');

interface BrandAsset {
  id: string;
  fileName: string;
  storageKey: string;
  mimeType: string;
  assetType: string;
  metadata?: { kind?: string };
}

/**
 * Determine WebContainer path based on asset type
 */
function getAssetDestinationPath(asset: BrandAsset): string {
  const kind = asset.metadata?.kind || asset.assetType;
  const fileName = asset.fileName;

  // Map asset kinds to WebContainer paths
  switch (kind) {
    case 'icon':
      // Favicons go to public root
      return `public/${fileName}`;

    case 'logo':
    case 'image':
      // Logos and images go to public/assets
      return `public/assets/${fileName}`;

    case 'font':
      // Fonts go to public/fonts
      return `public/fonts/${fileName}`;

    case 'video':
      // Videos go to public/videos
      return `public/videos/${fileName}`;

    case 'brand_zip':
      // Skip ZIPs - they should be extracted separately
      return '';

    default:
      return `public/brand/${fileName}`;
  }
}

async function fetchBrandAssetFile(storageKey: string): Promise<ArrayBuffer> {
  const response = await fetch(`${BACKEND_URL}/api/brand-assets/download/${encodeURIComponent(storageKey)}`);

  if (!response.ok) {
    throw new Error(`Failed to fetch brand asset: ${response.statusText}`);
  }

  return await response.arrayBuffer();
}

/**
 * Ensure directory exists in WebContainer
 */
async function ensureDirectory(webcontainer: WebContainer, dirPath: string): Promise<void> {
  const parts = dirPath.split('/').filter(Boolean);

  let currentPath = '';
  for (const part of parts) {
    currentPath = currentPath ? `${currentPath}/${part}` : part;

    try {
      await webcontainer.fs.mkdir(currentPath, { recursive: true });
    } catch (error) {
      // Directory might already exist, ignore error
    }
  }
}

/**
 * Convert ArrayBuffer to UTF-8 string (for text files like SVG)
 */
function arrayBufferToString(buffer: ArrayBuffer): string {
  const decoder = new TextDecoder('utf-8');
  return decoder.decode(buffer);
}

/**
 * Sync brand assets to WebContainer filesystem
 */
export async function syncBrandAssetsToWebContainer(
  webcontainer: WebContainer,
  assets: BrandAsset[],
): Promise<{ synced: number; skipped: number; failed: number }> {
  logger.info('Syncing brand assets to WebContainer', assets.length, 'assets');

  let synced = 0;
  let skipped = 0;
  let failed = 0;

  for (const asset of assets) {
    try {
      const destPath = getAssetDestinationPath(asset);

      if (!destPath) {
        logger.debug(`Skipping asset: ${asset.fileName} (no destination)`);
        skipped++;
        continue;
      }

      // Ensure parent directory exists
      const dirPath = destPath.split('/').slice(0, -1).join('/');
      if (dirPath) {
        await ensureDirectory(webcontainer, dirPath);
      }

      // Fetch asset file
      logger.debug(`Fetching brand asset: ${asset.fileName}`);
      const fileBuffer = await fetchBrandAssetFile(asset.storageKey);

      // Determine if file should be stored as text or binary
      const isTextFile = asset.mimeType.includes('svg') || asset.mimeType.includes('text');

      if (isTextFile) {
        // Text file (SVG): write as UTF-8 string
        const textContents = arrayBufferToString(fileBuffer);
        await webcontainer.fs.writeFile(destPath, textContents);
        logger.debug(`Text asset ${asset.fileName}: stored as UTF-8, length: ${textContents.length}`);
      } else {
        // Binary file (PNG, JPEG, fonts, etc.): write as Uint8Array directly
        const binaryContents = new Uint8Array(fileBuffer);
        await webcontainer.fs.writeFile(destPath, binaryContents);

        // Log first bytes for verification
        const firstBytes = binaryContents.slice(0, 8);
        logger.debug(`Binary asset ${asset.fileName}: stored as Uint8Array, size: ${binaryContents.length} bytes`);
        logger.debug(`First bytes (hex): ${Array.from(firstBytes).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);

        // Verify PNG magic number if it's a PNG
        if (asset.mimeType === 'image/png') {
          const pngMagic = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
          const matches = pngMagic.every((byte, i) => binaryContents[i] === byte);
          logger.debug(`PNG magic number check: ${matches ? ' Valid' : ' Invalid'}`);
        }
      }

      logger.info(` Synced brand asset: ${destPath}`);
      synced++;
    } catch (error) {
      logger.error(`Failed to sync asset ${asset.fileName}:`, error);
      failed++;
    }
  }

  logger.info(`Brand asset sync complete: ${synced} synced, ${skipped} skipped, ${failed} failed`);
  return { synced, skipped, failed };
}
</file>

<file path="packages/ui-frontend/app/utils/webcontainerRunner.ts">
/**
 * WebContainer command runner
 * Executes npm install and dev server commands in WebContainer
 */

import type { WebContainer } from '@webcontainer/api';
import { createScopedLogger } from './logger';
import { workbenchStore } from '~/lib/stores/workbench';
import { ensureDevHeaders } from '~/lib/webcontainer/ensure-dev-headers';
import { PREVIEW_REGISTRATION_TIMEOUT_MS, WEBCONTAINER_DEFAULT_PORT } from './constants';
import type { WebContainerProcess, ExtendedWebContainer } from '~/types/webcontainer';
import serverTemplate from '~/templates/webcontainer-server.template.js?raw';

const logger = createScopedLogger('WebContainerRunner');

let devServerProcess: WebContainerProcess | null = null;
let serverRunning = false; // Track if server is already running

/**
 * Register preview URL with fallback if port event doesn't fire
 * WebContainer should automatically emit 'port' events, but this provides a safety net
 */
async function ensurePreviewRegistered(
  webcontainer: WebContainer,
  port: number = WEBCONTAINER_DEFAULT_PORT,
): Promise<void> {
  // Wait for server to start and port event to fire
  await new Promise((resolve) => setTimeout(resolve, PREVIEW_REGISTRATION_TIMEOUT_MS));

  const previews = workbenchStore.previews.get();
  const existingPreview = previews.find((p) => p.port === port);

  if (existingPreview) {
    logger.info(` Preview already registered for port ${port} via port event`);
    return;
  }

  // Port event didn't fire, try manual registration
  logger.warn(` Port event didn't fire for port ${port}, attempting manual registration...`);

  try {
    // Try to get server URL - WebContainer exposes this through the origin property
    const wcExtended = webcontainer as ExtendedWebContainer;
    let url: string | undefined;

    // Try different methods to get the URL
    if (typeof wcExtended.origin === 'string') {
      url = wcExtended.origin;
      logger.debug('Got URL from webcontainer.origin:', url);
    } else if (typeof wcExtended.serverOrigin === 'string') {
      url = wcExtended.serverOrigin;
      logger.debug('Got URL from webcontainer.serverOrigin:', url);
    }

    if (url) {
      workbenchStore.registerPreview(port, url);
      logger.info(` Preview manually registered at ${url}`);
    } else {
      logger.error(' Could not determine WebContainer URL - preview may not load');
      logger.error(
        '   WebContainer properties:',
        Object.keys(wcExtended as any).filter((k) => !k.startsWith('_')),
      );
    }
  } catch (error) {
    logger.error(' Error during manual preview registration:', error);
  }
}

async function fileExists(webcontainer: WebContainer, filePath: string): Promise<boolean> {
  try {
    await webcontainer.fs.readFile(filePath, 'utf8');
    return true;
  } catch {
    return false;
  }
}

/**
 * Find package.json in the file tree
 */
function findPackageJson(files: any[]): any | null {
  for (const file of files) {
    if (file.type === 'file' && file.name === 'package.json') {
      return file;
    }
    if (file.type === 'directory' && file.children) {
      const found = findPackageJson(file.children);
      if (found) return found;
    }
  }
  return null;
}

/**
 * Find index.html in the file tree
 */
function findIndexHtml(files: any[]): any | null {
  for (const file of files) {
    if (file.type === 'file' && file.name === 'index.html') {
      return file;
    }
    if (file.type === 'directory' && file.children) {
      const found = findIndexHtml(file.children);
      if (found) return found;
    }
  }
  return null;
}

/**
 * Find any HTML file in the file tree
 */
function findAnyHtmlFile(files: any[]): any | null {
  for (const file of files) {
    if (file.type === 'file' && file.name.toLowerCase().endsWith('.html')) {
      return file;
    }
    if (file.type === 'directory' && file.children) {
      const found = findAnyHtmlFile(file.children);
      if (found) return found;
    }
  }
  return null;
}

// REMOVED: No proxy plugin needed - external resources load directly with COEP headers

/**
 * Start a static server for simple HTML apps with proxy endpoints and binary file handling
 */
async function startStaticServer(
  webcontainer: WebContainer,
  baseDir: string = '.',
  htmlFileName: string = 'index.html',
): Promise<void> {
  logger.info('Starting static server for directory:', baseDir, 'HTML file:', htmlFileName);

  // Load server template and replace placeholders
  const serverScript = serverTemplate
    .replace(/__BASE_DIR__/g, baseDir)
    .replace(/__HTML_FILE__/g, htmlFileName)
    .replace(/__PORT__/g, String(WEBCONTAINER_DEFAULT_PORT));

  /* OLD EMBEDDED SERVER - NOW EXTRACTED TO TEMPLATE FILE
  const serverScript = `
const http = require('http');
const fs = require('fs');
const path = require('path');

const BASE_DIR = '${baseDir}';
const PORT = ${WEBCONTAINER_DEFAULT_PORT};
const DEFAULT_FILE = '${htmlFileName}';

const mimeTypes = {
  '.html': 'text/html; charset=utf-8',
  '.css': 'text/css; charset=utf-8',
  '.js': 'application/javascript; charset=utf-8',
  '.mjs': 'application/javascript; charset=utf-8',
  '.json': 'application/json; charset=utf-8',
  '.png': 'image/png',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.webp': 'image/webp',
  '.gif': 'image/gif',
  '.svg': 'image/svg+xml',
  '.ico': 'image/x-icon',
  '.bmp': 'image/bmp',
  '.woff': 'font/woff',
  '.woff2': 'font/woff2',
  '.ttf': 'font/ttf',
};

const server = http.createServer(async (req, res) => {
  const url = new URL(req.url, \`http://localhost:\${PORT}\`);

  // Regular static file serving - no proxying, external resources load directly
  let reqPath = url.pathname === '/' ? DEFAULT_FILE : url.pathname;
  // Strip leading slashes to ensure relative paths for WebContainer
  reqPath = reqPath.replace(/^\\/+/, '');

  // If the request targets a conventional top-level static dir, resolve from project root
  // This ensures paths like "/public/*" work even when index.html is nested (e.g., src/index.html)
  const topDir = reqPath.split('/')[0];
  const treatAsRoot = ['public', 'assets', 'static', 'images', 'media'].includes(topDir);

  const filePath = (BASE_DIR === '.' || treatAsRoot)
    ? reqPath
    : path.join(BASE_DIR, reqPath);
  const extname = path.extname(filePath);
  const contentType = mimeTypes[extname] || 'application/octet-stream';

  console.log('[Server] Request:', req.url, '-> File:', filePath);

  const tryServeFile = (attemptPath, isRetry) => {
    fs.readFile(attemptPath, (error, content) => {
      if (error) {
        if (!isRetry && (contentType.startsWith('image/') || contentType.startsWith('video/') || contentType.startsWith('audio/'))) {
          const filename = path.basename(filePath);
          const roots = ['public', 'assets', 'images', 'media', 'static'];
          const fallbackPaths = [
            // Prefer project-root fallbacks first
            ...roots.map(dir => path.join(dir, filename)),
            // Then try baseDir fallbacks (for nested setups)
            ...roots.map(dir => BASE_DIR === '.' ? path.join(dir, filename) : path.join(BASE_DIR, dir, filename))
          ];

          const tryNext = (index) => {
            if (index >= fallbackPaths.length) {
              console.error('[Server] Error: File not found after fallback search:', filePath);
              res.writeHead(404, { 'Access-Control-Allow-Origin': '*' });
              res.end('File not found: ' + filePath);
              return;
            }

            fs.readFile(fallbackPaths[index], (err, data) => {
              if (!err) {
                console.log('[Server] Found file at fallback path:', fallbackPaths[index]);
                res.writeHead(200, {
                  'Content-Type': contentType,
                  'Access-Control-Allow-Origin': '*',
                  'Cross-Origin-Resource-Policy': 'cross-origin'
                });
                res.end(data);
              } else {
                tryNext(index + 1);
              }
            });
          };

          tryNext(0);
        } else {
          console.error('[Server] Error:', error.message);
          res.writeHead(404, { 'Access-Control-Allow-Origin': '*' });
          res.end('File not found: ' + attemptPath);
        }
      } else {
        const ct = contentType.toLowerCase();
        const isBinaryContent = ct.startsWith('image/') ||
                               ct.startsWith('video/') ||
                               ct.startsWith('audio/') ||
                               ct === 'application/octet-stream';

        console.log('[Server] Serving file:', attemptPath,
                   'Type:', contentType,
                   'Binary:', isBinaryContent,
                   'Content type:', content.constructor.name,
                   'Length:', content.length);

        const contentStr = content.toString('utf-8');
        let bodyBuf;

        if (contentStr.startsWith('__BASE64__')) {
          // Decode base64 to binary Buffer
          const base64Data = contentStr.substring(10); // Remove __BASE64__ prefix
          console.log('[Server] Detected base64 marker, decoding...');
          bodyBuf = Buffer.from(base64Data, 'base64');
          console.log('[Server] Decoded from base64, buffer length:', bodyBuf.length);
        } else {
          // Regular content
          bodyBuf = Buffer.isBuffer(content) ? content : Buffer.from(content);
        }

        const headers = {
          'Content-Type': contentType,
          'Access-Control-Allow-Origin': '*',
          'Cross-Origin-Resource-Policy': 'cross-origin',
          'X-Content-Type-Options': 'nosniff',
          'Cache-Control': 'no-store',
          'Content-Length': String(bodyBuf.length),
        };

        res.writeHead(200, headers);

        if (isBinaryContent) {
          // Debug: log magic bytes for verification
          try {
            const head = Array.from(bodyBuf.slice(0, 8))
              .map(b => b.toString(16).padStart(2, '0')).join(' ');
            console.log('[Server] Binary head:', head);
          } catch {}
          res.end(bodyBuf);
        } else {
          res.end(bodyBuf.toString('utf-8'));
        }
      }
    });
  };

  tryServeFile(filePath, false);
});

server.listen(PORT, () => {
  console.log('[Server] Static server with proxy running on port ' + PORT);
});
`;
  */ // END OLD EMBEDDED SERVER

  // Write the server script
  await webcontainer.fs.writeFile('server.js', serverScript);

  // Kill any existing dev server
  if (devServerProcess) {
    try {
      devServerProcess.kill();
    } catch (error) {
      logger.debug('Error killing previous server:', error);
    }
    devServerProcess = null;
  }

  // Start the static server
  devServerProcess = await webcontainer.spawn('node', ['server.js']);

  devServerProcess.output.pipeTo(
    new WritableStream({
      write(data) {
        logger.debug('[Static Server]', data);
      },
    }),
  );

  logger.info('Static server process started');

  // Ensure preview is registered (fallback if port event doesn't fire)
  ensurePreviewRegistered(webcontainer).catch((error) => {
    logger.error('Failed to ensure preview registration:', error);
  });
}

/**
 * Run npm install and start dev server in WebContainer
 */
export async function runDevServer(webcontainer: WebContainer, files: any[]): Promise<void> {
  logger.info('Running dev server setup...');

  const hasPackageJson = findPackageJson(files);
  const isStaticServer = !hasPackageJson;

  // For npm-based apps with HMR, skip restart if already running
  // For static servers, we need to trigger a preview reload since they don't have HMR
  if (serverRunning && !isStaticServer) {
    logger.info('Server already running - skipping restart, files will hot-reload automatically');
    return;
  }

  // For static servers, trigger preview reload after files sync
  if (serverRunning && isStaticServer) {
    logger.info('Static server running - files synced, triggering preview reload');
    // Dispatch event to trigger iframe reload
    if (typeof window !== 'undefined') {
      window.dispatchEvent(new CustomEvent('webcontainer:static-reload'));
    }
    return;
  }

  const hasIndexHtml = findIndexHtml(files);
  const anyHtmlFile = !hasIndexHtml ? findAnyHtmlFile(files) : null;

  logger.debug('File detection:', {
    hasPackageJson: !!hasPackageJson,
    hasIndexHtml: !!hasIndexHtml,
    anyHtmlFile: anyHtmlFile?.path,
    packageJsonPath: hasPackageJson?.path,
    indexHtmlPath: hasIndexHtml?.path,
  });

  // Kill any existing dev server first (only on initial start)
  if (devServerProcess) {
    try {
      devServerProcess.kill();
      logger.info('Killed previous dev server');
    } catch (error) {
      logger.debug('Error killing previous server:', error);
    }
    devServerProcess = null;
    serverRunning = false;
  }

  if (hasPackageJson) {
    try {
      // Set up COEP headers (must run first to create vite.config if needed)
      await ensureDevHeaders(webcontainer);

      // No proxy setup needed - external resources load directly with COEP headers

      logger.info('Installing dependencies...');

      // Run npm install
      const installProcess = await webcontainer.spawn('npm', ['install']);

      installProcess.output.pipeTo(
        new WritableStream({
          write(data) {
            logger.debug('[npm install]', data);
          },
        }),
      );

      const installExitCode = await installProcess.exit;
      logger.info(`npm install completed with exit code ${installExitCode}`);

      if (installExitCode !== 0) {
        logger.error('npm install failed');
        return;
      }

      // Start dev server
      logger.info('Starting dev server...');
      devServerProcess = await webcontainer.spawn('npm', ['run', 'dev']);

      devServerProcess.output.pipeTo(
        new WritableStream({
          write(data) {
            logger.debug('[npm run dev]', data);
          },
        }),
      );

      serverRunning = true; // Mark server as running
      logger.info('Dev server started successfully');

      // Ensure preview is registered (fallback if port event doesn't fire)
      ensurePreviewRegistered(webcontainer).catch((error) => {
        logger.error('Failed to ensure preview registration:', error);
      });
    } catch (error) {
      logger.error('Failed to start dev server:', error);
      serverRunning = false;
    }
  } else if (hasIndexHtml || anyHtmlFile) {
    // For simple HTML apps, start a static server
    const htmlFile = hasIndexHtml || anyHtmlFile;
    const indexPath = htmlFile!.path;

    // Normalize path: strip leading slashes for baseDir calculation
    const normalizedPath = indexPath.replace(/^\/+/, '');

    let baseDir = '.';
    if (normalizedPath.includes('/')) {
      const lastSlash = normalizedPath.lastIndexOf('/');
      baseDir = normalizedPath.substring(0, lastSlash);
    }

    // Extract the HTML filename for the default route
    const htmlFileName = normalizedPath.includes('/')
      ? normalizedPath.substring(normalizedPath.lastIndexOf('/') + 1)
      : normalizedPath;

    logger.debug('Static server config:', {
      indexPath,
      normalizedPath,
      baseDir,
      htmlFileName,
    });

    try {
      await startStaticServer(webcontainer, baseDir, htmlFileName);
      serverRunning = true; // Mark server as running
    } catch (error) {
      logger.error('Failed to start static server:', error);
      serverRunning = false;
    }
  } else {
    logger.warn('No package.json or HTML file found - cannot start preview');
  }
}

/**
 * Stop the currently running dev server
 */
export function stopDevServer(): void {
  if (devServerProcess) {
    try {
      devServerProcess.kill();
      logger.info('Dev server stopped');
    } catch (error) {
      logger.error('Failed to stop dev server:', error);
    }
    devServerProcess = null;
    serverRunning = false;
  }
}

/**
 * Reset server state - call when starting a new conversation
 * This ensures the next app creation will start a fresh server
 */
export function resetServerState(): void {
  logger.info('Resetting server state for new conversation');
  serverRunning = false;

  // Stop any running server process
  if (devServerProcess) {
    try {
      devServerProcess.kill();
      logger.debug('Killed existing dev server process');
    } catch (error) {
      logger.debug('Error killing dev server (may already be stopped):', error);
    }
    devServerProcess = null;
  }
}
</file>

<file path="packages/ui-server/src/events/send.ts">
import type { WebSocket } from 'ws';
import { safeValidateStreamEvent, type StreamEvent } from './types.js';
import { logStreamEvent } from './logger.js';

/**
 * Centralized event sender with validation and logging
 */
export function sendStreamEvent(
  socket: WebSocket,
  event: StreamEvent,
  options?: {
    skipValidation?: boolean;
    skipLogging?: boolean;
  },
): boolean {
  const { skipValidation = false, skipLogging = false } = options || {};

  // Validate event schema
  if (!skipValidation) {
    const validation = safeValidateStreamEvent(event);
    if (!validation.success) {
      console.error('[StreamEvent] Validation failed:', {
        event,
        errors: validation.error.errors,
      });
      return false;
    }
  }

  // Check socket state
  if (socket.readyState !== 1) {
    // WebSocket.OPEN
    console.warn('[StreamEvent] Socket not open, cannot send event:', event.kind);
    return false;
  }

  // Log event (for observability)
  if (!skipLogging) {
    logStreamEvent('outbound', event);
  }

  // Send event
  try {
    socket.send(JSON.stringify(event));
    return true;
  } catch (error) {
    console.error('[StreamEvent] Failed to send:', error);
    return false;
  }
}

/**
 * Batch send multiple events
 */
export function sendStreamEvents(socket: WebSocket, events: StreamEvent[]): number {
  let sent = 0;
  for (const event of events) {
    if (sendStreamEvent(socket, event)) {
      sent++;
    }
  }
  return sent;
}

/**
 * Create a scoped sender for a specific connection/request
 */
export function createEventSender(socket: WebSocket, requestId?: string) {
  return {
    send(event: StreamEvent) {
      // Inject requestId if provided
      const eventWithId = requestId ? { ...event, requestId } : event;
      return sendStreamEvent(socket, eventWithId);
    },
    sendRaw(event: StreamEvent) {
      return sendStreamEvent(socket, event, { skipValidation: true, skipLogging: true });
    },
  };
}
</file>

<file path="packages/ui-server/src/events/types.ts">
import { z } from 'zod';

/**
 * Shared streaming protocol types
 * These types define the contract between server and client for real-time streaming
 */

// Base event with common fields
const BaseEventSchema = z.object({
  ts: z.number(), // Timestamp in ms
  requestId: z.string().optional(), // Request correlation ID
});

// Stream lifecycle events
const StreamStartEventSchema = BaseEventSchema.extend({
  kind: z.literal('stream_start'),
  messageId: z.string(),
});

const StreamEndEventSchema = BaseEventSchema.extend({
  kind: z.literal('stream_end'),
  messageId: z.string(),
  usage: z
    .object({
      inputTokens: z.number(),
      outputTokens: z.number(),
    })
    .optional(),
});

// Content delta event
const DeltaEventSchema = BaseEventSchema.extend({
  kind: z.literal('delta'),
  messageId: z.string(),
  text: z.string(),
});

// Phase transition event
const PhaseEventSchema = BaseEventSchema.extend({
  kind: z.literal('phase'),
  messageId: z.string(),
  name: z.enum(['pending', 'thinking', 'reasoning', 'code-writing', 'building', 'completed']),
});

// Thinking complete event (with duration)
const ThinkingCompleteEventSchema = BaseEventSchema.extend({
  kind: z.literal('thinking_complete'),
  messageId: z.string(),
  durationSeconds: z.number(),
});

// Reasoning content event (the plan/approach text)
const ReasoningEventSchema = BaseEventSchema.extend({
  kind: z.literal('reasoning'),
  messageId: z.string(),
  text: z.string(),
});

// File operation event (grouped by file, deduplicated, with progressive states)
const FileOperationEventSchema = BaseEventSchema.extend({
  kind: z.literal('file_operation'),
  messageId: z.string(),
  operation: z.enum(['creating', 'editing', 'created', 'edited']),
  filePath: z.string(),
});

// Tool execution event
const ToolEventSchema = BaseEventSchema.extend({
  kind: z.literal('tool'),
  event: z.enum(['start', 'end']),
  toolName: z.string(),
  toolUseId: z.string().optional(),
  messageId: z.string().optional(),
  filePath: z.string().optional(), // File being operated on
});

// Files updated event
const FilesUpdatedEventSchema = BaseEventSchema.extend({
  kind: z.literal('files_updated'),
  files: z.array(z.any()),
  sessionId: z.string().optional(),
});

// Error event
const ErrorEventSchema = BaseEventSchema.extend({
  kind: z.literal('error'),
  message: z.string(),
  code: z.string().optional(),
  details: z.any().optional(),
});

// Status event (legacy compatibility)
const StatusEventSchema = BaseEventSchema.extend({
  kind: z.literal('status'),
  message: z.string(),
});

// Response event (legacy compatibility)
const ResponseEventSchema = BaseEventSchema.extend({
  kind: z.literal('response'),
  content: z.string(),
  messageId: z.string().optional(),
});

// Union of all stream events
export const StreamEventSchema = z.discriminatedUnion('kind', [
  StreamStartEventSchema,
  DeltaEventSchema,
  PhaseEventSchema,
  ThinkingCompleteEventSchema,
  ReasoningEventSchema,
  FileOperationEventSchema,
  ToolEventSchema,
  StreamEndEventSchema,
  FilesUpdatedEventSchema,
  ErrorEventSchema,
  StatusEventSchema,
  ResponseEventSchema,
]);

// TypeScript types derived from schemas
export type StreamEvent = z.infer<typeof StreamEventSchema>;
export type StreamStartEvent = z.infer<typeof StreamStartEventSchema>;
export type DeltaEvent = z.infer<typeof DeltaEventSchema>;
export type PhaseEvent = z.infer<typeof PhaseEventSchema>;
export type ThinkingCompleteEvent = z.infer<typeof ThinkingCompleteEventSchema>;
export type ReasoningEvent = z.infer<typeof ReasoningEventSchema>;
export type FileOperationEvent = z.infer<typeof FileOperationEventSchema>;
export type ToolEvent = z.infer<typeof ToolEventSchema>;
export type StreamEndEvent = z.infer<typeof StreamEndEventSchema>;
export type FilesUpdatedEvent = z.infer<typeof FilesUpdatedEventSchema>;
export type ErrorEvent = z.infer<typeof ErrorEventSchema>;
export type StatusEvent = z.infer<typeof StatusEventSchema>;
export type ResponseEvent = z.infer<typeof ResponseEventSchema>;

/**
 * Validate and parse a stream event
 * @throws {z.ZodError} if validation fails
 */
export function validateStreamEvent(data: unknown): StreamEvent {
  return StreamEventSchema.parse(data);
}

/**
 * Safe validation that returns a result
 */
export function safeValidateStreamEvent(
  data: unknown,
): { success: true; data: StreamEvent } | { success: false; error: z.ZodError } {
  const result = StreamEventSchema.safeParse(data);
  if (result.success) {
    return { success: true, data: result.data };
  }
  return { success: false, error: result.error };
}

/**
 * Event builder helpers for type safety
 */
export const StreamEvents = {
  streamStart(messageId: string, requestId?: string): StreamStartEvent {
    return {
      kind: 'stream_start',
      messageId,
      ts: Date.now(),
      requestId,
    };
  },

  delta(messageId: string, text: string, requestId?: string): DeltaEvent {
    return {
      kind: 'delta',
      messageId,
      text,
      ts: Date.now(),
      requestId,
    };
  },

  phase(messageId: string, name: PhaseEvent['name'], requestId?: string): PhaseEvent {
    return {
      kind: 'phase',
      messageId,
      name,
      ts: Date.now(),
      requestId,
    };
  },

  toolStart(
    toolName: string,
    toolUseId?: string,
    messageId?: string,
    filePath?: string,
    requestId?: string,
  ): ToolEvent {
    return {
      kind: 'tool',
      event: 'start',
      toolName,
      toolUseId,
      messageId,
      filePath,
      ts: Date.now(),
      requestId,
    };
  },

  toolEnd(toolName: string, toolUseId?: string, messageId?: string, filePath?: string, requestId?: string): ToolEvent {
    return {
      kind: 'tool',
      event: 'end',
      toolName,
      toolUseId,
      messageId,
      filePath,
      ts: Date.now(),
      requestId,
    };
  },

  streamEnd(
    messageId: string,
    usage?: { inputTokens: number; outputTokens: number },
    requestId?: string,
  ): StreamEndEvent {
    return {
      kind: 'stream_end',
      messageId,
      usage,
      ts: Date.now(),
      requestId,
    };
  },

  filesUpdated(files: any[], sessionId?: string, requestId?: string): FilesUpdatedEvent {
    return {
      kind: 'files_updated',
      files,
      sessionId,
      ts: Date.now(),
      requestId,
    };
  },

  error(message: string, code?: string, details?: any, requestId?: string): ErrorEvent {
    return {
      kind: 'error',
      message,
      code,
      details,
      ts: Date.now(),
      requestId,
    };
  },

  status(message: string, requestId?: string): StatusEvent {
    return {
      kind: 'status',
      message,
      ts: Date.now(),
      requestId,
    };
  },

  response(content: string, messageId?: string, requestId?: string): ResponseEvent {
    return {
      kind: 'response',
      content,
      messageId,
      ts: Date.now(),
      requestId,
    };
  },

  thinkingComplete(messageId: string, durationSeconds: number, requestId?: string): ThinkingCompleteEvent {
    return {
      kind: 'thinking_complete',
      messageId,
      durationSeconds,
      ts: Date.now(),
      requestId,
    };
  },

  reasoning(messageId: string, text: string, requestId?: string): ReasoningEvent {
    return {
      kind: 'reasoning',
      messageId,
      text,
      ts: Date.now(),
      requestId,
    };
  },

  fileOperation(
    messageId: string,
    operation: 'creating' | 'editing' | 'created' | 'edited',
    filePath: string,
    requestId?: string,
  ): FileOperationEvent {
    return {
      kind: 'file_operation',
      messageId,
      operation,
      filePath,
      ts: Date.now(),
      requestId,
    };
  },
};
</file>

<file path="packages/ui-server/src/routes/deployments.ts">
/**
 * Deployment & Export API Routes
 *
 * Endpoints:
 * - POST   /api/apps/:appId/deploy/github-pages     - Deploy to GitHub Pages
 * - GET    /api/apps/:appId/deploy/history          - Get deployment history
 * - GET    /api/apps/:appId/deploy/:id              - Get deployment details
 * - GET    /api/apps/:appId/deploy/:id/logs         - Get deployment logs
 * - DELETE /api/apps/:appId/deploy/:id              - Cancel deployment
 *
 * - POST   /api/apps/:appId/export                  - Create ZIP export
 * - GET    /api/apps/:appId/export/history          - Get export history
 * - GET    /api/apps/:appId/export/:id/download     - Download export
 */

import type { FastifyInstance } from 'fastify';
import type { DatabaseClient } from '@eitherway/database';
import {
  DeploymentsRepository,
  ExportsRepository,
  DeploymentService,
  ExportService,
  PostgresFileStore,
  type DeploymentConfig,
  type ExportConfig
} from '@eitherway/database';
import { join } from 'path';

export async function registerDeploymentRoutes(
  fastify: FastifyInstance,
  db: DatabaseClient,
  workspaceDir: string
) {
  const deploymentsRepo = new DeploymentsRepository(db);
  const exportsRepo = new ExportsRepository(db);
  const deploymentService = new DeploymentService(db);
  const fileStore = new PostgresFileStore(db);
  const exportService = new ExportService(db, fileStore);

  // DEPLOYMENT ROUTES

  /**
   * POST /api/apps/:appId/deploy/github-pages
   * Deploy app to GitHub Pages
   */
  fastify.post<{
    Params: { appId: string };
    Body: {
      userId: string;
      sessionId?: string;
      repositoryUrl: string;
      branch?: string;
      buildCommand?: string;
      outputDirectory?: string;
      environmentVars?: Record<string, string>;
    };
  }>('/api/apps/:appId/deploy/github-pages', async (request, reply) => {
    const { appId } = request.params;
    const {
      userId,
      sessionId,
      repositoryUrl,
      branch,
      buildCommand,
      outputDirectory,
      environmentVars
    } = request.body;

    if (!repositoryUrl) {
      return reply.code(400).send({
        success: false,
        error: 'Missing required field: repositoryUrl'
      });
    }

    try {
      const config: DeploymentConfig = {
        appId,
        userId,
        sessionId,
        repositoryUrl,
        branch,
        buildCommand,
        outputDirectory,
        environmentVars
      };

      // Start deployment in background
      deploymentService.deployToGitHubPages(config, join(workspaceDir, appId))
        .then(result => {
          console.log(`[Deployment] ${result.status} for app ${appId}:`, result.deploymentUrl || result.error);
        })
        .catch(error => {
          console.error(`[Deployment] Error for app ${appId}:`, error);
        });

      return reply.code(202).send({
        success: true,
        message: 'Deployment started',
        appId
      });

    } catch (error: any) {
      console.error('[Deployment] Error starting deployment:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to start deployment',
        message: error.message
      });
    }
  });

  fastify.get<{
    Params: { appId: string };
    Querystring: { limit?: string };
  }>('/api/apps/:appId/deploy/history', async (request, reply) => {
    const { appId } = request.params;
    const limit = parseInt(request.query.limit || '20', 10);

    try {
      const deployments = await deploymentsRepo.getByAppId(appId, limit);

      return reply.code(200).send({
        success: true,
        deployments
      });
    } catch (error: any) {
      console.error('[Deployment] Error fetching history:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to fetch deployment history',
        message: error.message
      });
    }
  });

  fastify.get<{
    Params: { appId: string; id: string };
  }>('/api/apps/:appId/deploy/:id', async (request, reply) => {
    const { id } = request.params;

    try {
      const deployment = await deploymentsRepo.getById(id);

      if (!deployment) {
        return reply.code(404).send({
          success: false,
          error: 'Deployment not found'
        });
      }

      return reply.code(200).send({
        success: true,
        deployment
      });
    } catch (error: any) {
      console.error('[Deployment] Error fetching deployment:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to fetch deployment',
        message: error.message
      });
    }
  });

  fastify.get<{
    Params: { appId: string; id: string };
  }>('/api/apps/:appId/deploy/:id/logs', async (request, reply) => {
    const { id } = request.params;

    try {
      const logs = await deploymentsRepo.getLogs(id);

      return reply.code(200).send({
        success: true,
        logs
      });
    } catch (error: any) {
      console.error('[Deployment] Error fetching logs:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to fetch deployment logs',
        message: error.message
      });
    }
  });

  fastify.delete<{
    Params: { appId: string; id: string };
  }>('/api/apps/:appId/deploy/:id', async (request, reply) => {
    const { id } = request.params;

    try {
      const cancelled = await deploymentsRepo.cancel(id);

      if (!cancelled) {
        return reply.code(404).send({
          success: false,
          error: 'Deployment not found or already completed'
        });
      }

      return reply.code(200).send({
        success: true,
        message: 'Deployment cancelled'
      });
    } catch (error: any) {
      console.error('[Deployment] Error cancelling deployment:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to cancel deployment',
        message: error.message
      });
    }
  });

  fastify.get<{
    Params: { appId: string };
  }>('/api/apps/:appId/deploy/summary', async (request, reply) => {
    const { appId } = request.params;

    try {
      const summary = await deploymentsRepo.getSummary(appId);

      if (!summary) {
        return reply.code(404).send({
          success: false,
          error: 'No deployment summary available'
        });
      }

      return reply.code(200).send({
        success: true,
        summary
      });
    } catch (error: any) {
      console.error('[Deployment] Error fetching summary:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to fetch deployment summary',
        message: error.message
      });
    }
  });

  // EXPORT ROUTES

  /**
   * POST /api/apps/:appId/export
   * Create ZIP export (appId can be sessionId or actual appId)
   */
  fastify.post<{
    Params: { appId: string };
    Body: {
      userId: string;
      sessionId?: string;
      includeNodeModules?: boolean;
      includeGitHistory?: boolean;
      excludePatterns?: string[];
    };
  }>('/api/apps/:appId/export', async (request, reply) => {
    let { appId } = request.params;
    const {
      userId,
      sessionId,
      includeNodeModules,
      includeGitHistory,
      excludePatterns
    } = request.body;

    try {
      // If appId looks like a session ID or doesn't exist, get it from session
      const { SessionsRepository } = await import('@eitherway/database');
      const sessionsRepo = new SessionsRepository(db);

      const sessionToUse = sessionId || appId;
      const session = await sessionsRepo.findById(sessionToUse);

      let actualUserId = userId;

      if (session && session.app_id) {
        appId = session.app_id;
        // Use the session's user_id if available (it's a proper UUID)
        if (session.user_id) {
          actualUserId = session.user_id;
        }
        console.log(`[Export] Using app_id ${appId} from session ${sessionToUse}`);
      } else if (!session) {
        // Try to use appId directly if it's an actual app ID
        console.log(`[Export] Using appId ${appId} directly`);
      } else {
        return reply.code(400).send({
          success: false,
          error: 'No files found',
          message: 'Session has no associated app or files'
        });
      }

      const config: ExportConfig = {
        appId,
        userId: actualUserId,
        sessionId: sessionToUse,
        exportType: 'zip',
        includeNodeModules,
        includeGitHistory,
        excludePatterns
      };

      const { buffer, exportId, stats } = await exportService.createZipExport(config);

      reply.header('Content-Type', 'application/zip');
      reply.header('Content-Disposition', `attachment; filename="app-${appId}-${Date.now()}.zip"`);
      reply.header('Content-Length', buffer.length.toString());
      reply.header('X-Export-Id', exportId);
      reply.header('X-File-Count', stats.fileCount.toString());
      reply.header('X-Total-Size', stats.totalSizeBytes.toString());

      await exportsRepo.trackDownload(exportId);

      return reply.send(buffer);

    } catch (error: any) {
      console.error('[Export] Error creating export:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to create export',
        message: error.message
      });
    }
  });

  fastify.get<{
    Params: { appId: string };
    Querystring: { limit?: string };
  }>('/api/apps/:appId/export/history', async (request, reply) => {
    const { appId } = request.params;
    const limit = parseInt(request.query.limit || '20', 10);

    try {
      const exports = await exportsRepo.getByAppId(appId, limit);

      return reply.code(200).send({
        success: true,
        exports
      });
    } catch (error: any) {
      console.error('[Export] Error fetching history:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to fetch export history',
        message: error.message
      });
    }
  });

  fastify.get<{
    Params: { appId: string };
  }>('/api/apps/:appId/export/statistics', async (request, reply) => {
    const { appId } = request.params;

    try {
      const statistics = await exportsRepo.getStatistics(appId);

      if (!statistics) {
        return reply.code(404).send({
          success: false,
          error: 'No export statistics available'
        });
      }

      return reply.code(200).send({
        success: true,
        statistics
      });
    } catch (error: any) {
      console.error('[Export] Error fetching statistics:', error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to fetch export statistics',
        message: error.message
      });
    }
  });

  console.log('[Deployment] Routes registered successfully');
}
</file>

<file path=".env.example">
# Anthropic API Key
ANTHROPIC_API_KEY=your_anthropic_api_key_here

# OpenAI API Key (for image generation)
OPENAI_API_KEY=your_openai_api_key_here

# CoinGecko API Keys (for crypto price data)
# Demo API: https://www.coingecko.com/en/api/pricing
COINGECKO_DEMO_API_KEY=
# Pro API (optional): https://www.coingecko.com/en/api/pricing
COINGECKO_PRO_API_KEY=

# PostgreSQL Configuration
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_DB=eitherway
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_MAX_CONNECTIONS=20

# Server Configuration
PORT=3001
WORKSPACE_DIR=./workspace

# Environment
NODE_ENV=development
</file>

<file path="packages/runtime/src/model-client.ts">
/**
 * Model Client for Claude Sonnet 4.5 with streaming support
 */

import Anthropic from '@anthropic-ai/sdk';
import { ClaudeConfig, Message, ToolDefinition } from '@eitherway/tools-core';

export interface StreamDelta {
  type: 'text' | 'tool_use';
  content: string;
  toolUseId?: string;
  toolName?: string;
}

export interface ModelResponse {
  id: string;
  role: 'assistant';
  content: Array<{
    type: 'text' | 'tool_use' | 'server_tool_use' | 'web_search_tool_result';
    text?: string;
    id?: string;
    name?: string;
    input?: Record<string, any>;
    tool_use_id?: string;
    content?: any;
  }>;
  stopReason: string | null;
  usage: {
    inputTokens: number;
    outputTokens: number;
    serverToolUse?: {
      webSearchRequests?: number;
    };
  };
}

export class ModelClient {
  private client: Anthropic;
  private config: ClaudeConfig;

  constructor(config: ClaudeConfig) {
    this.config = config;

    if (config.provider === 'anthropic') {
      this.client = new Anthropic({
        apiKey: config.apiKey,
        baseURL: config.providerConfig?.anthropic?.baseURL,
      });
    } else {
      throw new Error(`Provider ${config.provider} not yet implemented. Use 'anthropic' for Portion 1.`);
    }
  }

  /**
   * Send a message with optional streaming
   */
  async sendMessage(
    messages: Message[],
    systemPrompt: string,
    tools: ToolDefinition[],
    options?: {
      onDelta?: (delta: StreamDelta) => void;
      onComplete?: (response: ModelResponse) => void;
      webSearchConfig?: {
        enabled: boolean;
        maxUses?: number;
        allowedDomains?: string[];
        blockedDomains?: string[];
      };
    },
  ): Promise<ModelResponse> {
    const allTools: any[] = [...tools];

    if (options?.webSearchConfig?.enabled) {
      const webSearchTool: any = {
        type: 'web_search_20250305',
        name: 'web_search',
      };

      if (options.webSearchConfig.maxUses !== undefined) {
        webSearchTool.max_uses = options.webSearchConfig.maxUses;
      }

      if (options.webSearchConfig.allowedDomains && options.webSearchConfig.allowedDomains.length > 0) {
        webSearchTool.allowed_domains = options.webSearchConfig.allowedDomains;
      }

      if (options.webSearchConfig.blockedDomains && options.webSearchConfig.blockedDomains.length > 0) {
        webSearchTool.blocked_domains = options.webSearchConfig.blockedDomains;
      }

      allTools.push(webSearchTool);
    }

    const params: Anthropic.MessageCreateParams = {
      model: this.config.model,
      max_tokens: this.config.maxTokens,
      system: systemPrompt,
      messages: this.convertMessages(messages),
      tools: allTools,
    };

    // Claude 4.5 doesn't allow both temperature and top_p - only include one
    if (this.config.topP !== undefined) {
      params.top_p = this.config.topP;
    } else {
      params.temperature = this.config.temperature;
    }

    if (this.config.streaming && options?.onDelta) {
      return this.streamMessage(params, options.onDelta, options.onComplete);
    } else {
      return this.nonStreamMessage(params);
    }
  }

  /**
   * Streaming message handling
   */
  private async streamMessage(
    params: Anthropic.MessageCreateParams,
    onDelta: (delta: StreamDelta) => void,
    onComplete?: (response: ModelResponse) => void,
  ): Promise<ModelResponse> {
    const stream = await this.client.messages.create({
      ...params,
      stream: true,
    });

    let messageId = '';
    let stopReason: string | null = null;
    let inputTokens = 0;
    let outputTokens = 0;
    const contentBlocks: any[] = [];
    let currentTextBlock = '';
    let currentToolUse: any = null;

    for await (const event of stream) {
      switch (event.type) {
        case 'message_start':
          messageId = event.message.id;
          inputTokens = event.message.usage.input_tokens;
          break;

        case 'content_block_start':
          const blockType = (event.content_block as any).type;
          console.log(`[STREAM] content_block_start: ${blockType}`);

          if (event.content_block.type === 'text') {
            currentTextBlock = '';
          } else if (event.content_block.type === 'tool_use') {
            currentToolUse = {
              type: 'tool_use',
              id: event.content_block.id,
              name: event.content_block.name,
              inputJson: '',
            };
          } else if ((event.content_block as any).type === 'server_tool_use') {
            console.log(`[STREAM]  server_tool_use detected: ${(event.content_block as any).id}`);
            currentToolUse = {
              type: 'server_tool_use',
              id: (event.content_block as any).id,
              name: (event.content_block as any).name,
              inputJson: '',
            };
          } else if ((event.content_block as any).type === 'web_search_tool_result') {
            console.log(`[STREAM]  web_search_tool_result detected for: ${(event.content_block as any).tool_use_id}`);
            contentBlocks.push({
              type: 'web_search_tool_result',
              tool_use_id: (event.content_block as any).tool_use_id,
              content: (event.content_block as any).content,
            });
          }
          break;

        case 'content_block_delta':
          if (event.delta.type === 'text_delta') {
            currentTextBlock += event.delta.text;
            onDelta({ type: 'text', content: event.delta.text });
          } else if (event.delta.type === 'input_json_delta') {
            // Accumulate tool input JSON (parse only once on content_block_stop)
            if (currentToolUse) {
              currentToolUse.inputJson += event.delta.partial_json;
            }
          }
          break;

        case 'content_block_stop':
          if (currentTextBlock) {
            console.log(`[STREAM] Pushing text block (${currentTextBlock.length} chars)`);
            contentBlocks.push({ type: 'text', text: currentTextBlock });
            currentTextBlock = '';
          } else if (currentToolUse) {
            // Parse accumulated JSON once at the end
            try {
              currentToolUse.input = JSON.parse(currentToolUse.inputJson || '{}');
            } catch (e) {
              console.error('Failed to parse tool input JSON:', e);
              currentToolUse.input = {};
            }
            delete currentToolUse.inputJson;
            console.log(`[STREAM] Pushing ${currentToolUse.type}: ${currentToolUse.name} (${currentToolUse.id})`);
            contentBlocks.push(currentToolUse);
            onDelta({
              type: 'tool_use',
              content: `[Tool: ${currentToolUse.name}]`,
              toolUseId: currentToolUse.id,
              toolName: currentToolUse.name,
            });
            currentToolUse = null;
          }
          break;

        case 'message_delta':
          if (event.delta.stop_reason) {
            stopReason = event.delta.stop_reason;
          }
          if (event.usage) {
            outputTokens = event.usage.output_tokens;
          }
          break;

        case 'message_stop':
          // Stream complete
          break;
      }
    }

    const response: ModelResponse = {
      id: messageId,
      role: 'assistant',
      content: contentBlocks,
      stopReason,
      usage: {
        inputTokens,
        outputTokens,
      },
    };

    // Log final content block summary
    console.log(`\n[STREAM] Response complete. Content blocks:`);
    contentBlocks.forEach((block, idx) => {
      console.log(
        `  [${idx}] ${block.type}${block.id ? ` (${block.id})` : ''}${block.tool_use_id ? ` -> ${block.tool_use_id}` : ''}`,
      );
    });

    if (onComplete) {
      onComplete(response);
    }

    return response;
  }

  /**
   * Non-streaming message handling
   */
  private async nonStreamMessage(params: Anthropic.MessageCreateParams): Promise<ModelResponse> {
    const response = await this.client.messages.create({
      ...params,
      stream: false,
    });

    return {
      id: response.id,
      role: 'assistant',
      content: response.content.map((block: any) => {
        if (block.type === 'text') {
          return { type: 'text', text: block.text };
        } else if (block.type === 'tool_use') {
          return {
            type: 'tool_use',
            id: block.id,
            name: block.name,
            input: block.input,
          };
        } else if (block.type === 'server_tool_use') {
          // Explicitly handle server-side tool use
          return {
            type: 'server_tool_use',
            id: block.id,
            name: block.name,
            input: block.input,
          };
        } else if (block.type === 'web_search_tool_result') {
          // Explicitly handle web search results
          return {
            type: 'web_search_tool_result',
            tool_use_id: block.tool_use_id,
            content: block.content,
          };
        }
        // Pass through any other block types unchanged
        return block;
      }),
      stopReason: response.stop_reason,
      usage: {
        inputTokens: response.usage.input_tokens,
        outputTokens: response.usage.output_tokens,
        serverToolUse: (response.usage as any).server_tool_use,
      },
    };
  }

  /**
   * Convert our Message format to Anthropic's format
   */
  private convertMessages(messages: Message[]): Anthropic.MessageParam[] {
    return messages.map((msg) => ({
      role: msg.role as 'user' | 'assistant',
      content: typeof msg.content === 'string' ? msg.content : (msg.content as any),
    }));
  }

  /**
   * Get current config
   */
  getConfig(): ClaudeConfig {
    return { ...this.config };
  }
}
</file>

<file path="packages/tools-impl/src/either-line-replace.ts">
/**
 * either-line-replace: Targeted line edits with text editor pattern
 * Enhanced with exact string matching and comprehensive verification
 */

import { readFile, writeFile } from 'fs/promises';
import { resolve } from 'path';
import { createHash } from 'crypto';
import type { ToolExecutor, ExecutionContext, ToolExecutorResult } from '@eitherway/tools-core';
import { SecurityGuard } from './security.js';

export class EitherLineReplaceExecutor implements ToolExecutor {
  name = 'either-line-replace';

  async execute(input: Record<string, any>, context: ExecutionContext): Promise<ToolExecutorResult> {
    const { path, locator, replacement, verify_after = true } = input;
    const { start_line, end_line, needle } = locator;

    // Security check
    const guard = new SecurityGuard(context.config.security);
    if (!guard.isPathAllowed(path)) {
      return {
        content: `Error: Access denied to path '${path}'. Path is not in allowed workspaces.`,
        isError: true,
      };
    }

    // Use database if fileStore is available
    if (context.fileStore && context.appId) {
      return this.executeWithDatabase(path, locator, replacement, context);
    }

    // Otherwise use filesystem
    const fullPath = resolve(context.workingDir, path);

    try {
      // Read file and calculate original sha256
      const content = await readFile(fullPath, 'utf-8');
      const originalSha256 = createHash('sha256').update(content).digest('hex');
      const lines = content.split('\n');

      // Validate line numbers
      if (start_line < 1 || start_line > lines.length) {
        return {
          content: `Error: start_line ${start_line} out of range (file has ${lines.length} lines)`,
          isError: true,
        };
      }

      if (end_line < start_line || end_line > lines.length) {
        return {
          content: `Error: end_line ${end_line} invalid (must be >= start_line and <= ${lines.length})`,
          isError: true,
        };
      }

      // Extract target lines
      const targetLines = lines.slice(start_line - 1, end_line);
      const targetText = targetLines.join('\n');

      // Verify needle if provided (text editor pattern: exact match verification)
      if (needle) {
        const needleOccurrences = content.split(needle).length - 1;

        if (needleOccurrences === 0) {
          const preview = targetText.length > 100 ? targetText.substring(0, 100) + '...' : targetText;
          return {
            content: `Error: Needle text not found in file.\n\nExpected to find:\n"${needle}"\n\nBut in lines ${start_line}-${end_line} found:\n"${preview}"\n\nUse either-view to verify current file contents and exact text to match.`,
            isError: true,
            metadata: {
              path,
              needle_mismatch: true,
              expected: needle,
              actualPreview: preview,
              suggestion: 'Use either-view to check file contents and provide exact matching text',
            },
          };
        }

        if (needleOccurrences > 1) {
          return {
            content: `Error: Needle text appears ${needleOccurrences} times in file. Provide more context to create a unique match.\n\nSearching for:\n"${needle}"\n\nProvide more surrounding lines or unique identifiers.`,
            isError: true,
            metadata: {
              path,
              needle_occurrences: needleOccurrences,
              suggestion: 'Include more context in needle to create a unique match',
            },
          };
        }

        if (!targetText.includes(needle)) {
          return {
            content: `Error: Needle found in file but not at specified line range ${start_line}-${end_line}.\n\nUse either-search-files to locate the correct line numbers.`,
            isError: true,
            metadata: {
              path,
              needle_location_mismatch: true,
              suggestion: 'Use either-search-files to find correct line numbers',
            },
          };
        }
      }

      // Perform replacement
      const before = lines.slice(0, start_line - 1);
      const after = lines.slice(end_line);
      const replacementLines = replacement.split('\n');

      const newLines = [...before, ...replacementLines, ...after];
      const newContent = newLines.join('\n');

      // Calculate new sha256
      const newSha256 = createHash('sha256').update(newContent).digest('hex');

      // Write back
      await writeFile(fullPath, newContent, 'utf-8');

      // Verify if requested (text editor pattern: always verify by default)
      let verificationMsg = '';
      let isVerified = false;
      if (verify_after) {
        const verified = await readFile(fullPath, 'utf-8');
        const verifiedSha256 = createHash('sha256').update(verified).digest('hex');
        isVerified = verifiedSha256 === newSha256;
        if (!isVerified) {
          verificationMsg =
            '\n\nWarning: Verification failed - file content differs from expected. File may have been modified by another process.';
        }
      }

      const linesReplaced = end_line - start_line + 1;
      const newLineCount = replacementLines.length;
      const netLineChange = newLineCount - linesReplaced;

      // Generate unified diff
      const diff = this.generateUnifiedDiff(path, targetLines, replacementLines, start_line);

      const summary =
        netLineChange === 0
          ? `${linesReplaced} line(s)`
          : `${linesReplaced} line(s)  ${newLineCount} line(s) (${netLineChange > 0 ? '+' : ''}${netLineChange})`;

      return {
        content: `Successfully replaced lines ${start_line}-${end_line} in '${path}' (${summary})\n\n${diff}${verificationMsg}`,
        isError: false,
        metadata: {
          path,
          startLine: start_line,
          endLine: end_line,
          linesReplaced,
          newLineCount,
          netLineChange,
          original_sha256: originalSha256,
          new_sha256: newSha256,
          verified: isVerified,
          needleVerified: needle ? true : false,
        },
      };
    } catch (error: any) {
      return {
        content: `Error replacing lines in '${path}': ${error.message}`,
        isError: true,
      };
    }
  }

  /**
   * Execute using database FileStore
   */
  private async executeWithDatabase(
    path: string,
    locator: any,
    replacement: string,
    context: ExecutionContext,
  ): Promise<ToolExecutorResult> {
    const { fileStore, appId } = context;
    const { start_line, end_line, needle } = locator;

    try {
      // Read file from database
      const fileData = await fileStore.read(appId, path);

      // Convert content to string
      let content: string;
      if (typeof fileData.content === 'string') {
        content = fileData.content;
      } else if (Buffer.isBuffer(fileData.content)) {
        content = fileData.content.toString('utf-8');
      } else {
        content = Buffer.from(fileData.content).toString('utf-8');
      }

      const originalSha256 = createHash('sha256').update(content).digest('hex');
      const lines = content.split('\n');

      // Validate line numbers
      if (start_line < 1 || start_line > lines.length) {
        return {
          content: `Error: start_line ${start_line} out of range (file has ${lines.length} lines)`,
          isError: true,
        };
      }

      if (end_line < start_line || end_line > lines.length) {
        return {
          content: `Error: end_line ${end_line} invalid (must be >= start_line and <= ${lines.length})`,
          isError: true,
        };
      }

      // Extract target lines
      const targetLines = lines.slice(start_line - 1, end_line);
      const targetText = targetLines.join('\n');

      // Verify needle if provided
      if (needle) {
        const needleOccurrences = content.split(needle).length - 1;

        if (needleOccurrences === 0) {
          const preview = targetText.length > 100 ? targetText.substring(0, 100) + '...' : targetText;
          return {
            content: `Error: Needle text not found in file.\n\nExpected to find:\n"${needle}"\n\nBut in lines ${start_line}-${end_line} found:\n"${preview}"\n\nUse either-view to verify current file contents and exact text to match.`,
            isError: true,
            metadata: {
              path,
              needle_mismatch: true,
              expected: needle,
              actualPreview: preview,
              suggestion: 'Use either-view to check file contents and provide exact matching text',
            },
          };
        }

        if (needleOccurrences > 1) {
          return {
            content: `Error: Needle text appears ${needleOccurrences} times in file. Provide more context to create a unique match.\n\nSearching for:\n"${needle}"\n\nProvide more surrounding lines or unique identifiers.`,
            isError: true,
            metadata: {
              path,
              needle_occurrences: needleOccurrences,
              suggestion: 'Include more context in needle to create a unique match',
            },
          };
        }

        if (!targetText.includes(needle)) {
          return {
            content: `Error: Needle found in file but not at specified line range ${start_line}-${end_line}.\n\nUse either-search-files to locate the correct line numbers.`,
            isError: true,
            metadata: {
              path,
              needle_location_mismatch: true,
              suggestion: 'Use either-search-files to find correct line numbers',
            },
          };
        }
      }

      // Perform replacement
      const before = lines.slice(0, start_line - 1);
      const after = lines.slice(end_line);
      const replacementLines = replacement.split('\n');

      const newLines = [...before, ...replacementLines, ...after];
      const newContent = newLines.join('\n');

      // Calculate new sha256
      const newSha256 = createHash('sha256').update(newContent).digest('hex');

      // Write back to database
      await fileStore.write(appId, path, newContent);

      const linesReplaced = end_line - start_line + 1;
      const newLineCount = replacementLines.length;
      const netLineChange = newLineCount - linesReplaced;

      // Generate unified diff
      const diff = this.generateUnifiedDiff(path, targetLines, replacementLines, start_line);

      const summary =
        netLineChange === 0
          ? `${linesReplaced} line(s)`
          : `${linesReplaced} line(s)  ${newLineCount} line(s) (${netLineChange > 0 ? '+' : ''}${netLineChange})`;

      return {
        content: `Successfully replaced lines ${start_line}-${end_line} in '${path}' (${summary}) in database\n\n${diff}`,
        isError: false,
        metadata: {
          path,
          startLine: start_line,
          endLine: end_line,
          linesReplaced,
          newLineCount,
          netLineChange,
          original_sha256: originalSha256,
          new_sha256: newSha256,
          needleVerified: needle ? true : false,
          storage: 'database',
        },
      };
    } catch (error: any) {
      return {
        content: `Error replacing lines in '${path}' in database: ${error.message}`,
        isError: true,
      };
    }
  }

  /**
   * Generate unified diff format
   */
  private generateUnifiedDiff(path: string, oldLines: string[], newLines: string[], startLine: number): string {
    const diff: string[] = [];

    diff.push(`--- ${path}`);
    diff.push(`+++ ${path}`);
    diff.push(`@@ -${startLine},${oldLines.length} +${startLine},${newLines.length} @@`);

    // Show removed lines
    oldLines.forEach((line) => {
      diff.push(`-${line}`);
    });

    // Show added lines
    newLines.forEach((line) => {
      diff.push(`+${line}`);
    });

    return diff.join('\n');
  }
}
</file>

<file path="packages/tools-impl/src/either-search-files.ts">
/**
 * either-search-files: Search code for patterns with regex support
 */

import { readFile } from 'fs/promises';
import { resolve } from 'path';
import fg from 'fast-glob';
import type { ToolExecutor, ExecutionContext, ToolExecutorResult } from '@eitherway/tools-core';
import { SecurityGuard } from './security.js';

interface SearchMatch {
  path: string;
  line: number;
  snippet: string;
  contextBefore?: string[];
  contextAfter?: string[];
}

export class EitherSearchFilesExecutor implements ToolExecutor {
  name = 'either-search-files';

  async execute(input: Record<string, any>, context: ExecutionContext): Promise<ToolExecutorResult> {
    const { query, glob = 'src/**/*', max_results = 100, regex = false, context_lines = 0 } = input;

    try {
      // Use database if fileStore is available
      if (context.fileStore && context.appId) {
        return this.executeWithDatabase(query, glob, max_results, regex, context_lines, context);
      }

      // Find files matching glob pattern
      const files = await fg(glob, {
        cwd: context.workingDir,
        absolute: false,
        onlyFiles: true,
        ignore: ['node_modules/**', '.git/**', 'dist/**', 'build/**', '*.min.js', '*.map'],
      });

      const guard = new SecurityGuard(context.config.security);
      const matches: SearchMatch[] = [];

      // Prepare search pattern
      let searchPattern: RegExp;
      if (regex) {
        try {
          searchPattern = new RegExp(query, 'g');
        } catch (error: any) {
          return {
            content: `Invalid regex pattern: ${error.message}`,
            isError: true,
          };
        }
      } else {
        // Escape special regex characters for literal search
        const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        searchPattern = new RegExp(escapedQuery, 'g');
      }

      // Search in each file
      for (const file of files) {
        if (!guard.isPathAllowed(file)) {
          continue; // Skip disallowed files
        }

        try {
          const fullPath = resolve(context.workingDir, file);
          const content = await readFile(fullPath, 'utf-8');
          const lines = content.split('\n');

          // Search for pattern
          for (let i = 0; i < lines.length; i++) {
            // Reset regex lastIndex before each test to avoid missed matches
            searchPattern.lastIndex = 0;
            if (searchPattern.test(lines[i])) {
              const match: SearchMatch = {
                path: file,
                line: i + 1,
                snippet: lines[i],
              };

              // Add context lines if requested
              if (context_lines > 0) {
                const startIdx = Math.max(0, i - context_lines);
                const endIdx = Math.min(lines.length - 1, i + context_lines);

                if (startIdx < i) {
                  match.contextBefore = lines.slice(startIdx, i);
                }
                if (endIdx > i) {
                  match.contextAfter = lines.slice(i + 1, endIdx + 1);
                }
              }

              matches.push(match);

              if (matches.length >= max_results) {
                break;
              }
            }
          }

          if (matches.length >= max_results) {
            break;
          }
        } catch (error) {
          // Skip files that can't be read (binary, etc.)
          continue;
        }
      }

      if (matches.length === 0) {
        return {
          content: `No matches found for "${query}" in ${glob}`,
          isError: false,
          metadata: {
            query,
            glob,
            regex,
            filesSearched: files.length,
            matchCount: 0,
          },
        };
      }

      // Format results with context
      const resultText = matches
        .map((m) => {
          let output = `${m.path}:${m.line}: ${m.snippet}`;

          if (m.contextBefore && m.contextBefore.length > 0) {
            const before = m.contextBefore
              .map((line, idx) => `  ${m.line - m.contextBefore!.length + idx} | ${line}`)
              .join('\n');
            output = `${before}\n${output}`;
          }

          if (m.contextAfter && m.contextAfter.length > 0) {
            const after = m.contextAfter.map((line, idx) => `  ${m.line + idx + 1} | ${line}`).join('\n');
            output = `${output}\n${after}`;
          }

          return output;
        })
        .join('\n---\n');

      return {
        content: `Found ${matches.length} match(es) in ${glob}:\n\n${resultText}`,
        isError: false,
        metadata: {
          query,
          glob,
          regex,
          filesSearched: files.length,
          matchCount: matches.length,
          matches: matches.map((m) => ({ path: m.path, line: m.line })),
        },
      };
    } catch (error: any) {
      return {
        content: `Error searching files: ${error.message}`,
        isError: true,
      };
    }
  }

  /**
   * Execute using database FileStore
   */
  private async executeWithDatabase(
    query: string,
    glob: string,
    max_results: number,
    regex: boolean,
    context_lines: number,
    context: ExecutionContext,
  ): Promise<ToolExecutorResult> {
    const { fileStore, appId } = context;

    try {
      // Get all files from database for this app
      const allFiles = await fileStore.list(appId);

      // Convert glob to regex for matching
      const globPattern = glob.replace(/\./g, '\\.').replace(/\*\*/g, '.*').replace(/\*/g, '[^/]*').replace(/\?/g, '.');
      const globRegex = new RegExp(`^${globPattern}$`);

      // Filter files by glob pattern
      const files = allFiles.filter((file: any) => {
        const path = file.path || file;
        return globRegex.test(path);
      });

      const guard = new SecurityGuard(context.config.security);
      const matches: SearchMatch[] = [];

      // Prepare search pattern
      let searchPattern: RegExp;
      if (regex) {
        try {
          searchPattern = new RegExp(query, 'g');
        } catch (error: any) {
          return {
            content: `Invalid regex pattern: ${error.message}`,
            isError: true,
          };
        }
      } else {
        // Escape special regex characters for literal search
        const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        searchPattern = new RegExp(escapedQuery, 'g');
      }

      // Search in each file
      for (const file of files) {
        const filePath = file.path || file;

        if (!guard.isPathAllowed(filePath)) {
          continue; // Skip disallowed files
        }

        try {
          // Read file from database
          const fileData = await fileStore.read(appId, filePath);

          // Convert content to string
          let content: string;
          if (typeof fileData.content === 'string') {
            content = fileData.content;
          } else if (Buffer.isBuffer(fileData.content)) {
            content = fileData.content.toString('utf-8');
          } else {
            content = Buffer.from(fileData.content).toString('utf-8');
          }

          const lines = content.split('\n');

          // Search for pattern
          for (let i = 0; i < lines.length; i++) {
            // Reset regex lastIndex before each test to avoid missed matches
            searchPattern.lastIndex = 0;
            if (searchPattern.test(lines[i])) {
              const match: SearchMatch = {
                path: filePath,
                line: i + 1,
                snippet: lines[i],
              };

              // Add context lines if requested
              if (context_lines > 0) {
                const startIdx = Math.max(0, i - context_lines);
                const endIdx = Math.min(lines.length - 1, i + context_lines);

                if (startIdx < i) {
                  match.contextBefore = lines.slice(startIdx, i);
                }
                if (endIdx > i) {
                  match.contextAfter = lines.slice(i + 1, endIdx + 1);
                }
              }

              matches.push(match);

              if (matches.length >= max_results) {
                break;
              }
            }
          }

          if (matches.length >= max_results) {
            break;
          }
        } catch (error: any) {
          // Skip files that can't be read or don't exist
          if (!error.message.includes('File not found')) {
            console.error(`Error reading file ${filePath}:`, error.message);
          }
          continue;
        }
      }

      if (matches.length === 0) {
        return {
          content: `No matches found for "${query}" in ${glob}`,
          isError: false,
          metadata: {
            query,
            glob,
            regex,
            filesSearched: files.length,
            matchCount: 0,
            storage: 'database',
          },
        };
      }

      // Format results with context
      const resultText = matches
        .map((m) => {
          let output = `${m.path}:${m.line}: ${m.snippet}`;

          if (m.contextBefore && m.contextBefore.length > 0) {
            const before = m.contextBefore
              .map((line, idx) => `  ${m.line - m.contextBefore!.length + idx} | ${line}`)
              .join('\n');
            output = `${before}\n${output}`;
          }

          if (m.contextAfter && m.contextAfter.length > 0) {
            const after = m.contextAfter.map((line, idx) => `  ${m.line + idx + 1} | ${line}`).join('\n');
            output = `${output}\n${after}`;
          }

          return output;
        })
        .join('\n---\n');

      return {
        content: `Found ${matches.length} match(es) in ${glob}:\n\n${resultText}`,
        isError: false,
        metadata: {
          query,
          glob,
          regex,
          filesSearched: files.length,
          matchCount: matches.length,
          matches: matches.map((m) => ({ path: m.path, line: m.line })),
          storage: 'database',
        },
      };
    } catch (error: any) {
      return {
        content: `Error searching files in database: ${error.message}`,
        isError: true,
      };
    }
  }
}
</file>

<file path="packages/ui-frontend/app/components/brand-kit/BrandKitPanel.tsx">
import { useState, useEffect } from 'react';
import { useStore } from '@nanostores/react';
import { authStore } from '~/lib/stores/auth';
import { chatStore } from '~/lib/stores/chat';
import { brandKitStore } from '~/lib/stores/brandKit';
import { useWalletConnection } from '~/lib/web3/hooks';
import { webcontainer } from '~/lib/webcontainer/index';
import { syncBrandAssetsToWebContainer } from '~/utils/brandAssetSync';
import { createScopedLogger } from '~/utils/logger';

const logger = createScopedLogger('BrandKitPanel');

interface BrandKitPanelProps {
  onClose: () => void;
}

interface BrandAsset {
  id: string;
  assetType: string;
  fileName: string;
  mimeType: string;
  fileSizeBytes: number;
  processingStatus: string;
  uploadedAt: string;
}

interface BrandColor {
  id: string;
  hex: string;
  rgb: { r: number; g: number; b: number };
  hsl: { h: number; s: number; l: number } | null;
  name: string | null;
  role: string | null;
  prominence: number | null;
  pixelPercentage: number | null;
}

interface BrandKitData {
  id: string;
  name: string;
  assets: BrandAsset[];
  colors: BrandColor[];
}

export function BrandKitPanel({ onClose }: BrandKitPanelProps) {
  const user = useStore(authStore.user);
  const chat = useStore(chatStore);
  const agentWorking = !!chat.currentPhase && chat.currentPhase !== 'completed';
  const { isConnected, address } = useWalletConnection();
  const [isUploading, setIsUploading] = useState(false);
  const [isLoadingExisting, setIsLoadingExisting] = useState(true);
  const [uploadProgress, setUploadProgress] = useState<string[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [brandKitData, setBrandKitData] = useState<BrandKitData | null>(null);
  const [currentBrandKitId, setCurrentBrandKitId] = useState<string | null>(null);

  // Prioritize wallet address (email auth is mostly mock)
  const userId = (isConnected && address ? address : user?.email) || null;

  // Do NOT fetch from server automatically - brand kits are per-session, not per-user
  useEffect(() => {
    const loadSessionBrandKit = async () => {
      setIsLoadingExisting(false);

      const { pendingBrandKitId } = brandKitStore.get();

      if (!pendingBrandKitId) {
        logger.info('No brand kit in current session');
        return;
      }

      try {
        // Fetch the specific brand kit by ID (not user's active brand kit)
        const kitData = await fetchBrandKitData(pendingBrandKitId);
        if (kitData) {
          setCurrentBrandKitId(pendingBrandKitId);
          logger.info('Loaded brand kit from current session:', pendingBrandKitId);
        } else {
          // Brand kit ID in localStorage is invalid/deleted, clear it
          logger.warn('Brand kit ID in localStorage not found, clearing');
          brandKitStore.set({ pendingBrandKitId: null, dirty: false });
        }
      } catch (err: any) {
        logger.error('Error loading session brand kit:', err);
        // Clear invalid brand kit ID
        brandKitStore.set({ pendingBrandKitId: null, dirty: false });
      }
    };

    loadSessionBrandKit();
  }, [chat.sessionId]);

  // Fetch brand kit data with assets and colors
  const fetchBrandKitData = async (brandKitId: string) => {
    try {
      const response = await fetch(`/api/brand-kits/${brandKitId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch brand kit data');
      }
      const data = await response.json();
      if (data.success && data.brandKit) {
        setBrandKitData(data.brandKit);
        return data.brandKit;
      }
      return null;
    } catch (err: any) {
      console.error('Failed to fetch brand kit data:', err);
      return null;
    }
  };

  const handleDeleteAsset = async (assetId: string, fileName: string) => {
    if (!currentBrandKitId) return;

    if (!confirm(`Delete ${fileName}? This will also update your color palette.`)) {
      return;
    }

    try {
      setUploadProgress([`Deleting ${fileName}...`]);

      const deleteResponse = await fetch(`/api/brand-kits/${currentBrandKitId}/assets/${assetId}`, {
        method: 'DELETE',
      });

      if (!deleteResponse.ok) {
        throw new Error(`Failed to delete asset: ${deleteResponse.statusText}`);
      }

      setUploadProgress((prev) => [...prev, ` ${fileName} deleted`]);

      // Re-aggregate colors after deletion
      setUploadProgress((prev) => [...prev, 'Updating color palette...']);
      const aggregateResponse = await fetch(`/api/brand-kits/${currentBrandKitId}/aggregate-colors`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({}),
      });

      if (aggregateResponse.ok) {
        const aggregateData = await aggregateResponse.json();
        setUploadProgress((prev) => [...prev, ` Palette updated: ${aggregateData.colorsExtracted || 0} colors`]);
      } else {
        setUploadProgress((prev) => [...prev, ' Color update failed']);
      }

      // Refresh brand kit data
      const kitData = await fetchBrandKitData(currentBrandKitId);
      setBrandKitData(kitData);

      setUploadProgress((prev) => [...prev, ' Complete!']);

      // Clear progress after 2 seconds
      setTimeout(() => setUploadProgress([]), 2000);
    } catch (err: any) {
      console.error('[BrandKitPanel] Delete failed:', err);
      setError(err.message || 'Failed to delete asset');
      setUploadProgress([]);
    }
  };

  const handleFileUpload = async (files: FileList | null) => {
    if (!files || files.length === 0) return;
    if (!userId) {
      setError('Please connect your wallet to upload brand assets');
      return;
    }

    setIsUploading(true);
    setError(null);
    setUploadProgress([]);

    try {
      // Step 1: Get or create a brand kit
      let brandKitId = currentBrandKitId;

      // If no existing brand kit, create one
      if (!brandKitId) {
        const brandKitName = `Brand Kit - ${new Date().toLocaleDateString()}`;
        console.log('[BrandKitPanel] Creating new brand kit with userId:', userId);

        const createResponse = await fetch('/api/brand-kits', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            userId: userId,
            name: brandKitName,
            description: 'Auto-generated brand kit from upload',
          }),
        });

        console.log('[BrandKitPanel] Create response status:', createResponse.status);

        if (!createResponse.ok) {
          const contentType = createResponse.headers.get('content-type');
          if (contentType && contentType.includes('application/json')) {
            const errorData = await createResponse.json();
            const errorMsg = errorData.error || 'Failed to create brand kit';
            const errorDetails = errorData.details || errorData.message || '';
            throw new Error(`${errorMsg}${errorDetails ? `: ${errorDetails}` : ''}`);
          } else {
            const text = await createResponse.text();
            throw new Error(`Failed to create brand kit: ${text || `HTTP ${createResponse.status}`}`);
          }
        }

        const { brandKit } = await createResponse.json();
        brandKitId = brandKit.id;
        setCurrentBrandKitId(brandKitId);
        console.log('[BrandKitPanel] New brand kit created:', brandKitId);
      } else {
        console.log('[BrandKitPanel] Reusing existing brand kit:', brandKitId);
      }

      // Step 2: Upload each file
      const uploadPromises = Array.from(files).map(async (file) => {
        const formData = new FormData();
        formData.append('file', file);

        setUploadProgress((prev) => [...prev, `Uploading ${file.name}...`]);

        const uploadResponse = await fetch(`/api/brand-kits/${brandKitId}/assets`, {
          method: 'POST',
          body: formData,
        });

        if (!uploadResponse.ok) {
          const contentType = uploadResponse.headers.get('content-type');
          if (contentType && contentType.includes('application/json')) {
            const errorData = await uploadResponse.json();
            throw new Error(`Failed to upload ${file.name}: ${errorData.error || 'Unknown error'}`);
          } else {
            const text = await uploadResponse.text();
            throw new Error(`Failed to upload ${file.name}: ${text || `HTTP ${uploadResponse.status}`}`);
          }
        }

        const uploadContentType = uploadResponse.headers.get('content-type');
        if (!uploadContentType || !uploadContentType.includes('application/json')) {
          const text = await uploadResponse.text();
          throw new Error(`Invalid response for ${file.name}: Expected JSON but got: ${text.substring(0, 100)}`);
        }

        const result = await uploadResponse.json();
        setUploadProgress((prev) => [...prev, ` ${file.name} uploaded successfully`]);
        return result;
      });

      await Promise.all(uploadPromises);

      setUploadProgress((prev) => [...prev, ' All files uploaded!']);

      // Aggregate colors across all assets
      setUploadProgress((prev) => [...prev, 'Extracting brand color palette...']);
      const aggregateResponse = await fetch(`/api/brand-kits/${brandKitId}/aggregate-colors`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({}),
      });

      if (!aggregateResponse.ok) {
        console.error('[BrandKitPanel] Color aggregation failed:', aggregateResponse.statusText);
        setUploadProgress((prev) => [...prev, ' Color extraction failed, but assets uploaded successfully']);
      } else {
        const aggregateData = await aggregateResponse.json();
        console.log('[BrandKitPanel] Color aggregation complete:', aggregateData);
        setUploadProgress((prev) => [
          ...prev,
          ` Extracted ${aggregateData.colorsExtracted || 0} colors from ${aggregateData.assetsProcessed || 0} assets`,
        ]);
      }

      // Fetch updated brand kit data to show assets and colors
      const kitData = await fetchBrandKitData(brandKitId);

      setUploadProgress((prev) => [...prev, ' Brand kit ready!']);

      // Mark assets pending for sync. We'll materialize them at the next prompt.
      brandKitStore.setKey('pendingBrandKitId', brandKitId);
      brandKitStore.setKey('dirty', true);
    } catch (err: any) {
      console.error('Brand kit upload error:', err);
      setError(err.message || 'Upload failed');
    } finally {
      setIsUploading(false);
    }
  };

  return (
    <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
      <div className="bg-gray-900 rounded-2xl shadow-2xl max-w-2xl w-full max-h-[85vh] flex flex-col overflow-hidden">
        <div className="flex items-center justify-between p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white">Brand Kit</h2>
          <button
            onClick={onClose}
            className="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg transition-colors"
            disabled={isUploading}
          >
            Close
          </button>
        </div>
        <div className="flex-1 overflow-y-auto p-6">
          <div className="space-y-4">
            {/* Upload Area */}
            <div className="p-6 bg-gray-800 rounded-lg border-2 border-dashed border-gray-600 text-center">
              <svg
                className="w-16 h-16 mx-auto mb-4 text-gray-500"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
                />
              </svg>
              <p className="text-white font-medium mb-2">Upload Your Brand Assets</p>
              <p className="text-sm text-gray-400 mb-4">Drag and drop or click to upload logos, colors, and fonts</p>
              <input
                type="file"
                className="hidden"
                id="brand-kit-upload"
                accept="image/png,image/jpeg,image/jpg,image/svg+xml,image/x-icon,.ico,.ttf,.otf,.woff,.woff2,.zip,.mp4,video/mp4"
                multiple
                onChange={(e) => handleFileUpload(e.target.files)}
                disabled={isUploading || agentWorking}
              />
              <label
                htmlFor="brand-kit-upload"
                title={agentWorking ? 'Wait for the agent to finish before uploading' : 'Choose files'}
                className={`inline-block px-6 py-3 rounded-lg cursor-pointer transition-colors ${
                  isUploading || agentWorking ? 'bg-gray-600 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700'
                } text-white`}
              >
                {isUploading ? 'Uploading...' : 'Choose Files'}
              </label>
            </div>

            {/* Upload Progress */}
            {uploadProgress.length > 0 && (
              <div className="bg-gray-800 rounded-lg p-4 max-h-60 overflow-y-auto">
                <h4 className="text-sm font-semibold text-gray-300 mb-2">Upload Progress</h4>
                <div className="space-y-1">
                  {uploadProgress.map((msg, idx) => (
                    <p key={idx} className="text-xs text-gray-400">
                      {msg}
                    </p>
                  ))}
                </div>
              </div>
            )}

            {/* Error Message */}
            {error && (
              <div className="bg-red-900/20 border border-red-700 rounded-lg p-4">
                <h4 className="text-sm font-semibold text-red-400 mb-1">Error</h4>
                <p className="text-xs text-red-300">{error}</p>
              </div>
            )}

            {/* Info Box */}
            {!isUploading && uploadProgress.length === 0 && !brandKitData && (
              <div className="bg-blue-900/20 border border-blue-700 rounded-lg p-4">
                <h4 className="text-sm font-semibold text-blue-400 mb-2">Supported file types:</h4>
                <ul className="text-xs text-blue-300 space-y-1">
                  <li>
                     <strong>Images:</strong> PNG, JPEG, SVG, ICO (up to 20MB)
                  </li>
                  <li>
                     <strong>Fonts:</strong> TTF, OTF, WOFF, WOFF2 (up to 10MB)
                  </li>
                  <li>
                     <strong>Archives:</strong> ZIP brand packages (up to 200MB)
                  </li>
                  <li>
                     <strong>Videos:</strong> MP4 promo clips (up to 100MB)
                  </li>
                </ul>
                <p className="text-xs text-blue-400 mt-3">Colors are automatically extracted from logos and images!</p>
              </div>
            )}

            {/* Uploaded Assets */}
            {brandKitData && brandKitData.assets.length > 0 && (
              <div className="bg-gray-800 rounded-lg p-4">
                <h4 className="text-sm font-semibold text-gray-300 mb-3">Uploaded Assets</h4>
                <div className="space-y-2">
                  {brandKitData.assets.map((asset) => (
                    <div key={asset.id} className="flex items-center justify-between p-2 bg-gray-700 rounded group">
                      <div className="flex items-center gap-2 flex-1 min-w-0">
                        <div className="text-gray-400">
                          {asset.mimeType.startsWith('image/') && <div className="i-ph:image text-lg" />}
                          {asset.mimeType.startsWith('font/') && <div className="i-ph:text-aa text-lg" />}
                          {asset.mimeType.startsWith('video/') && <div className="i-ph:video text-lg" />}
                          {asset.mimeType.includes('zip') && <div className="i-ph:file-zip text-lg" />}
                        </div>
                        <div className="flex-1 min-w-0">
                          <p className="text-xs text-white truncate">{asset.fileName}</p>
                          <p className="text-xs text-gray-400">
                            {(asset.fileSizeBytes / 1024).toFixed(1)} KB  {asset.assetType}
                          </p>
                        </div>
                      </div>
                      <div className="flex items-center gap-2">
                        <div className="text-xs">
                          {asset.processingStatus === 'completed' && <span className="text-green-400"></span>}
                          {asset.processingStatus === 'processing' && <span className="text-yellow-400">...</span>}
                          {asset.processingStatus === 'failed' && <span className="text-red-400"></span>}
                        </div>
                        <button
                          onClick={() => handleDeleteAsset(asset.id, asset.fileName)}
                          disabled={isUploading}
                          className="opacity-0 group-hover:opacity-100 transition-opacity p-1 hover:bg-red-600 rounded text-gray-400 hover:text-white disabled:opacity-50 disabled:cursor-not-allowed"
                          title="Delete asset"
                        >
                          <div className="i-ph:x text-sm" />
                        </button>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* Extracted Colors */}
            {brandKitData && brandKitData.colors.length > 0 && (
              <div className="bg-gray-800 rounded-lg p-4">
                <h4 className="text-sm font-semibold text-gray-300 mb-3">Extracted Color Palette</h4>
                <div className="grid grid-cols-5 gap-2">
                  {brandKitData.colors.map((color) => (
                    <div key={color.id} className="flex flex-col items-center">
                      <div
                        className="w-12 h-12 rounded-lg border-2 border-gray-600"
                        style={{ backgroundColor: color.hex }}
                        title={`${color.name || color.hex}\n${color.prominence ? `${(color.prominence * 100).toFixed(0)}% prominence` : ''}`}
                      />
                      <p className="text-xs text-gray-400 mt-1 text-center">{color.hex}</p>
                      {color.name && <p className="text-xs text-gray-500 truncate max-w-full">{color.name}</p>}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/header/Header.tsx">
import { useStore } from '@nanostores/react';
import { useState, useEffect } from 'react';
import { createPortal } from 'react-dom';
import { ClientOnly } from 'remix-utils/client-only';
import { chatStore } from '~/lib/stores/chat';
import { workbenchStore } from '~/lib/stores/workbench';
import { authStore } from '~/lib/stores/auth';
import { classNames } from '~/utils/classNames';
import { HeaderActionButtons } from './HeaderActionButtons.client';
import { useWalletConnection } from '~/lib/web3/hooks';
import { Dialog, DialogRoot } from '~/components/ui/Dialog';
import { DeploymentPanel } from '~/components/deployment/DeploymentPanel';
import { BrandKitPanel } from '~/components/brand-kit/BrandKitPanel';

export function Header() {
  const chat = useStore(chatStore);
  const { connectWallet, isConnected, address, formatAddress, disconnectWallet } = useWalletConnection();
  const isAppReady = useStore(workbenchStore.isAppReadyForDeploy);
  const previews = useStore(workbenchStore.previews);
  const user = useStore(authStore.user);
  const [isBurgerOpen, setIsBurgerOpen] = useState(false);
  const [showDeployPanel, setShowDeployPanel] = useState(false);
  const [showBrandKitPanel, setShowBrandKitPanel] = useState(false);
  const [deployPanelTab, setDeployPanelTab] = useState<'deploy' | 'download'>('deploy');

  // Use wallet address as primary identifier (email auth is mostly mock)
  const userId = (isConnected && address ? address : user?.email) || null;
  const sessionId = chat.sessionId || userId || 'demo-session';
  const appId = chat.sessionId || 'demo-app-' + Date.now();

  console.log('Header - chat.started:', chat.started);

  // Listen for brand kit upload event from chat clip button
  useEffect(() => {
    const handleOpenBrandKit = () => {
      setShowBrandKitPanel(true);
    };

    window.addEventListener('open-brand-kit', handleOpenBrandKit);
    return () => window.removeEventListener('open-brand-kit', handleOpenBrandKit);
  }, []);

  return (
    <header
      className={classNames(
        'relative flex items-center justify-between bg-eitherway-elements-background-depth-1 p-5 h-[var(--header-height)]',
        {
          'border-transparent': !chat.started,
          'border-eitherway-elements-borderColor': chat.started,
        },
        'justify-end',
      )}
    >
      <div className="flex items-center gap-2 justify-end w-full">
        {chat.started && (
          <ClientOnly>
            {() => (
              <div>
                <HeaderActionButtons />
              </div>
            )}
          </ClientOnly>
        )}

        <div className="hidden min-[900px]:flex">
          <ClientOnly>
            {() => (
              <button
                className="px-6 py-2 rounded-2xl text-sm border bg-eitherway-elements-background-depth-1 text-eitherway-elements-textPrimary border-eitherway-elements-borderColor"
                onClick={isConnected ? disconnectWallet : connectWallet}
              >
                {isConnected && address ? formatAddress(address) : 'CONNECT WALLET'}
              </button>
            )}
          </ClientOnly>
        </div>
        {chat.started && (
          <button
            className="flex bg-black p-2 relative z-[2000]"
            onClick={() => {
              console.log('Burger button clicked!');
              setIsBurgerOpen(!isBurgerOpen);
            }}
          >
            <div className="w-6 h-6 flex items-center bg-black justify-center">
              {isBurgerOpen ? (
                <div className="i-ph:x text-xl text-white" />
              ) : (
                <div className="i-ph:list text-xl text-white" />
              )}
            </div>
          </button>
        )}
      </div>

      <DialogRoot open={isBurgerOpen} onOpenChange={setIsBurgerOpen}>
        <Dialog
          className="!fixed !top-[var(--header-height)] !left-4 !right-4  !translate-x-0 !translate-y-0 !max-w-none !w-auto !max-h-[calc(100vh-var(--header-height))] !overflow-y-auto"
          onBackdrop={() => setIsBurgerOpen(false)}
          noBorder={true}
        >
          <div className="bg-eitherway-elements-background-depth-1 pt-16 border border-eitherway-elements-borderColor rounded-2xl shadow-lg p-6">
            <div className="flex flex-col gap-6">
              <nav className="flex flex-col gap-3">
                <a
                  href="#pricing"
                  className="w-full px-6 py-3 rounded-2xl text-sm font-medium border border-eitherway-elements-borderColor text-center bg-black text-white hover:bg-[#0B00E6] transition-colors"
                  onClick={() => setIsBurgerOpen(false)}
                >
                  Pricing
                </a>
                <a
                  href="http://docs.eitherway.ai"
                  className="w-full px-6 py-3 rounded-2xl text-sm font-medium border border-eitherway-elements-borderColor text-center bg-black text-white hover:bg-[#0B00E6] transition-colors"
                  onClick={() => setIsBurgerOpen(false)}
                >
                  Documentation
                </a>

                <div className="flex flex-col gap-3 min-[900px]:hidden">
                  <ClientOnly>
                    {() => (
                      <button
                        className="w-full px-6 py-3 rounded-2xl text-sm font-medium border bg-eitherway-elements-background-depth-1 text-eitherway-elements-textPrimary border-eitherway-elements-borderColor hover:bg-eitherway-elements-item-backgroundActive transition-colors"
                        onClick={() => {
                          if (isConnected) {
                            disconnectWallet();
                          } else {
                            connectWallet();
                          }

                          setIsBurgerOpen(false);
                        }}
                      >
                        {isConnected && address ? formatAddress(address) : 'CONNECT WALLET'}
                      </button>
                    )}
                  </ClientOnly>
                  <button
                    onClick={() => {
                      setDeployPanelTab('download');
                      setShowDeployPanel(true);
                      setIsBurgerOpen(false);
                    }}
                    className="w-full flex items-center justify-center gap-3 px-6 py-3 rounded-2xl text-sm border bg-black border-eitherway-elements-borderColor text-white hover:bg-eitherway-elements-item-backgroundActive transition-colors"
                  >
                    <img src="/icons/chat/download.svg" alt="Download" className="w-4 h-4" />
                    <span>DOWNLOAD</span>
                  </button>

                  <button
                    onClick={() => {
                      setDeployPanelTab('deploy');
                      setShowDeployPanel(true);
                      setIsBurgerOpen(false);
                    }}
                    className="w-full flex items-center justify-center gap-3 px-6 py-3 rounded-2xl text-sm border bg-eitherway-elements-background-depth-1 border-eitherway-elements-borderColor text-white hover:bg-eitherway-elements-item-backgroundActive transition-colors"
                  >
                    <img src="/icons/chat/deploy.svg" alt="Deploy" className="w-4 h-4" />
                    <span>DEPLOY</span>
                  </button>
                </div>
                <button
                  className="w-full px-6 py-3 rounded-2xl text-sm font-medium bg-[#0D00FF] text-white transition-colors relative overflow-hidden"
                  onClick={() => {
                    connectWallet();
                    setIsBurgerOpen(false);
                  }}
                >
                  <span className="relative z-10">BUY $EITHER</span>
                  <div className="absolute w-10 h-full -left-16 top-0 bg-[#FFFFFF40] skew-x-[-20deg] hover:left-[calc(100%+20px)] transition-all duration-400 ease-out"></div>
                </button>
              </nav>
            </div>
          </div>
        </Dialog>
      </DialogRoot>

      {/* Deployment Panel Modal - Rendered via Portal to document.body */}
      {typeof document !== 'undefined' &&
        showDeployPanel &&
        createPortal(
          <DeploymentPanel
            appId={appId}
            sessionId={sessionId}
            userId={userId}
            initialTab={deployPanelTab}
            onClose={() => setShowDeployPanel(false)}
          />,
          document.body,
        )}

      {/* Brand Kit Panel Modal - Rendered via Portal to document.body */}
      {typeof document !== 'undefined' &&
        showBrandKitPanel &&
        createPortal(<BrandKitPanel onClose={() => setShowBrandKitPanel(false)} />, document.body)}
    </header>
  );
}
</file>

<file path="packages/ui-frontend/app/lib/persistence/useBackendHistory.ts">
import { useLoaderData, useNavigate } from '@remix-run/react';
import { useState, useEffect } from 'react';
import type { Message } from 'ai';
import { toast } from 'react-toastify';
import { createScopedLogger } from '~/utils/logger';
import { BACKEND_URL } from '~/config/api';

const logger = createScopedLogger('BackendHistory');

export interface BackendMessage {
  id: string;
  session_id: string;
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
  model?: string;
  token_count?: number;
  created_at: string;
}

export interface FileNode {
  name: string;
  path: string;
  type: 'file' | 'directory';
  size?: number;
  children?: FileNode[];
}

export function useBackendHistory() {
  const navigate = useNavigate();
  const { id: sessionId } = useLoaderData<{ id?: string }>();

  const [initialMessages, setInitialMessages] = useState<Message[]>([]);
  const [files, setFiles] = useState<FileNode[]>([]);
  const [ready, setReady] = useState<boolean>(false);
  const [sessionTitle, setSessionTitle] = useState<string>('');

  useEffect(() => {
    if (!sessionId) {
      // No session ID in URL - this is a new chat
      logger.debug('No session ID in URL, starting fresh chat');
      setReady(true);
      return;
    }

    logger.info('Loading session from backend:', sessionId);

    Promise.all([
      fetch(`${BACKEND_URL}/api/sessions/${sessionId}`),
      fetch(`${BACKEND_URL}/api/sessions/${sessionId}/files/tree`),
    ])
      .then(async ([sessionResponse, filesResponse]) => {
        if (!sessionResponse.ok) {
          if (sessionResponse.status === 404) {
            logger.warn('Session not found on backend, redirecting to new chat');
            toast.error('Session not found');
            navigate('/chat', { replace: true });
            return null;
          }
          throw new Error(`Failed to load session: ${sessionResponse.statusText}`);
        }

        const sessionData = await sessionResponse.json();
        const filesData = filesResponse.ok ? await filesResponse.json() : { files: [] };

        return { sessionData, filesData };
      })
      .then((result) => {
        if (!result) return;

        const { sessionData, filesData } = result;
        const { session, messages } = sessionData;

        logger.info(
          `Loaded ${messages.length} messages and ${filesData.files?.length || 0} files from backend session:`,
          session.title,
        );

        // Transform backend messages to AI SDK format
        const transformedMessages: Message[] = messages.map((msg: BackendMessage) => ({
          id: msg.id,
          role: msg.role,
          content: msg.content,
          createdAt: new Date(msg.created_at),
        }));

        setInitialMessages(transformedMessages);
        setFiles(filesData.files || []);
        setSessionTitle(session.title || 'Untitled Chat');

        // Store session ID in localStorage for continuity
        localStorage.setItem('currentSessionId', sessionId);
        console.log(' [Backend History] Loaded session:', sessionId);
        console.log('   Messages:', transformedMessages.length);
        console.log('   Files:', filesData.files?.length || 0);

        setReady(true);
      })
      .catch((error) => {
        logger.error('Failed to load session from backend:', error);
        toast.error('Failed to load chat history');
        navigate('/chat', { replace: true });
        setReady(true);
      });
  }, [sessionId, navigate]);

  // Simplified storeMessageHistory - backend storage happens via WebSocket streaming
  const storeMessageHistory = async (messages: Message[]) => {
    // Messages are already being stored by the backend during streaming
    // This is kept for compatibility but is now a no-op
    // Removed noisy debug log - this fires on every message change
  };

  return {
    ready: !sessionId || ready,
    initialMessages,
    files,
    sessionTitle,
    sessionId: sessionId || null,
    storeMessageHistory,
  };
}
</file>

<file path="packages/ui-frontend/app/lib/stores/files.ts">
import type { PathWatcherEvent, WebContainer } from '@webcontainer/api';
import { getEncoding } from 'istextorbinary';
import { map, type MapStore } from 'nanostores';
import { Buffer } from 'node:buffer';
//  polyfill  relative
function relative(from: string, to: string): string {
  //  
  if (to.startsWith(from)) {
    return to.slice(from.length).replace(/^\//, '') || '.';
  }
  return to;
}

const nodePath = { relative };
import { bufferWatchEvents } from '~/utils/buffer';
import { WORK_DIR } from '~/utils/constants';
import { computeFileModifications } from '~/utils/diff';
import { createScopedLogger } from '~/utils/logger';
import { unreachable } from '~/utils/unreachable';
import { BACKEND_URL } from '~/config/api';

const logger = createScopedLogger('FilesStore');

const utf8TextDecoder = new TextDecoder('utf8', { fatal: true });

export interface File {
  type: 'file';
  content: string;
  isBinary: boolean;
}

export interface Folder {
  type: 'folder';
}

type Dirent = File | Folder;

export type FileMap = Record<string, Dirent | undefined>;

export class FilesStore {
  #webcontainer: Promise<WebContainer>;

  /**
   * Tracks the number of files without folders.
   */
  #size = 0;

  /**
   * @note Keeps track all modified files with their original content since the last user message.
   * Needs to be reset when the user sends another message and all changes have to be submitted
   * for the model to be aware of the changes.
   */
  #modifiedFiles: Map<string, string> = import.meta.hot?.data.modifiedFiles ?? new Map();

  /**
   * Map of files that matches the state of WebContainer.
   */
  files: MapStore<FileMap> = import.meta.hot?.data.files ?? map({});

  get filesCount() {
    return this.#size;
  }

  constructor(webcontainerPromise: Promise<WebContainer>) {
    this.#webcontainer = webcontainerPromise;

    if (import.meta.hot) {
      import.meta.hot.data.files = this.files;
      import.meta.hot.data.modifiedFiles = this.#modifiedFiles;
    }

    this.#init();
  }

  getFile(filePath: string) {
    const dirent = this.files.get()[filePath];

    if (dirent?.type !== 'file') {
      return undefined;
    }

    return dirent;
  }

  getFileModifications() {
    return computeFileModifications(this.files.get(), this.#modifiedFiles);
  }

  resetFileModifications() {
    this.#modifiedFiles.clear();
  }

  async saveFile(filePath: string, content: string) {
    console.log('[FilesStore]  Starting file save:', filePath);
    const webcontainer = await this.#webcontainer;

    try {
      const relativePath = nodePath.relative(webcontainer.workdir, filePath);
      console.log('[FilesStore]  Relative path:', relativePath);

      if (!relativePath) {
        throw new Error(`EINVAL: invalid file path, write '${relativePath}'`);
      }

      const oldContent = this.getFile(filePath)?.content;

      if (!oldContent) {
        unreachable('Expected content to be defined');
      }

      console.log('[FilesStore]   Writing to WebContainer...', relativePath);
      await webcontainer.fs.writeFile(relativePath, content);
      console.log('[FilesStore]  WebContainer write complete');

      if (!this.#modifiedFiles.has(filePath)) {
        this.#modifiedFiles.set(filePath, oldContent);
      }

      // we immediately update the file and don't rely on the `change` event coming from the watcher
      this.files.setKey(filePath, { type: 'file', content, isBinary: false });

      // CRITICAL FIX: Make backend sync BLOCKING to catch errors and provide feedback
      console.log('[FilesStore]  Starting backend sync...');
      try {
        await this.#syncToBackend(relativePath, content);
        console.log('[FilesStore]  Backend sync successful');
        logger.info('File saved successfully to backend:', relativePath);
      } catch (error: any) {
        console.error('[FilesStore]  Backend sync FAILED:', error);
        logger.error('Failed to sync file to backend:', error);

        // Show error toast to user
        if (typeof window !== 'undefined') {
          import('react-toastify')
            .then(({ toast }) => {
              toast.error(`Failed to save ${filePath.split('/').pop()} to server: ${error.message}`, {
                autoClose: 5000,
                position: 'bottom-right',
              });
            })
            .catch(() => {
              console.error('[FilesStore] Could not import toast library');
            });
        }

        // Still throw so caller knows it failed
        throw new Error(`Backend sync failed: ${error.message}`);
      }

      if (typeof window !== 'undefined') {
        window.dispatchEvent(
          new CustomEvent('webcontainer:file-updated', {
            detail: { filePath: relativePath },
          }),
        );
      }
    } catch (error) {
      console.error('[FilesStore]  File save failed:', error);
      logger.error('Failed to update file content\n\n', error);

      throw error;
    }
  }

  async #syncToBackend(filePath: string, content: string, retries = 3) {
    const sessionId = localStorage.getItem('currentSessionId');
    console.log('[FilesStore] Session ID:', sessionId);

    if (!sessionId) {
      const error = 'No active session found - cannot sync to backend. Please refresh the page.';
      console.error('[FilesStore]', error);
      throw new Error(error);
    }

    const url = `${BACKEND_URL}/api/sessions/${sessionId}/files/write`;

    console.log('[FilesStore]  POST', url);
    console.log('[FilesStore]  File:', filePath, '| Size:', content.length, 'chars');

    // Retry logic for transient network failures
    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            path: filePath,
            content: content,
          }),
        });

        console.log('[FilesStore]  Response status:', response.status, response.statusText);

        if (!response.ok) {
          // Try to get error details from response
          let errorMessage = response.statusText;
          try {
            const errorData = await response.json();
            errorMessage = errorData.error || errorMessage;
            console.error('[FilesStore] Error details:', errorData);
          } catch (e) {
            // Response wasn't JSON, use statusText
          }

          // For 5xx errors, retry
          if (response.status >= 500 && attempt < retries) {
            console.warn(`[FilesStore]   Server error (attempt ${attempt}/${retries}), retrying in ${attempt}s...`);
            await new Promise((resolve) => setTimeout(resolve, 1000 * attempt));
            continue;
          }

          throw new Error(`Server returned ${response.status}: ${errorMessage}`);
        }

        const result = await response.json();
        console.log('[FilesStore]  Success:', result.message);
        logger.info(`File ${filePath} synced to backend successfully`);
        return result;
      } catch (error: any) {
        console.error(`[FilesStore]  Attempt ${attempt}/${retries} failed:`, error.message);

        // If it's a network error and we have retries left, try again
        if (attempt < retries && (error.name === 'TypeError' || error.message.includes('fetch'))) {
          console.warn(`[FilesStore]   Network error, retrying in ${attempt}s...`);
          await new Promise((resolve) => setTimeout(resolve, 1000 * attempt));
          continue;
        }

        // Last attempt or non-retryable error - throw it
        throw error;
      }
    }

    // Should never reach here, but just in case
    throw new Error('Max retries exceeded');
  }

  async #init() {
    const webcontainer = await this.#webcontainer;

    webcontainer.internal.watchPaths(
      { include: [`${WORK_DIR}/**`], exclude: ['**/node_modules', '.git'], includeContent: true },
      bufferWatchEvents(100, this.#processEventBuffer.bind(this)),
    );
  }

  #processEventBuffer(events: Array<[events: PathWatcherEvent[]]>) {
    const watchEvents = events.flat(2);

    for (const { type, path, buffer } of watchEvents) {
      const sanitizedPath = path.replace(/\/+$/g, '');

      switch (type) {
        case 'add_dir': {
          // we intentionally add a trailing slash so we can distinguish files from folders in the file tree
          this.files.setKey(sanitizedPath, { type: 'folder' });
          break;
        }
        case 'remove_dir': {
          this.files.setKey(sanitizedPath, undefined);

          for (const [direntPath] of Object.entries(this.files)) {
            if (direntPath.startsWith(sanitizedPath)) {
              this.files.setKey(direntPath, undefined);
            }
          }

          break;
        }
        case 'add_file':
        case 'change': {
          if (type === 'add_file') {
            this.#size++;
          }

          let content = '';

          /**
           * @note This check is purely for the editor. The way we detect this is not
           * bullet-proof and it's a best guess so there might be false-positives.
           * The reason we do this is because we don't want to display binary files
           * in the editor nor allow to edit them.
           */
          const isBinary = isBinaryFile(buffer);

          if (!isBinary) {
            content = this.#decodeFileContent(buffer);
          }

          this.files.setKey(sanitizedPath, { type: 'file', content, isBinary });

          break;
        }
        case 'remove_file': {
          this.#size--;
          this.files.setKey(sanitizedPath, undefined);
          break;
        }
        case 'update_directory': {
          // we don't care about these events
          break;
        }
      }
    }
  }

  #decodeFileContent(buffer?: Uint8Array) {
    if (!buffer || buffer.byteLength === 0) {
      return '';
    }

    try {
      return utf8TextDecoder.decode(buffer);
    } catch (error) {
      console.log(error);
      return '';
    }
  }
}

function isBinaryFile(buffer: Uint8Array | undefined) {
  if (buffer === undefined) {
    return false;
  }

  return getEncoding(convertToBuffer(buffer), { chunkLength: 100 }) === 'binary';
}

/**
 * Converts a `Uint8Array` into a Node.js `Buffer` by copying the prototype.
 * The goal is to  avoid expensive copies. It does create a new typed array
 * but that's generally cheap as long as it uses the same underlying
 * array buffer.
 */
function convertToBuffer(view: Uint8Array): Buffer {
  const buffer = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);

  Object.setPrototypeOf(buffer, Buffer.prototype);

  return buffer as Buffer;
}
</file>

<file path="packages/ui-server/src/server-enhanced.ts">
#!/usr/bin/env node
import Fastify from 'fastify';
import cors from '@fastify/cors';
import websocket from '@fastify/websocket';
import { Agent, ConfigLoader } from '@eitherway/runtime';
import { getAllExecutors } from '@eitherway/tools-impl';
import { createDatabaseClient, FilesRepository } from '@eitherway/database';
import { readdir, readFile, stat, writeFile } from 'fs/promises';
import { join, dirname, resolve, relative } from 'path';
import { fileURLToPath } from 'url';
import { registerSessionRoutes } from './routes/sessions.js';
import { registerAppRoutes } from './routes/apps.js';
import { registerImageRoutes } from './routes/images.js';

const fastify = Fastify({ logger: true });

// @ts-expect-error Fastify plugin type compatibility issue with current version
await fastify.register(cors, { origin: true });
// @ts-expect-error Fastify plugin type compatibility issue with current version
await fastify.register(websocket);

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const PROJECT_ROOT = join(__dirname, '../../..');
const WORKSPACE_DIR = process.env.WORKSPACE_DIR || join(PROJECT_ROOT, 'workspace');

const loader = new ConfigLoader(join(PROJECT_ROOT, 'configs'));
const { claudeConfig, agentConfig } = await loader.loadAll();

const db = createDatabaseClient();

console.log('Checking database connection...');
const healthy = await db.healthCheck();
if (!healthy) {
  console.error('Failed to connect to database');
  process.exit(1);
}
console.log(' Database connected\n');

await registerSessionRoutes(fastify, db);
await registerAppRoutes(fastify, db);
await registerImageRoutes(fastify, db);

fastify.get('/api/health', async () => {
  const dbHealthy = await db.healthCheck();
  return {
    status: 'ok',
    workspace: WORKSPACE_DIR,
    database: dbHealthy ? 'connected' : 'disconnected',
  };
});

fastify.get('/api/files', async () => {
  const files = await getFileTree(WORKSPACE_DIR);
  return { files };
});

fastify.get<{ Params: { '*': string } }>('/api/files/*', async (request, reply) => {
  const filePath = request.params['*'];
  const fullPath = resolve(WORKSPACE_DIR, filePath);

  const normalizedWorkspace = resolve(WORKSPACE_DIR);
  const normalizedPath = resolve(fullPath);
  const relativePath = relative(normalizedWorkspace, normalizedPath);

  if (relativePath.startsWith('..') || resolve(normalizedWorkspace, relativePath) !== normalizedPath) {
    return reply.code(403).send({ error: 'Access denied: path traversal detected' });
  }

  try {
    const content = await readFile(fullPath, 'utf-8');
    return { path: filePath, content };
  } catch (error: any) {
    return reply.code(404).send({ error: error.message });
  }
});

/**
 * POST /api/files/:path
 * Save a file to both filesystem and database
 */
fastify.post<{
  Params: { '*': string };
  Body: { content: string };
}>('/api/files/*', async (request, reply) => {
  const filePath = request.params['*'];
  const { content } = request.body;

  if (!content && content !== '') {
    return reply.code(400).send({ error: 'Content is required' });
  }

  const fullPath = resolve(WORKSPACE_DIR, filePath);

  // Security: Ensure the resolved path is within WORKSPACE_DIR
  const normalizedWorkspace = resolve(WORKSPACE_DIR);
  const normalizedPath = resolve(fullPath);
  const relativePath = relative(normalizedWorkspace, normalizedPath);

  if (relativePath.startsWith('..') || resolve(normalizedWorkspace, relativePath) !== normalizedPath) {
    return reply.code(403).send({ error: 'Access denied: path traversal detected' });
  }

  try {
    // Write to filesystem
    await writeFile(fullPath, content, 'utf-8');

    // Save to database
    const filesRepo = new FilesRepository(db);
    const appId = process.env.APP_ID || 'default-app';
    await filesRepo.upsertFile(appId, filePath, content);

    return {
      success: true,
      path: filePath,
      message: 'File saved successfully',
    };
  } catch (error: any) {
    console.error('Error saving file:', error);
    return reply.code(500).send({ error: error.message });
  }
});

await fastify.register(async (fastify) => {
  // @ts-expect-error Fastify WebSocket type compatibility issue
  fastify.get('/api/agent', { websocket: true }, (connection) => {
    connection.socket.on('message', async (message: Buffer) => {
      const data = JSON.parse(message.toString());

      if (data.type === 'prompt') {
        try {
          const agent = new Agent({
            workingDir: WORKSPACE_DIR,
            claudeConfig,
            agentConfig,
            executors: getAllExecutors(),
            dryRun: false,
            webSearch: agentConfig.tools.webSearch,
          });

          // @ts-expect-error Fastify WebSocket socket type issue
          connection.socket.send(
            JSON.stringify({
              type: 'status',
              message: 'Processing request...',
            }),
          );

          const response = await agent.processRequest(data.prompt);

          // @ts-expect-error Fastify WebSocket socket type issue
          connection.socket.send(
            JSON.stringify({
              type: 'response',
              content: response,
            }),
          );

          const files = await getFileTree(WORKSPACE_DIR);
          // @ts-expect-error Fastify WebSocket socket type issue
          connection.socket.send(
            JSON.stringify({
              type: 'files_updated',
              files,
            }),
          );

          await agent.saveTranscript();
        } catch (error: any) {
          // Log the full error for debugging
          console.error('[Agent Error]', error);

          // Parse error message for better display
          let errorMessage = error.message || 'Unknown error occurred';

          // Check if it's an Anthropic API error
          if (error.message && error.message.includes('"type":"api_error"')) {
            try {
              // Try to parse the JSON error
              const jsonMatch = error.message.match(/\{.*\}/);
              if (jsonMatch) {
                const errorObj = JSON.parse(jsonMatch[0]);
                if (errorObj.error?.message) {
                  errorMessage = `Anthropic API Error: ${errorObj.error.message}`;
                  if (errorObj.request_id) {
                    errorMessage += ` (Request ID: ${errorObj.request_id})`;
                  }
                }
              }
            } catch (parseError) {
              // If parsing fails, use the original message
              console.error('[Error Parsing]', parseError);
            }
          }

          // @ts-expect-error Fastify WebSocket socket type issue
          connection.socket.send(
            JSON.stringify({
              type: 'error',
              message: errorMessage,
            }),
          );
        }
      }
    });

    connection.socket.on('close', () => {
      console.log('Client disconnected');
    });
  });
});

async function getFileTree(dir: string, basePath: string = ''): Promise<FileNode[]> {
  const entries = await readdir(dir, { withFileTypes: true });
  const nodes: FileNode[] = [];

  for (const entry of entries) {
    if (entry.name.startsWith('.') || entry.name === 'node_modules') {
      continue;
    }

    const fullPath = join(dir, entry.name);
    const relativePath = basePath ? join(basePath, entry.name) : entry.name;

    if (entry.isDirectory()) {
      const children = await getFileTree(fullPath, relativePath);
      nodes.push({
        name: entry.name,
        path: relativePath,
        type: 'directory',
        children,
      });
    } else {
      const stats = await stat(fullPath);
      nodes.push({
        name: entry.name,
        path: relativePath,
        type: 'file',
        size: stats.size,
      });
    }
  }

  return nodes.sort((a, b) => {
    if (a.type === b.type) return a.name.localeCompare(b.name);
    return a.type === 'directory' ? -1 : 1;
  });
}

interface FileNode {
  name: string;
  path: string;
  type: 'file' | 'directory';
  size?: number;
  children?: FileNode[];
}

const PORT = process.env.PORT || 3001;

try {
  await fastify.listen({ port: Number(PORT), host: '0.0.0.0' });
  console.log(`\n EitherWay UI Server running on http://localhost:${PORT}`);
  console.log(` Workspace: ${WORKSPACE_DIR}`);
  console.log(` Database: Connected\n`);
} catch (err) {
  fastify.log.error(err);
  process.exit(1);
}

process.on('SIGTERM', async () => {
  await db.close();
  await fastify.close();
});
</file>

<file path="packages/tools-core/src/schemas.ts">
/**
 * JSON Schema definitions for all tools
 * These match Anthropic's Messages API tool schema format
 */

import { ToolDefinition } from './types.js';

export const TOOL_SCHEMAS: Record<string, ToolDefinition> = {
  'either-view': {
    name: 'either-view',
    description: 'Read a file (or small list) to understand current code before changing it.',
    input_schema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Relative path to a file.',
        },
        max_bytes: {
          type: 'integer',
          minimum: 1,
          maximum: 1048576,
          description: 'Maximum bytes to read (default: 1MB)',
        },
        encoding: {
          type: 'string',
          description: 'File encoding (default: utf-8)',
          default: 'utf-8',
        },
      },
      required: ['path'],
      additionalProperties: false,
    },
  },

  'either-search-files': {
    name: 'either-search-files',
    description: 'Search code for patterns to understand usage and dependencies.',
    input_schema: {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'Search pattern or text to find',
        },
        glob: {
          type: 'string',
          description: 'File pattern to search in',
          default: 'src/**/*',
        },
        max_results: {
          type: 'integer',
          minimum: 1,
          maximum: 1000,
          description: 'Maximum number of results to return',
          default: 100,
        },
        regex: {
          type: 'boolean',
          description: 'Treat query as a regex pattern (default: false)',
          default: false,
        },
        context_lines: {
          type: 'integer',
          minimum: 0,
          description: 'Number of context lines to show before/after matches',
          default: 0,
        },
      },
      required: ['query'],
      additionalProperties: false,
    },
  },

  'either-write': {
    name: 'either-write',
    description: 'Create a NEW file with provided content. Fails if file exists unless overwrite=true.',
    input_schema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Relative path for the new file',
        },
        content: {
          type: 'string',
          description: 'Content to write to the file',
        },
        overwrite: {
          type: 'boolean',
          description: 'Allow overwriting existing file',
          default: false,
        },
        create_dirs: {
          type: 'boolean',
          description: 'Create parent directories if needed',
          default: true,
        },
      },
      required: ['path', 'content'],
      additionalProperties: false,
    },
  },

  'either-line-replace': {
    name: 'either-line-replace',
    description: 'Targeted edits in EXISTING files. Prefer this over rewriting entire files.',
    input_schema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path to the file to edit',
        },
        locator: {
          type: 'object',
          description: 'Location specification for the edit',
          properties: {
            start_line: {
              type: 'integer',
              minimum: 1,
              description: 'Starting line number (1-indexed)',
            },
            end_line: {
              type: 'integer',
              minimum: 1,
              description: 'Ending line number (inclusive)',
            },
            needle: {
              type: 'string',
              description: 'Optional exact text to verify you are editing the intended block',
            },
          },
          required: ['start_line', 'end_line'],
          additionalProperties: false,
        },
        replacement: {
          type: 'string',
          description: 'New content to replace the specified lines',
        },
        verify_after: {
          type: 'boolean',
          description: 'Verify the edit was applied correctly',
          default: true,
        },
      },
      required: ['path', 'locator', 'replacement'],
      additionalProperties: false,
    },
  },

  'eithergen--generate_image': {
    name: 'eithergen--generate_image',
    description:
      'Generate high-quality images using DALL-E 3 and save to database-backed VFS. This tool WAITS for generation to complete and validates the image before returning. The tool response includes the EXACT file path - you MUST use this exact path when referencing the image in HTML/code (e.g., if saved to "/public/hero.png", use src="/public/hero.png" not src="/hero.png"). Generation takes 10-30 seconds.',
    input_schema: {
      type: 'object',
      properties: {
        prompt: {
          type: 'string',
          description: 'Detailed image generation prompt. Be specific about style, composition, colors, and content.',
        },
        path: {
          type: 'string',
          description:
            'Path where the image should be saved (e.g., "/public/hero.png"). You MUST use this exact same path when referencing the image in HTML/code. Extension will be added automatically if missing.',
        },
        size: {
          type: 'string',
          pattern: '^[0-9]+x[0-9]+$',
          description:
            'Image size. Supports: "1024x1024" (square), "1792x1024" (landscape), "1024x1792" (portrait). Default: "1024x1024"',
          default: '1024x1024',
        },
        quality: {
          type: 'string',
          enum: ['standard', 'hd'],
          description: 'Image quality. "hd" creates finer details and greater consistency. Default: "standard"',
          default: 'standard',
        },
      },
      required: ['prompt', 'path'],
      additionalProperties: false,
    },
  },
};

// Export individual schemas for direct access
export const EITHER_VIEW_SCHEMA = TOOL_SCHEMAS['either-view'];
export const EITHER_SEARCH_FILES_SCHEMA = TOOL_SCHEMAS['either-search-files'];
export const EITHER_WRITE_SCHEMA = TOOL_SCHEMAS['either-write'];
export const EITHER_LINE_REPLACE_SCHEMA = TOOL_SCHEMAS['either-line-replace'];
export const IMAGEGEN_SCHEMA = TOOL_SCHEMAS['eithergen--generate_image'];

// Get all tool definitions as array for Claude API
export function getAllToolDefinitions(): ToolDefinition[] {
  return Object.values(TOOL_SCHEMAS);
}
</file>

<file path="packages/ui-frontend/app/components/deployment/DeploymentPanel.tsx">
/**
 * Deployment & Download Modals
 *
 * Modern modals for deployment to Netlify and downloading project files
 */

import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

// TYPES

interface DeploymentPanelProps {
  appId: string;
  sessionId: string;
  userId: string;
  initialTab?: 'deploy' | 'download';
  onClose?: () => void;
}

// MAIN COMPONENT

export function DeploymentPanel({ appId, sessionId, userId, initialTab = 'deploy', onClose }: DeploymentPanelProps) {
  return (
    <AnimatePresence>
      {initialTab === 'deploy' ? (
        <DeployModal appId={appId} sessionId={sessionId} userId={userId} onClose={onClose} />
      ) : (
        <DownloadModal appId={appId} sessionId={sessionId} userId={userId} onClose={onClose} />
      )}
    </AnimatePresence>
  );
}

// DEPLOY MODAL (NETLIFY ONLY)

interface DeployResult {
  siteId: string;
  deployId: string;
  siteUrl: string;
  adminUrl: string;
  deployUrl: string;
}

function DeployModal({ appId, sessionId, userId, onClose }: Omit<DeploymentPanelProps, 'initialTab'>) {
  const [netlifyToken, setNetlifyToken] = useState('');
  const [siteName, setSiteName] = useState('');
  const [isDeploying, setIsDeploying] = useState(false);
  const [deployResult, setDeployResult] = useState<DeployResult | null>(null);
  const [error, setError] = useState<string | null>(null);

  const handleDeploy = async () => {
    if (!netlifyToken) {
      setError('Please enter your Netlify access token');
      return;
    }

    setIsDeploying(true);
    setError(null);

    try {
      // Step 1: Validate and save the token
      console.log('[Deploy] Validating Netlify token...');
      const validateResponse = await fetch('/api/netlify/validate-token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId,
          token: netlifyToken
        })
      });

      const validateData = await validateResponse.json();

      if (!validateResponse.ok || !validateData.success) {
        setError(`Token validation failed: ${validateData.error || 'Invalid token'}`);
        setIsDeploying(false);
        return;
      }

      console.log('[Deploy] Token validated successfully!');

      // Step 2: Deploy to Netlify
      console.log('[Deploy] Starting deployment...');
      const deployResponse = await fetch('/api/netlify/deploy', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          appId,
          userId,
          sessionId,
          siteName: siteName || undefined,
          deployTitle: siteName ? `Deploy ${siteName}` : 'Deploy from EitherWay',
          includeNodeModules: false
        })
      });

      const deployData = await deployResponse.json();

      if (!deployResponse.ok || !deployData.success) {
        setError(`Deployment failed: ${deployData.error || 'Unknown error'}`);
        setIsDeploying(false);
        return;
      }

      console.log('[Deploy] Deployment successful!', deployData.data);

      setDeployResult(deployData.data);
      setIsDeploying(false);

    } catch (error: any) {
      console.error('Deployment error:', error);
      setError(`Failed to deploy: ${error.message}`);
      setIsDeploying(false);
    }
  };

  // Show success view if deployment completed
  if (deployResult) {
    return (
      <ModalOverlay onClose={onClose}>
        <motion.div
          initial={{ scale: 0.95, opacity: 0, y: 20 }}
          animate={{ scale: 1, opacity: 1, y: 0 }}
          exit={{ scale: 0.95, opacity: 0, y: 20 }}
          transition={{ duration: 0.2, ease: [0.16, 1, 0.3, 1] }}
          className="bg-[#1a1a1a] rounded-2xl shadow-2xl w-full max-w-2xl mx-4 overflow-hidden border border-gray-800"
          onClick={(e) => e.stopPropagation()}
        >
          {/* Success Header */}
          <div className="px-6 py-5 border-b border-gray-800 flex items-center justify-between bg-gradient-to-r from-emerald-500/10 to-teal-500/10">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-full bg-emerald-500/20 flex items-center justify-center">
                <svg className="w-6 h-6 text-emerald-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                </svg>
              </div>
              <div>
                <h2 className="text-xl font-semibold text-white">Deployment Successful!</h2>
                <p className="text-sm text-gray-400 mt-0.5">Your site is now live on Netlify</p>
              </div>
            </div>
            <button
              onClick={onClose}
              className="w-8 h-8 rounded-lg flex items-center justify-center text-gray-400 hover:text-white hover:bg-gray-800 transition-colors"
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>

          {/* Success Content */}
          <div className="p-6">
            {/* URLs Section */}
            <div className="space-y-3 mb-6">
              <div className="bg-[#0e0e0e] border border-gray-800 rounded-xl p-4">
                <div className="flex items-start gap-3">
                  <svg className="w-5 h-5 text-[#00c7b7] flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9" />
                  </svg>
                  <div className="flex-1 min-w-0">
                    <p className="text-xs font-medium text-gray-400 mb-1">Production URL</p>
                    <a
                      href={deployResult.siteUrl}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-sm text-[#00c7b7] hover:text-[#00b3a6] break-all transition-colors"
                    >
                      {deployResult.siteUrl}
                    </a>
                  </div>
                </div>
              </div>

              <div className="bg-[#0e0e0e] border border-gray-800 rounded-xl p-4">
                <div className="flex items-start gap-3">
                  <svg className="w-5 h-5 text-blue-400 flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                  </svg>
                  <div className="flex-1 min-w-0">
                    <p className="text-xs font-medium text-gray-400 mb-1">Netlify Admin</p>
                    <a
                      href={deployResult.adminUrl}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-sm text-blue-400 hover:text-blue-300 break-all transition-colors"
                    >
                      {deployResult.adminUrl}
                    </a>
                  </div>
                </div>
              </div>
            </div>

            {/* Action Buttons */}
            <div className="flex gap-3">
              <button
                onClick={() => window.open(deployResult.siteUrl, '_blank')}
                className="flex-1 py-3 bg-gradient-to-r from-[#00c7b7] to-[#00a896] hover:from-[#00b3a6] hover:to-[#009688] text-white rounded-xl font-medium transition-all flex items-center justify-center gap-2 shadow-lg shadow-[#00c7b7]/20"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                </svg>
                Open Site
              </button>
              <button
                onClick={onClose}
                className="px-6 py-3 bg-gray-800 hover:bg-gray-700 text-white rounded-xl font-medium transition-colors"
              >
                Close
              </button>
            </div>

            {/* Deploy Info */}
            <div className="mt-4 pt-4 border-t border-gray-800">
              <div className="flex items-center justify-between text-xs text-gray-500">
                <span>Deploy ID: {deployResult.deployId}</span>
                <span>Site ID: {deployResult.siteId.slice(0, 8)}...</span>
              </div>
            </div>
          </div>
        </motion.div>
      </ModalOverlay>
    );
  }

  return (
    <ModalOverlay onClose={onClose}>
      <motion.div
        initial={{ scale: 0.95, opacity: 0, y: 20 }}
        animate={{ scale: 1, opacity: 1, y: 0 }}
        exit={{ scale: 0.95, opacity: 0, y: 20 }}
        transition={{ duration: 0.2, ease: [0.16, 1, 0.3, 1] }}
        className="bg-[#1a1a1a] rounded-2xl shadow-2xl w-full max-w-2xl mx-4 overflow-hidden border border-gray-800"
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="px-6 py-5 border-b border-gray-800 flex items-center justify-between">
          <div>
            <h2 className="text-xl font-semibold text-white">Deploy</h2>
            <p className="text-sm text-gray-400 mt-1">Choose where to deploy your application</p>
          </div>
          <button
            onClick={onClose}
            className="w-8 h-8 rounded-lg flex items-center justify-center text-gray-400 hover:text-white hover:bg-gray-800 transition-colors"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {/* Content */}
        <div className="p-6">
          {/* Web Section */}
          <div className="mb-6">
            <h3 className="text-sm font-medium text-gray-400 uppercase tracking-wider mb-4">Web</h3>

            {/* Netlify Card */}
            <div className="bg-[#0e0e0e] border border-gray-800 rounded-xl p-5 hover:border-gray-700 transition-colors">
              <div className="flex items-start gap-4">
                {/* Netlify Icon */}
                <div className="w-12 h-12 bg-white rounded-lg flex items-center justify-center flex-shrink-0 p-2">
                  <img
                    src="https://uxwing.com/wp-content/themes/uxwing/download/brands-and-social-media/netlify-icon.png"
                    alt="Netlify"
                    className="w-full h-full object-contain"
                  />
                </div>

                {/* Content */}
                <div className="flex-1 min-w-0">
                  <div className="flex items-center justify-between mb-3">
                    <h4 className="text-lg font-semibold text-white">Netlify</h4>
                  </div>

                  <p className="text-sm text-gray-400 mb-4">
                    Deploy your application to Netlify's global edge network with automatic SSL and CDN.
                  </p>

                  {/* Form Fields */}
                  <div className="space-y-3">
                    <div>
                      <label className="block text-sm font-medium text-gray-300 mb-2">
                        Access Token *
                      </label>
                      <input
                        type="password"
                        value={netlifyToken}
                        onChange={(e) => setNetlifyToken(e.target.value)}
                        placeholder="Enter your Netlify access token"
                        className="w-full px-3 py-2 bg-[#1a1a1a] border border-gray-700 rounded-lg text-white text-sm placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-[#00c7b7] focus:border-transparent"
                      />
                      <p className="mt-1.5 text-xs text-gray-500">
                        Generate a token{' '}
                        <a
                          href="https://docs.netlify.com/api-and-cli-guides/api-guides/get-started-with-api/#authentication"
                          target="_blank"
                          rel="noopener noreferrer"
                          className="text-[#00c7b7] hover:underline"
                        >
                          here
                        </a>
                      </p>
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-300 mb-2">
                        Site Name (Optional)
                      </label>
                      <input
                        type="text"
                        value={siteName}
                        onChange={(e) => setSiteName(e.target.value)}
                        placeholder="my-awesome-site"
                        className="w-full px-3 py-2 bg-[#1a1a1a] border border-gray-700 rounded-lg text-white text-sm placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-[#00c7b7] focus:border-transparent"
                      />
                      <p className="mt-1.5 text-xs text-gray-500">
                        Leave empty for auto-generated name
                      </p>
                    </div>
                  </div>

                  {/* Error Message */}
                  {error && (
                    <div className="mt-3 bg-red-500/10 border border-red-500/30 rounded-lg p-3">
                      <div className="flex gap-2">
                        <svg className="w-5 h-5 text-red-400 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <p className="text-sm text-red-300">{error}</p>
                      </div>
                    </div>
                  )}

                  {/* Deploy Button */}
                  <button
                    onClick={handleDeploy}
                    disabled={isDeploying || !netlifyToken}
                    className="mt-4 w-full py-2.5 bg-gradient-to-r from-[#00c7b7] to-[#00a896] hover:from-[#00b3a6] hover:to-[#009688] disabled:from-gray-700 disabled:to-gray-700 disabled:cursor-not-allowed text-white rounded-lg font-medium transition-all text-sm flex items-center justify-center gap-2"
                  >
                    {isDeploying ? (
                      <>
                        <svg className="animate-spin h-4 w-4" fill="none" viewBox="0 0 24 24">
                          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                        </svg>
                        <span>Deploying...</span>
                      </>
                    ) : (
                      <>
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                        </svg>
                        <span>Deploy to Netlify</span>
                      </>
                    )}
                  </button>
                </div>
              </div>
            </div>
          </div>

          {/* Info Box */}
          <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
            <div className="flex gap-3">
              <svg className="w-5 h-5 text-blue-400 flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
              <div>
                <h4 className="text-sm font-semibold text-blue-300 mb-1">Before deploying</h4>
                <ul className="text-xs text-blue-200/80 space-y-1">
                  <li> Ensure your application is production-ready</li>
                  <li> Your Netlify token needs deploy permissions</li>
                  <li> Build process will run automatically</li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </motion.div>
    </ModalOverlay>
  );
}

// DOWNLOAD MODAL

function DownloadModal({ appId, sessionId, userId, onClose }: Omit<DeploymentPanelProps, 'initialTab'>) {
  const [includeNodeModules, setIncludeNodeModules] = useState(false);
  const [isExporting, setIsExporting] = useState(false);

  const handleDownload = async () => {
    setIsExporting(true);

    try {
      const response = await fetch(`/api/apps/${appId}/export`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId,
          sessionId,
          includeNodeModules
        })
      });

      if (response.ok) {
        // Download ZIP file
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `app-${appId}-${Date.now()}.zip`;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
      } else {
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
          const data = await response.json();
          alert(`Export failed: ${data.error || data.message || 'Unknown error'}`);
        } else {
          const text = await response.text();
          alert(`Export failed: ${text || `HTTP ${response.status}`}`);
        }
      }
    } catch (error: any) {
      console.error('Export error:', error);
      alert(`Failed to export: ${error.message}`);
    } finally {
      setIsExporting(false);
    }
  };

  return (
    <ModalOverlay onClose={onClose}>
      <motion.div
        initial={{ scale: 0.95, opacity: 0, y: 20 }}
        animate={{ scale: 1, opacity: 1, y: 0 }}
        exit={{ scale: 0.95, opacity: 0, y: 20 }}
        transition={{ duration: 0.2, ease: [0.16, 1, 0.3, 1] }}
        className="bg-[#1a1a1a] rounded-2xl shadow-2xl w-full max-w-2xl mx-4 overflow-hidden border border-gray-800"
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="px-6 py-5 border-b border-gray-800 flex items-center justify-between">
          <div>
            <h2 className="text-xl font-semibold text-white">Download</h2>
            <p className="text-sm text-gray-400 mt-1">Export your project files</p>
          </div>
          <button
            onClick={onClose}
            className="w-8 h-8 rounded-lg flex items-center justify-center text-gray-400 hover:text-white hover:bg-gray-800 transition-colors"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {/* Content */}
        <div className="p-6">
          {/* Export Options Section */}
          <div className="bg-[#0e0e0e] border border-gray-800 rounded-xl p-5 mb-4">
            <h3 className="text-base font-semibold text-white mb-4">Export Options</h3>

            {/* Checkbox */}
            <label className="flex items-start gap-3 cursor-pointer group">
              <div className="relative flex items-center justify-center">
                <input
                  type="checkbox"
                  checked={includeNodeModules}
                  onChange={(e) => setIncludeNodeModules(e.target.checked)}
                  className="w-5 h-5 bg-[#1a1a1a] border-2 border-gray-700 rounded cursor-pointer appearance-none checked:bg-blue-600 checked:border-blue-600 transition-colors"
                />
                {includeNodeModules && (
                  <svg
                    className="w-3 h-3 text-white absolute pointer-events-none"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
                  </svg>
                )}
              </div>
              <div className="flex-1">
                <span className="text-sm font-medium text-gray-200 group-hover:text-white transition-colors">
                  Include node_modules
                </span>
                <p className="text-xs text-gray-500 mt-1">
                  By default, node_modules and .env files are excluded for security and file size reasons.
                </p>
              </div>
            </label>
          </div>

          {/* Download Button */}
          <button
            onClick={handleDownload}
            disabled={isExporting}
            className="w-full py-3 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 disabled:from-gray-700 disabled:to-gray-700 disabled:cursor-not-allowed text-white rounded-xl font-medium transition-all flex items-center justify-center gap-2.5 shadow-lg shadow-blue-500/20"
          >
            {isExporting ? (
              <>
                <svg className="animate-spin h-5 w-5" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                </svg>
                <span>Preparing download...</span>
              </>
            ) : (
              <>
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                </svg>
                <span>Download ZIP</span>
              </>
            )}
          </button>

          {/* What's Included Section */}
          <div className="mt-4 bg-emerald-500/10 border border-emerald-500/30 rounded-lg p-4">
            <div className="flex gap-3">
              <svg className="w-5 h-5 text-emerald-400 flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4" />
              </svg>
              <div>
                <h4 className="text-sm font-semibold text-emerald-300 mb-2">What's Included</h4>
                <ul className="text-xs text-emerald-200/80 space-y-1.5">
                  <li className="flex items-center gap-2">
                    <span className="text-emerald-400"></span>
                    <span>All application source files</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <span className="text-emerald-400"></span>
                    <span>README with setup instructions</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <span className="text-emerald-400"></span>
                    <span>Configuration files (package.json, etc.)</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <span className="text-emerald-400"></span>
                    <span>Compressed for faster download</span>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </motion.div>
    </ModalOverlay>
  );
}

// MODAL OVERLAY COMPONENT

function ModalOverlay({ children, onClose }: { children: React.ReactNode; onClose?: () => void }) {
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      transition={{ duration: 0.2 }}
      className="fixed inset-0 bg-black/70 backdrop-blur-sm z-50 flex items-center justify-center p-4 overflow-y-auto"
      onClick={onClose}
    >
      {children}
    </motion.div>
  );
}
</file>

<file path="packages/ui-frontend/app/components/sidebar/Menu.client.tsx">
import { motion, type Variants } from 'framer-motion';
import { useCallback, useEffect, useRef, useState } from 'react';
import { toast } from 'react-toastify';
import { Dialog, DialogButton, DialogDescription, DialogRoot, DialogTitle } from '~/components/ui/Dialog';
import { ThemeSwitch } from '~/components/ui/ThemeSwitch';
import { getDb, deleteById, getAll, chatId, type ChatHistoryItem } from '~/lib/persistence';
import { cubicEasingFn } from '~/utils/easings';
import { logger } from '~/utils/logger';
import { HistoryItem } from './HistoryItem';
import { binDates } from './date-binning';
import { useStore } from '@nanostores/react';
import { sidebarStore, openSidebar, closeSidebar } from '~/lib/stores/sidebar';
import { clearSession } from '~/utils/sessionManager';
import { BACKEND_URL } from '~/config/api';
import { authStore } from '~/lib/stores/auth';
import { useWalletConnection } from '~/lib/web3/hooks';

const menuVariants = {
  closed: {
    opacity: 0,
    visibility: 'hidden',
    left: '-150px',
    transition: {
      duration: 0.2,
      ease: cubicEasingFn,
    },
  },
  open: {
    opacity: 1,
    visibility: 'initial',
    left: 0,
    transition: {
      duration: 0.2,
      ease: cubicEasingFn,
    },
  },
} satisfies Variants;

type DialogContent = { type: 'delete'; item: ChatHistoryItem } | null;

export function Menu() {
  const menuRef = useRef<HTMLDivElement>(null);
  const [list, setList] = useState<ChatHistoryItem[]>([]);
  const sidebar = useStore(sidebarStore);
  const open = sidebar.isOpen;
  const [dialogContent, setDialogContent] = useState<DialogContent>(null);

  // Get authenticated user info
  const user = useStore(authStore.user);
  const { isConnected, address } = useWalletConnection();
  // Prioritize wallet address (email auth is mostly mock)
  const userId = (isConnected && address ? address : user?.email) || null;

  const loadEntries = useCallback(async () => {
    try {
      // Only load if user is authenticated
      if (!userId) {
        console.log('No authenticated user, skipping history load');
        setList([]);
        return;
      }

      // First get user ID from the authenticated user's identifier (wallet address or email)
      const userResponse = await fetch(`${BACKEND_URL}/api/users?email=${encodeURIComponent(userId)}`);
      if (!userResponse.ok) {
        throw new Error('Failed to fetch user');
      }
      const backendUser = await userResponse.json();

      // Then fetch sessions for this user
      const sessionsResponse = await fetch(`${BACKEND_URL}/api/sessions?userId=${backendUser.id}&limit=50`);
      if (!sessionsResponse.ok) {
        throw new Error('Failed to fetch sessions');
      }
      const { sessions } = await sessionsResponse.json();

      // Transform backend sessions to match ChatHistoryItem format
      const transformedList = sessions.map((session: any) => ({
        id: session.id,
        urlId: session.id,
        description: session.title || 'Untitled Chat',
        timestamp: new Date(session.created_at).getTime(),
      }));

      setList(transformedList);
    } catch (error) {
      console.error('Failed to load chat history:', error);
      toast.error('Failed to load chat history');
    }
  }, [userId]);

  const deleteItem = useCallback(
    async (event: React.UIEvent, item: ChatHistoryItem) => {
      event.preventDefault();

      try {
        const response = await fetch(`${BACKEND_URL}/api/sessions/${item.id}`, {
          method: 'DELETE',
        });

        if (!response.ok) {
          throw new Error('Failed to delete session');
        }

        // Reload the list
        await loadEntries();

        // If we just deleted the current session, clear it and navigate home
        const currentSessionId = localStorage.getItem('currentSessionId');
        if (currentSessionId === item.id) {
          localStorage.removeItem('currentSessionId');
          window.location.pathname = '/';
        }

        toast.success('Chat deleted successfully');
      } catch (error) {
        toast.error('Failed to delete conversation');
        logger.error(error);
      }
    },
    [loadEntries],
  );

  const closeDialog = () => {
    setDialogContent(null);
  };

  useEffect(() => {
    loadEntries();
  }, [loadEntries]);

  useEffect(() => {
    if (open) {
      loadEntries();
    }
  }, [open, loadEntries]);

  useEffect(() => {
    const enterThreshold = 40;
    const exitThreshold = 40;

    function onMouseMove(event: MouseEvent) {
      if (event.pageX < enterThreshold) {
        openSidebar();
      }

      if (menuRef.current && event.clientX > menuRef.current.getBoundingClientRect().right + exitThreshold) {
        closeSidebar();
      }
    }

    window.addEventListener('mousemove', onMouseMove);

    return () => {
      window.removeEventListener('mousemove', onMouseMove);
    };
  }, []);

  return (
    <motion.div
      ref={menuRef}
      initial="closed"
      animate={open ? 'open' : 'closed'}
      variants={menuVariants}
      className="flex flex-col bg-eitherway-elements-background-depth-2 side-menu z-10 fixed top-0 w-[350px] h-full border-r rounded-r-3xl border-eitherway-elements-borderColor shadow-xl shadow-eitherway-elements-sidebar-dropdownShadow text-sm"
    >
      <div className="flex items-center h-[var(--header-height)]">{/* Placeholder */}</div>
      <div className="flex-1 flex flex-col bg-eitherway-elements-background-depth-2 h-full w-full overflow-hidden">
        <div className="p-4">
          <button
            onClick={() => {
              // Clear session to start fresh conversation
              clearSession();
              // Navigate to chat page
              window.location.href = '/chat';
            }}
            className="flex gap-2 items-center bg-white/10 text-eitherway-elements-sidebar-buttonText hover:bg-white/20 rounded-md p-2 transition-theme w-full"
          >
            <span className="inline-block i-eitherway:chat text-white scale-110" />
            Start new chat
          </button>
        </div>
        <div className="text-eitherway-elements-textPrimary font-medium pl-6 pr-5 my-2">Your Chats</div>
        <div className={`flex-1 pl-4 pr-5 pb-5 ${list.length > 0 ? 'overflow-auto' : 'overflow-hidden'}`}>
          {list.length === 0 && (
            <div className="pl-2 text-eitherway-elements-textTertiary">No previous conversations</div>
          )}
          <DialogRoot open={dialogContent !== null}>
            {binDates(list).map(({ category, items }) => (
              <div key={category} className="mt-4 first:mt-0 space-y-1">
                <div className="text-eitherway-elements-textTertiary sticky top-0 z-1 bg-eitherway-elements-background-depth-2 pl-2 pt-2 pb-1">
                  {category}
                </div>
                {items.map((item) => (
                  <HistoryItem key={item.id} item={item} onDelete={() => setDialogContent({ type: 'delete', item })} />
                ))}
              </div>
            ))}
            <Dialog onBackdrop={closeDialog} onClose={closeDialog}>
              {dialogContent?.type === 'delete' && (
                <>
                  <DialogTitle>Delete Chat?</DialogTitle>
                  <DialogDescription asChild>
                    <div>
                      <p>
                        You are about to delete <strong>{dialogContent.item.description}</strong>.
                      </p>
                      <p className="mt-1">Are you sure you want to delete this chat?</p>
                    </div>
                  </DialogDescription>
                  <div className="px-5 pb-4 bg-eitherway-elements-background-depth-2 flex gap-2 justify-end">
                    <DialogButton type="secondary" onClick={closeDialog}>
                      Cancel
                    </DialogButton>
                    <DialogButton
                      type="danger"
                      onClick={(event) => {
                        deleteItem(event, dialogContent.item);
                        closeDialog();
                      }}
                    >
                      Delete
                    </DialogButton>
                  </div>
                </>
              )}
            </Dialog>
          </DialogRoot>
        </div>
        <div className="flex items-center border-t border-eitherway-elements-borderColor p-4">
          <ThemeSwitch className="ml-auto" />
        </div>
      </div>
    </motion.div>
  );
}
</file>

<file path="packages/ui-frontend/app/utils/sessionManager.ts">
/**
 * Session management utilities
 * Handles creating and managing chat sessions with the backend
 */

import { brandKitStore } from '~/lib/stores/brandKit';
import { BACKEND_URL } from '~/config/api';

interface Session {
  id: string;
  user_id: string;
  app_id: string;
  title: string;
  status: 'active' | 'archived';
  created_at: string;
  updated_at: string;
  last_message_at: string | null;
}

export async function createSession(email: string, title: string): Promise<Session> {
  const response = await fetch(`${BACKEND_URL}/api/sessions`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ email, title }),
  });

  if (!response.ok) {
    throw new Error(`Failed to create session: ${response.statusText}`);
  }

  return response.json();
}

export async function getOrCreateSession(email: string, title: string = 'New Chat'): Promise<Session> {
  const storedSessionId = localStorage.getItem('currentSessionId');

  if (storedSessionId) {
    console.log(' [Session Persistence] Found stored session ID:', storedSessionId);
    // Try to fetch the session to verify it still exists
    try {
      const response = await fetch(`${BACKEND_URL}/api/sessions/${storedSessionId}`);
      if (response.ok) {
        const data = await response.json();
        console.log(
          ' [Session Persistence] Reusing existing session:',
          data.session.id,
          '- Title:',
          data.session.title,
        );
        return data.session;
      } else {
        console.warn(
          ' [Session Persistence] Stored session not found on server (status:',
          response.status,
          '), creating new one',
        );
      }
    } catch (error) {
      console.warn(' [Session Persistence] Error fetching stored session, creating new one:', error);
    }
  } else {
    console.log(' [Session Persistence] No stored session found in localStorage');
  }

  console.log(' [Session Persistence] Creating new session with title:', title);
  const session = await createSession(email, title);
  localStorage.setItem('currentSessionId', session.id);
  console.log(' [Session Persistence] New session created and stored:', session.id);
  return session;
}

/**
 * Clear the current session from localStorage
 * Also resets server state and clears WebContainer files (without teardown to preserve port listeners)
 */
export function clearSession() {
  const currentSessionId = localStorage.getItem('currentSessionId');
  console.log(' [Session Persistence] Clearing session:', currentSessionId || '(no session)');
  localStorage.removeItem('currentSessionId');
  console.log(' [Session Persistence] Session cleared from localStorage');

  // Archive active brand kits on backend to prevent old assets from appearing in new session
  console.log(' [Session Persistence] Archiving active brand kits...');
  const walletAddress = typeof window !== 'undefined' ? localStorage.getItem('walletAddress') : null;
  const userId = walletAddress || 'user@eitherway.app';

  if (userId) {
    fetch(`${BACKEND_URL}/api/brand-kits/user/${encodeURIComponent(userId)}/archive-active`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({}),
    })
      .then((response) => {
        if (response.ok) {
          console.log(' [Session Persistence] Active brand kits archived for:', userId);
        } else {
          console.warn(' [Session Persistence] Failed to archive brand kits:', response.statusText);
        }
      })
      .catch((error) => {
        console.warn(' [Session Persistence] Error archiving brand kits:', error);
      });
  } else {
    console.warn(' [Session Persistence] No userId found (wallet or email), skipping brand kit archival');
  }

  // Clear brand kit state to prevent old assets from appearing in new session
  console.log(' [Session Persistence] Clearing brand kit state...');
  brandKitStore.set({ pendingBrandKitId: null, dirty: false });
  console.log(' [Session Persistence] Brand kit state cleared');

  console.log(' [Session Persistence] Resetting server state...');
  import('./webcontainerRunner')
    .then(({ resetServerState }) => {
      resetServerState();
      console.log(' [Session Persistence] Server state reset complete');
    })
    .catch((error) => {
      console.warn(' [Session Persistence] Could not reset server state:', error);
    });

  // Clear WebContainer files without tearing down (matches main branch behavior)
  // This preserves PreviewsStore port listeners while clearing workspace
  console.log(' [Session Persistence] Clearing WebContainer files...');
  import('~/lib/webcontainer')
    .then(async ({ webcontainer }) => {
      try {
        const wc = await webcontainer;
        const files = await wc.fs.readdir('.', { withFileTypes: true });

        for (const file of files) {
          try {
            if (file.isDirectory()) {
              await wc.fs.rm(file.name, { recursive: true, force: true });
            } else {
              await wc.fs.rm(file.name, { force: true });
            }
            console.log(' [Session Persistence] Deleted:', file.name);
          } catch (err) {
            console.warn(' [Session Persistence] Could not delete:', file.name, err);
          }
        }
        console.log(' [Session Persistence] WebContainer files cleared');
      } catch (error) {
        console.warn(' [Session Persistence] Could not clear WebContainer files:', error);
      }
    })
    .catch((error) => {
      console.warn(' [Session Persistence] Could not import WebContainer module:', error);
    });
}
</file>

<file path="packages/ui-frontend/app/utils/websocketClient.ts">
/**
 * WebSocket client for EitherWay backend
 * Connects to ws://localhost:3001/api/agent and transforms events to match SSE format
 */

export interface StreamOptions {
  prompt: string;
  sessionId?: string;
  onChunk: (chunk: string) => void;
  onComplete: () => void;
  onError: (error: string) => void;
  onPhase?: (phase: 'pending' | 'thinking' | 'reasoning' | 'code-writing' | 'building' | 'completed') => void;
  onReasoning?: (text: string) => void;
  onThinkingComplete?: (duration: number) => void;
  onFileOperation?: (operation: 'creating' | 'editing' | 'created' | 'edited', filePath: string) => void;
  onFilesUpdated?: (files: any[], sessionId?: string) => void;
  onTokenUsage?: (inputTokens: number, outputTokens: number) => void;
}

export interface StreamController {
  abort: () => void;
  send: (message: any) => void;
}

import { WEBSOCKET_URL } from '~/config/api';

const BACKEND_URL = WEBSOCKET_URL;

/**
 * Stream from WebSocket backend with automatic reconnection
 * Connects to /api/agent?sessionId=xxx with WebSocket
 */
export async function streamFromWebSocket(options: StreamOptions): Promise<StreamController> {
  const {
    prompt,
    sessionId = `session-${Date.now()}`,
    onChunk,
    onComplete,
    onError,
    onPhase,
    onReasoning,
    onThinkingComplete,
    onFileOperation,
    onFilesUpdated,
    onTokenUsage,
  } = options;

  let ws: WebSocket | null = null;
  let aborted = false;
  let reconnectAttempts = 0;
  let isCompleted = false;
  const MAX_RECONNECT_ATTEMPTS = 5;
  const BASE_RECONNECT_DELAY = 1000; // Start with 1 second

  const abort = () => {
    aborted = true;
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.close();
    }
  };

  const send = (message: any) => {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(message));
    }
  };

  // Reconnection logic with exponential backoff
  const attemptReconnect = async (): Promise<boolean> => {
    if (aborted || isCompleted) {
      console.log('[WebSocket] Skipping reconnect - stream aborted or completed');
      return false;
    }

    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
      console.error('[WebSocket] Max reconnection attempts reached');
      onError('Connection lost - maximum retry attempts exceeded');
      return false;
    }

    reconnectAttempts++;
    const delay = BASE_RECONNECT_DELAY * Math.pow(2, reconnectAttempts - 1);
    console.log(`[WebSocket] Reconnection attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms...`);

    await new Promise((resolve) => setTimeout(resolve, delay));

    try {
      await connectWebSocket();
      console.log('[WebSocket] Reconnected successfully');
      reconnectAttempts = 0; // Reset on successful reconnect
      return true;
    } catch (error) {
      console.error('[WebSocket] Reconnection failed:', error);
      return attemptReconnect(); // Try again
    }
  };

  // WebSocket connection setup
  const connectWebSocket = async (): Promise<void> => {
    const wsUrl = `${BACKEND_URL}/api/agent?sessionId=${sessionId}`;
    console.log('[WebSocket] Connecting to:', wsUrl);

    ws = new WebSocket(wsUrl);

    // Wait for connection to open
    await new Promise<void>((resolve, reject) => {
      if (!ws) return reject(new Error('WebSocket not initialized'));

      ws.onopen = () => {
        console.log('[WebSocket] Connected');
        resolve();
      };

      ws.onerror = (event) => {
        console.error('[WebSocket] Connection error:', event);
        reject(new Error('WebSocket connection failed'));
      };

      setTimeout(() => reject(new Error('WebSocket connection timeout')), 10000);
    });

    ws.onmessage = (event) => {
      if (aborted) return;

      try {
        const data = JSON.parse(event.data);
        // Only log important events, not every chunk/reasoning delta
        if (!['delta', 'reasoning'].includes(data.kind)) {
          console.log('[WebSocket] Received:', data.kind);
        }

        switch (data.kind) {
          case 'stream_start':
            // Message streaming started
            console.log('[WebSocket] Stream started, messageId:', data.messageId);
            break;

          case 'delta':
            // Text delta - map to chunk for compatibility
            if (data.text) {
              onChunk(data.text);
            }
            break;

          case 'reasoning':
            // Reasoning text during planning phase
            if (onReasoning && data.text) {
              onReasoning(data.text);
            }
            break;

          case 'phase':
            // Phase change (thinking, reasoning, code-writing, building, completed)
            if (onPhase && data.name) {
              onPhase(data.name);
            }
            break;

          case 'thinking_complete':
            // Thinking phase completed with duration
            if (onThinkingComplete && data.durationSeconds !== undefined) {
              onThinkingComplete(data.durationSeconds);
            }
            break;

          case 'file_operation':
            // File operation progress (creating, created, editing, edited)
            if (onFileOperation && data.operation && data.filePath) {
              onFileOperation(data.operation, data.filePath);
            }
            break;

          case 'tool':
            // Tool execution started/ended
            if (data.event === 'start') {
              console.log('[WebSocket] Tool started:', data.toolName, data.filePath);
            } else if (data.event === 'end') {
              console.log('[WebSocket] Tool ended:', data.toolName, data.filePath);
            }
            break;

          case 'files_updated':
            // Files were updated (backend sent updated file list)
            if (onFilesUpdated && data.files) {
              onFilesUpdated(data.files, data.sessionId);
            }
            break;

          case 'stream_end':
            // Stream completed
            console.log('[WebSocket] Stream ended, usage:', data.usage);
            isCompleted = true;
            if (onTokenUsage && data.usage) {
              onTokenUsage(data.usage.inputTokens, data.usage.outputTokens);
            }
            onComplete();
            break;

          case 'response':
            // Final response (backward compatibility)
            console.log('[WebSocket] Got final response');
            break;

          case 'error':
            // Error occurred
            console.error('[WebSocket] Error:', data.message);
            onError(data.message || 'Unknown error');
            break;

          default:
            console.log('[WebSocket] Unknown event kind:', data.kind);
        }
      } catch (parseError) {
        console.error('[WebSocket] Failed to parse message:', parseError);
      }
    };

    ws.onerror = (event) => {
      if (!aborted) {
        console.error('[WebSocket] Error:', event);
        // Don't call onError here - let onclose handle reconnection
      }
    };

    ws.onclose = async () => {
      console.log('[WebSocket] Connection closed');
      if (!aborted && !isCompleted) {
        // Connection closed unexpectedly - attempt reconnection
        console.log('[WebSocket] Unexpected close - attempting reconnection...');
        const reconnected = await attemptReconnect();
        if (!reconnected) {
          onError('Connection lost - unable to reconnect');
        }
      }
    };
  };

  try {
    // Initial connection
    await connectWebSocket();

    console.log('[WebSocket] Sending prompt:', prompt);
    if (ws) {
      ws.send(
        JSON.stringify({
          type: 'prompt',
          prompt: prompt,
        }),
      );
    }

    return { abort, send };
  } catch (error) {
    if (!aborted) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      console.error('[WebSocket] Error:', errorMessage);
      onError(errorMessage);
    }

    return { abort, send };
  }
}
</file>

<file path="packages/ui-frontend/vite.config.ts">
import { vitePlugin as remixVitePlugin } from '@remix-run/dev';
import UnoCSS from 'unocss/vite';
import { defineConfig, type ViteDevServer } from 'vite';
import { nodePolyfills } from 'vite-plugin-node-polyfills';
import { optimizeCssModules } from 'vite-plugin-optimize-css-modules';
import tsconfigPaths from 'vite-tsconfig-paths';

export default defineConfig((config) => {
  return {
    server: {
      port: parseInt(process.env.PORT || '5173'),
      host: '0.0.0.0',
      allowedHosts: ['dev.eitherway.ai', 'localhost', '127.0.0.1'],
      proxy: {
        '/api': {
          target: 'https://localhost:3001',
          changeOrigin: true,
          secure: false,
        },
      },
    },
    preview: {
      port: parseInt(process.env.PORT || '5173'),
      host: '0.0.0.0',
      allowedHosts: ['dev.eitherway.ai', 'localhost', '127.0.0.1'],
      proxy: {
        '/api': {
          target: 'https://localhost:3001',
          changeOrigin: true,
          secure: false,
        },
      },
    },
    build: {
      target: 'esnext',
    },
    ssr: {
      noExternal: ['@ai-sdk/anthropic', 'ai'],
    },
    plugins: [
      nodePolyfills({
        include: ['buffer'],
      }),
      remixVitePlugin({
        future: {
          v3_fetcherPersist: true,
          v3_relativeSplatPath: true,
          v3_throwAbortReason: true,
        },
      }),
      UnoCSS(),
      tsconfigPaths(),
      chrome129IssuePlugin(),
      config.mode === 'production' && optimizeCssModules({ apply: 'build' }),
    ],
  };
});

function chrome129IssuePlugin() {
  return {
    name: 'chrome129IssuePlugin',
    configureServer(server: ViteDevServer) {
      server.middlewares.use((req, res, next) => {
        const raw = req.headers['user-agent']?.match(/Chrom(e|ium)\/([0-9]+)\./);

        if (raw) {
          const version = parseInt(raw[2], 10);

          if (version === 129) {
            res.setHeader('content-type', 'text/html');
            res.end(
              '<body><h1>Please use Chrome Canary for testing.</h1><p>Chrome 129 has an issue with JavaScript modules & Vite local development, see <a href="https://github.com/stackblitz/dappit.new/issues/86#issuecomment-2395519258">for more information.</a></p><p><b>Note:</b> This only impacts <u>local development</u>. `pnpm run build` and `pnpm run start` will work fine in this browser.</p></body>',
            );

            return;
          }
        }

        // Permissive CORS headers - allow everything
        res.setHeader('Access-Control-Allow-Origin', '*');
        res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
        res.setHeader('Access-Control-Allow-Headers', '*');
        res.setHeader('Access-Control-Allow-Credentials', 'true');

        // Enable crossOriginIsolated for WebContainers with most permissive COEP
        res.setHeader('Cross-Origin-Opener-Policy', 'same-origin');
        res.setHeader('Cross-Origin-Embedder-Policy', 'credentialless');

        // Allow cross-origin resources
        res.setHeader('Cross-Origin-Resource-Policy', 'cross-origin');

        next();
      });
    },
  };
}
</file>

<file path="packages/database/src/index.ts">
export { DatabaseClient, createDatabaseClient } from './client.js';
export type { DatabaseConfig } from './client.js';

export { UsersRepository } from './repositories/users.js';
export { SessionsRepository } from './repositories/sessions.js';
export { MessagesRepository } from './repositories/messages.js';
export { AppsRepository } from './repositories/apps.js';
export { FilesRepository, FileReferencesRepository } from './repositories/files.js';
export { SessionMemoryRepository, WorkingSetRepository } from './repositories/session-memory.js';
export { ImageJobsRepository, ImageAssetsRepository } from './repositories/images.js';
export { EventsRepository } from './repositories/events.js';
export { UserIntegrationsRepository, NetlifySitesRepository } from './repositories/netlify.js';
export { DeploymentsRepository, ExportsRepository } from './repositories/deployments.js';
export { BrandKitsRepository, BrandAssetsRepository, BrandColorsRepository } from './repositories/brand-kits.js';
export type { BrandKit, BrandAsset, BrandColor } from './repositories/brand-kits.js';

export { ImageGenerationService } from './services/image-generator.js';
export type { ImageGenerationOptions } from './services/image-generator.js';

export { ImpactedFilesAnalyzer } from './services/impacted-analyzer.js';
export type { ImpactAnalysisResult } from './services/impacted-analyzer.js';

export { AtomicFileWriter } from './services/atomic-file-writer.js';
export type { AtomicWriteResult } from './services/atomic-file-writer.js';

export { MemoryPreludeService } from './services/memory-prelude.js';
export type { MemoryPrelude } from './services/memory-prelude.js';

export { DiffBuilder } from './services/diff-builder.js';
export type { FileDiff, DiffContext } from './services/diff-builder.js';

export { IntegrityChecker } from './services/integrity-checker.js';
export type { FileIntegrityResult, ImageIntegrityResult } from './services/integrity-checker.js';

export { PreparedQueries } from './services/prepared-queries.js';

export { PostgresFileStore } from './services/file-store.js';
export type { FileStore, FileNode, FileContent } from './services/file-store.js';

export { RateLimiter } from './services/rate-limiter.js';
export type { RateLimitResult } from './services/rate-limiter.js';

export { NetlifyService } from './services/netlify-service.js';
export type { NetlifyDeployConfig, NetlifyDeployResult, NetlifyTokenValidationResult } from './services/netlify-service.js';

export { ExportService } from './services/export-service.js';
export type { ExportConfig, ExportResult, ExportStats } from './services/export-service.js';

export { DeploymentService } from './services/deployment-service.js';
export type { DeploymentConfig, DeploymentResult } from './services/deployment-service.js';

export { PaletteExtractor } from './services/palette-extractor.js';
export type { ExtractedColor, PaletteExtractionOptions } from './services/palette-extractor.js';

export type * from './types.js';
</file>

<file path="packages/ui-frontend/app/components/header/HeaderActionButtons.client.tsx">
import { useStore } from '@nanostores/react';
import { useEffect, useState } from 'react';
import { createPortal } from 'react-dom';
import { chatStore } from '~/lib/stores/chat';
import { workbenchStore } from '~/lib/stores/workbench';
import { authStore } from '~/lib/stores/auth';
import { classNames } from '~/utils/classNames';
import { DeploymentPanel } from '~/components/deployment/DeploymentPanel';
import { BrandKitPanel } from '~/components/brand-kit/BrandKitPanel';
import { useWalletConnection } from '~/lib/web3/hooks';

interface HeaderActionButtonsProps {}

export function HeaderActionButtons({}: HeaderActionButtonsProps) {
  const showWorkbench = useStore(workbenchStore.showWorkbench);
  const chat = useStore(chatStore);
  const { showChat, sessionId: chatSessionId } = chat;
  const isAppReady = useStore(workbenchStore.isAppReadyForDeploy);
  const previews = useStore(workbenchStore.previews);
  const user = useStore(authStore.user);
  const { isConnected, address } = useWalletConnection();
  const [isSmallScreen, setIsSmallScreen] = useState(false);

  // Panel visibility state
  const [showDeployPanel, setShowDeployPanel] = useState(false);
  const [showBrandKitPanel, setShowBrandKitPanel] = useState(false);
  const [deployPanelTab, setDeployPanelTab] = useState<'deploy' | 'download'>('deploy');

  const canHideChat = showWorkbench || !showChat;

  const previewUrl = previews[0]?.baseUrl || 'http://localhost:5173';

  // Use wallet address as primary identifier (email auth is mostly mock)
  const userId = (isConnected && address ? address : user?.email) || null;
  const sessionId = chatSessionId || userId || 'demo-session';
  const appId = chatSessionId || 'demo-app-' + Date.now();

  //   
  useEffect(() => {
    const checkScreenSize = () => {
      setIsSmallScreen(window.innerWidth < 1280);
    };

    checkScreenSize();
    window.addEventListener('resize', checkScreenSize);

    return () => window.removeEventListener('resize', checkScreenSize);
  }, []);

  // Listen for brand kit upload event from chat clip button
  useEffect(() => {
    const handleOpenBrandKit = () => {
      setShowBrandKitPanel(true);
    };

    window.addEventListener('open-brand-kit', handleOpenBrandKit);
    return () => window.removeEventListener('open-brand-kit', handleOpenBrandKit);
  }, []);

  return (
    <>
      {/* Button Groups - Wrapped in parent container */}
      <div className="flex gap-2">
        <div className="hidden min-[900px]:flex border border-eitherway-elements-borderColor rounded-2xl overflow-hidden">
          <Button
            className="rounded-l-2xl px-5!"
            onClick={() => {
              setDeployPanelTab('download');
              setShowDeployPanel(true);
            }}
          >
            <img src="/icons/chat/download.svg" alt="Download" />
            <span className="ml-1.5">DOWNLOAD</span>
          </Button>
          <div className="w-[1px] bg-eitherway-elements-borderColor" />
          <Button
            className="rounded-r-2xl px-5!"
            onClick={() => {
              setDeployPanelTab('deploy');
              setShowDeployPanel(true);
            }}
          >
            <img src="/icons/chat/deploy.svg" alt="Deploy" />
            <span className="ml-1.5">DEPLOY</span>
          </Button>
        </div>

        {/* Chat/Workbench Toggle */}
        <div className="flex border border-eitherway-elements-borderColor rounded-md overflow-hidden">
          <Button
            active={showChat}
            disabled={!canHideChat}
            className="rounded-l-md"
            onClick={() => {
              if (canHideChat) {
                if (isSmallScreen && !showChat) {
                  //     workbench   
                  workbenchStore.showWorkbench.set(false);
                }

                chatStore.setKey('showChat', !showChat);
              }
            }}
          >
            <div className="i-eitherway:chat h-3.5 w-3.5" />
          </Button>
          <div className="w-[1px] bg-eitherway-elements-borderColor" />
          <Button
            active={showWorkbench}
            className="i-rounded-r-md"
            onClick={() => {
              if (showWorkbench && !showChat) {
                chatStore.setKey('showChat', true);
              }

              if (isSmallScreen && !showWorkbench) {
                //        workbench
                chatStore.setKey('showChat', false);
              }

              workbenchStore.showWorkbench.set(!showWorkbench);
            }}
          >
            <div className="i-ph:code-bold" />
          </Button>
        </div>
      </div>

      {/* Modals - Rendered via Portal to document.body */}
      {typeof document !== 'undefined' &&
        showDeployPanel &&
        createPortal(
          <DeploymentPanel
            appId={appId}
            sessionId={sessionId}
            userId={userId}
            initialTab={deployPanelTab}
            onClose={() => setShowDeployPanel(false)}
          />,
          document.body,
        )}

      {typeof document !== 'undefined' &&
        showBrandKitPanel &&
        createPortal(<BrandKitPanel onClose={() => setShowBrandKitPanel(false)} />, document.body)}
    </>
  );
}

interface ButtonProps {
  active?: boolean;
  disabled?: boolean;
  children?: any;
  className?: string;
  onClick?: VoidFunction;
}

function Button({ active = false, disabled = false, children, className, onClick }: ButtonProps) {
  return (
    <button
      className={classNames('flex items-center p-1.5', className, {
        'bg-black hover:bg-eitherway-elements-item-backgroundActive text-eitherway-elements-textTertiary hover:text-eitherway-elements-textPrimary':
          !active && !disabled,
        'bg-black text-eitherway-elements-item-contentAccent': active && !disabled,
        'bg-black text-alpha-gray-20 dark:text-alpha-white-20 cursor-not-allowed': disabled,
      })}
      disabled={disabled}
      onClick={disabled ? undefined : onClick}
    >
      {children}
    </button>
  );
}
</file>

<file path="packages/ui-frontend/app/utils/fileSync.ts">
/**
 * File synchronization between backend and WebContainer
 * Loads files from the backend API and writes them to WebContainer
 */

import type { WebContainer } from '@webcontainer/api';
import { createScopedLogger } from './logger';
import { BACKEND_URL } from '~/config/api';

const logger = createScopedLogger('FileSync');

interface FileNode {
  name: string;
  path: string;
  type: 'file' | 'directory';
  size?: number;
  children?: FileNode[];
}

interface FileContentResponse {
  content: string;
  isBinary?: boolean;
  mimeType?: string;
}

async function fetchFileContent(sessionId: string, filePath: string): Promise<FileContentResponse> {
  const response = await fetch(
    `${BACKEND_URL}/api/sessions/${sessionId}/files/read?path=${encodeURIComponent(filePath)}`,
  );

  if (!response.ok) {
    throw new Error(`Failed to fetch file ${filePath}: ${response.statusText}`);
  }

  const data = await response.json();
  return {
    content: data.content || '',
    isBinary: data.isBinary || false,
    mimeType: data.mimeType,
  };
}

/**
 * Recursively collect all file paths from the file tree
 */
function collectFilePaths(nodes: FileNode[]): string[] {
  const paths: string[] = [];

  for (const node of nodes) {
    if (node.type === 'file') {
      paths.push(node.path);
    } else if (node.type === 'directory' && node.children) {
      paths.push(...collectFilePaths(node.children));
    }
  }

  return paths;
}

/**
 * Ensure directory exists in WebContainer
 */
async function ensureDirectory(webcontainer: WebContainer, dirPath: string): Promise<void> {
  const parts = dirPath.split('/').filter(Boolean);

  let currentPath = '';
  for (const part of parts) {
    currentPath = currentPath ? `${currentPath}/${part}` : part;

    try {
      await webcontainer.fs.mkdir(currentPath, { recursive: true });
    } catch (error) {
      // Directory might already exist, ignore error
    }
  }
}

/**
 * Sync files from backend to WebContainer
 */
export async function syncFilesToWebContainer(
  webcontainer: WebContainer,
  files: FileNode[],
  sessionId: string,
): Promise<void> {
  logger.info('Syncing files to WebContainer', files.length, 'files');

  const filePaths = collectFilePaths(files);
  logger.debug('File paths to sync:', filePaths);

  for (const filePath of filePaths) {
    try {
      // Ensure parent directory exists
      const dirPath = filePath.split('/').slice(0, -1).join('/');
      if (dirPath) {
        await ensureDirectory(webcontainer, dirPath);
      }

      // Fetch file content
      const fileData = await fetchFileContent(sessionId, filePath);

      // DEBUG: Log first 100 chars of content to verify it's changing
      logger.debug(` Fetched ${filePath}: ${fileData.content.substring(0, 100)}...`);

      if (fileData.isBinary && fileData.content) {
        // Binary file: decode base64 and write as Uint8Array for Vite dev server
        // Vite doesn't understand __BASE64__ prefix, needs actual binary
        let base64Content = String(fileData.content).replace(/^\s+|\s+$/g, '');

        // Decode base64 to binary
        const binaryString = atob(base64Content);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }

        // Write as Uint8Array (WebContainer native binary format)
        await webcontainer.fs.writeFile(filePath, bytes);

        logger.debug(`Binary file ${filePath}: wrote ${bytes.length} bytes as Uint8Array`);

        // Verify PNG magic number
        if ((fileData.mimeType || '').toLowerCase().includes('image/png') && bytes.length >= 8) {
          const pngMagic = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
          const matches = pngMagic.every((byte, i) => bytes[i] === byte);
          logger.debug(`PNG magic: ${matches ? ' Valid' : ' Invalid'} (${Array.from(bytes.slice(0, 8)).map(b => b.toString(16).padStart(2, '0')).join(' ')})`);
        }
      } else {
        // Text file: write as string
        await webcontainer.fs.writeFile(filePath, fileData.content || '');
      }

      logger.debug(`Synced file: ${filePath} (binary: ${fileData.isBinary || false})`);
    } catch (error: any) {
      logger.error(`Failed to sync file ${filePath}:`, error);

      // Provide more detailed error information
      if (error.message?.includes('404') || error.message?.includes('Not Found')) {
        logger.error(` File not found in session workspace: ${filePath}`);
        logger.error(`This usually means the file was not properly saved to the session's file system.`);
        logger.error(`Check that the file was written via /api/sessions/${sessionId}/files/write or write-binary`);
      } else if (error.message?.includes('Failed to fetch')) {
        logger.error(` Network error fetching file: ${filePath}`);
        logger.error(`Backend server may be unreachable or file endpoint may be down`);
      } else {
        logger.error(` Unknown error syncing file: ${error.message || error}`);
      }
    }
  }

  logger.info('File sync complete');
}
</file>

<file path="packages/ui-server/src/routes/brand-kits.ts">
/**
 * Brand Kit API Routes
 *
 * Endpoints:
 * - POST /api/brand-kits - Create new brand kit
 * - GET /api/brand-kits - List user's brand kits
 * - GET /api/brand-kits/:id - Get brand kit details with assets and colors
 * - PUT /api/brand-kits/:id - Update brand kit
 * - DELETE /api/brand-kits/:id - Delete brand kit
 * - POST /api/brand-kits/:id/assets - Upload asset and extract palette
 * - DELETE /api/brand-kits/:id/assets/:assetId - Delete asset
 * - POST /api/brand-kits/:id/colors - Manually add color
 * - PUT /api/brand-kits/:id/colors/:colorId - Update color
 * - DELETE /api/brand-kits/:id/colors/:colorId - Delete color
 */

import { FastifyInstance } from 'fastify';
import {
  DatabaseClient,
  BrandKitsRepository,
  BrandAssetsRepository,
  BrandColorsRepository,
  PaletteExtractor,
  EventsRepository,
  UsersRepository
} from '@eitherway/database';
import { writeFile, mkdir, readFile, rm } from 'fs/promises';
import { join } from 'path';
import { randomUUID } from 'crypto';

export async function registerBrandKitRoutes(
  fastify: FastifyInstance,
  db: DatabaseClient
) {
  console.log('[Brand Kits] Registering brand kit routes...');

  const brandKitsRepo = new BrandKitsRepository(db);
  const assetsRepo = new BrandAssetsRepository(db);
  const colorsRepo = new BrandColorsRepository(db);
  const paletteExtractor = new PaletteExtractor();
  const eventsRepo = new EventsRepository(db);
  const usersRepo = new UsersRepository(db);

  // Storage configuration (local for now, can be upgraded to S3/GCS)
  const UPLOAD_DIR = process.env.BRAND_KIT_UPLOAD_DIR || '/tmp/eitherway-brand-kits';

  console.log('[Brand Kits] Upload directory:', UPLOAD_DIR);
  console.log('[Brand Kits] Repositories initialized');

  /**
   * Helper: Clean up temporary files for a brand kit
   * Called when:
   * - Brand kit is archived (Start New Chat)
   * - Brand kit is deleted
   * - Assets are successfully synced to VFS
   */
  async function cleanupBrandKitTempFiles(brandKitId: string, userId: string): Promise<void> {
    try {
      const brandKitTempDir = join(UPLOAD_DIR, `brand-kits/${userId}/${brandKitId}`);
      await rm(brandKitTempDir, { recursive: true, force: true });
      console.log(`[Brand Kits] Cleaned up temp files for brand kit: ${brandKitId}`);
    } catch (error: any) {
      console.error(`[Brand Kits] Failed to cleanup temp files for brand kit ${brandKitId}:`, error.message);
      // Don't throw - cleanup is best-effort
    }
  }

  fastify.get('/api/brand-kits/health', async (request, reply) => {
    console.log('[Brand Kits API] Health check called');
    try {
      // Test database connection
      await db.query('SELECT 1 as test');
      console.log('[Brand Kits API] Database connection OK');

      return {
        success: true,
        database: 'connected',
        uploadDir: UPLOAD_DIR
      };
    } catch (error: any) {
      console.error('[Brand Kits API] Health check failed:', error);
      return reply.code(500).send({
        success: false,
        error: error.message
      });
    }
  });

  /**
   * POST /api/brand-kits
   * Create a new brand kit
   */
  fastify.post<{
    Body: {
      name: string;
      description?: string;
      userId: string;  // Can be email or wallet address
    };
  }>('/api/brand-kits', async (request, reply) => {
    // Top-level try-catch to ensure we always send JSON
    try {
      const { name, description, userId } = request.body;

      if (!name || !userId) {
        return reply.code(400).send({
          error: 'Missing required fields',
          details: ['name and userId are required']
        });
      }
      console.log('[Brand Kits API] Creating brand kit. UserId:', userId, 'Name:', name);

      // Ensure user exists (auto-create if wallet address)
      const emailToUse = userId.startsWith('0x') ? `${userId}@wallet.local` : userId;
      console.log('[Brand Kits API] Email to use:', emailToUse);

      let userRecord = await usersRepo.findByEmail(emailToUse);
      console.log('[Brand Kits API] Existing user found?', !!userRecord);

      if (!userRecord) {
        console.log('[Brand Kits API] Creating new user:', emailToUse);
        const displayName = userId.startsWith('0x')
          ? `Wallet ${userId.substring(0, 8)}...`
          : userId.split('@')[0];

        try {
          userRecord = await usersRepo.create(emailToUse, displayName);
          console.log('[Brand Kits API] User created successfully:', userRecord.id);
        } catch (userCreateError: any) {
          console.error('[Brand Kits API] Failed to create user:', userCreateError);
          console.error('[Brand Kits API] User create error details:', {
            message: userCreateError.message,
            code: userCreateError.code,
            detail: userCreateError.detail,
            stack: userCreateError.stack
          });
          throw new Error(`Failed to create user: ${userCreateError.message}`);
        }
      }

      console.log('[Brand Kits API] Creating brand kit for user:', userRecord.id);
      const brandKit = await brandKitsRepo.create(userRecord.id, name, description);
      console.log('[Brand Kits API] Brand kit created:', brandKit.id);

      await eventsRepo.log('brand_kit.created', {
        brandKitId: brandKit.id,
        name: brandKit.name
      }, { sessionId: undefined, appId: undefined, actor: 'user' });

      return {
        success: true,
        brandKit: {
          id: brandKit.id,
          name: brandKit.name,
          description: brandKit.description,
          status: brandKit.status,
          createdAt: brandKit.created_at
        }
      };
    } catch (outerError: any) {
      // Outer catch to handle any errors in request parsing or validation
      console.error('[Brand Kits API] Outer error - Request handling failed:', outerError);
      console.error('[Brand Kits API] Outer error stack:', outerError.stack);
      return reply.code(500).send({
        error: 'Request handling failed',
        message: outerError.message || 'Unknown error',
        details: 'Check server logs for details'
      });
    }
  });

  /**
   * POST /api/brand-kits/:id/cleanup-temp
   * Clean up temporary files after assets have been synced to VFS
   * Called by frontend after successful VFS sync
   */
  fastify.post<{
    Params: { id: string };
  }>('/api/brand-kits/:id/cleanup-temp', async (request, reply) => {
    const { id: brandKitId } = request.params;

    try {
      const brandKit = await brandKitsRepo.findById(brandKitId);
      if (!brandKit) {
        return reply.code(404).send({ error: 'Brand kit not found' });
      }

      await cleanupBrandKitTempFiles(brandKitId, brandKit.user_id);

      return {
        success: true,
        message: 'Temp files cleaned up successfully'
      };
    } catch (error: any) {
      console.error('[Brand Kits API] Failed to cleanup temp files:', error);
      return reply.code(500).send({
        error: 'Failed to cleanup temp files',
        message: error.message
      });
    }
  });

  /**
   * POST /api/brand-kits/user/:userId/archive-active
   * Archive all active brand kits for a user (for session clearing)
   * Body is optional (can be empty)
   */
  fastify.post<{
    Params: { userId: string };
    Body?: any;
  }>('/api/brand-kits/user/:userId/archive-active', async (request, reply) => {
    const { userId } = request.params;

    try {
      // Convert wallet address to email format if needed
      const emailToUse = userId.startsWith('0x') ? `${userId}@wallet.local` : userId;

      // Find user
      const userRecord = await usersRepo.findByEmail(emailToUse);
      if (!userRecord) {
        return reply.code(404).send({
          error: 'User not found',
          userId
        });
      }

      const activeBrandKits = await brandKitsRepo.findByUserId(userRecord.id, 'active');

      // Archive each one and clean up temp files
      let archivedCount = 0;
      for (const kit of activeBrandKits) {
        await brandKitsRepo.update(kit.id, { status: 'archived' });
        // Clean up temp files (async, non-blocking)
        cleanupBrandKitTempFiles(kit.id, userRecord.id).catch(err =>
          console.error(`[Brand Kits API] Cleanup failed for ${kit.id}:`, err)
        );
        archivedCount++;
      }

      console.log(`[Brand Kits API] Archived ${archivedCount} active brand kits for user ${userId}`);

      return {
        success: true,
        archivedCount
      };

    } catch (error: any) {
      console.error('[Brand Kits API] Failed to archive active brand kits:', error);
      return reply.code(500).send({
        error: 'Failed to archive active brand kits',
        message: error.message
      });
    }
  });

  fastify.get<{
    Params: { userId: string };
  }>('/api/brand-kits/user/:userId/active', async (request, reply) => {
    const { userId } = request.params;

    try {
      // Convert wallet address to email format if needed
      const emailToUse = userId.startsWith('0x') ? `${userId}@wallet.local` : userId;

      // Find user
      const userRecord = await usersRepo.findByEmail(emailToUse);
      if (!userRecord) {
        return reply.code(404).send({
          error: 'User not found',
          userId
        });
      }

      const brandKits = await brandKitsRepo.findByUserId(userRecord.id, 'active');

      if (brandKits.length === 0) {
        return reply.code(404).send({
          error: 'No active brand kit found',
          userId
        });
      }

      const latestKit = brandKits[0];
      const assets = await assetsRepo.findByBrandKitId(latestKit.id);
      const colors = await colorsRepo.findByBrandKitId(latestKit.id);

      return {
        success: true,
        brandKit: {
          id: latestKit.id,
          name: latestKit.name,
          description: latestKit.description,
          status: latestKit.status,
          createdAt: latestKit.created_at,
          updatedAt: latestKit.updated_at,
          assets: assets.map(asset => ({
            id: asset.id,
            assetType: asset.asset_type,
            fileName: asset.file_name,
            storageKey: asset.storage_key,
            mimeType: asset.mime_type,
            fileSizeBytes: asset.file_size_bytes,
            dimensions: asset.width_px && asset.height_px
              ? { width: asset.width_px, height: asset.height_px }
              : null,
            processingStatus: asset.processing_status,
            uploadedAt: asset.uploaded_at,
            metadata: { kind: (asset.metadata as any)?.kind }
          })),
          colors: colors.map(color => ({
            id: color.id,
            hex: color.color_hex,
            rgb: color.color_rgb,
            hsl: color.color_hsl,
            name: color.color_name,
            role: color.color_role,
            prominence: color.prominence_score,
            pixelPercentage: color.pixel_percentage,
            displayOrder: color.display_order
          }))
        }
      };
    } catch (error: any) {
      console.error('[Brand Kits API] Failed to get user active brand kit:', error);
      return reply.code(500).send({
        error: 'Failed to get active brand kit',
        message: error.message
      });
    }
  });

  fastify.get<{
    Querystring: {
      userId: string;
      status?: 'active' | 'archived' | 'all';
    };
  }>('/api/brand-kits', async (request, reply) => {
    const { userId, status = 'active' } = request.query;

    if (!userId) {
      return reply.code(400).send({
        error: 'Missing userId query parameter'
      });
    }

    try {
      const brandKits = await brandKitsRepo.findByUserId(userId, status);

      return {
        success: true,
        brandKits: brandKits.map(kit => ({
          id: kit.id,
          name: kit.name,
          description: kit.description,
          status: kit.status,
          createdAt: kit.created_at,
          updatedAt: kit.updated_at
        }))
      };
    } catch (error: any) {
      console.error('[Brand Kits API] Failed to list brand kits:', error);
      return reply.code(500).send({
        error: 'Failed to list brand kits',
        message: error.message
      });
    }
  });

  fastify.get<{
    Params: { id: string };
  }>('/api/brand-kits/:id', async (request, reply) => {
    const { id } = request.params;

    try {
      const brandKit = await brandKitsRepo.findById(id);

      if (!brandKit) {
        return reply.code(404).send({ error: 'Brand kit not found' });
      }

      const assets = await assetsRepo.findByBrandKitId(id);
      const colors = await colorsRepo.findByBrandKitId(id);

      return {
        success: true,
        brandKit: {
          id: brandKit.id,
          name: brandKit.name,
          description: brandKit.description,
          status: brandKit.status,
          createdAt: brandKit.created_at,
          updatedAt: brandKit.updated_at,
          assets: assets.map(asset => ({
            id: asset.id,
            assetType: asset.asset_type,
            fileName: asset.file_name,
            storageKey: asset.storage_key,
            mimeType: asset.mime_type,
            fileSizeBytes: asset.file_size_bytes,
            dimensions: asset.width_px && asset.height_px
              ? { width: asset.width_px, height: asset.height_px }
              : null,
            processingStatus: asset.processing_status,
            uploadedAt: asset.uploaded_at
          })),
          colors: colors.map(color => ({
            id: color.id,
            hex: color.color_hex,
            rgb: color.color_rgb,
            hsl: color.color_hsl,
            name: color.color_name,
            role: color.color_role,
            prominence: color.prominence_score,
            pixelPercentage: color.pixel_percentage,
            displayOrder: color.display_order
          }))
        }
      };
    } catch (error: any) {
      console.error('[Brand Kits API] Failed to get brand kit:', error);
      return reply.code(500).send({
        error: 'Failed to get brand kit',
        message: error.message
      });
    }
  });

  /**
   * PUT /api/brand-kits/:id
   * Update brand kit
   */
  fastify.put<{
    Params: { id: string };
    Body: {
      name?: string;
      description?: string;
      status?: 'active' | 'archived';
    };
  }>('/api/brand-kits/:id', async (request, reply) => {
    const { id } = request.params;
    const updates = request.body;

    try {
      const updated = await brandKitsRepo.update(id, updates);

      if (!updated) {
        return reply.code(404).send({ error: 'Brand kit not found' });
      }

      await eventsRepo.log('brand_kit.updated', {
        brandKitId: id,
        updates: Object.keys(updates)
      }, { sessionId: undefined, appId: undefined, actor: 'user' });

      return {
        success: true,
        brandKit: {
          id: updated.id,
          name: updated.name,
          description: updated.description,
          status: updated.status,
          updatedAt: updated.updated_at
        }
      };
    } catch (error: any) {
      console.error('[Brand Kits API] Failed to update brand kit:', error);
      return reply.code(500).send({
        error: 'Failed to update brand kit',
        message: error.message
      });
    }
  });

  fastify.delete<{
    Params: { id: string };
  }>('/api/brand-kits/:id', async (request, reply) => {
    const { id } = request.params;

    try {
      const brandKit = await brandKitsRepo.findById(id);
      if (!brandKit) {
        return reply.code(404).send({ error: 'Brand kit not found' });
      }

      const deleted = await brandKitsRepo.delete(id);

      if (!deleted) {
        return reply.code(404).send({ error: 'Brand kit not found' });
      }

      // Clean up temp files (async, non-blocking)
      cleanupBrandKitTempFiles(id, brandKit.user_id).catch(err =>
        console.error(`[Brand Kits API] Cleanup failed for ${id}:`, err)
      );

      await eventsRepo.log('brand_kit.deleted', {
        brandKitId: id
      }, { sessionId: undefined, appId: undefined, actor: 'user' });

      return { success: true };
    } catch (error: any) {
      console.error('[Brand Kits API] Failed to delete brand kit:', error);
      return reply.code(500).send({
        error: 'Failed to delete brand kit',
        message: error.message
      });
    }
  });

  /**
   * POST /api/brand-kits/:id/assets
   * Upload asset and extract color palette
   */
  fastify.post<{
    Params: { id: string };
  }>('/api/brand-kits/:id/assets', async (request, reply) => {
    const { id: brandKitId } = request.params;

    console.log('[Brand Kits API] Asset upload started for brand kit:', brandKitId);

    try {
      // Verify brand kit exists
      const brandKit = await brandKitsRepo.findById(brandKitId);
      if (!brandKit) {
        console.error('[Brand Kits API] Brand kit not found:', brandKitId);
        return reply.code(404).send({ error: 'Brand kit not found' });
      }

      console.log('[Brand Kits API] Brand kit found, fetching file...');

      const data = await (request as any).file();

      if (!data) {
        console.error('[Brand Kits API] No file data received');
        return reply.code(400).send({ error: 'No file uploaded' });
      }

      console.log('[Brand Kits API] File received:', data.filename, 'MIME:', data.mimetype);

      const buffer = await data.toBuffer();
      const fileName = data.filename;
      const mimeType = data.mimetype;

      console.log('[Brand Kits API] File buffered, size:', buffer.length, 'bytes');

      // Strict file type validation - only allow specified types
      const mimeToKind: Record<string, { kind: string; maxSize: number }> = {
        // Images: PNG, JPEG, SVG, ICO (20MB max)
        'image/png': { kind: 'image', maxSize: 20 * 1024 * 1024 },
        'image/jpeg': { kind: 'image', maxSize: 20 * 1024 * 1024 },
        'image/jpg': { kind: 'image', maxSize: 20 * 1024 * 1024 },
        'image/svg+xml': { kind: 'logo', maxSize: 20 * 1024 * 1024 },
        'image/x-icon': { kind: 'icon', maxSize: 20 * 1024 * 1024 },
        'image/vnd.microsoft.icon': { kind: 'icon', maxSize: 20 * 1024 * 1024 },

        // Fonts: TTF, OTF, WOFF, WOFF2 (10MB max)
        'font/ttf': { kind: 'font', maxSize: 10 * 1024 * 1024 },
        'font/otf': { kind: 'font', maxSize: 10 * 1024 * 1024 },
        'font/woff': { kind: 'font', maxSize: 10 * 1024 * 1024 },
        'font/woff2': { kind: 'font', maxSize: 10 * 1024 * 1024 },
        'application/x-font-ttf': { kind: 'font', maxSize: 10 * 1024 * 1024 },
        'application/x-font-otf': { kind: 'font', maxSize: 10 * 1024 * 1024 },
        'application/font-woff': { kind: 'font', maxSize: 10 * 1024 * 1024 },
        'application/font-woff2': { kind: 'font', maxSize: 10 * 1024 * 1024 },

        // Archives: ZIP brand packages (200MB max)
        'application/zip': { kind: 'brand_zip', maxSize: 200 * 1024 * 1024 },
        'application/x-zip-compressed': { kind: 'brand_zip', maxSize: 200 * 1024 * 1024 },

        // Videos: MP4 promo clips (100MB max)
        'video/mp4': { kind: 'video', maxSize: 100 * 1024 * 1024 },
      };

      const fileTypeInfo = mimeToKind[mimeType];
      if (!fileTypeInfo) {
        return reply.code(400).send({
          error: 'Unsupported file type',
          details: [
            'Allowed file types:',
            ' Images: PNG, JPEG, SVG, ICO (up to 20MB)',
            ' Fonts: TTF, OTF, WOFF, WOFF2 (up to 10MB)',
            ' Archives: ZIP brand packages (up to 200MB)',
            ' Videos: MP4 promo clips (up to 100MB)',
            '',
            `Received: ${mimeType}`
          ]
        });
      }

      if (buffer.length > fileTypeInfo.maxSize) {
        const maxSizeMB = Math.round(fileTypeInfo.maxSize / (1024 * 1024));
        return reply.code(400).send({
          error: 'File too large',
          details: [`Maximum file size for ${fileTypeInfo.kind} files is ${maxSizeMB}MB`]
        });
      }

      const assetKind = fileTypeInfo.kind;

      // Generate storage key
      const fileExt = fileName.split('.').pop() || 'bin';
      const storageKey = `brand-kits/${brandKit.user_id}/${brandKitId}/${randomUUID()}.${fileExt}`;

      const fullPath = join(UPLOAD_DIR, storageKey);
      await mkdir(join(UPLOAD_DIR, `brand-kits/${brandKit.user_id}/${brandKitId}`), { recursive: true });
      await writeFile(fullPath, buffer);

      const asset = await assetsRepo.create({
        brandKitId,
        userId: brandKit.user_id,
        assetType: assetKind as 'logo' | 'image' | 'icon' | 'pattern',
        fileName,
        storageKey,
        storageProvider: 'local',
        mimeType,
        fileSizeBytes: buffer.length,
        metadata: { kind: assetKind } // Store detailed kind in metadata
      });

      // Process the asset synchronously to ensure it's ready for color extraction
      try {
        await assetsRepo.updateProcessingStatus(asset.id, 'processing');

        // Extract dimensions for raster images
        const shouldProcessImage = ['image', 'logo', 'icon'].includes(assetKind) && mimeType !== 'image/svg+xml';
        if (shouldProcessImage) {
          const sharp = (await import('sharp')).default;
          const metadata = await sharp(buffer).metadata();

          if (metadata.width && metadata.height) {
            await assetsRepo.updateDimensions(asset.id, metadata.width, metadata.height);
          }
        }

        await assetsRepo.updateProcessingStatus(asset.id, 'completed');

        await eventsRepo.log('brand_kit.asset_processed', {
          brandKitId,
          assetId: asset.id,
          assetKind
        }, { sessionId: undefined, appId: undefined, actor: 'system' });

        console.log('[Brand Kits API] Asset processed successfully:', asset.id);

      } catch (error: any) {
        console.error('[Brand Kits API] Asset processing failed:', error);
        await assetsRepo.updateProcessingStatus(asset.id, 'failed', error.message);
      }

      return {
        success: true,
        asset: {
          id: asset.id,
          assetType: asset.asset_type,
          fileName: asset.file_name,
          processingStatus: 'completed',
          uploadedAt: asset.uploaded_at
        }
      };

    } catch (error: any) {
      console.error('[Brand Kits API] Asset upload failed:', error);
      return reply.code(500).send({
        error: 'Asset upload failed',
        message: error.message
      });
    }
  });

  /**
   * POST /api/brand-kits/:id/aggregate-colors
   * Aggregate color palette across ALL assets in the brand kit
   * This calculates global color prominence across all uploaded images
   */
  fastify.post<{
    Params: { id: string };
  }>('/api/brand-kits/:id/aggregate-colors', async (request, reply) => {
    const { id: brandKitId } = request.params;

    console.log('[Brand Kits API] Starting color aggregation for brand kit:', brandKitId);

    try {
      // Verify brand kit exists
      const brandKit = await brandKitsRepo.findById(brandKitId);
      if (!brandKit) {
        return reply.code(404).send({ error: 'Brand kit not found' });
      }

      const assets = await assetsRepo.findByBrandKitId(brandKitId);

      // Filter for processable image assets
      const imageAssets = assets.filter(asset => {
        const kind = (asset.metadata as any)?.kind || asset.asset_type;
        return ['image', 'logo', 'icon'].includes(kind) &&
               asset.mime_type !== 'image/svg+xml' &&
               asset.processing_status === 'completed';
      });

      await colorsRepo.deleteByBrandKitId(brandKitId);

      if (imageAssets.length === 0) {
        console.log('[Brand Kits API] No image assets to process - colors cleared');
        return {
          success: true,
          message: 'No image assets available for color extraction',
          colorsExtracted: 0,
          assetsProcessed: 0,
          colors: []
        };
      }

      console.log(`[Brand Kits API] Processing ${imageAssets.length} image assets for color aggregation`);

      // Aggregate color data across all images
      const colorMap = new Map<string, { rgb: any; hsl: any; count: number }>();
      let totalPixels = 0;

      for (const asset of imageAssets) {
        try {
          const assetPath = join(UPLOAD_DIR, asset.storage_key);
          const assetBuffer = await readFile(assetPath);

          // Extract colors from this asset
          const palette = await paletteExtractor.extract(assetBuffer, {
            maxColors: 10, // Extract more colors per image for better aggregation
            minProminence: 0.01
          });

          const sharp = (await import('sharp')).default;
          const metadata = await sharp(assetBuffer).metadata();
          const imagePixels = (metadata.width || 0) * (metadata.height || 0);

          // Aggregate color counts
          for (const color of palette.colors) {
            const pixelCount = Math.round((color.pixelPercentage || 0) * imagePixels);
            totalPixels += pixelCount;

            if (colorMap.has(color.hex)) {
              const existing = colorMap.get(color.hex)!;
              existing.count += pixelCount;
            } else {
              colorMap.set(color.hex, {
                rgb: color.rgb,
                hsl: color.hsl,
                count: pixelCount
              });
            }
          }

          console.log(`[Brand Kits API] Processed asset ${asset.file_name}: ${palette.colors.length} colors`);

        } catch (error: any) {
          console.error(`[Brand Kits API] Failed to process asset ${asset.file_name}:`, error);
          // Continue with other assets
        }
      }

      const aggregatedColors = Array.from(colorMap.entries())
        .map(([hex, data]) => ({
          hex,
          rgb: data.rgb,
          hsl: data.hsl,
          prominence: data.count / totalPixels,
          pixelPercentage: (data.count / totalPixels) * 100
        }))
        .sort((a, b) => b.prominence - a.prominence)
        .slice(0, 5); // Take top 5 colors

      console.log(`[Brand Kits API] Aggregated ${aggregatedColors.length} colors from ${colorMap.size} unique colors`);

      if (aggregatedColors.length > 0) {
        const colorRecords = aggregatedColors
          .map((color, idx) => {
            try {
              // Clamp RGB values to 0-255 range to prevent database constraint violations
              const clampedRgb = {
                r: Math.min(255, Math.max(0, Math.round(color.rgb.r))),
                g: Math.min(255, Math.max(0, Math.round(color.rgb.g))),
                b: Math.min(255, Math.max(0, Math.round(color.rgb.b)))
              };

              // Clamp HSL values to valid ranges
              const clampedHsl = {
                h: Math.min(360, Math.max(0, Math.round(color.hsl.h))),
                s: Math.min(100, Math.max(0, Math.round(color.hsl.s))),
                l: Math.min(100, Math.max(0, Math.round(color.hsl.l)))
              };

              // Regenerate hex from clamped RGB to ensure validity
              // This fixes malformed hex codes from the palette extractor
              const validHex = '#' +
                clampedRgb.r.toString(16).padStart(2, '0') +
                clampedRgb.g.toString(16).padStart(2, '0') +
                clampedRgb.b.toString(16).padStart(2, '0');

              if (!/^#[0-9A-Fa-f]{6}$/.test(validHex)) {
                console.warn(`[Brand Kits API] Skipping invalid color hex: ${validHex} (original: ${color.hex})`);
                return null;
              }

              return {
                brandKitId,
                assetId: undefined, // Aggregated colors don't belong to a single asset
                colorHex: validHex.toUpperCase(),
                colorRgb: clampedRgb,
                colorHsl: clampedHsl,
                colorName: PaletteExtractor.suggestColorName(clampedHsl),
                colorRole: 'extracted' as const,
                prominenceScore: color.prominence,
                pixelPercentage: color.pixelPercentage,
                displayOrder: idx
              };
            } catch (error: any) {
              console.error(`[Brand Kits API] Failed to process color ${color.hex}:`, error.message);
              return null;
            }
          })
          .filter((record): record is NonNullable<typeof record> => record !== null);

        if (colorRecords.length > 0) {
          await colorsRepo.bulkCreate(colorRecords);
        }

        console.log(`[Brand Kits API] Saved ${colorRecords.length} aggregated colors`);
      }

      await eventsRepo.log('brand_kit.colors_aggregated', {
        brandKitId,
        assetsProcessed: imageAssets.length,
        colorsExtracted: aggregatedColors.length
      }, { sessionId: undefined, appId: undefined, actor: 'system' });

      return {
        success: true,
        colorsExtracted: aggregatedColors.length,
        assetsProcessed: imageAssets.length,
        colors: aggregatedColors.map(c => ({
          hex: c.hex,
          prominence: Math.round(c.prominence * 100) + '%'
        }))
      };

    } catch (error: any) {
      console.error('[Brand Kits API] Color aggregation failed:', error);
      return reply.code(500).send({
        error: 'Color aggregation failed',
        message: error.message
      });
    }
  });

  fastify.delete<{
    Params: { id: string; assetId: string };
  }>('/api/brand-kits/:id/assets/:assetId', async (request, reply) => {
    const { assetId } = request.params;

    try {
      await colorsRepo.deleteByAssetId(assetId);

      const deleted = await assetsRepo.delete(assetId);

      if (!deleted) {
        return reply.code(404).send({ error: 'Asset not found' });
      }

      return { success: true };
    } catch (error: any) {
      console.error('[Brand Kits API] Asset deletion failed:', error);
      return reply.code(500).send({
        error: 'Asset deletion failed',
        message: error.message
      });
    }
  });

  /**
   * POST /api/brand-kits/:id/colors
   * Manually add a color to brand kit
   */
  fastify.post<{
    Params: { id: string };
    Body: {
      colorHex: string;
      colorName?: string;
      colorRole?: 'primary' | 'secondary' | 'accent' | 'neutral';
    };
  }>('/api/brand-kits/:id/colors', async (request, reply) => {
    const { id: brandKitId } = request.params;
    const { colorHex, colorName, colorRole } = request.body;

    if (!/^#[0-9A-Fa-f]{6}$/.test(colorHex)) {
      return reply.code(400).send({
        error: 'Invalid color format',
        details: ['Color must be in hexadecimal format (e.g., #FF5733)']
      });
    }

    try {
      // Convert hex to RGB
      const r = parseInt(colorHex.slice(1, 3), 16);
      const g = parseInt(colorHex.slice(3, 5), 16);
      const b = parseInt(colorHex.slice(5, 7), 16);

      const colorRgb = { r, g, b };

      const hslCalc = (rgb: { r: number; g: number; b: number }) => {
        const rNorm = rgb.r / 255;
        const gNorm = rgb.g / 255;
        const bNorm = rgb.b / 255;

        const max = Math.max(rNorm, gNorm, bNorm);
        const min = Math.min(rNorm, gNorm, bNorm);
        const diff = max - min;

        let h = 0;
        let s = 0;
        const l = (max + min) / 2;

        if (diff !== 0) {
          s = l > 0.5 ? diff / (2 - max - min) : diff / (max + min);

          switch (max) {
            case rNorm:
              h = ((gNorm - bNorm) / diff + (gNorm < bNorm ? 6 : 0)) / 6;
              break;
            case gNorm:
              h = ((bNorm - rNorm) / diff + 2) / 6;
              break;
            case bNorm:
              h = ((rNorm - gNorm) / diff + 4) / 6;
              break;
          }
        }

        return {
          h: Math.round(h * 360),
          s: Math.round(s * 100),
          l: Math.round(l * 100)
        };
      };

      const colorHsl = hslCalc(colorRgb);

      const color = await colorsRepo.create({
        brandKitId,
        colorHex: colorHex.toUpperCase(),
        colorRgb,
        colorHsl,
        colorName: colorName || PaletteExtractor.suggestColorName(colorHsl),
        colorRole
      });

      return {
        success: true,
        color: {
          id: color.id,
          hex: color.color_hex,
          rgb: color.color_rgb,
          hsl: color.color_hsl,
          name: color.color_name,
          role: color.color_role
        }
      };

    } catch (error: any) {
      console.error('[Brand Kits API] Color creation failed:', error);
      return reply.code(500).send({
        error: 'Color creation failed',
        message: error.message
      });
    }
  });

  /**
   * PUT /api/brand-kits/:id/colors/:colorId
   * Update color properties
   */
  fastify.put<{
    Params: { id: string; colorId: string };
    Body: {
      colorName?: string;
      colorRole?: 'primary' | 'secondary' | 'accent' | 'neutral';
      displayOrder?: number;
    };
  }>('/api/brand-kits/:id/colors/:colorId', async (request, reply) => {
    const { colorId } = request.params;
    const { colorName, colorRole, displayOrder } = request.body;

    // Map to database column names
    const updates = {
      color_name: colorName,
      color_role: colorRole,
      display_order: displayOrder
    };

    try {
      const updated = await colorsRepo.update(colorId, updates);

      if (!updated) {
        return reply.code(404).send({ error: 'Color not found' });
      }

      return {
        success: true,
        color: {
          id: updated.id,
          hex: updated.color_hex,
          name: updated.color_name,
          role: updated.color_role,
          displayOrder: updated.display_order
        }
      };

    } catch (error: any) {
      console.error('[Brand Kits API] Color update failed:', error);
      return reply.code(500).send({
        error: 'Color update failed',
        message: error.message
      });
    }
  });

  fastify.delete<{
    Params: { id: string; colorId: string };
  }>('/api/brand-kits/:id/colors/:colorId', async (request, reply) => {
    const { colorId } = request.params;

    try {
      const deleted = await colorsRepo.delete(colorId);

      if (!deleted) {
        return reply.code(404).send({ error: 'Color not found' });
      }

      return { success: true };
    } catch (error: any) {
      console.error('[Brand Kits API] Color deletion failed:', error);
      return reply.code(500).send({
        error: 'Color deletion failed',
        message: error.message
      });
    }
  });

  fastify.get('/api/brand-assets/download/*', async (request, reply) => {
    // Extract storage key from URL path after /download/
    const fullPath = (request.url || '').split('/api/brand-assets/download/')[1];

    console.log('[Brand Assets API] GET /download/* - Full path:', fullPath);

    if (!fullPath) {
      console.error('[Brand Assets API] Missing storage key in URL');
      return reply.code(400).send({
        error: 'Missing storage key in URL'
      });
    }

    try {
      // Decode storage key from URL
      const decodedKey = decodeURIComponent(fullPath);
      console.log('[Brand Assets API] Decoded storage key:', decodedKey);

      // Read file from local storage
      const diskPath = join(UPLOAD_DIR, decodedKey);
      console.log('[Brand Assets API] Reading from disk:', diskPath);

      const { stat } = await import('fs/promises');
      try {
        const stats = await stat(diskPath);
        console.log('[Brand Assets API] File found - Size:', stats.size, 'bytes');
      } catch (statError: any) {
        console.error('[Brand Assets API] File not found on disk:', diskPath);
        console.error('[Brand Assets API] Upload directory:', UPLOAD_DIR);
        console.error('[Brand Assets API] Storage key:', decodedKey);
        throw new Error(`File not found: ${decodedKey}`);
      }

      const fileBuffer = await readFile(diskPath);
      console.log('[Brand Assets API] Success: File read successfully:', fileBuffer.length, 'bytes');

      // Determine MIME type from file extension
      const ext = decodedKey.split('.').pop()?.toLowerCase();
      const mimeTypes: Record<string, string> = {
        'png': 'image/png',
        'jpg': 'image/jpeg',
        'jpeg': 'image/jpeg',
        'svg': 'image/svg+xml',
        'ico': 'image/x-icon',
        'ttf': 'font/ttf',
        'otf': 'font/otf',
        'woff': 'font/woff',
        'woff2': 'font/woff2',
        'mp4': 'video/mp4',
        'zip': 'application/zip',
      };
      const mimeType = (ext && mimeTypes[ext]) || 'application/octet-stream';

      reply.header('Content-Type', mimeType);
      reply.header('Content-Disposition', `inline`);
      reply.header('Content-Length', fileBuffer.length.toString());
      console.log('[Brand Assets API] Success: Sending file with Content-Type:', mimeType);
      reply.send(fileBuffer);

    } catch (error: any) {
      console.error('[Brand Assets API] Error: Asset download failed:', error);
      console.error('[Brand Assets API] Error details:', {
        message: error.message,
        code: error.code,
        path: error.path
      });
      return reply.code(404).send({
        error: 'Asset not found',
        message: error.message,
        details: `Upload directory: ${UPLOAD_DIR}`
      });
    }
  });

  console.log('[Brand Kits] Success: All brand kit routes registered successfully');
}
</file>

<file path="packages/ui-server/src/routes/sessions.ts">
import { FastifyInstance } from 'fastify';
import {
  UsersRepository,
  SessionsRepository,
  MessagesRepository,
  SessionMemoryRepository,
  WorkingSetRepository,
  EventsRepository,
  AppsRepository,
  DatabaseClient,
} from '@eitherway/database';

export async function registerSessionRoutes(fastify: FastifyInstance, db: DatabaseClient) {
  const usersRepo = new UsersRepository(db);
  const sessionsRepo = new SessionsRepository(db);
  const messagesRepo = new MessagesRepository(db);
  const memoryRepo = new SessionMemoryRepository(db);
  const workingSetRepo = new WorkingSetRepository(db);
  const eventsRepo = new EventsRepository(db);
  const appsRepo = new AppsRepository(db);

  // User lookup endpoint - does NOT count against rate limits
  fastify.get<{
    Querystring: { email: string };
  }>('/api/users', async (request, reply) => {
    const { email } = request.query;

    if (!email) {
      return reply.code(400).send({ error: 'email is required' });
    }

    const user = await usersRepo.findOrCreate(email);
    return user;
  });

  fastify.post<{
    Body: { email: string; title: string; appId?: string };
  }>('/api/sessions', async (request, reply) => {
    const { email, title } = request.body;

    const user = await usersRepo.findOrCreate(email);

    // Rate limiting disabled for local testing
    // const rateLimitCheck = await rateLimiter.checkSessionCreation(user.id);
    // if (!rateLimitCheck.allowed) {
    //   return reply.code(429).send({
    //     error: 'Rate limit exceeded',
    //     message: `You have reached your daily limit of ${rateLimitCheck.limit} chats. Please try again after ${rateLimitCheck.resetsAt.toISOString()}.`,
    //     current: rateLimitCheck.current,
    //     limit: rateLimitCheck.limit,
    //     resetsAt: rateLimitCheck.resetsAt.toISOString()
    //   });
    // }

    // Create a unique app for each session to ensure isolated workspaces
    const app = await appsRepo.create(user.id, title, 'private');
    const session = await sessionsRepo.create(user.id, title, app.id);

    // Rate limiting disabled for local testing
    // await rateLimiter.incrementSessionCount(user.id);

    await eventsRepo.log(
      'session.created',
      { sessionId: session.id, title },
      {
        sessionId: session.id,
        actor: 'user',
      },
    );

    return session;
  });

  fastify.get<{
    Params: { id: string };
  }>('/api/sessions/:id', async (request, reply) => {
    const session = await sessionsRepo.findById(request.params.id);

    if (!session) {
      return reply.code(404).send({ error: 'Session not found' });
    }

    const rawMessages = await messagesRepo.findRecentBySession(session.id, 50);
    const memory = await memoryRepo.findBySession(session.id);
    const workingSet = await workingSetRepo.findBySessionWithFiles(session.id);

    // Transform messages: extract text from Claude API content blocks
    const messages = rawMessages.map((msg) => {
      let content = msg.content;

      // Handle array of content blocks (Claude API format)
      if (Array.isArray(content)) {
        content = content
          .filter((block: any) => block.type === 'text')
          .map((block: any) => block.text)
          .join('\n');
      }
      // Handle object with text property
      else if (typeof content === 'object' && content !== null && 'text' in content) {
        content = content.text;
      }
      // Handle plain string or stringify other objects
      else if (typeof content !== 'string') {
        content = JSON.stringify(content);
      }

      return {
        ...msg,
        content,
      };
    });

    return {
      session,
      messages,
      memory,
      workingSet,
    };
  });

  fastify.get<{
    Querystring: { userId: string; limit?: string; offset?: string };
  }>('/api/sessions', async (request, reply) => {
    const { userId, limit = '50', offset = '0' } = request.query;

    if (!userId) {
      return reply.code(400).send({ error: 'userId is required' });
    }

    const sessions = await sessionsRepo.findByUser(userId, parseInt(limit, 10), parseInt(offset, 10));

    return { sessions };
  });

  fastify.post<{
    Params: { id: string };
    Body: { role: 'user' | 'assistant' | 'system' | 'tool'; content: any; model?: string; tokenCount?: number };
  }>('/api/sessions/:id/messages', async (request, reply) => {
    const { id } = request.params;
    const { role, content, model, tokenCount } = request.body;

    const session = await sessionsRepo.findById(id);
    if (!session) {
      return reply.code(404).send({ error: 'Session not found' });
    }

    // Rate limiting disabled for local testing
    // if (role === 'user') {
    //   const rateLimitCheck = await rateLimiter.checkMessageSending(id);
    //   if (!rateLimitCheck.allowed) {
    //     return reply.code(429).send({
    //       error: 'Rate limit exceeded',
    //       message: `You have reached your daily limit of ${rateLimitCheck.limit} messages per chat. Please try again after ${rateLimitCheck.resetsAt.toISOString()}.`,
    //       current: rateLimitCheck.current,
    //       limit: rateLimitCheck.limit,
    //       resetsAt: rateLimitCheck.resetsAt.toISOString()
    //     });
    //   }
    // }

    const message = await messagesRepo.create(id, role, content, model, tokenCount);

    // Rate limiting disabled for local testing
    // if (role === 'user') {
    //   await rateLimiter.incrementMessageCount(id);
    // }

    await sessionsRepo.touchLastMessage(id);

    await eventsRepo.log(
      'message.created',
      { messageId: message.id, role },
      {
        sessionId: id,
        actor: role === 'user' ? 'user' : 'assistant',
      },
    );

    return message;
  });

  fastify.patch<{
    Params: { id: string };
    Body: { title?: string; status?: 'active' | 'archived' };
  }>('/api/sessions/:id', async (request, reply) => {
    const { id } = request.params;
    const { title, status } = request.body;

    const session = await sessionsRepo.update(id, { title, status });

    return session;
  });

  fastify.delete<{
    Params: { id: string };
  }>('/api/sessions/:id', async (request, reply) => {
    const { id } = request.params;

    // Get session to find app_id before deleting
    const session = await sessionsRepo.findById(id);

    // Delete session first (due to foreign key constraints)
    await sessionsRepo.delete(id);

    // Delete associated app if it exists
    if (session?.app_id) {
      await appsRepo.delete(session.app_id);
    }

    return { success: true };
  });

  fastify.put<{
    Params: { id: string };
    Body: { rollingSummary?: string; facts?: any; lastCompactedMessageId?: string };
  }>('/api/sessions/:id/memory', async (request, reply) => {
    const { id } = request.params;
    const data = request.body;

    const memory = await memoryRepo.upsert(id, data);

    return memory;
  });

  fastify.post<{
    Params: { id: string };
    Body: { appId: string; fileId: string; reason?: string; pinnedBy?: 'agent' | 'user' };
  }>('/api/sessions/:id/working-set', async (request, reply) => {
    const { id } = request.params;
    const { appId, fileId, reason, pinnedBy } = request.body;

    const item = await workingSetRepo.add(id, appId, fileId, reason, pinnedBy);

    return item;
  });

  fastify.delete<{
    Params: { sessionId: string; fileId: string };
  }>('/api/sessions/:sessionId/working-set/:fileId', async (request, reply) => {
    const { sessionId, fileId } = request.params;

    await workingSetRepo.remove(sessionId, fileId);

    return { success: true };
  });
}
</file>

<file path="packages/ui-server/package.json">
{
  "name": "@eitherway/ui-server",
  "version": "0.1.0",
  "description": "Backend server for EitherWay UI",
  "type": "module",
  "main": "./dist/index.js",
  "scripts": {
    "build": "tsc",
    "dev": "node --env-file=../../.env --import tsx/esm src/server.ts",
    "start": "node --env-file=../../.env dist/server.js"
  },
  "dependencies": {
    "@eitherway/database": "workspace:*",
    "@eitherway/runtime": "workspace:*",
    "@eitherway/tools-impl": "workspace:*",
    "@fastify/cors": "^8.5.0",
    "@fastify/multipart": "^8.0.0",
    "@fastify/websocket": "^8.3.1",
    "fastify": "^4.25.2",
    "sharp": "^0.33.5",
    "ws": "^8.16.0",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/node": "^20.11.16",
    "@types/ws": "^8.5.10",
    "tsx": "^4.7.0",
    "typescript": "^5.3.3"
  }
}
</file>

<file path="packages/ui-server/src/cdn-rewriter.ts">
/**
 * CDN URL Rewriter
 * Automatically rewrites external CDN URLs to use our proxy endpoint
 * Fixes COEP issues with WebContainer by proxying through /api/proxy-cdn
 */

const CDN_PATTERNS = [
  // Image CDNs
  /https?:\/\/via\.placeholder\.com\/[^\s"'`)]+/g,
  /https?:\/\/placehold\.co\/[^\s"'`)]+/g,
  /https?:\/\/ui-avatars\.com\/[^\s"'`)]+/g,
  /https?:\/\/api\.dicebear\.com\/[^\s"'`)]+/g,
  /https?:\/\/avatars\.githubusercontent\.com\/[^\s"'`)]+/g,
  /https?:\/\/source\.unsplash\.com\/[^\s"'`)]+/g,
  /https?:\/\/i\.imgur\.com\/[^\s"'`)]+/g,
  /https?:\/\/raw\.githubusercontent\.com\/[^\s"'`)]+/g,

  // Crypto coin images
  /https?:\/\/coin-images\.coingecko\.com\/[^\s"'`)]+/g,
  /https?:\/\/assets\.coingecko\.com\/[^\s"'`)]+/g,

  // JS/CSS CDNs
  /https?:\/\/cdn\.jsdelivr\.net\/[^\s"'`)]+/g,
  /https?:\/\/unpkg\.com\/[^\s"'`)]+/g,
  /https?:\/\/cdnjs\.cloudflare\.com\/[^\s"'`)]+/g,

  // Font CDNs
  /https?:\/\/fonts\.gstatic\.com\/[^\s"'`)]+/g,
];

export interface RewriteOptions {
  proxyBaseUrl?: string;
  skipFonts?: boolean;
  serverOrigin?: string;
  injectShim?: boolean;
  rewriteStaticUrls?: boolean;
}

/**
 * Rewrite external CDN URLs in content to use our proxy
 */
export function rewriteCDNUrls(content: string, options: RewriteOptions = {}): string {
  const { proxyBaseUrl = '/api/proxy-cdn', skipFonts = false, serverOrigin } = options;

  // If serverOrigin is provided, make URLs absolute
  const proxyUrl = serverOrigin ? `${serverOrigin}${proxyBaseUrl}` : proxyBaseUrl;

  let rewritten = content;

  for (const pattern of CDN_PATTERNS) {
    // Skip font URLs if requested
    if (skipFonts && pattern.source.includes('fonts.gstatic')) {
      continue;
    }

    rewritten = rewritten.replace(pattern, (url) => {
      // Encode the URL for the query parameter
      const encodedUrl = encodeURIComponent(url);
      return `${proxyUrl}?url=${encodedUrl}`;
    });
  }

  return rewritten;
}

/**
 * Check if a file should have CDN URLs rewritten
 */
export function shouldRewriteFile(filename: string): boolean {
  const ext = filename.toLowerCase().split('.').pop() || '';
  return ['html', 'htm', 'js', 'jsx', 'ts', 'tsx', 'vue', 'svelte'].includes(ext);
}

function generateInlineShim(_serverOrigin: string): string {
  return `<script>
(function() {
  var serverOrigin = window.location.origin;
  var API_PATTERN_HOST = /^(?:api\\.|pro-api\\.)/;

  function isExternal(url) {
    try {
      var parsed = new URL(url, window.location.href);
      if (parsed.protocol !== 'http:' && parsed.protocol !== 'https:') return false;
      if (parsed.origin === window.location.origin) return false;
      if (parsed.pathname && parsed.pathname.charAt(0) === '/') {
        var isRelative = !parsed.host || parsed.host === window.location.host;
        if (isRelative) return false;
      }
      return true;
    } catch {
      return false;
    }
  }

  function toProxy(url) {
    if (!isExternal(url)) return null;
    try {
      var parsed = new URL(url, window.location.href);
      var fullUrl = parsed.toString();
      var endpoint = API_PATTERN_HOST.test(parsed.hostname) ? '/api/proxy-api' : '/api/proxy-cdn';
      return serverOrigin + endpoint + '?url=' + encodeURIComponent(fullUrl);
    } catch {
      return null;
    }
  }

  var _fetch = window.fetch;
  window.fetch = function(input, init) {
    var url = typeof input === 'string' ? input : (input instanceof Request ? input.url : String(input));
    var proxied = toProxy(url);
    if (proxied) {
      input = proxied;
      init = Object.assign({ credentials: 'omit' }, init || {});
    }
    return _fetch.call(this, input, init);
  };

  var _xhrOpen = XMLHttpRequest.prototype.open;
  XMLHttpRequest.prototype.open = function(method, url) {
    var proxied = toProxy(url);
    if (proxied) {
      arguments[1] = proxied;
    }
    return _xhrOpen.apply(this, arguments);
  };
})();
</script>`;
}

/**
 * Rewrite file content for preview environments
 *
 * IMPORTANT: For WebContainer previews, set injectShim: false
 * The runtime shim uses window.location.origin and cannot reach external backend in WebContainer.
 *
 * What this does:
 * 1. Rewrites absolute CDN URLs in text files (HTML/JS/TS/etc) to use /api/proxy-cdn
 *    - Only touches absolute URLs (https://cdn.example.com/...)
 *    - Never touches relative URLs (/public/image.png)
 *
 * 2. Optionally injects runtime shim for dynamic fetch/XHR requests (HTML only)
 *    - Uses window.location.origin for proxy endpoints
 *    - Only proxies truly external URLs
 *    - Never proxies relative URLs or same-origin requests
 *
 * 3. Normalizes YouTube embeds to use nocookie embed URLs
 */
export function maybeRewriteFile(filename: string, content: string, options: RewriteOptions = {}): string {
  const {
    serverOrigin,
    injectShim = false, // Default false for WebContainer safety
    rewriteStaticUrls = true,
  } = options;

  // Skip rewriting entirely only if explicitly disabled
  if (!rewriteStaticUrls && !injectShim) {
    return content;
  }

  let processedContent = content;
  const isHtml = filename.toLowerCase().endsWith('.html') || filename.toLowerCase().endsWith('.htm');

  // Step 1: Rewrite static CDN URLs in text files (only absolute URLs)
  // If serverOrigin is undefined, URLs will be relative (for WebContainer)
  if (rewriteStaticUrls && shouldRewriteFile(filename)) {
    processedContent = rewriteCDNUrls(processedContent, {
      serverOrigin, // undefined = relative URLs
      skipFonts: options.skipFonts,
    });
  }

  // Step 2: HTML-specific processing
  if (isHtml) {
    // Normalize YouTube embeds
    processedContent = processedContent.replace(
      /<iframe([^>]*?)src=["']https?:\/\/(www\.)?youtube\.com\/watch\?v=([A-Za-z0-9_-]{11})[^"']*["']([^>]*)><\/iframe>/gi,
      (_match, pre, _www, videoId, post) => {
        const mustAllow =
          'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
        let attrs = `${pre}src="https://www.youtube-nocookie.com/embed/${videoId}"`;

        if (!/allow=/i.test(pre + post)) {
          attrs += ` allow="${mustAllow}"`;
        }

        if (!/allowfullscreen/i.test(pre + post)) {
          attrs += ` allowfullscreen`;
        }

        return `<iframe${attrs}${post}></iframe>`;
      },
    );

    // Inject runtime shim for dynamic requests (only if explicitly enabled)
    if (injectShim && serverOrigin) {
      const shimTag = generateInlineShim(serverOrigin);

      if (processedContent.includes('</head>')) {
        processedContent = processedContent.replace('</head>', `${shimTag}\n</head>`);
      } else if (processedContent.includes('</body>')) {
        processedContent = processedContent.replace('</body>', `${shimTag}\n</body>`);
      } else {
        processedContent = shimTag + '\n' + processedContent;
      }
    }
  }

  return processedContent;
}
</file>

<file path="packages/runtime/src/database-agent.ts">
import { Agent, AgentOptions, StreamingCallbacks } from './agent.js';
import type { DatabaseClient, Session, Message } from '@eitherway/database';
import {
  SessionsRepository,
  MessagesRepository,
  SessionMemoryRepository,
  WorkingSetRepository,
  EventsRepository,
} from '@eitherway/database';

export interface DatabaseAgentOptions extends Omit<AgentOptions, 'workingDir'> {
  db: DatabaseClient;
  sessionId: string;
  userId?: string;
  appId?: string;
  workingDir?: string;
}

export class DatabaseAgent {
  private agent: Agent;
  private db: DatabaseClient;
  private sessionsRepo: SessionsRepository;
  private messagesRepo: MessagesRepository;
  private memoryRepo: SessionMemoryRepository;
  private workingSetRepo: WorkingSetRepository;
  private eventsRepo: EventsRepository;
  private sessionId: string;
  private appId?: string;

  constructor(options: DatabaseAgentOptions) {
    this.db = options.db;
    this.sessionId = options.sessionId;
    this.appId = options.appId;

    this.sessionsRepo = new SessionsRepository(this.db);
    this.messagesRepo = new MessagesRepository(this.db);
    this.memoryRepo = new SessionMemoryRepository(this.db);
    this.workingSetRepo = new WorkingSetRepository(this.db);
    this.eventsRepo = new EventsRepository(this.db);

    this.agent = new Agent({
      workingDir: options.workingDir || process.cwd(),
      claudeConfig: options.claudeConfig,
      agentConfig: options.agentConfig,
      executors: options.executors,
      dryRun: options.dryRun,
      webSearch: options.webSearch,
    });
  }

  async processRequest(prompt: string, callbacks?: StreamingCallbacks): Promise<string> {
    await this.eventsRepo.log(
      'request.started',
      { prompt },
      {
        sessionId: this.sessionId,
        actor: 'user',
      },
    );

    // Load previous conversation history from database
    const previousMessages = await this.messagesRepo.findRecentBySession(this.sessionId, 50);

    // Convert database messages to Agent message format (filter out system/tool messages)
    const conversationHistory = previousMessages
      .filter((msg) => msg.role === 'user' || msg.role === 'assistant')
      .map((msg) => {
        let content = msg.content;

        // Ensure content is always an array (Claude API requirement)
        if (typeof content === 'string') {
          // Plain string - wrap in text block
          content = [{ type: 'text', text: content }];
        } else if (typeof content === 'object' && content !== null) {
          if (Array.isArray(content)) {
            // Already an array - keep as-is
            content = content;
          } else if ('text' in content && content.text) {
            // Object with text property - wrap in array
            content = [{ type: 'text', text: content.text }];
          } else {
            // Other object - stringify and wrap
            content = [{ type: 'text', text: JSON.stringify(content) }];
          }
        } else {
          // Fallback for any other type
          content = [{ type: 'text', text: String(content) }];
        }

        return {
          role: msg.role as 'user' | 'assistant',
          content,
        };
      });

    // Load conversation history into agent
    this.agent.loadConversationHistory(conversationHistory);

    const userMessage = await this.messagesRepo.create(
      this.sessionId,
      'user' as const,
      { text: prompt },
      undefined,
      undefined,
    );

    await this.sessionsRepo.touchLastMessage(this.sessionId);

    let response: string;
    let tokenCount = 0;

    try {
      response = await this.agent.processRequest(prompt, callbacks);

      const estimatedTokens = Math.ceil(response.length / 4);
      tokenCount = estimatedTokens;

      // Get the full conversation history to save the last assistant message properly
      const history = this.agent.getHistory();
      const lastAssistantMessage = history[history.length - 1];

      // Save the full content (could be text or array of content blocks)
      const contentToSave =
        lastAssistantMessage?.role === 'assistant' ? lastAssistantMessage.content : { text: response };

      const assistantMessage = await this.messagesRepo.create(
        this.sessionId,
        'assistant' as const,
        contentToSave as any,
        'claude-sonnet-4-5',
        tokenCount,
      );

      await this.sessionsRepo.touchLastMessage(this.sessionId);

      await this.eventsRepo.log(
        'request.completed',
        {
          userMessageId: userMessage.id,
          assistantMessageId: assistantMessage.id,
          tokenCount,
        },
        {
          sessionId: this.sessionId,
          actor: 'assistant',
        },
      );

      await this.updateMemoryIfNeeded();
    } catch (error: any) {
      await this.eventsRepo.log(
        'request.failed',
        {
          error: error.message,
          stack: error.stack,
        },
        {
          sessionId: this.sessionId,
          actor: 'system',
        },
      );
      throw error;
    }

    return response;
  }

  private async updateMemoryIfNeeded(): Promise<void> {
    const messageCount = await this.messagesRepo.countBySession(this.sessionId);

    if (messageCount % 10 === 0) {
      const recentMessages = await this.messagesRepo.findRecentBySession(this.sessionId, 20);

      const summary = this.generateSummary(recentMessages);

      await this.memoryRepo.upsert(this.sessionId, {
        rollingSummary: summary,
        lastCompactedMessageId: recentMessages[recentMessages.length - 1]?.id.toString(),
      });
    }
  }

  private generateSummary(messages: Message[]): string {
    const userMessages = messages.filter((m) => m.role === 'user');
    const topics = userMessages
      .map((m) => {
        if (typeof m.content === 'object' && m.content.text) {
          return m.content.text.substring(0, 50);
        }
        return '';
      })
      .filter(Boolean);

    return `Recent topics: ${topics.join(', ')}`;
  }

  async saveTranscript(): Promise<void> {
    await this.agent.saveTranscript();
  }

  async addToWorkingSet(fileId: string, reason?: string): Promise<void> {
    if (!this.appId) {
      throw new Error('Cannot add to working set: no appId');
    }

    await this.workingSetRepo.add(this.sessionId, this.appId, fileId, reason, 'agent');
  }

  async getWorkingSet(): Promise<any[]> {
    return this.workingSetRepo.findBySessionWithFiles(this.sessionId);
  }

  async getSessionContext(): Promise<{
    session: Session | null;
    recentMessages: Message[];
    memory: any;
    workingSet: any[];
  }> {
    const session = await this.sessionsRepo.findById(this.sessionId);
    const recentMessages = await this.messagesRepo.findRecentBySession(this.sessionId, 10);
    const memory = await this.memoryRepo.findBySession(this.sessionId);
    const workingSet = await this.workingSetRepo.findBySessionWithFiles(this.sessionId);

    return { session, recentMessages, memory, workingSet };
  }

  /**
   * Set database context for file operations
   */
  setDatabaseContext(fileStore: any, appId: string, sessionId?: string): void {
    this.agent.setDatabaseContext(fileStore, appId, sessionId);
  }
}
</file>

<file path="packages/ui-server/src/routes/session-files.ts">
import { FastifyInstance } from 'fastify';
import { SessionsRepository, PostgresFileStore, DatabaseClient, EventsRepository } from '@eitherway/database';

export async function registerSessionFileRoutes(fastify: FastifyInstance, db: DatabaseClient) {
  const sessionsRepo = new SessionsRepository(db);
  const fileStore = new PostgresFileStore(db);
  const eventsRepo = new EventsRepository(db);

  fastify.get<{
    Params: { sessionId: string };
    Querystring: { limit?: string };
  }>('/api/sessions/:sessionId/files/tree', async (request, reply) => {
    const { sessionId } = request.params;
    const limit = parseInt(request.query.limit || '1000', 10);

    const session = await sessionsRepo.findById(sessionId);

    if (!session) {
      return reply.code(404).send({ error: 'Session not found' });
    }

    if (!session.app_id) {
      return reply.send({ files: [] });
    }

    const files = await fileStore.list(session.app_id, limit);

    return { files };
  });

  fastify.get<{
    Params: { sessionId: string };
    Querystring: { path: string };
  }>('/api/sessions/:sessionId/files/read', async (request, reply) => {
    const { sessionId } = request.params;
    const { path } = request.query;

    if (!path) {
      return reply.code(400).send({ error: 'path query parameter is required' });
    }

    const session = await sessionsRepo.findById(sessionId);

    if (!session) {
      return reply.code(404).send({ error: 'Session not found' });
    }

    if (!session.app_id) {
      return reply.code(404).send({ error: 'No app associated with session' });
    }

    try {
      const fileContent = await fileStore.read(session.app_id, path);

      // Detect if file is binary based on mime type
      const mimeType = fileContent.mimeType || 'text/plain';
      const isBinary =
        mimeType.startsWith('image/') ||
        mimeType.startsWith('video/') ||
        mimeType.startsWith('audio/') ||
        mimeType.startsWith('application/octet-stream') ||
        mimeType.startsWith('application/pdf') ||
        mimeType.startsWith('application/zip');

      let content: string;
      if (isBinary) {
        // For binary files, return base64 encoded
        if (Buffer.isBuffer(fileContent.content)) {
          content = fileContent.content.toString('base64');
        } else if (typeof fileContent.content === 'string') {
          content = fileContent.content;
        } else {
          content = Buffer.from(fileContent.content).toString('base64');
        }
      } else {
        // For text files, return as UTF-8 string
        if (typeof fileContent.content === 'string') {
          content = fileContent.content;
        } else if (Buffer.isBuffer(fileContent.content)) {
          content = fileContent.content.toString('utf-8');
        } else {
          content = Buffer.from(fileContent.content).toString('utf-8');
        }

        // No URL rewriting - let external resources load directly with COEP headers
      }

      return {
        path: fileContent.path,
        content,
        mimeType,
        isBinary, // Include binary flag for frontend
        version: fileContent.version,
      };
    } catch (error: any) {
      return reply.code(404).send({ error: error.message });
    }
  });

  fastify.post<{
    Params: { sessionId: string };
    Body: { path: string; content: string; mimeType?: string };
  }>('/api/sessions/:sessionId/files/write', async (request, reply) => {
    const { sessionId } = request.params;
    const { path, content, mimeType } = request.body;

    if (!path) {
      return reply.code(400).send({ error: 'path is required' });
    }

    if (content === undefined) {
      return reply.code(400).send({ error: 'content is required' });
    }

    const session = await sessionsRepo.findById(sessionId);

    if (!session) {
      return reply.code(404).send({ error: 'Session not found' });
    }

    if (!session.app_id) {
      return reply.code(400).send({ error: 'No app associated with session' });
    }

    try {
      await fileStore.write(session.app_id, path, content, mimeType);

      await eventsRepo.log(
        'file.updated',
        { path },
        {
          sessionId,
          appId: session.app_id,
          actor: 'user',
        },
      );

      return {
        success: true,
        path,
        message: 'File saved successfully',
      };
    } catch (error: any) {
      console.error('Error writing file:', error);
      return reply.code(500).send({ error: error.message });
    }
  });

  /**
   * POST /api/sessions/:sessionId/files/write-binary
   * Write binary files (images, fonts, etc.) to VFS
   * Accepts base64-encoded content or raw buffer
   */
  fastify.post<{
    Params: { sessionId: string };
    Body: { path: string; content: string; mimeType?: string; encoding?: string };
  }>('/api/sessions/:sessionId/files/write-binary', async (request, reply) => {
    const { sessionId } = request.params;
    const { path, content, mimeType, encoding = 'base64' } = request.body;

    console.log('[Write Binary] Request received:', {
      sessionId,
      path,
      hasContent: content !== undefined,
      contentType: typeof content,
      contentLength: content ? content.length : 0,
      mimeType,
      encoding,
      bodyKeys: Object.keys(request.body || {}),
    });

    if (!path) {
      return reply.code(400).send({ error: 'path is required' });
    }

    if (content === undefined || content === null || content === '') {
      console.error('[Write Binary] Content validation failed:', {
        contentIsUndefined: content === undefined,
        contentIsNull: content === null,
        contentIsEmpty: content === '',
        bodyReceived: request.body,
      });
      return reply.code(400).send({
        error: 'content is required',
        details: 'Content must be a non-empty string (base64-encoded for binary files)'
      });
    }

    const session = await sessionsRepo.findById(sessionId);

    if (!session) {
      return reply.code(404).send({ error: 'Session not found' });
    }

    if (!session.app_id) {
      return reply.code(400).send({ error: 'No app associated with session' });
    }

    try {
      // Decode base64 content to buffer
      let buffer: Buffer;
      if (encoding === 'base64') {
        buffer = Buffer.from(content, 'base64');

        // Validate decoded buffer
        if (buffer.length === 0) {
          return reply.code(400).send({ error: 'Base64 decoding resulted in empty buffer' });
        }

        // Log first bytes for debugging
        const firstBytes = buffer.slice(0, 16);
        console.log(`[Write Binary] Decoded buffer size: ${buffer.length} bytes`);
        console.log(`[Write Binary] First bytes (hex): ${firstBytes.toString('hex')}`);

        // For PNG images, verify magic number (89 50 4E 47 0D 0A 1A 0A)
        if (mimeType?.startsWith('image/png') && buffer.length >= 8) {
          const pngMagic = Buffer.from([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]);
          const fileMagic = buffer.slice(0, 8);
          if (!fileMagic.equals(pngMagic)) {
            console.warn('[Write Binary] PNG magic number mismatch - file may be corrupted');
            console.warn(`[Write Binary] Expected: ${pngMagic.toString('hex')}, Got: ${fileMagic.toString('hex')}`);
          } else {
            console.log('[Write Binary] PNG magic number verified ');
          }
        }
      } else {
        // If not base64, assume it's already a buffer or binary string
        buffer = Buffer.from(content);
      }

      // Write binary buffer to VFS
      await fileStore.write(session.app_id, path, buffer, mimeType);

      await eventsRepo.log(
        'file.updated',
        { path, size: buffer.length },
        {
          sessionId,
          appId: session.app_id,
          actor: 'user',
        },
      );

      return {
        success: true,
        path,
        size: buffer.length,
        message: 'Binary file saved successfully',
      };
    } catch (error: any) {
      console.error('Error writing binary file:', error);
      return reply.code(500).send({ error: error.message });
    }
  });

  fastify.post<{
    Params: { sessionId: string };
    Body: { oldPath: string; newPath: string };
  }>('/api/sessions/:sessionId/files/rename', async (request, reply) => {
    const { sessionId } = request.params;
    const { oldPath, newPath } = request.body;

    if (!oldPath || !newPath) {
      return reply.code(400).send({ error: 'oldPath and newPath are required' });
    }

    const session = await sessionsRepo.findById(sessionId);

    if (!session) {
      return reply.code(404).send({ error: 'Session not found' });
    }

    if (!session.app_id) {
      return reply.code(400).send({ error: 'No app associated with session' });
    }

    try {
      await fileStore.rename(session.app_id, oldPath, newPath);

      await eventsRepo.log(
        'file.renamed',
        { oldPath, newPath },
        {
          sessionId,
          appId: session.app_id,
          actor: 'user',
        },
      );

      return {
        success: true,
        oldPath,
        newPath,
        message: 'File renamed successfully',
      };
    } catch (error: any) {
      console.error('Error renaming file:', error);
      return reply.code(500).send({ error: error.message });
    }
  });

  fastify.delete<{
    Params: { sessionId: string };
    Querystring: { path: string };
  }>('/api/sessions/:sessionId/files', async (request, reply) => {
    const { sessionId } = request.params;
    const { path } = request.query;

    if (!path) {
      return reply.code(400).send({ error: 'path query parameter is required' });
    }

    const session = await sessionsRepo.findById(sessionId);

    if (!session) {
      return reply.code(404).send({ error: 'Session not found' });
    }

    if (!session.app_id) {
      return reply.code(400).send({ error: 'No app associated with session' });
    }

    try {
      await fileStore.delete(session.app_id, path);

      await eventsRepo.log(
        'file.deleted',
        { path },
        {
          sessionId,
          appId: session.app_id,
          actor: 'user',
        },
      );

      return {
        success: true,
        path,
        message: 'File deleted successfully',
      };
    } catch (error: any) {
      console.error('Error deleting file:', error);
      return reply.code(500).send({ error: error.message });
    }
  });

  fastify.get<{
    Params: { sessionId: string };
    Querystring: { path: string; limit?: string };
  }>('/api/sessions/:sessionId/files/versions', async (request, reply) => {
    const { sessionId } = request.params;
    const { path, limit = '50' } = request.query;

    if (!path) {
      return reply.code(400).send({ error: 'path query parameter is required' });
    }

    const session = await sessionsRepo.findById(sessionId);

    if (!session) {
      return reply.code(404).send({ error: 'Session not found' });
    }

    if (!session.app_id) {
      return reply.code(404).send({ error: 'No app associated with session' });
    }

    try {
      const versions = await fileStore.getVersions(session.app_id, path, parseInt(limit, 10));

      return { versions };
    } catch (error: any) {
      return reply.code(404).send({ error: error.message });
    }
  });
}
</file>

<file path="packages/ui-frontend/app/components/chat/Chat.client.tsx">
import { useStore } from '@nanostores/react';
import type { Message } from 'ai';
import { useAnimate } from 'framer-motion';
import { memo, useEffect, useRef, useState } from 'react';
import { cssTransition, toast, ToastContainer } from 'react-toastify';
import { useShortcuts, useSnapScroll } from '~/lib/hooks';
import { useBackendHistory } from '~/lib/persistence/useBackendHistory';
import { chatStore } from '~/lib/stores/chat';
import { authStore } from '~/lib/stores/auth';
import { brandKitStore } from '~/lib/stores/brandKit';
import { workbenchStore } from '~/lib/stores/workbench';
import { useWalletConnection } from '~/lib/web3/hooks';
import { cubicEasingFn } from '~/utils/easings';
import { createScopedLogger } from '~/utils/logger';
import { streamFromWebSocket, type StreamController } from '~/utils/websocketClient';
import { getOrCreateSession, clearSession } from '~/utils/sessionManager';
import { syncFilesToWebContainer } from '~/utils/fileSync';
import { syncBrandAssetsToWebContainer } from '~/utils/brandAssetSync';
import { webcontainer } from '~/lib/webcontainer/index';
import { runDevServer } from '~/utils/webcontainerRunner';
import { BaseChat } from './BaseChat';
import { BACKEND_URL } from '~/config/api';

const toastAnimation = cssTransition({
  enter: 'animated fadeInRight',
  exit: 'animated fadeOutRight',
});

const logger = createScopedLogger('Chat');

/**
 * Helper: Generate session title from the user's full prompt
 * Uses the entire user message as the title, with smart truncation for long prompts
 */
function generateTitleFromPrompt(prompt: string): string {
  // Normalize whitespace: trim and collapse multiple spaces/newlines into single spaces
  let title = prompt.trim().replace(/\s+/g, ' ');

  // Truncate at 100 characters with ellipsis for readability
  if (title.length > 100) {
    // Try to break at a word boundary near the limit
    const truncated = title.substring(0, 100);
    const lastSpace = truncated.lastIndexOf(' ');

    if (lastSpace > 80) {
      // Break at word boundary if it's reasonably close to the limit
      title = truncated.substring(0, lastSpace) + '...';
    } else {
      // Otherwise just hard truncate
      title = truncated + '...';
    }
  }

  // Fallback if empty after processing
  return title.length > 0 ? title : 'New Chat';
}

/**
 * Helper: Sanitize filename by replacing spaces with hyphens and removing special characters
 */
function sanitizeFilename(filename: string): string {
  // Extract extension
  const lastDotIndex = filename.lastIndexOf('.');
  const name = lastDotIndex > 0 ? filename.slice(0, lastDotIndex) : filename;
  const ext = lastDotIndex > 0 ? filename.slice(lastDotIndex) : '';

  // Sanitize the name part:
  // - Replace spaces and underscores with hyphens
  // - Convert to lowercase
  // - Remove special characters except hyphens and alphanumeric
  const sanitizedName = name
    .replace(/[\s_]+/g, '-')
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, '');

  return sanitizedName + ext.toLowerCase();
}

/**
 * Helper: Determine destination path for a brand asset based on its type
 */
function getAssetDestinationPath(asset: any): string {
  const kind = asset.metadata?.kind || asset.assetType;
  const fileName = sanitizeFilename(asset.fileName);

  switch (kind) {
    case 'icon':
      return `public/${fileName}`;
    case 'logo':
    case 'image':
      return `public/assets/${fileName}`;
    case 'font':
      return `public/fonts/${fileName}`;
    case 'video':
      return `public/videos/${fileName}`;
    case 'brand_zip':
      return ''; // Skip ZIPs
    default:
      return `public/brand/${fileName}`;
  }
}

/**
 * Helper: Convert ArrayBuffer to base64 string using FileReader
 * More reliable for binary data than manual string concatenation
 */
async function arrayBufferToBase64(buffer: ArrayBuffer): Promise<string> {
  return new Promise((resolve, reject) => {
    const blob = new Blob([buffer]);
    const reader = new FileReader();

    reader.onload = () => {
      const dataUrl = reader.result as string;
      // Data URL format: data:mime/type;base64,<base64data>
      // Extract just the base64 part
      const base64 = dataUrl.split(',')[1];
      resolve(base64);
    };

    reader.onerror = () => {
      reject(new Error('Failed to convert ArrayBuffer to base64'));
    };

    reader.readAsDataURL(blob);
  });
}

/**
 * Ensure brand assets are synced to both client WebContainer and server session workspace
 * before starting a new streaming request
 */
async function ensureBrandAssetsSyncedBeforeStream(sessionId: string, userId: string | null) {
  let { pendingBrandKitId } = brandKitStore.get();

  // If no brand kit in store, try to fetch user's active brand kit
  if (!pendingBrandKitId && userId) {
    try {
      logger.debug('Fetching active brand kit for user:', userId);
      const response = await fetch(`/api/brand-kits/user/${encodeURIComponent(userId)}/active`);

      if (response.ok) {
        const data = await response.json();
        if (data.success && data.brandKit) {
          pendingBrandKitId = data.brandKit.id;
          brandKitStore.setKey('pendingBrandKitId', pendingBrandKitId);
          logger.info('Fetched and set user active brand kit:', pendingBrandKitId);
        }
      } else if (response.status !== 404) {
        logger.debug('No active brand kit found for user');
      }
    } catch (error) {
      logger.debug('Error fetching active brand kit:', error);
    }
  }

  // If still no brand kit, nothing to sync
  if (!pendingBrandKitId) {
    logger.debug('No brand kit to sync');
    return;
  }

  try {
    // 1) Fetch the latest kit with assets (from UI server)
    logger.info(' Syncing brand kit assets to session:', sessionId, 'Brand Kit:', pendingBrandKitId);
    const res = await fetch(`/api/brand-kits/${pendingBrandKitId}`);
    if (!res.ok) {
      throw new Error(`Failed to fetch brand kit: ${res.statusText}`);
    }
    const data = await res.json();
    const assets = data?.brandKit?.assets ?? [];

    if (assets.length === 0) {
      logger.info('No assets to sync');
      return;
    }

    logger.info(`Found ${assets.length} brand assets to sync`);

    // 2) Sync into client WebContainer
    logger.info(' Obtaining WebContainer instance...');
    const wc = await webcontainer;
    logger.info(' WebContainer instance obtained, starting asset sync...');

    const result = await syncBrandAssetsToWebContainer(wc, assets);
    logger.info(
      ` Client WebContainer sync complete: ${result.synced} synced, ${result.failed} failed, ${result.skipped} skipped`,
    );

    if (result.failed > 0) {
      logger.warn(`  ${result.failed} assets failed to sync to WebContainer`);
    }

    if (result.synced === 0 && assets.length > 0) {
      throw new Error('No assets were synced to WebContainer - files will not be available in preview');
    }

    // 3) Push to the server session workspace
    let serverSynced = 0;
    const serverFailed: string[] = [];

    for (const asset of assets) {
      try {
        const destPath = getAssetDestinationPath(asset);
        if (!destPath) {
          logger.debug(`Skipping asset (no destination): ${asset.fileName}`);
          continue;
        }

        logger.info(` Syncing asset to server: ${asset.fileName}  ${destPath}`);
        logger.debug(`Storage key: ${asset.storageKey}`);

        // Fetch asset bytes from storage with retry logic
        let assetBuffer: ArrayBuffer | null = null;
        let fetchError: Error | null = null;

        for (let attempt = 1; attempt <= 3; attempt++) {
          try {
            logger.debug(`Attempt ${attempt}/3: Fetching ${asset.storageKey}`);
            const assetRes = await fetch(
              `${BACKEND_URL}/api/brand-assets/download/${encodeURIComponent(asset.storageKey)}`,
            );

            if (!assetRes.ok) {
              throw new Error(`HTTP ${assetRes.status}: ${assetRes.statusText}`);
            }

            assetBuffer = await assetRes.arrayBuffer();
            logger.debug(` Fetched ${assetBuffer.byteLength} bytes for ${asset.fileName}`);
            break; // Success, exit retry loop
          } catch (err: any) {
            fetchError = err;
            logger.warn(`Attempt ${attempt}/3 failed for ${asset.fileName}: ${err.message}`);
            if (attempt < 3) {
              // Wait before retry (exponential backoff)
              await new Promise((resolve) => setTimeout(resolve, attempt * 1000));
            }
          }
        }

        if (!assetBuffer) {
          throw new Error(`Failed to fetch asset after 3 attempts: ${fetchError?.message}`);
        }

        // Convert to base64 using FileReader (more reliable for binary data)
        const base64Content = await arrayBufferToBase64(assetBuffer);
        logger.debug(`Encoded to base64: ${base64Content.length} characters`);

        // Validate base64 encoding
        if (!base64Content || base64Content.length === 0) {
          throw new Error('Base64 encoding failed - empty result');
        }

        // Log first bytes of original for debugging
        const firstBytes = new Uint8Array(assetBuffer.slice(0, 16));
        logger.debug(`Original first bytes: ${Array.from(firstBytes).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);

        // POST to server write-binary endpoint with validation
        logger.debug(`Writing to session workspace: ${destPath}`);
        logger.debug(`Writing asset to session ${sessionId} at path: ${destPath}`);
        const writeRes = await fetch(`/api/sessions/${sessionId}/files/write-binary`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            path: destPath,
            content: base64Content,
            mimeType: asset.mimeType,
            encoding: 'base64',
          }),
        });

        logger.debug(`Write response status: ${writeRes.status}`);

        if (!writeRes.ok) {
          const errorData = await writeRes.json().catch(() => ({ error: writeRes.statusText }));
          throw new Error(`Failed to write to server: ${errorData.error || writeRes.statusText}`);
        }

        const writeResult = await writeRes.json();
        logger.info(` Server synced: ${destPath} (${writeResult.size} bytes)`);

        // The file is written successfully, but may not be immediately readable
        // due to async database commit. The file will be available when the agent
        // needs it during code generation.

        serverSynced++;
      } catch (error: any) {
        logger.error(` Failed to sync asset ${asset.fileName} to server:`, error);
        serverFailed.push(`${asset.fileName}: ${error.message}`);
        // Continue with other assets
      }
    }

    logger.info(` Synced ${serverSynced}/${assets.length} assets to server workspace (session: ${sessionId})`);

    if (serverFailed.length > 0) {
      logger.error(` Failed to sync ${serverFailed.length} assets:`, serverFailed);
      toast.error(`Some brand assets failed to sync: ${serverFailed[0]}`);
    }

    // 4) Create brand kit manifest with color palette for the agent
    // IMPORTANT: Only write manifest if at least some assets synced successfully
    // This prevents creating a manifest that references non-existent files
    const colors = data?.brandKit?.colors ?? [];
    if (colors.length > 0 && serverSynced > 0) {
      const manifest = {
        brandKit: {
          id: pendingBrandKitId,
          colors: colors.map((c: any) => ({
            hex: c.hex,
            name: c.name,
            role: c.role,
            prominence: c.prominence,
          })),
          assets: assets.map((a: any) => ({
            fileName: sanitizeFilename(a.fileName),
            type: a.assetType,
            path: getAssetDestinationPath(a),
          })),
        },
      };

      const manifestJson = JSON.stringify(manifest, null, 2);

      try {
        const manifestRes = await fetch(`/api/sessions/${sessionId}/files/write`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            path: 'brand-kit.json',
            content: manifestJson,
            mimeType: 'application/json',
          }),
        });

        if (manifestRes.ok) {
          logger.info(' Brand kit manifest created with color palette');
        }
      } catch (error) {
        logger.error('Failed to write brand kit manifest:', error);
      }
    } else if (colors.length > 0 && serverSynced === 0) {
      logger.warn('  Skipping brand kit manifest creation - no assets synced successfully');
    }

    logger.info(` Brand assets fully synced to session ${sessionId}`);

    // 5) Archive the brand kit and clear UI after successful sync
    // This ensures the brand kit doesn't persist across different app requests
    if (userId && pendingBrandKitId) {
      try {
        logger.info(' Archiving brand kit after successful sync:', pendingBrandKitId);
        const archiveRes = await fetch(`/api/brand-kits/user/${encodeURIComponent(userId)}/archive-active`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({}),
        });

        if (archiveRes.ok) {
          logger.info(' Brand kit archived successfully');
          // Clear frontend state
          brandKitStore.setKey('pendingBrandKitId', null);
          brandKitStore.setKey('uploadedAssets', []);
          logger.info(' Brand kit UI cleared');
        } else {
          logger.warn('Failed to archive brand kit:', archiveRes.status);
        }
      } catch (archiveError) {
        logger.warn('Failed to archive brand kit (non-critical):', archiveError);
        // Non-critical error - assets are already synced
      }
    }
  } catch (error) {
    logger.error('Failed to sync brand assets:', error);
    toast.error('Failed to sync brand assets. They may not be available in the workspace.');
  }
}

export function Chat() {
  const { ready, initialMessages, files, sessionTitle, sessionId, storeMessageHistory } = useBackendHistory();

  return (
    <>
      {ready && (
        <ChatImpl
          initialMessages={initialMessages}
          files={files}
          sessionTitle={sessionTitle}
          sessionId={sessionId}
          storeMessageHistory={storeMessageHistory}
        />
      )}
      <ToastContainer
        closeButton={({ closeToast }) => {
          return (
            <button className="Toastify__close-button" onClick={closeToast}>
              <div className="i-ph:x text-lg" />
            </button>
          );
        }}
        icon={({ type }) => {
          switch (type) {
            case 'success': {
              return <div className="i-ph:check-bold text-eitherway-elements-icon-success text-2xl" />;
            }
            case 'error': {
              return <div className="i-ph:warning-circle-bold text-eitherway-elements-icon-error text-2xl" />;
            }
          }

          return undefined;
        }}
        position="bottom-right"
        pauseOnFocusLoss
        transition={toastAnimation}
      />
    </>
  );
}

interface FileNode {
  name: string;
  path: string;
  type: 'file' | 'directory';
  size?: number;
  children?: FileNode[];
}

interface ChatProps {
  initialMessages: Message[];
  files: FileNode[];
  sessionTitle: string;
  sessionId: string | null;
  storeMessageHistory: (messages: Message[]) => Promise<void>;
}

export const ChatImpl = memo(({ initialMessages, files, sessionTitle, sessionId, storeMessageHistory }: ChatProps) => {
  useShortcuts();

  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const [chatStarted, setChatStarted] = useState(initialMessages.length > 0);

  const { showChat } = useStore(chatStore);
  const user = useStore(authStore.user);
  const { isConnected, address } = useWalletConnection();

  // Prioritize wallet address (email auth is mostly mock)
  const userId = (isConnected && address ? address : user?.email) || null;

  useEffect(() => {
    console.log('Chat.client - setting chatStarted to:', chatStarted);
    chatStore.setKey('started', chatStarted);
  }, [chatStarted]);

  const [animationScope, animate] = useAnimate();

  // Extended Message type with metadata
  interface ExtendedMessage extends Message {
    metadata?: {
      reasoningText?: string;
      thinkingDuration?: number | null;
      fileOperations?: Array<{ operation: string; filePath: string }>;
      tokenUsage?: { inputTokens: number; outputTokens: number } | null;
      phase?: 'pending' | 'thinking' | 'reasoning' | 'code-writing' | 'building' | 'completed' | null;
    };
  }

  // Local state for messages (replaces useChat)
  const [messages, setMessages] = useState<ExtendedMessage[]>(initialMessages);
  const [isLoading, setIsLoading] = useState(false);
  const [input, setInput] = useState('');
  const streamControllerRef = useRef<StreamController | null>(null);

  // Phase 2: Enhanced streaming state (for current message only)
  const [currentPhase, setCurrentPhase] = useState<
    'pending' | 'thinking' | 'reasoning' | 'code-writing' | 'building' | 'completed' | null
  >(null);
  const [reasoningText, setReasoningText] = useState('');
  const [thinkingDuration, setThinkingDuration] = useState<number | null>(null);
  const [fileOperations, setFileOperations] = useState<Array<{ operation: string; filePath: string }>>([]);
  const [tokenUsage, setTokenUsage] = useState<{ inputTokens: number; outputTokens: number } | null>(null);

  const TEXTAREA_MAX_HEIGHT = chatStarted ? 400 : 200;

  useEffect(() => {
    chatStore.setKey('started', initialMessages.length > 0);
    if (sessionId) {
      chatStore.setKey('sessionId', sessionId);
    }
  }, [sessionId]);

  // Keep messages in sync with initialMessages when loading from backend
  useEffect(() => {
    if (initialMessages.length > 0 && messages.length === 0) {
      console.log(' [Chat] Loading', initialMessages.length, 'messages from backend history');
      setMessages(initialMessages);
      setChatStarted(true);
    }
  }, [initialMessages]);

  useEffect(() => {
    if (files.length > 0 && sessionId) {
      console.log(' [Chat] Syncing', files.length, 'files to WebContainer for session:', sessionId);

      // Auto-show workbench when loading from history
      workbenchStore.showWorkbench.set(true);
      logger.info(' Auto-showing workbench for historical session');

      // Async function to sync files and start dev server
      (async () => {
        try {
          const wc = await webcontainer;

          // CRITICAL: Ensure brand assets are synced to both WC and server workspace
          // before loading files. This prevents 404 errors when the preview tries to
          await ensureBrandAssetsSyncedBeforeStream(sessionId, userId);
          logger.info(' Brand assets resynced for historical session');

          await syncFilesToWebContainer(wc, files, sessionId);
          logger.info(' Files synced to WebContainer from history');

          // Start dev server with the loaded files
          await runDevServer(wc, files);
          logger.info(' Dev server started for historical session');
        } catch (error) {
          logger.error(' Failed to load files from history:', error);
          toast.error('Failed to load workspace files');
        }
      })();
    }
  }, [files, sessionId, userId]);

  useEffect(() => {
    // Store message history when messages change (no-op for backend, kept for compatibility)
    if (messages.length > initialMessages.length) {
      storeMessageHistory(messages).catch((error) => toast.error(error.message));
    }
  }, [messages, storeMessageHistory, initialMessages.length]);

  const scrollTextArea = () => {
    const textarea = textareaRef.current;

    if (textarea) {
      textarea.scrollTop = textarea.scrollHeight;
    }
  };

  const abort = () => {
    if (streamControllerRef.current) {
      streamControllerRef.current.abort();
      streamControllerRef.current = null;
    }

    setMessages((prev) => {
      return prev.map((msg, idx) => {
        if (idx === prev.length - 1 && msg.role === 'assistant') {
          return {
            ...msg,
            metadata: {
              reasoningText,
              thinkingDuration,
              fileOperations,
              tokenUsage,
              phase: currentPhase,
            },
          };
        }
        return msg;
      });
    });

    setIsLoading(false);
    chatStore.setKey('aborted', true);
  };

  const handleInputChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
    setInput(event.target.value);
  };

  useEffect(() => {
    const textarea = textareaRef.current;

    if (textarea) {
      textarea.style.height = 'auto';

      const scrollHeight = textarea.scrollHeight;

      textarea.style.height = `${Math.min(scrollHeight, TEXTAREA_MAX_HEIGHT)}px`;
      textarea.style.overflowY = scrollHeight > TEXTAREA_MAX_HEIGHT ? 'auto' : 'hidden';
    }
  }, [input, textareaRef, TEXTAREA_MAX_HEIGHT]);

  const runAnimation = async () => {
    if (chatStarted) {
      return;
    }

    console.log('Chat.client - runAnimation called, setting chatStarted to true');

    await Promise.all([
      animate('#examples', { opacity: 0, display: 'none' }, { duration: 0.1 }),
      animate('#intro', { opacity: 0, flex: 1 }, { duration: 0.2, ease: cubicEasingFn }),
    ]);

    chatStore.setKey('started', true);
    setChatStarted(true);
  };

  const sendMessage = async (_event: React.UIEvent, messageInput?: string) => {
    const _input = messageInput || input;

    if (_input.length === 0 || isLoading) {
      return;
    }

    chatStore.setKey('aborted', false);

    runAnimation();

    setCurrentPhase(null);
    chatStore.setKey('currentPhase', null); // Also reset global store
    setReasoningText('');
    setThinkingDuration(null);
    setFileOperations([]);
    setTokenUsage(null);

    const userMessage: Message = {
      id: `user-${Date.now()}`,
      role: 'user',
      content: _input,
    };

    const assistantMessageId = `assistant-${Date.now()}`;
    const assistantMessage: ExtendedMessage = {
      id: assistantMessageId,
      role: 'assistant',
      content: '',
      metadata: {
        reasoningText: '',
        thinkingDuration: null,
        fileOperations: [],
        tokenUsage: null,
        phase: null,
      },
    };

    setMessages((prev) => [...prev, userMessage, assistantMessage]);
    setInput('');
    setIsLoading(true);

    textareaRef.current?.blur();

    // IMPORTANT: Create new objects instead of mutating for React to detect changes
    const updateMessageMetadata = (updates: Partial<ExtendedMessage['metadata']>) => {
      setMessages((prev) => {
        const updated = prev.map((msg) => {
          // Find message by ID (not position) so it works even if new messages are added
          if (msg.id === assistantMessageId) {
            const newMetadata = {
              ...msg.metadata,
              ...updates,
            };
            // Removed noisy metadata logging - fires for every update
            return {
              ...msg,
              metadata: newMetadata,
            };
          }
          return msg;
        });
        return updated;
      });
    };

    // Stream response from WebSocket backend
    try {
      // MATCH MAIN BRANCH BEHAVIOR: Clear session for first message to start fresh
      // This ensures each new app request gets a clean workspace
      if (messages.length === 0 || !chatStarted) {
        clearSession();
        console.log(' [Chat] Starting fresh session for new conversation');
      }

      // Ensure user is authenticated before creating session
      if (!userId) {
        toast.error('Please connect your wallet to start chatting');
        setIsLoading(false);
        return;
      }

      const session = await getOrCreateSession(userId, 'EitherWay Chat');
      logger.debug('Using session:', session.id);
      console.log(' [Chat Message] Session ID for this message:', session.id);
      console.log(' [Chat Message] localStorage currentSessionId:', localStorage.getItem('currentSessionId'));
      console.log(' [Chat Message] User ID:', userId);

      // Store session ID in chat store for export/deployment
      chatStore.setKey('sessionId', session.id);

      // Generate and update session title from first user message
      if (messages.length === 0) {
        const generatedTitle = generateTitleFromPrompt(_input);
        logger.info(` Generated session title: "${generatedTitle}"`);

        try {
          await fetch(`/api/sessions/${session.id}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title: generatedTitle }),
          });
          logger.info(' Session title updated');
        } catch (error) {
          logger.warn('Failed to update session title:', error);
          // Non-critical, continue with streaming
        }
      }

      // CRITICAL: Ensure brand assets are synced to THIS session (the one we're about to use)
      // This must happen AFTER session is determined, not during upload
      logger.info(` Syncing brand assets to active session: ${session.id}`);
      await ensureBrandAssetsSyncedBeforeStream(session.id, userId);

      const controller = await streamFromWebSocket({
        prompt: _input,
        sessionId: session.id, // Use session ID from database
        onChunk: (chunk) => {
          setMessages((prev) => {
            return prev.map((msg) => {
              if (msg.id === assistantMessageId) {
                return {
                  ...msg,
                  content: msg.content + chunk,
                };
              }
              return msg;
            });
          });
        },
        onComplete: () => {
          // Metadata is already saved in real-time by updateMessageMetadata in each callback
          // No need to save here - closures would capture empty state values anyway
          setIsLoading(false);
          streamControllerRef.current = null;
          logger.debug('Streaming complete');
        },
        onError: (error) => {
          setMessages((prev) => {
            return prev.map((msg) => {
              if (msg.id === assistantMessageId) {
                return {
                  ...msg,
                  content: `[Error: ${error}]`,
                  metadata: {
                    reasoningText,
                    thinkingDuration,
                    fileOperations,
                    tokenUsage,
                    phase: currentPhase,
                  },
                };
              }
              return msg;
            });
          });
          setIsLoading(false);
          streamControllerRef.current = null;
          toast.error(`Streaming error: ${error}`);
          logger.error('Streaming error:', error);
        },
        // Phase 2: Enhanced callbacks
        onPhase: (phase) => {
          logger.info('Phase:', phase);
          setCurrentPhase(phase);
          chatStore.setKey('currentPhase', phase);

          updateMessageMetadata({ phase });

          // Auto-show workbench when agent starts writing code
          if (phase === 'code-writing') {
            workbenchStore.showWorkbench.set(true);
            logger.info(' Auto-showing workbench preview - agent started writing code');
          }
        },
        onReasoning: (text) => {
          // Removed noisy debug logging - fires for every reasoning chunk
          setReasoningText((prev) => {
            const newText = prev + text;
            updateMessageMetadata({ reasoningText: newText });
            return newText;
          });
        },
        onThinkingComplete: (duration) => {
          logger.debug('Thinking complete in', duration, 'seconds');
          setThinkingDuration(duration);
          updateMessageMetadata({ thinkingDuration: duration });
        },
        onFileOperation: (operation, filePath) => {
          logger.debug('File operation:', operation, filePath);
          setFileOperations((prev) => {
            const newOps = [...prev, { operation, filePath }];
            updateMessageMetadata({ fileOperations: newOps });
            return newOps;
          });
        },
        onFilesUpdated: async (files, sessionIdFromEvent) => {
          logger.debug('Files updated:', files.length, 'files', sessionIdFromEvent);

          // Sync files to WebContainer
          try {
            const wc = await webcontainer;

            // CRITICAL: The files array from the agent may not include brand assets
            // that were uploaded before the stream started. Fetch complete file tree.
            logger.debug('Fetching complete file tree to ensure brand assets are included...');
            let completeFileTree = files;

            try {
              const treeRes = await fetch(`/api/sessions/${session.id}/files/tree?limit=1000`);
              if (treeRes.ok) {
                const treeData = await treeRes.json();
                if (treeData.files && treeData.files.length > 0) {
                  logger.info(
                    ` Fetched complete file tree: ${treeData.files.length} total files (agent provided ${files.length})`,
                  );

                  // Debug: Log all file paths in the tree
                  const flattenFiles = (nodes: any[], prefix = ''): string[] => {
                    const paths: string[] = [];
                    for (const node of nodes) {
                      const fullPath = prefix ? `${prefix}/${node.name}` : node.name;
                      if (node.type === 'file') {
                        paths.push(fullPath);
                      }
                      if (node.type === 'directory' && node.children) {
                        paths.push(...flattenFiles(node.children, fullPath));
                      }
                    }
                    return paths;
                  };

                  const allPaths = flattenFiles(treeData.files);
                  logger.debug(` File tree contains: ${allPaths.join(', ')}`);

                  const hasBrandAsset = allPaths.some((p) => p.includes('public/assets/') && p.endsWith('.png'));
                  if (!hasBrandAsset) {
                    logger.warn('  Brand asset NOT found in file tree! This will cause 404 errors.');
                    logger.warn('Files in tree:', allPaths);
                  } else {
                    logger.info(' Brand asset found in file tree');
                  }

                  completeFileTree = treeData.files;
                } else {
                  logger.warn('File tree fetch succeeded but returned empty - using agent files');
                }
              } else {
                logger.warn(`File tree fetch failed: ${treeRes.status} - using agent files`);
              }
            } catch (treeError) {
              logger.warn('Failed to fetch complete file tree, using agent files:', treeError);
            }

            await syncFilesToWebContainer(wc, completeFileTree, session.id);
            logger.info(` Files synced to WebContainer: ${completeFileTree.length} files`);

            // After syncing, run dev server
            await runDevServer(wc, completeFileTree);
            logger.info('Dev server started in WebContainer');
          } catch (error) {
            logger.error('Failed to sync files or start dev server:', error);
            toast.error('Failed to load files into workspace');
          }
        },
        onTokenUsage: (inputTokens, outputTokens) => {
          logger.debug('Token usage:', inputTokens, 'input,', outputTokens, 'output');
          const usage = { inputTokens, outputTokens };
          setTokenUsage(usage);
          updateMessageMetadata({ tokenUsage: usage });
        },
      });

      streamControllerRef.current = controller;
    } catch (error) {
      setMessages((prev) => {
        return prev.map((msg) => {
          if (msg.id === assistantMessageId) {
            return {
              ...msg,
              content: `[Error: ${error instanceof Error ? error.message : 'Unknown error'}]`,
            };
          }
          return msg;
        });
      });
      setIsLoading(false);
      toast.error('Failed to start streaming');
      logger.error('Failed to start streaming:', error);
    }
  };

  const [messageRef, scrollRef] = useSnapScroll();

  return (
    <BaseChat
      ref={animationScope}
      textareaRef={textareaRef}
      input={input}
      showChat={showChat}
      chatStarted={chatStarted}
      isStreaming={isLoading}
      sendMessage={sendMessage}
      messageRef={messageRef}
      scrollRef={scrollRef}
      handleInputChange={handleInputChange}
      handleStop={abort}
      minTextareaHeight={131}
      messages={messages}
      currentPhase={currentPhase}
      reasoningText={reasoningText}
      thinkingDuration={thinkingDuration}
      fileOperations={fileOperations}
      tokenUsage={tokenUsage}
    />
  );
});
</file>

<file path="packages/runtime/src/agent.ts">
/**
 * Agent Orchestrator with Stage 1-5 workflow
 * Portion 1: Implements Stages 1-2 (Analyze, Plan)
 */

import { ModelClient } from './model-client.js';
import { ToolRunner } from './tool-runner.js';
import { TranscriptRecorder } from './transcript.js';
import { VerifierRunner } from './verifier.js';
import { getAllToolDefinitions } from '@eitherway/tools-core';
import { MAX_AGENT_TURNS, REASONING_STREAM_CHUNK_SIZE, REASONING_STREAM_DELAY_MS } from './constants.js';
import type { Message, ToolUse, ToolResult, ClaudeConfig, AgentConfig, ToolExecutor } from '@eitherway/tools-core';

/**
 * Phase types for streaming UI
 */
export type StreamingPhase = 'thinking' | 'reasoning' | 'code-writing' | 'building' | 'completed';

/**
 * Streaming callbacks for real-time updates
 */
export interface StreamingCallbacks {
  onDelta?: (delta: { type: string; content: string }) => void;
  onReasoning?: (delta: { text: string }) => void; // Separate callback for reasoning text
  onPhase?: (phase: StreamingPhase) => void;
  onThinkingComplete?: (duration: number) => void; // Duration in seconds
  onFileOperation?: (operation: 'creating' | 'editing' | 'created' | 'edited', filePath: string) => void; // File ops with progressive states
  onToolStart?: (tool: { name: string; toolUseId: string; filePath?: string }) => void;
  onToolEnd?: (tool: { name: string; toolUseId: string; filePath?: string }) => void;
  onComplete?: (usage: { inputTokens: number; outputTokens: number }) => void;
}

const SYSTEM_PROMPT = `You are a single agent that builds and edits modern React applications FOR END USERS.
Use ONLY the tools listed below. Prefer either-line-replace for small, targeted edits.

TECHNOLOGY STACK (MANDATORY):
  - **React 18+** with functional components and hooks
  - **Vite** as the build tool and dev server
  - **Tailwind CSS** for styling (NO custom CSS files unless absolutely necessary)
  - **JSX/TSX** for component syntax
  - All apps MUST use this stack - NO vanilla HTML/CSS/JS

COMPLETENESS REQUIREMENT (HIGHEST PRIORITY):
  - EVERY app you create must be 100% COMPLETE and FUNCTIONAL from the start
  - If a component imports another component  YOU MUST CREATE that component in the SAME turn
  - If you mention a feature  YOU MUST IMPLEMENT that feature completely with all necessary components
  - NEVER stop until ALL imported components exist and ALL functionality works
  - Check: Does the user's request require state management? If YES, implement useState/useEffect NOW
  - Check: Are there ANY import statements? If YES, create those files NOW
  - Check: Will interactive features work? If NO, add the necessary event handlers and state NOW
  - DO NOT create partial apps - users expect working applications, not templates
  - ALL components must be fully styled with Tailwind CSS classes

CRITICAL BUILD RULES:
  - You are building apps for END USERS, not developers
  - NEVER create README.md, QUICKSTART.md, or ANY .md/.txt documentation files
  - NO separate documentation files of any kind (guides, summaries, tech docs, etc.)
  - All help, instructions, and guidance must be built INTO the app's UI
  - Create only executable code files that make up the actual application
  - Focus on user experience, not developer experience

REACT COMPONENT ARCHITECTURE (CRITICAL):
  - ALWAYS use functional components with hooks
  - Component structure: import statements  component definition  export
  - Use proper React hooks: useState for state, useEffect for side effects
  - Props should be destructured in component parameters
  - Event handlers: use arrow functions or useCallback for performance
  - Conditional rendering: use ternary operators or && for inline conditionals
  - Lists: always map with unique keys (use index only as last resort)

  Component Template:
  import { useState, useEffect } from 'react';

  export default function ComponentName({ propName }) {
    const [state, setState] = useState(initialValue);

    useEffect(() => {
      // Side effects here
    }, [dependencies]);

    const handleEvent = () => {
      // Event logic
    };

    return (
      <div className="tailwind classes">
        {/* JSX content */}
      </div>
    );
  }

TAILWIND CSS STYLING (CRITICAL):
  - NEVER write custom CSS - use Tailwind utility classes exclusively
  - Use responsive prefixes: sm:, md:, lg:, xl:, 2xl: for responsive design
  - Use hover:, focus:, active: for interactive states
  - Common patterns:
    * Flexbox: flex items-center justify-between gap-4
    * Grid: grid grid-cols-3 gap-4
    * Spacing: p-4 (padding), m-4 (margin), space-x-4 (horizontal gap)
    * Colors: bg-blue-500, text-white, border-gray-300
    * Rounded: rounded-lg (borders), rounded-full (circles)
    * Shadows: shadow-md, shadow-lg
    * Transitions: transition-all duration-300 ease-in-out
  - For complex styles, combine utilities: "flex items-center justify-center min-h-screen bg-gradient-to-br from-blue-500 to-purple-600"
  - Use dark: prefix for dark mode support when appropriate

  AVOID THESE ANTI-PATTERNS:
   NEVER create separate .css files
   NEVER use inline styles (style={{...}}) - use Tailwind classes instead
   NEVER write custom CSS rules
   ALWAYS use Tailwind utility classes

FILE STRUCTURE (MANDATORY):
  - index.html: Vite entry point with root div
  - src/main.jsx: React entry point that renders App
  - src/App.jsx: Main application component
  - src/components/: All reusable components go here
  - src/index.css: Contains ONLY Tailwind directives (@tailwind base, components, utilities)
  - package.json: Dependencies and scripts
  - vite.config.js: Vite configuration
  - tailwind.config.js: Tailwind configuration
  - postcss.config.js: PostCSS configuration for Tailwind

YOUTUBE EMBED REQUIREMENTS (CRITICAL):
  - ALWAYS use /embed/VIDEO_ID URL, NEVER /watch?v=VIDEO_ID
  - Use youtube-nocookie.com for privacy (not youtube.com)
  - MUST include ALL these attributes or video will fail in WebContainer:

  Correct YouTube embed template:
  <iframe
    width="560"
    height="315"
    src="https://www.youtube-nocookie.com/embed/VIDEO_ID"
    title="YouTube video player"
    frameborder="0"
    credentialless
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen
  ></iframe>

  Replace VIDEO_ID with actual video ID (from youtube.com/watch?v=VIDEO_ID)
  The credentialless attribute is REQUIRED for WebContainer COEP policy
  The allow attribute is REQUIRED - without these the video will be blocked

SVG USAGE IN WEBCONTAINER (CRITICAL):
  - WebContainer uses COEP credentialless which can block improperly formatted SVGs
  - ALWAYS prefer inline SVG over data URIs for reliability
  - Data URIs (data:image/svg+xml,...) may be blocked by CSP or COEP policies
  - Use one of these reliable approaches:

  Option 1 - Inline SVG (PREFERRED):
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="..."/>
  </svg>

  Option 2 - External SVG file:
  Create icon.svg as a separate file, then reference it:
  <img src="icon.svg" alt="Icon">

  AVOID these patterns in WebContainer:
   <img src="data:image/svg+xml,..."> (may be blocked by COEP/CSP)
   background: url('data:image/svg+xml,...') (may be blocked)
   <use xlink:href="data:..."> (explicitly blocked since Dec 2023)

  Always include xmlns="http://www.w3.org/2000/svg" in SVG elements
  For icon libraries, create individual .svg files rather than data URI sprites

ICONS AND VISUAL ELEMENTS (CRITICAL):
  - NEVER use emojis (     etc.) in user-facing applications
  - NEVER use Unicode symbols (, , , , , etc.) as icons - they're too simple
  - Emojis and Unicode symbols appear unprofessional and inconsistent
  - ALWAYS use proper SVG icons instead

  How to create SVG icons:

  1. Inline SVG icons (BEST - most reliable for WebContainer):
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5z"/>
  </svg>

  2. Find SVG icons online using web_search:
  Use web_search to find "free SVG icons [icon name]" or "open source SVG icons"
  Popular sources: Heroicons, Feather Icons, Material Icons, Bootstrap Icons
  Copy the SVG code and paste it inline or create a separate .svg file

  3. External SVG files (for reusable icons):
  Create separate .svg files for icons and reference them:
  <img src="icons/rocket.svg" alt="Rocket icon" width="24" height="24">

  Example: For a cryptocurrency app needing a rocket icon
  - Use web_search: "free SVG rocket icon"
  - Find a clean, professional SVG from Heroicons or similar
  - Copy the SVG <path> data and create inline SVG or .svg file
  - NEVER substitute with emoji  or Unicode 

  Examples of what NOT to do:
   <span></span> (emoji)
   <span></span> (Unicode symbol)
   <span></span> (Unicode symbol)
   <svg>...rocket path...</svg> (proper SVG icon)

  The only exception: emojis in user-generated content or chat messages
  Always use professional SVG icons for all UI elements

READ-BEFORE-WRITE DISCIPLINE (CRITICAL):
  - When EDITING existing files: ALWAYS use either-view BEFORE either-line-replace
  - When CREATING new files: NO need to check if file exists - just use either-write
  - either-write will fail if file exists (safe), so don't pre-check with either-view
  - Use the needle parameter in either-line-replace to ensure you're editing the right lines
  - Performance: Avoid unnecessary reads - only read files you're about to modify

For execution:
  Stage 1: Analyze request (intent, scope, constraints).
  Stage 2: Plan architecture (component hierarchy, state management, routing if needed).
           CRITICAL: List ALL files needed (components, config files, etc.) - create them ALL in one turn.
  Stage 3: Select tools (name each planned call, READ first for edits).
           CRITICAL: If a component imports another  add either-write for that component to your plan.
  Stage 4: Execute in parallel (emit multiple tool_use blocks that do not conflict).
           CRITICAL: Create ALL files in this single turn - don't leave any for later.
  Stage 5: Verify & Respond (self-check: did I create ALL imported components? Are all features working?)
           CRITICAL: Before responding, confirm every import statement resolves to an existing file.

Determinism:
  - Default temperature low (0.2); fix seeds where supported.
  - Use the smallest change that works; avoid rewrites.
  - Always prefer either-line-replace over either-write for existing files.

Safety:
  - File operations restricted to allowed workspaces and globs.
  - Web search is server-side with automatic rate limiting and citations.
  - All tool calls are logged with metrics (latency, sizes, file counts).

External API & CORS Handling:
  - WebContainer environment automatically proxies ALL external API requests
  - NO need to worry about CORS - the proxy handles it transparently
  - Simply use standard fetch() calls to any external API
  - The runtime automatically intercepts and routes through /api/proxy-api endpoint
  - CDN resources (images, fonts, scripts) are proxied through /api/proxy-cdn
  - This system works seamlessly - write code as if CORS doesn't exist
  - Example: fetch('https://api.example.com/data') just works, no configuration needed

API Best Practices:
  - Choose reliable, well-documented public APIs for your use case
  - Always implement client-side caching (30-60 seconds minimum) to respect rate limits
  - Handle API errors gracefully with try/catch and user-friendly error messages
  - Display loading states while fetching data
  - Consider fallback data or cached responses when APIs are unavailable
  - For crypto data: CoinGecko, CoinCap, or similar reputable sources
  - For weather: OpenWeather, WeatherAPI, or government APIs
  - For images: Use CDNs that allow hotlinking and work with our proxy
  - Avoid services that block external embedding or require authentication

Output contract:
  - When executing, emit parallel tool_use blocks grouped by task.
  - After tools, review diffs and summarize what changed and why.

Tools available:
  - either-view: Read files (returns sha256, line_count, encoding)
  - either-search-files: Search code (supports regex, context lines)
  - either-line-replace: Edit lines (returns unified diff, verifies with sha256)
  - either-write: Create files (returns diff summary)
  - web_search: Search the web for up-to-date information (server-side, automatic citations)
  - eithergen--generate_image: Generate images (OpenAI/custom provider, saves to disk)`;

export interface AgentOptions {
  workingDir: string;
  claudeConfig: ClaudeConfig;
  agentConfig: AgentConfig;
  executors: ToolExecutor[];
  dryRun?: boolean;
  webSearch?: {
    enabled: boolean;
    maxUses?: number;
    allowedDomains?: string[];
    blockedDomains?: string[];
  };
}

export class Agent {
  private modelClient: ModelClient;
  private toolRunner: ToolRunner;
  private recorder: TranscriptRecorder;
  private conversationHistory: Message[];
  private options: AgentOptions;

  // --- READ-before-WRITE enforcement constants ---
  private static readonly WRITE_TOOLS = new Set(['either-line-replace', 'either-write']);
  private static readonly READ_TOOL = 'either-view';

  constructor(options: AgentOptions) {
    this.options = options;
    this.modelClient = new ModelClient(options.claudeConfig);
    this.toolRunner = new ToolRunner(options.executors, options.workingDir, options.agentConfig);
    this.recorder = new TranscriptRecorder(options.agentConfig);
    this.conversationHistory = [];
  }

  /**
   * Load conversation history (for restoring state)
   */
  loadConversationHistory(messages: Message[]): void {
    this.conversationHistory = messages;
  }

  /**
   * Process a user request through the agent workflow
   * @param userMessage - The user's prompt
   * @param callbacks - Optional streaming callbacks for real-time updates
   */
  async processRequest(userMessage: string, callbacks?: StreamingCallbacks): Promise<string> {
    // Start transcript
    const transcriptId = this.recorder.startTranscript(userMessage);

    // Add user message to history (content must be array for Claude API)
    this.conversationHistory.push({
      role: 'user',
      content: [{ type: 'text', text: userMessage }],
    });

    this.recorder.addEntry({
      timestamp: new Date().toISOString(),
      role: 'user',
      content: userMessage,
    });

    let finalResponse = '';
    let turnCount = 0;
    const changedFiles = new Set<string>();
    let hasExecutedTools = false;

    // Track cumulative token usage across all turns
    let totalInputTokens = 0;
    let totalOutputTokens = 0;

    let justExecutedTools = false; // Track if we executed tools in previous iteration

    // Buffering for thinking  reasoning transition
    let thinkingBuffer = '';
    let thinkingStartTime: number | null = null;
    let isInThinkingPhase = false;

    // Buffering for final summary (after tools)
    let summaryBuffer = '';
    let isInSummaryPhase = false;

    // Track file operations across ALL turns (not just per-turn)
    const fileOpsThisRequest = new Map<string, 'create' | 'edit'>();
    const filesCreatedThisRequest = new Set<string>();

    while (turnCount < MAX_AGENT_TURNS) {
      turnCount++;

      // Validate conversation history before sending to Claude
      this.validateConversationHistory();

      // Track if we should skip thinking phase (for subsequent turns after tools)
      let hasEmittedThinking = false;
      if (justExecutedTools) {
        // Skip thinking phase for summary turn (no need to show "Thinking..." again)
        hasEmittedThinking = true;
        isInSummaryPhase = true; // Buffer summary text for smooth streaming
        summaryBuffer = '';
        justExecutedTools = false;
      }

      // Send message to Claude
      const response = await this.modelClient.sendMessage(
        this.conversationHistory,
        SYSTEM_PROMPT,
        getAllToolDefinitions(),
        {
          onDelta: async (delta) => {
            if (delta.type === 'text') {
              // Start thinking phase on first text delta
              if (!hasEmittedThinking && callbacks?.onPhase) {
                callbacks.onPhase('thinking');
                thinkingStartTime = Date.now();
                isInThinkingPhase = true;
                hasEmittedThinking = true;
              }

              // Buffer text during thinking phase (don't emit yet)
              if (isInThinkingPhase) {
                thinkingBuffer += delta.content;
              } else if (isInSummaryPhase) {
                // Buffer summary text for smooth streaming
                summaryBuffer += delta.content;
              } else {
                // Normal streaming (shouldn't happen in our workflow)
                if (callbacks?.onDelta) {
                  callbacks.onDelta(delta);
                } else {
                  process.stdout.write(delta.content);
                }
              }
            }
          },
          webSearchConfig: this.options.webSearch,
        },
      );

      // Accumulate token usage
      totalInputTokens += response.usage.inputTokens;
      totalOutputTokens += response.usage.outputTokens;

      // Record assistant response
      this.recorder.addEntry({
        timestamp: new Date().toISOString(),
        role: 'assistant',
        content: response.content,
        metadata: {
          model: this.options.claudeConfig.model,
          tokenUsage: {
            input: response.usage.inputTokens,
            output: response.usage.outputTokens,
          },
          stopReason: response.stopReason || undefined,
        },
      });

      // Extract text for final summary
      const textBlocks = response.content
        .filter((c: any) => c.type === 'text')
        .map((c: any) => c.text)
        .join('\n');

      // --- Enforce READ-before-WRITE by injecting either-view blocks if missing ---
      const { contentBlocks: enforcedAssistantBlocks, toolUses } = this.injectReadBeforeWriteBlocks(response.content);

      // --- Handle thinking  reasoning transition ---
      if (isInThinkingPhase && thinkingBuffer && toolUses.length > 0) {
        // Thinking phase complete, we have tools to execute
        isInThinkingPhase = false;

        // Calculate thinking duration
        const thinkingDuration = thinkingStartTime ? Math.round((Date.now() - thinkingStartTime) / 1000) : 0;

        // Emit thinking complete with duration
        if (callbacks?.onThinkingComplete) {
          callbacks.onThinkingComplete(thinkingDuration);
        }

        // Small delay to let user read the "Thought for X seconds" message
        await new Promise((resolve) => setTimeout(resolve, 800));

        // Emit reasoning phase
        if (callbacks?.onPhase) {
          callbacks.onPhase('reasoning');
        }

        // Stream buffered text smoothly (chunk by chunk for animation)
        if (callbacks?.onReasoning) {
          for (let i = 0; i < thinkingBuffer.length; i += REASONING_STREAM_CHUNK_SIZE) {
            const chunk = thinkingBuffer.slice(i, i + REASONING_STREAM_CHUNK_SIZE);
            callbacks.onReasoning({ text: chunk });
            await new Promise((resolve) => setTimeout(resolve, REASONING_STREAM_DELAY_MS));
          }
        }

        // Clear buffer
        thinkingBuffer = '';
      } else if (isInThinkingPhase && thinkingBuffer && toolUses.length === 0) {
        // No tools, treat buffered text as final response (edge case)
        isInThinkingPhase = false;
        if (callbacks?.onDelta) {
          callbacks.onDelta({ type: 'text', content: thinkingBuffer });
        }
        thinkingBuffer = '';
      }

      // Only add assistant message if it has content (Anthropic API requirement)
      if (enforcedAssistantBlocks.length > 0) {
        this.conversationHistory.push({
          role: 'assistant',
          content: enforcedAssistantBlocks as any,
        });
      } else {
        // Edge case: empty response - add placeholder to maintain conversation flow
        console.warn('[Agent] Warning: Assistant response had no content blocks, adding placeholder');
        this.conversationHistory.push({
          role: 'assistant',
          content: [{ type: 'text', text: '...' }],
        });
      }

      // If no tool uses (client-side tools), we're done - run verification if we executed tools
      // Server-side tools (web search) are already executed and don't need processing
      if (toolUses.length === 0) {
        finalResponse = textBlocks;

        // If we were in summary phase, stream the buffered summary smoothly
        if (isInSummaryPhase && summaryBuffer) {
          // Emit 'building' phase
          if (callbacks?.onPhase) {
            callbacks.onPhase('building');
          }

          // Stream buffered summary smoothly using reasoning callback
          if (callbacks?.onReasoning) {
            for (let i = 0; i < summaryBuffer.length; i += REASONING_STREAM_CHUNK_SIZE) {
              const chunk = summaryBuffer.slice(i, i + REASONING_STREAM_CHUNK_SIZE);
              callbacks.onReasoning({ text: chunk });
              await new Promise((resolve) => setTimeout(resolve, REASONING_STREAM_DELAY_MS));
            }
          }

          // Clear summary phase
          isInSummaryPhase = false;
          summaryBuffer = '';
        }

        // Run verification if tools were executed this session
        if (hasExecutedTools && !this.options.dryRun) {
          const verificationSummary = await this.runVerification(changedFiles);
          finalResponse += verificationSummary;
        }

        break;
      }

      // Emit 'code-writing' phase when we have tools to execute
      if (toolUses.length > 0 && callbacks?.onPhase) {
        // Add delay before showing "Writing code..." for natural pacing
        await new Promise((resolve) => setTimeout(resolve, 600));
        callbacks.onPhase('code-writing');
      }

      // Mark that we're executing tools so next iteration can emit 'completed'
      if (toolUses.length > 0) {
        justExecutedTools = true;
        hasExecutedTools = true;
      }

      // Execute tools (dry run if specified)
      let toolResults: ToolResult[];
      if (this.options.dryRun) {
        toolResults = toolUses.map((tu: ToolUse) => ({
          type: 'tool_result' as const,
          tool_use_id: tu.id,
          content: `[DRY RUN] Would execute: ${tu.name} with input: ${JSON.stringify(tu.input, null, 2)}`,
        }));
      } else {
        // Track new file operations this turn (for emitting)
        const newFileOpsThisTurn = new Map<string, 'create' | 'edit'>();

        // Emit tool start events and execute tools
        toolResults = [];
        for (const toolUse of toolUses) {
          // Extract file path for file operation tools
          const filePath = (toolUse.input as any)?.path;

          // Track file operations (deduplicate and determine correct operation type)
          if (filePath && (toolUse.name === 'either-write' || toolUse.name === 'either-line-replace')) {
            // Determine operation: 'create' if new file, 'edit' if already exists
            let operation: 'create' | 'edit';
            if (filesCreatedThisRequest.has(filePath)) {
              // File was created earlier in this request, so this is an edit
              operation = 'edit';
            } else if (toolUse.name === 'either-write') {
              // either-write creates a new file
              operation = 'create';
              filesCreatedThisRequest.add(filePath);
            } else {
              // either-line-replace edits existing file
              operation = 'edit';
            }

            // Only track if not already emitted in this request
            if (!fileOpsThisRequest.has(filePath)) {
              fileOpsThisRequest.set(filePath, operation);
              newFileOpsThisTurn.set(filePath, operation);

              // Emit "Creating..." or "Editing..." message before execution
              if (callbacks?.onFileOperation) {
                await new Promise((resolve) => setTimeout(resolve, 200)); // Delay between file operations
                const progressiveState: 'creating' | 'editing' = operation === 'create' ? 'creating' : 'editing';
                callbacks.onFileOperation(progressiveState, filePath);
              }
            }
          }

          // Emit tool start (hidden for file operations, shown for others)
          if (callbacks?.onToolStart && !filePath) {
            callbacks.onToolStart({
              name: toolUse.name,
              toolUseId: toolUse.id,
              filePath,
            });
          }

          // Execute single tool
          const result = await this.toolRunner.executeTools([toolUse]);
          toolResults.push(...result);

          // Emit "Created" or "Edited" message after execution (only for new operations)
          if (filePath && newFileOpsThisTurn.has(filePath)) {
            if (callbacks?.onFileOperation) {
              await new Promise((resolve) => setTimeout(resolve, 300)); // Delay before completion message
              const operation = newFileOpsThisTurn.get(filePath);
              const completedState: 'created' | 'edited' = operation === 'create' ? 'created' : 'edited';
              callbacks.onFileOperation(completedState, filePath);
            }
          }

          // Emit tool end (hidden for file operations, shown for others)
          if (callbacks?.onToolEnd && !filePath) {
            callbacks.onToolEnd({
              name: toolUse.name,
              toolUseId: toolUse.id,
              filePath,
            });
          }
        }

        hasExecutedTools = true;

        // Track changed files and collect created file paths
        const createdFilesThisTurn = new Set<string>();
        for (const result of toolResults) {
          const metadata = (result as any).metadata;
          if (metadata?.path && !result.is_error) {
            changedFiles.add(metadata.path);
            createdFilesThisTurn.add(metadata.path);
          }
        }

        // Check for missing file references in newly created HTML files
        const missingRefs = await this.checkMissingFileReferences(toolUses, createdFilesThisTurn, toolResults);
        if (missingRefs.length > 0) {
          // Add warning to the last tool result to inform the agent
          const warningMessage = `\n\n WARNING: Missing file references detected:\n${missingRefs.map((ref) => `  - ${ref.htmlFile} references <${ref.tag} ${ref.attr}="${ref.file}"> but ${ref.file} was not created`).join('\n')}\n\nYou MUST create these files in your next response to make the app functional.`;

          // Append warning to the last tool result
          if (toolResults.length > 0) {
            const lastResult = toolResults[toolResults.length - 1];
            lastResult.content = (lastResult.content || '') + warningMessage;
            console.warn('[Agent]' + warningMessage);
          }
        }
      }

      // Record tool results
      this.recorder.addEntry({
        timestamp: new Date().toISOString(),
        role: 'user',
        content: toolResults,
      });

      // Add tool results to conversation
      this.conversationHistory.push({
        role: 'user',
        content: toolResults,
      });

      // If stop reason was end_turn, continue conversation
      if (response.stopReason === 'end_turn') {
        continue;
      }
    }

    // End transcript
    this.recorder.endTranscript(transcriptId, finalResponse);

    // Emit completed phase (only at the very end, after all turns)
    if (callbacks?.onPhase) {
      callbacks.onPhase('completed');
    }

    // Emit completion with token usage
    if (callbacks?.onComplete) {
      callbacks.onComplete({
        inputTokens: totalInputTokens,
        outputTokens: totalOutputTokens,
      });
    }

    return finalResponse;
  }

  /**
   * Get conversation history
   */
  getHistory(): Message[] {
    return [...this.conversationHistory];
  }

  /**
   * Reset conversation
   */
  reset(): void {
    this.conversationHistory = [];
    this.toolRunner.clearCache();
  }

  /**
   * Save transcript to disk
   */
  async saveTranscript(): Promise<void> {
    await this.recorder.saveCurrentTranscript();
  }

  /**
   * Set database context for file operations
   */
  setDatabaseContext(fileStore: any, appId: string, sessionId?: string): void {
    this.toolRunner.setDatabaseContext(fileStore, appId, sessionId);
  }

  /**
   * Run verification and create summary
   */
  private async runVerification(changedFiles: Set<string>): Promise<string> {
    const verifier = new VerifierRunner(this.options.workingDir);

    // Create change summary
    const changeSummary = this.createChangeSummary(changedFiles);

    // Run verification
    const verifyResult = await verifier.run();
    const verifySummary = VerifierRunner.formatSummary(verifyResult);

    // Get metrics summary
    const metrics = this.toolRunner.getMetrics();
    const metricsSummary = metrics.getSummaryString();

    return `\n\n---\n${changeSummary}${verifySummary}\n\n**Metrics:**\n${metricsSummary}`;
  }

  /**
   * Create a summary of changed files
   */
  private createChangeSummary(changedFiles: Set<string>): string {
    if (changedFiles.size === 0) {
      return '';
    }

    const files = Array.from(changedFiles).sort();
    const summary =
      files.length === 1
        ? `**Changed:** ${files[0]}\n`
        : `**Changed (${files.length} files):**\n${files.map((f) => `  - ${f}`).join('\n')}\n`;

    return summary;
  }

  /**
   * Validate conversation history format and content
   * Prevents API errors by ensuring all messages follow Claude API requirements
   */
  private validateConversationHistory(): void {
    this.conversationHistory.forEach((msg, idx) => {
      // Validate that content is always an array (Claude API requirement)
      if (!Array.isArray(msg.content)) {
        console.error(`\n CONVERSATION HISTORY VALIDATION ERROR:`);
        console.error(`   Message [${idx}] (role: ${msg.role}) has non-array content`);
        console.error(`   Content type: ${typeof msg.content}`);
        console.error(`   Content value:`, msg.content);
        console.error(`\n   Claude API requires content to be an array of content blocks.`);
        console.error('');

        throw new Error(
          `Conversation history validation failed: ` +
            `Message ${idx} has invalid content format (expected array, got ${typeof msg.content}). ` +
            `This will cause Claude API to reject the request with "Input should be a valid list" error.`,
        );
      }

      // Validate that content array is not empty (except for optional final assistant message)
      if (msg.content.length === 0) {
        const isFinalAssistant = idx === this.conversationHistory.length - 1 && msg.role === 'assistant';
        if (!isFinalAssistant) {
          console.error(`\n CONVERSATION HISTORY VALIDATION ERROR:`);
          console.error(`   Message [${idx}] (role: ${msg.role}) has empty content array`);
          console.error(`\n   Claude API requires all messages to have non-empty content,`);
          console.error(`   except for the optional final assistant message.`);
          console.error('');

          throw new Error(
            `Conversation history validation failed: ` +
              `Message ${idx} has empty content array. ` +
              `This will cause Claude API to reject the request with "all messages must have non-empty content" error.`,
          );
        }
      }

      // Validate server_tool_use blocks are properly paired with web_search_tool_result
      if (msg.role === 'assistant' && Array.isArray(msg.content)) {
        const serverToolUses = msg.content.filter((b: any) => b.type === 'server_tool_use');
        const webSearchResults = msg.content.filter((b: any) => b.type === 'web_search_tool_result');

        if (serverToolUses.length > 0) {
          console.log(`\n[DEBUG] Message [${idx}] validation:`);
          console.log(`  server_tool_uses: ${serverToolUses.length}`);
          console.log(`  web_search_tool_results: ${webSearchResults.length}`);
          console.log(`  All blocks in message:`);
          msg.content.forEach((block: any, blockIdx: number) => {
            console.log(
              `    [${blockIdx}] ${block.type}${block.id ? ` (id: ${block.id})` : ''}${block.tool_use_id ? ` (tool_use_id: ${block.tool_use_id})` : ''}`,
            );
          });

          // Verify each server_tool_use has a corresponding web_search_tool_result
          serverToolUses.forEach((stu: any) => {
            const hasMatchingResult = webSearchResults.some((wsr: any) => wsr.tool_use_id === stu.id);

            if (!hasMatchingResult) {
              console.error(
                `\n  WARNING: Message [${idx}] has server_tool_use (${stu.id}) without web_search_tool_result`,
              );
              console.error(`   This might cause issues, but continuing anyway for debugging...`);
              console.error('');

              // Temporarily disable throwing - just log the warning
              // throw new Error(
              //   `Conversation history validation failed: ` +
              //   `Message ${idx} has server_tool_use "${stu.name}" (${stu.id}) ` +
              //   `without corresponding web_search_tool_result. ` +
              //   `This indicates a bug in the streaming or content block handling.`
              // );
            }
          });
        }
      }
    });
  }

  /**
   * Injects `either-view` reads before any write/edit tool calls that lack a
   * preceding read for the same `path` within the same assistant turn.
   * Also returns the final list of tool_uses to execute (in order).
   */
  private injectReadBeforeWriteBlocks(contentBlocks: any[]): { contentBlocks: any[]; toolUses: ToolUse[] } {
    const out: any[] = [];
    const toolUsesCollected: ToolUse[] = [];
    const seenReadForPath = new Set<string>();

    const pushAndCollect = (blk: any) => {
      out.push(blk);
      if (blk && blk.type === 'tool_use') {
        toolUsesCollected.push({
          type: 'tool_use',
          id: blk.id,
          name: blk.name,
          input: blk.input,
        });
      }
    };

    for (const blk of contentBlocks) {
      // Track explicit reads
      if (blk?.type === 'tool_use' && blk.name === Agent.READ_TOOL) {
        const path = blk.input?.path;
        if (typeof path === 'string' && path.length > 0) {
          seenReadForPath.add(path);
        }
        pushAndCollect(blk);
        continue;
      }

      // Before either-line-replace (EDIT), ensure we've read the target file
      // NO injection for either-write (CREATE) - it handles file existence checks internally
      if (blk?.type === 'tool_use' && blk.name === 'either-line-replace') {
        const path = blk.input?.path;

        if (typeof path === 'string' && path.length > 0 && !seenReadForPath.has(path)) {
          // Inject a synthetic read tool_use directly before the edit
          const injectedId = `enforcer-view-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
          const injected = {
            type: 'tool_use',
            id: injectedId,
            name: Agent.READ_TOOL,
            input: { path },
          };
          pushAndCollect(injected);
          seenReadForPath.add(path);
        }

        // Optionally annotate missing needle (soft warning)
        if (!blk.input?.needle) {
          blk.input = {
            ...blk.input,
            _enforcerWarning: 'No `needle` provided; injected a read to reduce risk.',
          };
        }

        pushAndCollect(blk);
        continue;
      }

      // For eithergen--generate_image or other WRITE tools, no read injection needed
      if (blk?.type === 'tool_use' && Agent.WRITE_TOOLS.has(blk.name)) {
        pushAndCollect(blk);
        continue;
      }

      // passthrough others
      pushAndCollect(blk);
    }

    // Only return *tool_use* blocks as executable tool uses, in order
    const executableToolUses = toolUsesCollected.filter((b: any) => b.type === 'tool_use') as ToolUse[];
    return { contentBlocks: out, toolUses: executableToolUses };
  }

  /**
   * Check for missing file references in newly created files
   * Detects:
   * - HTML: <script src="..."> and <link href="..."> that reference non-existent files
   * - React: import statements that reference non-existent components
   */
  private async checkMissingFileReferences(
    toolUses: ToolUse[],
    createdFiles: Set<string>,
    toolResults: ToolResult[],
  ): Promise<Array<{ htmlFile: string; tag: string; attr: string; file: string }>> {
    const missing: Array<{ htmlFile: string; tag: string; attr: string; file: string }> = [];

    // Check HTML files for script/link references
    const htmlWrites = toolUses.filter(
      (tu) =>
        (tu.name === 'either-write' || tu.name === 'either-line-replace') &&
        tu.input?.path?.toLowerCase().endsWith('.html'),
    );

    for (const htmlWrite of htmlWrites) {
      const htmlPath = htmlWrite.input?.path;
      if (!htmlPath) continue;

      const resultIdx = toolUses.indexOf(htmlWrite);
      const result = toolResults[resultIdx];
      if (!result || result.is_error) continue;

      const htmlContent = htmlWrite.name === 'either-write' ? htmlWrite.input?.content : null;

      if (!htmlContent || typeof htmlContent !== 'string') continue;

      // Extract script and link references using simple regex
      const scriptMatches = htmlContent.matchAll(/<script[^>]+src=["']([^"']+)["']/gi);
      for (const match of scriptMatches) {
        const scriptPath = match[1];
        const normalizedPath = scriptPath.replace(/^\.?\//, '');
        if (!createdFiles.has(normalizedPath) && !createdFiles.has(scriptPath)) {
          missing.push({
            htmlFile: htmlPath,
            tag: 'script',
            attr: 'src',
            file: scriptPath,
          });
        }
      }

      const linkMatches = htmlContent.matchAll(/<link[^>]+href=["']([^"']+)["'][^>]*>/gi);
      for (const match of linkMatches) {
        const fullTag = match[0];
        if (fullTag.includes('stylesheet')) {
          const linkPath = match[1];
          const normalizedPath = linkPath.replace(/^\.?\//, '');
          if (!createdFiles.has(normalizedPath) && !createdFiles.has(linkPath)) {
            missing.push({
              htmlFile: htmlPath,
              tag: 'link',
              attr: 'href',
              file: linkPath,
            });
          }
        }
      }
    }

    // Check React/JSX/TSX files for import statements
    const reactWrites = toolUses.filter(
      (tu) =>
        (tu.name === 'either-write' || tu.name === 'either-line-replace') &&
        (tu.input?.path?.endsWith('.jsx') ||
          tu.input?.path?.endsWith('.tsx') ||
          tu.input?.path?.endsWith('.js') ||
          tu.input?.path?.endsWith('.ts')),
    );

    for (const reactWrite of reactWrites) {
      const filePath = reactWrite.input?.path;
      if (!filePath) continue;

      const resultIdx = toolUses.indexOf(reactWrite);
      const result = toolResults[resultIdx];
      if (!result || result.is_error) continue;

      const content = reactWrite.name === 'either-write' ? reactWrite.input?.content : null;

      if (!content || typeof content !== 'string') continue;

      // Extract import statements: import ... from './path'
      const importMatches = content.matchAll(
        /import\s+(?:(?:\{[^}]+\}|[\w]+)(?:\s*,\s*(?:\{[^}]+\}|[\w]+))*)\s+from\s+['"]([^'"]+)['"]/g,
      );

      for (const match of importMatches) {
        const importPath = match[1];

        // Skip node_modules and external packages (e.g., 'react', '@vitejs/plugin-react')
        if (!importPath.startsWith('.')) continue;

        // Normalize path (remove leading ./)
        let normalizedPath = importPath.replace(/^\.\//, '');

        // Check multiple possible file paths (with/without extensions, index files)
        const possiblePaths = [
          normalizedPath,
          `${normalizedPath}.jsx`,
          `${normalizedPath}.tsx`,
          `${normalizedPath}.js`,
          `${normalizedPath}.ts`,
          `${normalizedPath}/index.jsx`,
          `${normalizedPath}/index.tsx`,
          `${normalizedPath}/index.js`,
          `${normalizedPath}/index.ts`,
        ];

        // Also check paths relative to src/ directory
        const srcPaths = possiblePaths.map((p) => `src/${p}`);

        // Check if any of the possible paths exist in createdFiles
        const exists = [...possiblePaths, ...srcPaths].some(
          (p) => createdFiles.has(p) || createdFiles.has(`./${p}`) || createdFiles.has(`/${p}`),
        );

        if (!exists) {
          missing.push({
            htmlFile: filePath,
            tag: 'import',
            attr: 'from',
            file: importPath,
          });
        }
      }
    }

    return missing;
  }
}
</file>

<file path="packages/ui-server/src/server.ts">
#!/usr/bin/env node
/**
 * Backend server for EitherWay UI
 * Provides HTTP API and WebSocket for real-time agent interaction
 */

import Fastify from 'fastify';
import cors from '@fastify/cors';
import websocket from '@fastify/websocket';
import multipart from '@fastify/multipart';
import { Agent, DatabaseAgent, ConfigLoader, StreamingCallbacks } from '@eitherway/runtime';
import { getAllExecutors } from '@eitherway/tools-impl';
import { createDatabaseClient, FilesRepository, SessionsRepository, PostgresFileStore } from '@eitherway/database';
import { readdir, readFile, stat, writeFile, rm, mkdir, access } from 'fs/promises';
import { join, dirname, resolve, relative } from 'path';
import { fileURLToPath } from 'url';
import { maybeRewriteFile } from './cdn-rewriter.js';
import { registerSessionRoutes } from './routes/sessions.js';
import { registerSessionFileRoutes } from './routes/session-files.js';
import { registerImageRoutes } from './routes/images.js';
import { registerNetlifyRoutes } from './routes/netlify.js';
import { registerDeploymentRoutes } from './routes/deployments.js';
import { registerAppRoutes } from './routes/apps.js';
import { registerBrandKitRoutes } from './routes/brand-kits.js';
import { constants } from 'fs';
import { randomUUID } from 'crypto';
import { StreamEvents, createEventSender } from './events/index.js';
import { API_CACHE_TTL_MS, CDN_CACHE_MAX_AGE_SECONDS, DEFAULT_SERVER_PORT } from './constants.js';
import { isSecureUrl } from './security/ssrf-guard.js';

// Resolve project root (go up from packages/ui-server/src to project root)
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const PROJECT_ROOT = join(__dirname, '../../..');

// Check for HTTPS certificates
const CERTS_DIR = join(PROJECT_ROOT, '.certs');
const CERT_PATH = join(CERTS_DIR, 'localhost-cert.pem');
const KEY_PATH = join(CERTS_DIR, 'localhost-key.pem');

let useHttps = false;
let httpsOptions = {};

try {
  await access(CERT_PATH, constants.R_OK);
  await access(KEY_PATH, constants.R_OK);

  const [cert, key] = await Promise.all([readFile(CERT_PATH, 'utf-8'), readFile(KEY_PATH, 'utf-8')]);

  httpsOptions = { https: { cert, key } };
  useHttps = true;
  console.log(' HTTPS certificates found - server will use HTTPS');
} catch (error) {
  console.log(' No HTTPS certificates found - server will use HTTP');
  console.log('  Run: npm run setup:https to enable HTTPS for WebContainer preview compatibility');
}

const fastify = Fastify({
  logger: true,
  bodyLimit: 250 * 1024 * 1024, // 250MB to accommodate brand packages (200MB) + overhead
  ...httpsOptions,
});

// Enable CORS
// @ts-expect-error Fastify plugin type compatibility issue with current version
await fastify.register(cors, {
  origin: true,
});

// Enable WebSocket
// @ts-expect-error Fastify plugin type compatibility issue with current version
await fastify.register(websocket);

// Enable multipart for file uploads
// @ts-expect-error Fastify plugin type compatibility issue with current version
await fastify.register(multipart, {
  limits: {
    fileSize: 200 * 1024 * 1024, // 200MB max file size
  },
});

const WORKSPACE_DIR = process.env.WORKSPACE_DIR || join(PROJECT_ROOT, 'workspace');
const USE_LOCAL_FS = process.env.USE_LOCAL_FS === 'true';

// Load configuration from project root
const loader = new ConfigLoader(join(PROJECT_ROOT, 'configs'));
const { claudeConfig, agentConfig } = await loader.loadAll();

// Initialize database client (optional - will work without DB if not configured)
let db: any = null;
let dbConnected = false;
try {
  db = createDatabaseClient();
  dbConnected = await db.healthCheck();
  if (dbConnected) {
    console.log(' Database connected - using DB-backed VFS');
    await registerSessionRoutes(fastify, db);
    await registerSessionFileRoutes(fastify, db);
    await registerImageRoutes(fastify, db);
    await registerAppRoutes(fastify, db);
    await registerNetlifyRoutes(fastify, db, WORKSPACE_DIR);
    await registerDeploymentRoutes(fastify, db, WORKSPACE_DIR);
    await registerBrandKitRoutes(fastify, db);
  } else {
    console.log(' Database not available - files will only be saved to filesystem');
  }
} catch (error) {
  console.log(' Database not configured - files will only be saved to filesystem');
}

/**
 * GET /api/health
 */
fastify.get('/api/health', async () => {
  return {
    status: 'ok',
    workspace: WORKSPACE_DIR,
    database: dbConnected ? 'connected' : 'disconnected',
  };
});

/**
 * GET /api/proxy-cdn
 * Universal proxy for external CDN resources with CORS/COEP headers
 */
fastify.get<{ Querystring: { url: string } }>('/api/proxy-cdn', async (request, reply) => {
  const { url } = request.query;

  if (!url) {
    return reply.code(400).header('Content-Type', 'application/json').send({ error: 'Missing url parameter' });
  }

  try {
    const targetUrl = new URL(url);
    const securityCheck = isSecureUrl(targetUrl);

    if (!securityCheck.valid) {
      return reply.code(403).header('Content-Type', 'application/json').send({
        error: securityCheck.errorMessage,
        code: securityCheck.errorCode,
      });
    }

    console.log('[Proxy CDN] Fetching:', url);
    const response = await fetch(url, {
      headers: {
        'User-Agent':
          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        Accept: '*/*',
        'Accept-Language': 'en-US,en;q=0.9',
        Referer: targetUrl.origin + '/',
        Origin: targetUrl.origin,
      },
    });

    if (!response.ok) {
      console.error('[Proxy CDN] Upstream error:', url, response.status);
      return reply
        .code(response.status)
        .header('Content-Type', 'application/json')
        .send({ error: `Upstream returned ${response.status}` });
    }

    const contentType = response.headers.get('content-type') || 'application/octet-stream';
    const buffer = await response.arrayBuffer();

    console.log('[Proxy CDN] Success:', url, 'Type:', contentType, 'Size:', buffer.byteLength);

    return reply
      .header('Content-Type', contentType)
      .header('Cross-Origin-Resource-Policy', 'cross-origin')
      .header('Access-Control-Allow-Origin', '*')
      .header('Cache-Control', `public, max-age=${CDN_CACHE_MAX_AGE_SECONDS}`)
      .send(Buffer.from(buffer));
  } catch (error: any) {
    console.error('[Proxy CDN] Error:', url, error.message);
    return reply
      .code(500)
      .header('Content-Type', 'application/json')
      .send({ error: `Proxy error: ${error.message}` });
  }
});

const COINGECKO_DEMO_KEY = process.env.COINGECKO_DEMO_API_KEY || '';
const COINGECKO_PRO_KEY = process.env.COINGECKO_PRO_API_KEY || '';

const apiCache = new Map<string, { t: number; body: Buffer; headers: Record<string, string>; status: number }>();

/**
 * GET /api/proxy-api
 * Universal proxy for external APIs with auth injection and caching
 */
fastify.get<{ Querystring: { url: string } }>('/api/proxy-api', async (request, reply) => {
  const { url } = request.query;

  if (!url) {
    return reply.code(400).send({ error: 'Missing url parameter' });
  }

  let targetUrl: URL;
  try {
    targetUrl = new URL(url);
  } catch {
    return reply.code(400).send({ error: 'Invalid url' });
  }

  const securityCheck = isSecureUrl(targetUrl);
  if (!securityCheck.valid) {
    return reply.code(403).send({
      error: securityCheck.errorMessage,
      code: securityCheck.errorCode,
    });
  }

  const cacheKey = `GET:${targetUrl.toString()}`;
  const hit = apiCache.get(cacheKey);
  if (hit && Date.now() - hit.t < API_CACHE_TTL_MS) {
    return reply
      .headers({
        ...hit.headers,
        'Access-Control-Allow-Origin': '*',
        Vary: 'Origin',
        'Cross-Origin-Resource-Policy': 'cross-origin',
        'X-Cache': 'HIT',
      })
      .code(hit.status)
      .send(hit.body);
  }

  const headers: Record<string, string> = {
    Accept: 'application/json',
    'User-Agent': 'EitherWay-Proxy/1.0',
  };

  if (targetUrl.hostname === 'api.coingecko.com' && COINGECKO_DEMO_KEY) {
    headers['x-cg-demo-api-key'] = COINGECKO_DEMO_KEY;
  }
  if (targetUrl.hostname === 'pro-api.coingecko.com' && COINGECKO_PRO_KEY) {
    headers['x-cg-pro-api-key'] = COINGECKO_PRO_KEY;
  }

  try {
    const upstream = await fetch(targetUrl.toString(), {
      method: 'GET',
      headers,
      credentials: 'omit',
    });

    const body = Buffer.from(await upstream.arrayBuffer());
    const passthrough = Object.fromEntries(upstream.headers);
    const status = upstream.status;

    if (status >= 200 && status < 400) {
      apiCache.set(cacheKey, { t: Date.now(), body, headers: passthrough, status });
    }

    return reply
      .headers({
        ...passthrough,
        'Access-Control-Allow-Origin': '*',
        Vary: 'Origin',
        'Cross-Origin-Resource-Policy': 'cross-origin',
        'Cache-Control': passthrough['cache-control'] || 'public, max-age=30',
      })
      .code(status)
      .send(body);
  } catch (error: any) {
    return reply.code(500).send({ error: `API proxy error: ${error.message}` });
  }
});

fastify.get('/api/files', async () => {
  if (!USE_LOCAL_FS) {
    return { files: [], deprecated: true, message: 'Use /api/sessions/:id/files/tree instead' };
  }
  const files = await getFileTree(WORKSPACE_DIR);
  return { files };
});

fastify.get<{ Params: { '*': string } }>('/api/files/*', async (request, reply) => {
  if (!USE_LOCAL_FS) {
    return reply.code(410).send({ error: 'Deprecated. Use /api/sessions/:id/files/read?path=... instead' });
  }
  const filePath = request.params['*'];
  const fullPath = resolve(WORKSPACE_DIR, filePath);

  // Security: Ensure the resolved path is within WORKSPACE_DIR
  const normalizedWorkspace = resolve(WORKSPACE_DIR);
  const normalizedPath = resolve(fullPath);
  const relativePath = relative(normalizedWorkspace, normalizedPath);

  if (relativePath.startsWith('..') || resolve(normalizedWorkspace, relativePath) !== normalizedPath) {
    return reply.code(403).send({ error: 'Access denied: path traversal detected' });
  }

  try {
    const content = await readFile(fullPath, 'utf-8');

    // Get server origin for absolute CDN proxy URLs
    const protocol = request.headers['x-forwarded-proto'] || 'http';
    const host = request.headers.host || `localhost:${PORT}`;
    const serverOrigin = `${protocol}://${host}`;

    const rewrittenContent = maybeRewriteFile(filePath, content, { serverOrigin });
    return { path: filePath, content: rewrittenContent };
  } catch (error: any) {
    return reply.code(404).send({ error: error.message });
  }
});

fastify.post<{
  Params: { '*': string };
  Body: { content: string };
}>('/api/files/*', async (request, reply) => {
  if (!USE_LOCAL_FS) {
    return reply.code(410).send({ error: 'Deprecated. Use /api/sessions/:id/files/write instead' });
  }
  const filePath = request.params['*'];
  const { content } = request.body;

  if (!content && content !== '') {
    return reply.code(400).send({ error: 'Content is required' });
  }

  const fullPath = resolve(WORKSPACE_DIR, filePath);

  // Security: Ensure the resolved path is within WORKSPACE_DIR
  const normalizedWorkspace = resolve(WORKSPACE_DIR);
  const normalizedPath = resolve(fullPath);
  const relativePath = relative(normalizedWorkspace, normalizedPath);

  if (relativePath.startsWith('..') || resolve(normalizedWorkspace, relativePath) !== normalizedPath) {
    return reply.code(403).send({ error: 'Access denied: path traversal detected' });
  }

  try {
    // Write to filesystem
    await writeFile(fullPath, content, 'utf-8');

    // Note: Files are saved to database only when switching workspaces
    // to ensure they're associated with the correct session's app_id

    return {
      success: true,
      path: filePath,
      message: 'File saved successfully',
    };
  } catch (error: any) {
    console.error('Error saving file:', error);
    return reply.code(500).send({ error: error.message });
  }
});

/**
 * Helper: Save all workspace files to database for a session
 */
async function saveWorkspaceToDatabase(sessionAppId: string): Promise<void> {
  if (!dbConnected || !db) return;

  const filesRepo = new FilesRepository(db);
  const files = await getFileTree(WORKSPACE_DIR);

  for (const fileEntry of files) {
    const filePath = fileEntry.path;
    const fullPath = join(WORKSPACE_DIR, filePath);

    try {
      const content = await readFile(fullPath, 'utf-8');
      await filesRepo.upsertFile(sessionAppId, filePath, content);
    } catch (error) {
      console.error(`Failed to save ${filePath}:`, error);
    }
  }
}

/**
 * Helper: Load workspace files from database for a session
 */
async function loadWorkspaceFromDatabase(sessionAppId: string): Promise<void> {
  if (!dbConnected || !db) {
    console.log('No database connection - cannot load workspace');
    return;
  }

  const filesRepo = new FilesRepository(db);

  // Clear workspace directory (except .git and node_modules)
  const entries = await readdir(WORKSPACE_DIR, { withFileTypes: true });
  for (const entry of entries) {
    if (entry.name === '.git' || entry.name === 'node_modules') continue;

    const fullPath = join(WORKSPACE_DIR, entry.name);
    await rm(fullPath, { recursive: true, force: true });
  }

  // Load files from database
  const files = await filesRepo.findByApp(sessionAppId);

  for (const file of files) {
    const fullPath = join(WORKSPACE_DIR, file.path);
    const dirPath = dirname(fullPath);

    // Create directory if needed
    await mkdir(dirPath, { recursive: true });

    // Get file content from latest version
    const version = await filesRepo.getHeadVersion(file.id);
    if (version && version.content_text) {
      await writeFile(fullPath, version.content_text, 'utf-8');
    }
  }
}

fastify.post<{
  Params: { id: string };
  Body: { currentSessionId?: string };
}>('/api/sessions/:id/switch-workspace', async (request, reply) => {
  if (!USE_LOCAL_FS) {
    return reply.code(410).send({ error: 'Deprecated. Session switching now happens client-side without reload' });
  }
  const { id: newSessionId } = request.params;
  const { currentSessionId } = request.body;

  if (!dbConnected || !db) {
    return reply.code(503).send({ error: 'Database not available' });
  }

  try {
    const sessionsRepo = new SessionsRepository(db);

    // Save current workspace if there's a current session
    if (currentSessionId) {
      const currentSession = await sessionsRepo.findById(currentSessionId);
      if (currentSession && currentSession.app_id) {
        await saveWorkspaceToDatabase(currentSession.app_id);
      }
    }

    // Load new workspace
    const newSession = await sessionsRepo.findById(newSessionId);
    if (!newSession) {
      return reply.code(404).send({ error: 'Session not found' });
    }

    if (newSession.app_id) {
      await loadWorkspaceFromDatabase(newSession.app_id);
    }

    // Get updated file tree
    const files = await getFileTree(WORKSPACE_DIR);

    return {
      success: true,
      sessionId: newSessionId,
      appId: newSession.app_id,
      files,
    };
  } catch (error: any) {
    console.error('Error switching workspace:', error);
    return reply.code(500).send({ error: error.message });
  }
});

await fastify.register(async (fastify) => {
  fastify.get<{
    Querystring: { sessionId?: string };
    // @ts-expect-error Fastify WebSocket type compatibility issue
  }>('/api/agent', { websocket: true }, async (connection, request) => {
    // @ts-expect-error Fastify WebSocket request type issue
    const { sessionId } = request.query;

    // Create event sender for this connection
    // @ts-expect-error Fastify WebSocket socket type issue
    const sender = createEventSender(connection.socket);

    if (!sessionId && !USE_LOCAL_FS) {
      sender.send(StreamEvents.error('sessionId query parameter is required'));
      // @ts-expect-error Fastify WebSocket socket type issue
      connection.socket.close();
      return;
    }

    connection.socket.on('message', async (message: Buffer) => {
      const data = JSON.parse(message.toString());

      if (data.type === 'prompt') {
        try {
          let response: string;
          const messageId: string = randomUUID(); // Generate message ID for streaming

          // Use DatabaseAgent when in database mode
          if (!USE_LOCAL_FS && dbConnected && db && sessionId) {
            const sessionsRepo = new SessionsRepository(db);
            const fileStore = new PostgresFileStore(db);
            const session = await sessionsRepo.findById(sessionId);

            if (!session) {
              sender.send(StreamEvents.error('Session not found'));
              return;
            }

            // Rate limiting disabled for local testing
            // if (rateLimiter) {
            //   const rateLimitCheck = await rateLimiter.checkMessageSending(sessionId);
            //   if (!rateLimitCheck.allowed) {
            //     sendEvent(connection.socket, {
            //       type: 'error',
            //       message: `Rate limit exceeded: You have reached your daily limit of ${rateLimitCheck.limit} messages per chat. Please try again after ${rateLimitCheck.resetsAt.toISOString()}.`
            //     });
            //     return;
            //   }
            // }

            const dbAgent = new DatabaseAgent({
              db,
              sessionId,
              appId: session.app_id || undefined,
              workingDir: WORKSPACE_DIR,
              claudeConfig,
              agentConfig,
              executors: getAllExecutors(),
              dryRun: false,
              webSearch: agentConfig.tools.webSearch,
            });

            // Set database context for file operations
            if (session.app_id) {
              dbAgent.setDatabaseContext(fileStore, session.app_id, sessionId);
            }

            // Use the messageId declared above
            let accumulatedText = '';
            let tokenUsage: { inputTokens: number; outputTokens: number } | undefined;

            // Send stream_start event
            sender.send(StreamEvents.streamStart(messageId));

            // Create streaming callbacks
            const streamingCallbacks: StreamingCallbacks = {
              onDelta: (delta) => {
                if (delta.type === 'text') {
                  accumulatedText += delta.content;
                  sender.send(StreamEvents.delta(messageId, delta.content));
                }
              },
              onReasoning: (delta) => {
                // Stream reasoning text smoothly
                sender.send(StreamEvents.reasoning(messageId, delta.text));
              },
              onPhase: (phase) => {
                sender.send(StreamEvents.phase(messageId, phase));
              },
              onThinkingComplete: (duration) => {
                // Emit thinking complete with duration
                sender.send(StreamEvents.thinkingComplete(messageId, duration));
              },
              onFileOperation: (operation, filePath) => {
                // Emit deduplicated file operations
                sender.send(StreamEvents.fileOperation(messageId, operation, filePath));
              },
              onToolStart: (tool) => {
                sender.send(StreamEvents.toolStart(tool.name, tool.toolUseId, messageId, tool.filePath));
              },
              onToolEnd: (tool) => {
                sender.send(StreamEvents.toolEnd(tool.name, tool.toolUseId, messageId, tool.filePath));
              },
              onComplete: (usage) => {
                tokenUsage = usage;
              },
            };

            // Enrich prompt with brand kit context if available
            const enrichedPrompt = await enrichPromptWithBrandKit(data.prompt, session, fileStore);

            // Process request with streaming
            response = await dbAgent.processRequest(enrichedPrompt, streamingCallbacks);

            // Send stream_end event with token usage
            sender.send(StreamEvents.streamEnd(messageId, tokenUsage));
          } else {
            // Use regular Agent for local filesystem mode
            const agent = new Agent({
              workingDir: WORKSPACE_DIR,
              claudeConfig,
              agentConfig,
              executors: getAllExecutors(),
              dryRun: false,
              webSearch: agentConfig.tools.webSearch,
            });

            // Use the messageId declared above
            let accumulatedText = '';
            let tokenUsage: { inputTokens: number; outputTokens: number } | undefined;

            // Send stream_start event
            sender.send(StreamEvents.streamStart(messageId));

            // Create streaming callbacks
            const streamingCallbacks: StreamingCallbacks = {
              onDelta: (delta) => {
                if (delta.type === 'text') {
                  accumulatedText += delta.content;
                  sender.send(StreamEvents.delta(messageId, delta.content));
                }
              },
              onReasoning: (delta) => {
                // Stream reasoning text smoothly
                sender.send(StreamEvents.reasoning(messageId, delta.text));
              },
              onPhase: (phase) => {
                sender.send(StreamEvents.phase(messageId, phase));
              },
              onThinkingComplete: (duration) => {
                // Emit thinking complete with duration
                sender.send(StreamEvents.thinkingComplete(messageId, duration));
              },
              onFileOperation: (operation, filePath) => {
                // Emit deduplicated file operations
                sender.send(StreamEvents.fileOperation(messageId, operation, filePath));
              },
              onToolStart: (tool) => {
                sender.send(StreamEvents.toolStart(tool.name, tool.toolUseId, messageId, tool.filePath));
              },
              onToolEnd: (tool) => {
                sender.send(StreamEvents.toolEnd(tool.name, tool.toolUseId, messageId, tool.filePath));
              },
              onComplete: (usage) => {
                tokenUsage = usage;
              },
            };

            response = await agent.processRequest(data.prompt, streamingCallbacks);

            // Send stream_end event with token usage
            sender.send(StreamEvents.streamEnd(messageId, tokenUsage));
          }

          // Send final response for backward compatibility
          sender.send(StreamEvents.response(response, messageId));

          // Rate limiting disabled for local testing
          // if (rateLimiter && sessionId) {
          //   await rateLimiter.incrementMessageCount(sessionId);
          // }

          if (!USE_LOCAL_FS && dbConnected && db && sessionId) {
            const sessionsRepo = new SessionsRepository(db);
            const fileStore = new PostgresFileStore(db);

            const session = await sessionsRepo.findById(sessionId);

            if (session?.app_id) {
              const files = await fileStore.list(session.app_id);

              sender.send(StreamEvents.filesUpdated(files, sessionId));
            }
          } else {
            const files = await getFileTree(WORKSPACE_DIR);
            sender.send(StreamEvents.filesUpdated(files));
          }
        } catch (error: any) {
          // Log the full error for debugging
          console.error('[Agent Error]', error);

          // Parse error message for better display
          let errorMessage = error.message || 'Unknown error occurred';

          // Check if it's an Anthropic API error
          if (error.message && error.message.includes('"type":"api_error"')) {
            try {
              // Try to parse the JSON error
              const jsonMatch = error.message.match(/\{.*\}/);
              if (jsonMatch) {
                const errorObj = JSON.parse(jsonMatch[0]);
                if (errorObj.error?.message) {
                  errorMessage = `Anthropic API Error: ${errorObj.error.message}`;
                  if (errorObj.request_id) {
                    errorMessage += ` (Request ID: ${errorObj.request_id})`;
                  }
                }
              }
            } catch (parseError) {
              // If parsing fails, use the original message
              console.error('[Error Parsing]', parseError);
            }
          }

          sender.send(StreamEvents.error(errorMessage));
        }
      }
    });

    connection.socket.on('close', () => {
      console.log('Client disconnected');
    });
  });
});

/**
 * Helper: Build brand kit context for prompt injection
 * Returns enriched prompt with brand kit assets and colors if available
 * Reads brand-kit.json manifest from workspace (written by frontend after sync)
 */
async function enrichPromptWithBrandKit(
  originalPrompt: string,
  session: any,
  fileStore: PostgresFileStore
): Promise<string> {
  try {
    if (!session?.app_id) {
      return originalPrompt;
    }

    // Read brand-kit.json manifest from workspace
    console.log('[Brand Kit] Checking for brand-kit.json in workspace...');
    console.log('[Brand Kit] Session app_id:', session.app_id);

    let manifestContent: any;
    try {
      const manifestFile = await fileStore.read(session.app_id, 'brand-kit.json');
      console.log('[Brand Kit] Manifest file retrieved, content type:', typeof manifestFile.content);

      const contentString = manifestFile.content.toString();
      console.log('[Brand Kit] Manifest content (first 500 chars):', contentString.substring(0, 500));

      manifestContent = JSON.parse(contentString);
      console.log('[Brand Kit] Manifest parsed successfully');
      console.log('[Brand Kit] Manifest structure:', JSON.stringify(manifestContent, null, 2).substring(0, 1000));
    } catch (error: any) {
      console.log('[Brand Kit] Failed to read brand-kit.json:', error.message);
      console.log('[Brand Kit] Error stack:', error.stack);
      return originalPrompt;
    }

    const { colors, assets } = manifestContent.brandKit || {};
    console.log('[Brand Kit] Extracted from manifest - colors:', colors?.length || 0, 'assets:', assets?.length || 0);

    if ((!colors || colors.length === 0) && (!assets || assets.length === 0)) {
      console.log('[Brand Kit] Brand kit manifest is empty - skipping enrichment');
      return originalPrompt;
    }

    // Build brand context string (matching beta-deployment format)
    let brandContext = '\n\nBRAND KIT AVAILABLE:\n';

    if (colors && colors.length > 0) {
      brandContext += '\nColor Palette:\n';
      colors.forEach((color: any) => {
        brandContext += `- ${color.hex}`;
        if (color.name) brandContext += ` (${color.name})`;
        if (color.role) brandContext += ` - ${color.role}`;
        if (color.prominence) brandContext += ` [${Math.round(color.prominence * 100)}% prominence]`;
        brandContext += '\n';
      });
    }

    if (assets && assets.length > 0) {
      brandContext += '\nBrand Assets:\n';
      assets.forEach((asset: any) => {
        if (asset.path) {
          // Convert file path to web-accessible path
          const webPath = asset.path.replace(/^public\//, '/');
          brandContext += `- ${asset.fileName} (${asset.type}) at ${webPath}\n`;
        }
      });
    }

    brandContext += '\nIMPORTANT: Use these brand colors and assets in your design. The color palette should be your primary color scheme, and brand assets should be integrated where appropriate.\n';

    const enrichedPrompt = brandContext + originalPrompt;

    console.log('[Brand Kit]  SUCCESS: Injected brand kit context into prompt!');
    console.log('[Brand Kit] Colors:', colors?.length || 0, '| Assets:', assets?.length || 0);
    console.log('[Brand Kit] Brand context preview:', brandContext.substring(0, 300));
    console.log('[Brand Kit] Original prompt (first 100 chars):', originalPrompt.substring(0, 100));
    console.log('[Brand Kit] Enriched prompt total length:', enrichedPrompt.length);
    console.log('[Brand Kit] Full enriched prompt (first 500 chars):', enrichedPrompt.substring(0, 500));

    // Prepend brand context to the user's prompt
    return enrichedPrompt;

  } catch (error: any) {
    console.error('[Brand Kit] Failed to enrich prompt:', error.message);
    console.error('[Brand Kit] Full error:', error);
    return originalPrompt; // Fall back to original on error
  }
}

/**
 * Helper: Get file tree
 */
async function getFileTree(dir: string, basePath: string = ''): Promise<FileNode[]> {
  const entries = await readdir(dir, { withFileTypes: true });
  const nodes: FileNode[] = [];

  for (const entry of entries) {
    // Skip node_modules, .git, etc.
    if (entry.name.startsWith('.') || entry.name === 'node_modules') {
      continue;
    }

    const fullPath = join(dir, entry.name);
    const relativePath = basePath ? join(basePath, entry.name) : entry.name;

    if (entry.isDirectory()) {
      const children = await getFileTree(fullPath, relativePath);
      nodes.push({
        name: entry.name,
        path: relativePath,
        type: 'directory',
        children,
      });
    } else {
      const stats = await stat(fullPath);
      nodes.push({
        name: entry.name,
        path: relativePath,
        type: 'file',
        size: stats.size,
      });
    }
  }

  return nodes.sort((a, b) => {
    if (a.type === b.type) return a.name.localeCompare(b.name);
    return a.type === 'directory' ? -1 : 1;
  });
}

interface FileNode {
  name: string;
  path: string;
  type: 'file' | 'directory';
  size?: number;
  children?: FileNode[];
}

// Start server
const PORT = process.env.PORT || DEFAULT_SERVER_PORT;

try {
  await fastify.listen({ port: Number(PORT), host: '0.0.0.0' });
  const protocol = useHttps ? 'https' : 'http';
  console.log(`\n EitherWay UI Server running on ${protocol}://localhost:${PORT}`);
  console.log(` Workspace: ${WORKSPACE_DIR}`);
  if (useHttps) {
    console.log(` HTTPS enabled - WebContainer previews will work without mixed content issues\n`);
  } else {
    console.log(`  Using HTTP - WebContainer previews may have mixed content issues`);
    console.log(`   Run: npm run setup:https to enable HTTPS\n`);
  }
} catch (err) {
  fastify.log.error(err);
  process.exit(1);
}
</file>

</files>
